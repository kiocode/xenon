#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DonkehFramework

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DonkehFramework_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_classes.hpp"
#include "UMG_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"


namespace SDK
{

// Class DonkehFramework.DFGunRecoilHandler
// 0x0000 (0x0028 - 0x0028)
class UDFGunRecoilHandler : public UObject
{
public:
	struct FVector GetConeOfFireOffset();
	void OnTick(float DeltaTime);
	void OnWeaponFire();
	void OnWeaponStartFire();
	void OnWeaponStopFire();

	class ADFBaseGun* GetOwningGun() const;
	class APawn* GetOwningPawn() const;
	bool IsFiring() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFGunRecoilHandler">();
	}
	static class UDFGunRecoilHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFGunRecoilHandler>();
	}
};
static_assert(alignof(UDFGunRecoilHandler) == 0x000008, "Wrong alignment on UDFGunRecoilHandler");
static_assert(sizeof(UDFGunRecoilHandler) == 0x000028, "Wrong size on UDFGunRecoilHandler");

// Class DonkehFramework.DFCfgDataManager
// 0x0050 (0x0078 - 0x0028)
class UDFCfgDataManager : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFCfgDataManager">();
	}
	static class UDFCfgDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFCfgDataManager>();
	}
};
static_assert(alignof(UDFCfgDataManager) == 0x000008, "Wrong alignment on UDFCfgDataManager");
static_assert(sizeof(UDFCfgDataManager) == 0x000078, "Wrong size on UDFCfgDataManager");

// Class DonkehFramework.DFHandlerInterface
// 0x0000 (0x0028 - 0x0028)
class IDFHandlerInterface final : public IInterface
{
public:
	void EventInit();
	void EventOnNewPawn(class APawn* NewPawn, class APawn* PreviousPawn);
	void EventReset();
	void EventRespawn();
	bool EventShouldUpdateThisFrame(float DeltaTime, bool bActiveAndSpawnedInWorld);
	void EventUpdate(float DeltaTime, bool bMakeDecision);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFHandlerInterface">();
	}
	static class IDFHandlerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDFHandlerInterface>();
	}
};
static_assert(alignof(IDFHandlerInterface) == 0x000008, "Wrong alignment on IDFHandlerInterface");
static_assert(sizeof(IDFHandlerInterface) == 0x000028, "Wrong size on IDFHandlerInterface");

// Class DonkehFramework.DFMapRotationManager
// 0x0018 (0x0090 - 0x0078)
class UDFMapRotationManager final : public UDFCfgDataManager
{
public:
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFMapRotationManager">();
	}
	static class UDFMapRotationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFMapRotationManager>();
	}
};
static_assert(alignof(UDFMapRotationManager) == 0x000008, "Wrong alignment on UDFMapRotationManager");
static_assert(sizeof(UDFMapRotationManager) == 0x000090, "Wrong size on UDFMapRotationManager");

// Class DonkehFramework.DFLocalPlayer
// 0x0000 (0x0258 - 0x0258)
class UDFLocalPlayer : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFLocalPlayer">();
	}
	static class UDFLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFLocalPlayer>();
	}
};
static_assert(alignof(UDFLocalPlayer) == 0x000008, "Wrong alignment on UDFLocalPlayer");
static_assert(sizeof(UDFLocalPlayer) == 0x000258, "Wrong size on UDFLocalPlayer");

// Class DonkehFramework.DFBaseAIController
// 0x0008 (0x0330 - 0x0328)
class ADFBaseAIController : public AAIController
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanRestartPlayer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseAIController">();
	}
	static class ADFBaseAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseAIController>();
	}
};
static_assert(alignof(ADFBaseAIController) == 0x000008, "Wrong alignment on ADFBaseAIController");
static_assert(sizeof(ADFBaseAIController) == 0x000330, "Wrong size on ADFBaseAIController");

// Class DonkehFramework.DFInfo
// 0x0000 (0x0220 - 0x0220)
class ADFInfo : public AInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFInfo">();
	}
	static class ADFInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFInfo>();
	}
};
static_assert(alignof(ADFInfo) == 0x000008, "Wrong alignment on ADFInfo");
static_assert(sizeof(ADFInfo) == 0x000220, "Wrong size on ADFInfo");

// Class DonkehFramework.DFPlayerAdminList
// 0x0050 (0x00C8 - 0x0078)
class UDFPlayerAdminList final : public UDFCfgDataManager
{
public:
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFPlayerAdminList">();
	}
	static class UDFPlayerAdminList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFPlayerAdminList>();
	}
};
static_assert(alignof(UDFPlayerAdminList) == 0x000008, "Wrong alignment on UDFPlayerAdminList");
static_assert(sizeof(UDFPlayerAdminList) == 0x0000C8, "Wrong size on UDFPlayerAdminList");

// Class DonkehFramework.DFBaseItem
// 0x0188 (0x03A8 - 0x0220)
class ADFBaseItem : public AActor
{
public:
	class ADFBaseCharacter*                       PawnOwner;                                         // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ItemMesh;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ItemMesh1P;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          PawnMesh1P;                                        // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              PawnMesh1PAnimClass;                               // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PawnMesh1PLocationOffset;                          // 0x0248(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               PawnMesh1PRotationOffset;                          // 0x0254(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EItemType                                     ItemType;                                          // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpecificItemType                             SpecificItemType;                                  // 0x0261(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCanEquip : 1;                                     // 0x0262(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanAimWhileEquipped : 1;                          // 0x0262(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableFireInput : 1;                             // 0x0262(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEquipped : 1;                                     // 0x0262(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPendingEquip : 1;                                 // 0x0262(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPendingUnEquip : 1;                               // 0x0262(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWantsToFire : 1;                                  // 0x0262(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_263[0x1];                                      // 0x0263(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastFiredShotID;                                   // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x10];                                     // 0x0268(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDebug : 1;                                        // 0x0278(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAnimCollection               CharacterAnimCollection;                           // 0x0280(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void ForceStopFiring();
	void OnEnterInventory(class ADFBaseCharacter* NewOwner, class ADFBaseCharacter* LastOwner);
	void OnEquip(const class ADFBaseItem* LastItem);
	void OnLeaveInventory(class ADFBaseCharacter* LastOwner);
	void OnRep_PawnOwner(class ADFBaseCharacter* LastOwner);
	void OnTurnOff();
	void OnUnEquip(bool bPlayAnimAndWait, bool bLeavingPawnInventory);
	void ReceiveOnEnterInventory(class ADFBaseCharacter* NewOwner, class ADFBaseCharacter* LastOwner);
	void ReceiveOnEquip(const class ADFBaseItem* LastItem);
	void ReceiveOnEquipFinished();
	void ReceiveOnLeaveInventory(class ADFBaseCharacter* LastOwner);
	void ReceiveOnTurnOff();
	void ReceiveOnUnEquip(bool bPlayAnimAndWait, bool bLeavingPawnInventory);
	void ReceiveOnUnEquipFinished(bool bLeavingPawnInventory);
	void ReceiveStartFire();
	void ReceiveStopFire();
	void ReceiveVisibilityChanged(bool bFirstPerson);
	bool RemoveLegacyLocomotionAnims(bool bFPP);
	void ServerStartFire(const struct FVector_NetQuantize& Origin, const struct FVector_NetQuantizeNormal& ShootDir, int32 RandomSeed, float Timestamp, int32 ShotID);
	void ServerStopFire();
	void SetMeshVisibility(bool bFirstPerson);
	void SetOwningPawn(class ADFBaseCharacter* NewOwner);
	void StartFire();
	void StopFire();

	bool CanAimWhileEquipped() const;
	bool CanEquip() const;
	bool CanFire() const;
	bool CanSprintWhileEquipped() const;
	bool CanStartFire() const;
	bool CanTriggerFire() const;
	struct FVector GetAdjustedAimDirection() const;
	class UStaticMeshComponent* GetItemMesh() const;
	class UStaticMeshComponent* GetItemMesh1P() const;
	class UStaticMeshComponent* GetItemMeshToUse(bool bIgnoreLocalControlOnServer) const;
	EItemType GetItemType() const;
	TMap<class FName, class UAnimSequenceBase*> GetLegacyLocomotionAnims(bool bFPP) const;
	struct FVector GetOwnerViewLocation() const;
	bool GetOwnerViewPoint(struct FVector* OutViewLoc, struct FRotator* OutViewRot) const;
	struct FRotator GetOwnerViewRotation() const;
	class UDFInventoryComponent* GetPawnInventory() const;
	class ADFBaseCharacter* GetPawnOwner() const;
	ESpecificItemType GetSpecificItemType() const;
	bool IsClientSimulated() const;
	bool IsEquipped() const;
	bool IsEquipping() const;
	bool IsLocallyControlled() const;
	bool IsUnEquipping() const;
	bool OwnerIsAiming() const;
	bool OwnerIsSprinting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseItem">();
	}
	static class ADFBaseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseItem>();
	}
};
static_assert(alignof(ADFBaseItem) == 0x000008, "Wrong alignment on ADFBaseItem");
static_assert(sizeof(ADFBaseItem) == 0x0003A8, "Wrong size on ADFBaseItem");
static_assert(offsetof(ADFBaseItem, PawnOwner) == 0x000220, "Member 'ADFBaseItem::PawnOwner' has a wrong offset!");
static_assert(offsetof(ADFBaseItem, ItemMesh) == 0x000228, "Member 'ADFBaseItem::ItemMesh' has a wrong offset!");
static_assert(offsetof(ADFBaseItem, ItemMesh1P) == 0x000230, "Member 'ADFBaseItem::ItemMesh1P' has a wrong offset!");
static_assert(offsetof(ADFBaseItem, PawnMesh1P) == 0x000238, "Member 'ADFBaseItem::PawnMesh1P' has a wrong offset!");
static_assert(offsetof(ADFBaseItem, PawnMesh1PAnimClass) == 0x000240, "Member 'ADFBaseItem::PawnMesh1PAnimClass' has a wrong offset!");
static_assert(offsetof(ADFBaseItem, PawnMesh1PLocationOffset) == 0x000248, "Member 'ADFBaseItem::PawnMesh1PLocationOffset' has a wrong offset!");
static_assert(offsetof(ADFBaseItem, PawnMesh1PRotationOffset) == 0x000254, "Member 'ADFBaseItem::PawnMesh1PRotationOffset' has a wrong offset!");
static_assert(offsetof(ADFBaseItem, ItemType) == 0x000260, "Member 'ADFBaseItem::ItemType' has a wrong offset!");
static_assert(offsetof(ADFBaseItem, SpecificItemType) == 0x000261, "Member 'ADFBaseItem::SpecificItemType' has a wrong offset!");
static_assert(offsetof(ADFBaseItem, LastFiredShotID) == 0x000264, "Member 'ADFBaseItem::LastFiredShotID' has a wrong offset!");
static_assert(offsetof(ADFBaseItem, CharacterAnimCollection) == 0x000280, "Member 'ADFBaseItem::CharacterAnimCollection' has a wrong offset!");

// Class DonkehFramework.DFIntrinsicCharAnimInstInterface
// 0x0000 (0x0028 - 0x0028)
class IDFIntrinsicCharAnimInstInterface final : public IInterface
{
public:
	float PlayDeathMontage(class UAnimMontage* MontageToPlay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFIntrinsicCharAnimInstInterface">();
	}
	static class IDFIntrinsicCharAnimInstInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDFIntrinsicCharAnimInstInterface>();
	}
};
static_assert(alignof(IDFIntrinsicCharAnimInstInterface) == 0x000008, "Wrong alignment on IDFIntrinsicCharAnimInstInterface");
static_assert(sizeof(IDFIntrinsicCharAnimInstInterface) == 0x000028, "Wrong size on IDFIntrinsicCharAnimInstInterface");

// Class DonkehFramework.DFPlayerBanList
// 0x0050 (0x00C8 - 0x0078)
class UDFPlayerBanList final : public UDFCfgDataManager
{
public:
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFPlayerBanList">();
	}
	static class UDFPlayerBanList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFPlayerBanList>();
	}
};
static_assert(alignof(UDFPlayerBanList) == 0x000008, "Wrong alignment on UDFPlayerBanList");
static_assert(sizeof(UDFPlayerBanList) == 0x0000C8, "Wrong size on UDFPlayerBanList");

// Class DonkehFramework.DFIntrinsicWeapAnimInstInterface
// 0x0000 (0x0028 - 0x0028)
class IDFIntrinsicWeapAnimInstInterface final : public IInterface
{
public:
	float PlayEquipMontage(class UAnimMontage* MontageToPlay);
	float PlayFireMontage(class UAnimMontage* MontageToPlay, bool bFireLast, bool bAiming);
	float PlayReloadMontage(class UAnimMontage* MontageToPlay, bool bFullReload);
	float PlayUnEquipMontage(class UAnimMontage* MontageToPlay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFIntrinsicWeapAnimInstInterface">();
	}
	static class IDFIntrinsicWeapAnimInstInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDFIntrinsicWeapAnimInstInterface>();
	}
};
static_assert(alignof(IDFIntrinsicWeapAnimInstInterface) == 0x000008, "Wrong alignment on IDFIntrinsicWeapAnimInstInterface");
static_assert(sizeof(IDFIntrinsicWeapAnimInstInterface) == 0x000028, "Wrong size on IDFIntrinsicWeapAnimInstInterface");

// Class DonkehFramework.DFPlayerWhitelist
// 0x0050 (0x00C8 - 0x0078)
class UDFPlayerWhitelist final : public UDFCfgDataManager
{
public:
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFPlayerWhitelist">();
	}
	static class UDFPlayerWhitelist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFPlayerWhitelist>();
	}
};
static_assert(alignof(UDFPlayerWhitelist) == 0x000008, "Wrong alignment on UDFPlayerWhitelist");
static_assert(sizeof(UDFPlayerWhitelist) == 0x0000C8, "Wrong size on UDFPlayerWhitelist");

// Class DonkehFramework.DFAssetManager
// 0x0008 (0x0440 - 0x0438)
class UDFAssetManager : public UAssetManager
{
public:
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFAssetManager">();
	}
	static class UDFAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFAssetManager>();
	}
};
static_assert(alignof(UDFAssetManager) == 0x000008, "Wrong alignment on UDFAssetManager");
static_assert(sizeof(UDFAssetManager) == 0x000440, "Wrong size on UDFAssetManager");

// Class DonkehFramework.DFBaseAmmoClip
// 0x0020 (0x03C8 - 0x03A8)
class ADFBaseAmmoClip final : public ADFBaseItem
{
public:
	class ADFBaseGun*                             GunOwner;                                          // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentClipAmmo;                                   // 0x03B0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ReloadCounter;                                     // 0x03B4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B5[0x3];                                      // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SimulatedCurrentClipAmmo;                          // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartingClipAmmo;                                  // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxClipAmmo;                                       // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static int32 StoreAmmoInInventory(class UDFInventoryComponent* AmmoStore, int32 AmmoAmt, const TSubclassOf<class ADFBaseAmmoClip>& AmmoType);

	void ConsumeAmmo(int32 AmmoToConsume);
	void OnRep_CurrentClipAmmo();
	void OnRep_ReloadCounter();
	void SetCurrentClipAmmo(int32 NewClipAmmo);
	void SetOwningGun(class ADFBaseGun* NewOwner);
	void StoreAmmo(int32 AmmoToStore);

	int32 GetCurrentClipAmmo() const;
	class ADFBaseGun* GetGunOwner() const;
	int32 GetMaxClipAmmo() const;
	int32 GetStartingClipAmmo() const;
	bool IsLoaded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseAmmoClip">();
	}
	static class ADFBaseAmmoClip* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseAmmoClip>();
	}
};
static_assert(alignof(ADFBaseAmmoClip) == 0x000008, "Wrong alignment on ADFBaseAmmoClip");
static_assert(sizeof(ADFBaseAmmoClip) == 0x0003C8, "Wrong size on ADFBaseAmmoClip");
static_assert(offsetof(ADFBaseAmmoClip, GunOwner) == 0x0003A8, "Member 'ADFBaseAmmoClip::GunOwner' has a wrong offset!");
static_assert(offsetof(ADFBaseAmmoClip, CurrentClipAmmo) == 0x0003B0, "Member 'ADFBaseAmmoClip::CurrentClipAmmo' has a wrong offset!");
static_assert(offsetof(ADFBaseAmmoClip, ReloadCounter) == 0x0003B4, "Member 'ADFBaseAmmoClip::ReloadCounter' has a wrong offset!");
static_assert(offsetof(ADFBaseAmmoClip, SimulatedCurrentClipAmmo) == 0x0003B8, "Member 'ADFBaseAmmoClip::SimulatedCurrentClipAmmo' has a wrong offset!");
static_assert(offsetof(ADFBaseAmmoClip, StartingClipAmmo) == 0x0003C0, "Member 'ADFBaseAmmoClip::StartingClipAmmo' has a wrong offset!");
static_assert(offsetof(ADFBaseAmmoClip, MaxClipAmmo) == 0x0003C4, "Member 'ADFBaseAmmoClip::MaxClipAmmo' has a wrong offset!");

// Class DonkehFramework.DFNavigationSystem
// 0x0000 (0x0538 - 0x0538)
class UDFNavigationSystem : public UNavigationSystemV1
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFNavigationSystem">();
	}
	static class UDFNavigationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFNavigationSystem>();
	}
};
static_assert(alignof(UDFNavigationSystem) == 0x000008, "Wrong alignment on UDFNavigationSystem");
static_assert(sizeof(UDFNavigationSystem) == 0x000538, "Wrong size on UDFNavigationSystem");

// Class DonkehFramework.DFBaseCharacter
// 0x0450 (0x0910 - 0x04C0)
#pragma pack(push, 0x1)
class alignas(0x10) ADFBaseCharacter : public ACharacter
{
public:
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         RemoteViewYaw;                                     // 0x04C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C1[0x7];                                      // 0x04C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bClientResimulateSprintStamina : 1;                // 0x04C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4C9[0x7];                                      // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAnimCollection               DefaultPawnAnimCollection;                         // 0x04D0(0x0128)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bPlayFootstepFXWithPerspMeshOnly : 1;              // 0x05F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTickAllAnimationOnDedicatedServer : 1;            // 0x05F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlyTickAnimMontagesOnDedicatedServer : 1;        // 0x05F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5F9[0x7];                                      // 0x05F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterSoundCollection              DefaultPawnSoundCollection;                        // 0x0600(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ADFBaseItem*                            EquippedItem;                                      // 0x0610(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADFBaseItem*                            LastEquippedItem;                                  // 0x0618(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEquippedItemChanged;                             // 0x0620(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   ItemAttachPoint;                                   // 0x0630(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDFInventoryComponent*                  Inventory;                                         // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDFLoadout*                             DefaultLoadout;                                    // 0x0640(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDFItemEnabledMode                            ItemEnabledMode;                                   // 0x0648(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_649[0x3];                                      // 0x0649(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShotIDCounter;                                     // 0x064C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAllowWeaponFireWhileCrawling : 1;                 // 0x0650(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDying : 1;                                        // 0x0650(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_651[0x7];                                      // 0x0651(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHealthChanged;                                   // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0668(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_66C[0x14];                                     // 0x066C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollLifeSpan;                                   // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCharacterDeath;                                  // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0698(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69C[0x4];                                      // 0x069C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTakeHitInfo                           LastTakeHitInfo;                                   // 0x06A0(0x0120)(Edit, Net, Transient, EditConst, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C0[0x8];                                      // 0x07C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      BoneDamageMultipliers;                             // 0x07C8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bApplyDamageMomentumOnHit : 1;                     // 0x0818(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_819[0x7];                                      // 0x0819(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSprintTransition;                                // 0x0820(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAimTransition;                                   // 0x0830(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLeanTransition;                                  // 0x0840(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVaultTransition;                                 // 0x0850(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ECharacterStance                              ReplicatedStance;                                  // 0x0860(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterStance                              PreviousStance;                                    // 0x0861(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPressedVault : 1;                                 // 0x0862(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSprinting : 1;                                    // 0x0862(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAiming : 1;                                       // 0x0862(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsProne : 1;                                      // 0x0862(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVaulting : 1;                                     // 0x0862(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWasVaulting : 1;                                  // 0x0862(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_863[0x1];                                      // 0x0863(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDFVaultTraceResult                    PendingVaultTraceResult;                           // 0x0864(0x001C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDFVaultTraceData                      VaultParams;                                       // 0x0880(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ReplicatedLeanAmount;                              // 0x0898(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89C[0x4];                                      // 0x089C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDFCharacterLeanHandler*                LeanHandler;                                       // 0x08A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDFCharacterMovementComponent*          DFCharacterMovement;                               // 0x08A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetEyeHeight;                                   // 0x08B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BitPad_8B4_0 : 1;                                  // 0x08B4(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bInterpCrouchedEyeHeight : 1;                      // 0x08B4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8B5[0x3];                                      // 0x08B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrouchedTransitionInterpSpeed;                     // 0x08B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInterpProneEyeHeight : 1;                         // 0x08BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8BD[0x3];                                      // 0x08BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProneTransitionInterpSpeed;                        // 0x08C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneEyeHeight;                                    // 0x08C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamNum;                                           // 0x08C8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C9[0x7];                                      // 0x08C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADFTeamState*                           TeamState;                                         // 0x08D0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADFTeamState*                           PrevTeamState;                                     // 0x08D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAllowTeamIdOverride : 1;                          // 0x08E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8E1[0x7];                                      // 0x08E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPawnTeamNumUpdated;                              // 0x08E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPawnTeamStateUpdated;                            // 0x08F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Aim(bool bClientSimulation);
	void AimToggle();
	void ClearCharacterAnimInstances(bool bPerspectiveMeshOnly);
	void ClientAdjustPosition_CustomStamina(float Timestamp, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode, float ServerSprintStamina);
	void ClientAdjustRootMotionPosition_CustomStamina(float Timestamp, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, class FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode, float ServerSprintStamina);
	void ClientAdjustRootMotionSourcePosition_CustomStamina(float Timestamp, const struct FRootMotionSourceGroup& ServerRootMotion, bool bHasAnimRootMotion, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, class FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode, float ServerSprintStamina);
	void ClientVeryShortAdjustPosition_CustomStamina(float Timestamp, const struct FVector& NewLoc, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode, float ServerSprintStamina);
	void CrouchToggle();
	bool Die(float KillingDamage, const struct FDamageEvent& DamageEvent, class AController* Killer, class AActor* DamageCauser);
	void EquipItem(class ADFBaseItem* ItemToEquip);
	void EquipNextItem();
	void EquipNextItemByType(EItemType ItemType);
	void EquipPreviousItem();
	class ADFBaseItem* GetNextInventoryItem(bool bEquippable);
	class ADFBaseItem* GetPreviousInventoryItem(bool bEquippable);
	void GiveLoadout(class UDFLoadout* Loadout, bool bEquipFirstItem);
	void GoProne(bool bClientSimulation);
	void ItemEnabledModeChanged(EDFItemEnabledMode PreviousItemEnabledMode);
	void Lean(ELeanDirection DesiredLeanDir, bool bClientSimulation);
	void LeanToggle(ELeanDirection LeanDir);
	void LeaveProne(bool bClientSimulation);
	int32 NextShotID();
	void OnDeath(float KillingDamage, const struct FDamageEvent& DamageEvent, class APawn* InstigatingPawn, class AActor* DamageCauser);
	void OnRep_bAiming();
	void OnRep_bSprinting();
	void OnRep_EquippedItem(class ADFBaseItem* LastItem);
	void OnRep_Health(const float PreviousValue);
	void OnRep_IsProne();
	void OnRep_ItemEnabledMode(EDFItemEnabledMode PreviousItemEnabledMode);
	void OnRep_LastTakeHitInfo();
	void OnRep_ReplicatedLeanAmount(float LastReplicatedLeanAmount);
	void OnRep_ReplicatedStance();
	void OnRep_TeamNum(uint8 LastTeamNum);
	void OnRep_TeamState(class ADFTeamState* TeamStateBeforeUpdate);
	float PlayCharacterActionMontage(class UAnimMontage* ActionMontageToPlay);
	float PlayCharacterCockMontage(class UAnimMontage* CockMontageToPlay);
	float PlayCharacterDeathMontage(bool bDontPlayAndReturnDominantPlayLengthOnly);
	float PlayCharacterEndReloadMontage(class UAnimMontage* EndReloadMontageToPlay, bool bDryReload);
	float PlayCharacterEquipMontage(bool bDontPlayAndReturnDominantPlayLengthOnly);
	float PlayCharacterFireMontage(class UAnimMontage* FireMontageToPlay, bool bFireLast, bool bFireADS);
	float PlayCharacterMontage(class UAnimMontage* CharMontage, bool bForceDisableAutoBlendOut);
	float PlayCharacterPerspectiveAnimation(const struct FPerspectiveAnim& CharAnim, bool bForceDisableAutoBlendOut);
	float PlayCharacterReloadMontage(bool bDryReload);
	class UAudioComponent* PlayCharacterSound(const struct FPerspectiveSound& Sound);
	float PlayCharacterStartReloadMontage(class UAnimMontage* StartReloadMontageToPlay, bool bDryReload);
	float PlayCharacterThrowOverhandMontage(class UAnimMontage* ThrowOverhandMontageToPlay);
	float PlayCharacterThrowUnderhandMontage(class UAnimMontage* ThrowUnderhandMontageToPlay);
	float PlayCharacterUnEquipMontage(class UAnimMontage* UnEquipMontageToPlay);
	void ProneToggle();
	void ReceiveEquippedItemChanged(class ADFBaseItem* NewEquippedItem, class ADFBaseItem* PrevEquippedItem);
	void ReceiveHealthChanged(float NewHealthTotal, float PrevHealthTotal);
	void ReceiveOnEndAim();
	void ReceiveOnEndLean();
	void ReceiveOnEndProne(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
	void ReceiveOnEndSprint();
	void ReceiveOnEndVault();
	void ReceiveOnRepPlayerState();
	void ReceiveOnStartAim();
	void ReceiveOnStartLean();
	void ReceiveOnStartProne(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
	void ReceiveOnStartSprint();
	void ReceiveOnStartVault();
	void ReceivePawnTeamNumUpdated(uint8 LastTeamNum, uint8 NewTeamNum);
	void ReceivePawnTeamStateUpdated(class ADFTeamState* TeamStateBeforeUpdate, class ADFTeamState* NewTeamState, bool bNewTeamStateInit);
	void ReceivePlayHit(float DamageTaken, const struct FDamageEvent& DamageEvent, class APawn* PawnInstigator, class AActor* DamageCauser, bool bKilled);
	void ReceiveRestart();
	void Reload();
	void ServerDoVault(const struct FDFVaultTraceData& VaultStartParams);
	void ServerEquipItem(class ADFBaseItem* ItemToEquip);
	void ServerSuicide();
	void SetHealth(float InHealth);
	void SetItemEnabledMode(EDFItemEnabledMode ItemMode);
	void SetRagdollPhysics();
	void SpawnHitImpactFX(float DamageTaken, const struct FDamageEvent& DamageEvent, class APawn* PawnInstigator, class AActor* DamageCauser);
	void Sprint(bool bClientSimulation);
	void SprintToggle();
	void StartFire();
	void StopAllAnimMontages(bool bPerspectiveMeshOnly);
	void StopCharacterMontage(class UAnimMontage* CharMontage);
	void StopCharacterPerspectiveAnimation(const struct FPerspectiveAnim& CharAnim);
	void StopFire();
	void StopVaulting();
	void Suicide();
	void UnAim(bool bClientSimulation);
	void UnLean(ELeanDirection UnDesiredLeanDir, bool bClientSimulation);
	void UnSprint(bool bClientSimulation);
	void Vault();

	bool AllowsWeaponFire() const;
	bool CanAim() const;
	bool CanDie(float KillingDamage, const struct FDamageEvent& DamageEvent, class AController* Killer, class AActor* DamageCauser) const;
	bool CanGoProne() const;
	bool CanLean(ELeanDirection DesiredLeanDir) const;
	bool CanSprint() const;
	bool CanVault() const;
	struct FRotator GetAimOffsets() const;
	class UAnimSequenceBase* GetAnimToUseFromPerspectiveAnimPair(const struct FPerspectiveAnim& AnimationPair) const;
	EVisibilityBasedAnimTickOption GetCharacterAnimTickOptionToUse(bool bVisibleMesh) const;
	bool GetCharacterDeathMontageToUse(class UAnimMontage** OutCharDeathMontage) const;
	class USkeletalMeshComponent* GetCharacterMeshToUse(bool bIgnoreLocalControlOnServer) const;
	bool GetDamageMultiplierByBoneName(const class FName& BoneName, float* DamageMultiplier) const;
	class ADFBaseItem* GetEquippedItem() const;
	class UDFInventoryComponent* GetInventory() const;
	class FName GetItemAttachPoint() const;
	EDFItemEnabledMode GetItemEnabledMode() const;
	class UAnimMontage* GetMontageToUseFromPerspectiveAnimPair(const struct FPerspectiveAnim& AnimationPair) const;
	class ADFBaseItem* GetRelevantEquippedItem() const;
	bool IsAlive() const;
	bool IsEquipped() const;
	bool IsFiring() const;
	bool IsLeaning() const;
	bool IsPerspectiveMesh(const class USkeletalMeshComponent* MeshCompToCheck) const;
	bool IsPlayer() const;
	bool IsPrefiring() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseCharacter">();
	}
	static class ADFBaseCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADFBaseCharacter) == 0x000010, "Wrong alignment on ADFBaseCharacter");
static_assert(sizeof(ADFBaseCharacter) == 0x000910, "Wrong size on ADFBaseCharacter");
static_assert(offsetof(ADFBaseCharacter, RemoteViewYaw) == 0x0004C0, "Member 'ADFBaseCharacter::RemoteViewYaw' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, DefaultPawnAnimCollection) == 0x0004D0, "Member 'ADFBaseCharacter::DefaultPawnAnimCollection' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, DefaultPawnSoundCollection) == 0x000600, "Member 'ADFBaseCharacter::DefaultPawnSoundCollection' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, EquippedItem) == 0x000610, "Member 'ADFBaseCharacter::EquippedItem' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, LastEquippedItem) == 0x000618, "Member 'ADFBaseCharacter::LastEquippedItem' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, OnEquippedItemChanged) == 0x000620, "Member 'ADFBaseCharacter::OnEquippedItemChanged' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, ItemAttachPoint) == 0x000630, "Member 'ADFBaseCharacter::ItemAttachPoint' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, Inventory) == 0x000638, "Member 'ADFBaseCharacter::Inventory' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, DefaultLoadout) == 0x000640, "Member 'ADFBaseCharacter::DefaultLoadout' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, ItemEnabledMode) == 0x000648, "Member 'ADFBaseCharacter::ItemEnabledMode' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, ShotIDCounter) == 0x00064C, "Member 'ADFBaseCharacter::ShotIDCounter' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, OnHealthChanged) == 0x000658, "Member 'ADFBaseCharacter::OnHealthChanged' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, Health) == 0x000668, "Member 'ADFBaseCharacter::Health' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, RagdollLifeSpan) == 0x000680, "Member 'ADFBaseCharacter::RagdollLifeSpan' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, OnCharacterDeath) == 0x000688, "Member 'ADFBaseCharacter::OnCharacterDeath' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, MaxHealth) == 0x000698, "Member 'ADFBaseCharacter::MaxHealth' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, LastTakeHitInfo) == 0x0006A0, "Member 'ADFBaseCharacter::LastTakeHitInfo' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, BoneDamageMultipliers) == 0x0007C8, "Member 'ADFBaseCharacter::BoneDamageMultipliers' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, OnSprintTransition) == 0x000820, "Member 'ADFBaseCharacter::OnSprintTransition' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, OnAimTransition) == 0x000830, "Member 'ADFBaseCharacter::OnAimTransition' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, OnLeanTransition) == 0x000840, "Member 'ADFBaseCharacter::OnLeanTransition' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, OnVaultTransition) == 0x000850, "Member 'ADFBaseCharacter::OnVaultTransition' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, ReplicatedStance) == 0x000860, "Member 'ADFBaseCharacter::ReplicatedStance' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, PreviousStance) == 0x000861, "Member 'ADFBaseCharacter::PreviousStance' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, PendingVaultTraceResult) == 0x000864, "Member 'ADFBaseCharacter::PendingVaultTraceResult' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, VaultParams) == 0x000880, "Member 'ADFBaseCharacter::VaultParams' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, ReplicatedLeanAmount) == 0x000898, "Member 'ADFBaseCharacter::ReplicatedLeanAmount' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, LeanHandler) == 0x0008A0, "Member 'ADFBaseCharacter::LeanHandler' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, DFCharacterMovement) == 0x0008A8, "Member 'ADFBaseCharacter::DFCharacterMovement' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, TargetEyeHeight) == 0x0008B0, "Member 'ADFBaseCharacter::TargetEyeHeight' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, CrouchedTransitionInterpSpeed) == 0x0008B8, "Member 'ADFBaseCharacter::CrouchedTransitionInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, ProneTransitionInterpSpeed) == 0x0008C0, "Member 'ADFBaseCharacter::ProneTransitionInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, ProneEyeHeight) == 0x0008C4, "Member 'ADFBaseCharacter::ProneEyeHeight' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, TeamNum) == 0x0008C8, "Member 'ADFBaseCharacter::TeamNum' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, TeamState) == 0x0008D0, "Member 'ADFBaseCharacter::TeamState' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, PrevTeamState) == 0x0008D8, "Member 'ADFBaseCharacter::PrevTeamState' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, OnPawnTeamNumUpdated) == 0x0008E8, "Member 'ADFBaseCharacter::OnPawnTeamNumUpdated' has a wrong offset!");
static_assert(offsetof(ADFBaseCharacter, OnPawnTeamStateUpdated) == 0x0008F8, "Member 'ADFBaseCharacter::OnPawnTeamStateUpdated' has a wrong offset!");

// Class DonkehFramework.DFBaseGameMode
// 0x0110 (0x0418 - 0x0308)
class ADFBaseGameMode : public AGameMode
{
public:
	class ADFGameSession*                         DFGameSession;                                     // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ADFTeamState>               TeamStateClass;                                    // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AAIController>              AIControllerClass;                                 // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<uint8>                                 WinningTeams;                                      // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle_DefaultTimer;                          // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WarmupTime;                                        // 0x0340(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoundTimeLimit;                                    // 0x0344(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoundScoreLimit;                                   // 0x0348(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TimeBetweenMatches;                                // 0x034C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bBalanceTeams : 1;                                 // 0x0350(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BalanceTimerInterval;                              // 0x0354(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         AutoAssignHumanTeam;                               // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bBotAutofill : 1;                                  // 0x0359(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Config, GlobalConfig, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_35A[0x6];                                      // 0x035A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GameDisplayName;                                   // 0x0360(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         NumTeams;                                          // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAllowUnassignedTeams : 1;                         // 0x037C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPlayerNameChanges : 1;                       // 0x037C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPlayerNameChangesUnderNullOSS : 1;           // 0x037C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPlayerNameChangesUnderSteamOSS : 1;          // 0x037C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysDestroyPlayerDuringSeamlessTravel : 1;      // 0x037C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceRespawn : 1;                                 // 0x037C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRandomSpawns : 1;                                 // 0x037C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRestartPlayerAtTransformOnly : 1;                 // 0x037C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFriendlyFire : 1;                                 // 0x037D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdatePlayerGameplayMuteStates : 1;               // 0x037D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTeamOnlyVoice : 1;                                // 0x037D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ESpawnActorCollisionHandlingMethod            DefaultPawnSpawnCollisionHandlingMethodOverride;   // 0x037E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAllowBots : 1;                                    // 0x037F(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	struct FTimerHandle                           TimerHandle_BalanceTimer;                          // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<TSoftClassPtr<class UClass>>             GameRulesetClasses;                                // 0x0388(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NoClear, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         SignificantActors;                                 // 0x03D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDFGameRulesetBase*>             GameRulesets;                                      // 0x03E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAllowVoting : 1;                                  // 0x03F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPlayerToChangeVote : 1;                      // 0x03F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           AllowedVoteIssues;                                 // 0x0400(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDFVotingComponent>         PlayerVotingGameStateComponentClass;               // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class APlayerState* AddBot(uint8 PlayerTeamID, const class FString& PlayerName);
	void AddBots(int32 Num);
	void AddNamedBot(const class FString& BotName);
	void AddTeamBots(uint8 TeamId, int32 Num);
	void AssignTeam(class AController* ForController, uint8 AssignedTeam);
	void AutofillWithBots();
	bool BanPlayerById(int32 BannedPlayerId, const class FText& BanReason, float BanDuration);
	bool BanPlayerByName(const class FString& BannedPlayerName, const class FText& BanReason, float BanDuration);
	bool CheckRulesetWinConditions();
	bool CheckWinConditions();
	bool ChooseSpawnPointFromPlayerStart(class AController* Player, class AActor* StartSpot, struct FSpawnPointDef* OutChosenSpawnPoint, ESpawnActorCollisionHandlingMethod* OutCollisionHandlingMethod);
	class ADFTeamState* CreateTeam(const class UDFTeamDefinition* NewTeamDef, const uint8 NewTeamIdToUse);
	void DetermineMatchWinner();
	void DumpActiveRulesets();
	bool FindPlayerStartTransform(class AController* Player, struct FTransform* OutFoundSpawnTransform, const class FString& IncomingName);
	bool ForceTeam(const class FString& SwitchedPlayerName, uint8 TeamIdToAssign);
	bool ForceTeamId(int32 SwitchedPlayerId, uint8 TeamIdToAssign);
	int32 GetTotalNumPlayers(bool bIncludeTravellingPlayers);
	bool KickPlayerById(int32 KickedPlayerId, const class FText& KickReason);
	bool KickPlayerByName(const class FString& KickedPlayerName, const class FText& KickReason);
	void NextMap();
	bool PlayerBotCanRestart(class AAIController* Player);
	bool PlayerCanRestartGeneric(class AController* Player);
	void ReceiveOnLeavingMap();
	void ReceiveOnMatchAborted();
	void ReceiveOnMatchHasEnded();
	void ReceiveOnMatchHasStarted();
	void ReceiveOnMatchIsWaitingToStart();
	void ReceiveOnSwapAIControllers(class AAIController* OldAIC, class AAIController* NewAIC);
	void RegisterSignificantActor(class AActor* ActorToRegister);
	void RemoveAllBots();
	bool RemoveBot(class APlayerState* BotPS);
	bool RemoveBotByName(const class FString& PlayerName);
	void RemoveNewestBot();
	void RemoveNewestPlayer();
	void RemoveOldestBot();
	void RemoveOldestPlayer();
	void RemovePlayerByAge(bool bNewest, bool bExcludeBots, bool bExcludeHumans);
	void RemoveTeamBots(uint8 TeamId, int32 Num);
	void SignificantActorEndPlay(class AActor* RemovedActor, EEndPlayReason EndPlayReason);
	void SwitchToNextMap();
	void UnregisterSignificantActor(class AActor* ActorToRemove);
	void UpdatePlayerGameplayMuteStates(class ADFBasePlayerController* ForPlayerController);

	bool CanAddRuleset(TSubclassOf<class UDFGameRulesetBase>* RulesetClassToAdd, class FString* RulesetDenialReason) const;
	bool CanDealDamage(class ADFBasePlayerState* DamageInstigator, class ADFBasePlayerState* DamagedPlayer) const;
	bool CanRegisterSignificantActor(const class AActor* ActorToRegister, class FString* ActorDenialReason) const;
	uint8 ChooseTeam(class ADFBasePlayerState* ForPlayerState) const;
	uint8 GetAutoAssignHumanTeam() const;
	class FString GetNextGameName() const;
	class FString GetNextMapName() const;
	int32 GetNumPlayersOnTeam(uint8 TeamId, EPlayerKind PlayerType) const;
	bool IsFriendlyFireEnabled() const;
	bool IsHibernating() const;
	bool IsMatchWinner(class ADFBasePlayerState* PlayerStateToCheck) const;
	bool IsValidTeamId(uint8 TeamId) const;
	float ModifyDamage(float Damage, class AActor* DamagedActor, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser) const;
	bool ShouldBotAutofill() const;
	bool ShouldGameplayMuteRemotePlayer(class ADFBasePlayerController* ForPlayer, class ADFBasePlayerController* PlayerToCheck) const;
	bool ShouldHibernate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseGameMode">();
	}
	static class ADFBaseGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseGameMode>();
	}
};
static_assert(alignof(ADFBaseGameMode) == 0x000008, "Wrong alignment on ADFBaseGameMode");
static_assert(sizeof(ADFBaseGameMode) == 0x000418, "Wrong size on ADFBaseGameMode");
static_assert(offsetof(ADFBaseGameMode, DFGameSession) == 0x000308, "Member 'ADFBaseGameMode::DFGameSession' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, TeamStateClass) == 0x000318, "Member 'ADFBaseGameMode::TeamStateClass' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, AIControllerClass) == 0x000320, "Member 'ADFBaseGameMode::AIControllerClass' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, WinningTeams) == 0x000328, "Member 'ADFBaseGameMode::WinningTeams' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, TimerHandle_DefaultTimer) == 0x000338, "Member 'ADFBaseGameMode::TimerHandle_DefaultTimer' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, WarmupTime) == 0x000340, "Member 'ADFBaseGameMode::WarmupTime' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, RoundTimeLimit) == 0x000344, "Member 'ADFBaseGameMode::RoundTimeLimit' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, RoundScoreLimit) == 0x000348, "Member 'ADFBaseGameMode::RoundScoreLimit' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, TimeBetweenMatches) == 0x00034C, "Member 'ADFBaseGameMode::TimeBetweenMatches' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, BalanceTimerInterval) == 0x000354, "Member 'ADFBaseGameMode::BalanceTimerInterval' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, AutoAssignHumanTeam) == 0x000358, "Member 'ADFBaseGameMode::AutoAssignHumanTeam' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, GameDisplayName) == 0x000360, "Member 'ADFBaseGameMode::GameDisplayName' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, NumTeams) == 0x000378, "Member 'ADFBaseGameMode::NumTeams' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, DefaultPawnSpawnCollisionHandlingMethodOverride) == 0x00037E, "Member 'ADFBaseGameMode::DefaultPawnSpawnCollisionHandlingMethodOverride' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, TimerHandle_BalanceTimer) == 0x000380, "Member 'ADFBaseGameMode::TimerHandle_BalanceTimer' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, GameRulesetClasses) == 0x000388, "Member 'ADFBaseGameMode::GameRulesetClasses' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, SignificantActors) == 0x0003D8, "Member 'ADFBaseGameMode::SignificantActors' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, GameRulesets) == 0x0003E8, "Member 'ADFBaseGameMode::GameRulesets' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, AllowedVoteIssues) == 0x000400, "Member 'ADFBaseGameMode::AllowedVoteIssues' has a wrong offset!");
static_assert(offsetof(ADFBaseGameMode, PlayerVotingGameStateComponentClass) == 0x000410, "Member 'ADFBaseGameMode::PlayerVotingGameStateComponentClass' has a wrong offset!");

// Class DonkehFramework.DFBaseGame_DeathMatch
// 0x0008 (0x0420 - 0x0418)
class ADFBaseGame_DeathMatch final : public ADFBaseGameMode
{
public:
	class ADFBasePlayerState*                     WinningPlayerState;                                // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseGame_DeathMatch">();
	}
	static class ADFBaseGame_DeathMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseGame_DeathMatch>();
	}
};
static_assert(alignof(ADFBaseGame_DeathMatch) == 0x000008, "Wrong alignment on ADFBaseGame_DeathMatch");
static_assert(sizeof(ADFBaseGame_DeathMatch) == 0x000420, "Wrong size on ADFBaseGame_DeathMatch");
static_assert(offsetof(ADFBaseGame_DeathMatch, WinningPlayerState) == 0x000418, "Member 'ADFBaseGame_DeathMatch::WinningPlayerState' has a wrong offset!");

// Class DonkehFramework.DFNetworkEventSubsystem
// 0x0070 (0x00A0 - 0x0030)
class UDFNetworkEventSubsystem final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnPlayersUpdatedDynamic;                           // 0x0030(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTeamsUpdatedDynamic;                             // 0x0040(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDFNetworkEventSubsystem* Get(const class UObject* WorldContextObject);

	void OnGameStateEventDynamic__DelegateSignature(class AGameStateBase* GameState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFNetworkEventSubsystem">();
	}
	static class UDFNetworkEventSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFNetworkEventSubsystem>();
	}
};
static_assert(alignof(UDFNetworkEventSubsystem) == 0x000008, "Wrong alignment on UDFNetworkEventSubsystem");
static_assert(sizeof(UDFNetworkEventSubsystem) == 0x0000A0, "Wrong size on UDFNetworkEventSubsystem");
static_assert(offsetof(UDFNetworkEventSubsystem, OnPlayersUpdatedDynamic) == 0x000030, "Member 'UDFNetworkEventSubsystem::OnPlayersUpdatedDynamic' has a wrong offset!");
static_assert(offsetof(UDFNetworkEventSubsystem, OnTeamsUpdatedDynamic) == 0x000040, "Member 'UDFNetworkEventSubsystem::OnTeamsUpdatedDynamic' has a wrong offset!");

// Class DonkehFramework.DFBaseGame_TeamDeathMatch
// 0x0000 (0x0418 - 0x0418)
class ADFBaseGame_TeamDeathMatch final : public ADFBaseGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseGame_TeamDeathMatch">();
	}
	static class ADFBaseGame_TeamDeathMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseGame_TeamDeathMatch>();
	}
};
static_assert(alignof(ADFBaseGame_TeamDeathMatch) == 0x000008, "Wrong alignment on ADFBaseGame_TeamDeathMatch");
static_assert(sizeof(ADFBaseGame_TeamDeathMatch) == 0x000418, "Wrong size on ADFBaseGame_TeamDeathMatch");

// Class DonkehFramework.DFBaseGameInstance
// 0x00F0 (0x0288 - 0x0198)
class UDFBaseGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_198[0x70];                                     // 0x0198(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UDFGameDialogDescriptor*                PendingReturnToMainMenuMessage;                    // 0x0208(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210[0x68];                                     // 0x0210(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerStateTalkingStateChanged;                  // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void DumpOnlineSessionState();
	void FindGames(const ESessionSearchPresenceType SearchPresenceType);
	void ForceUpdateSession();
	void HostGame(const class FString& TravelURL, bool bLANGame, int32 MaxPlayers, const class FString& HostName, const class FString& Password);
	void JoinGame(int32 SearchResultIndex, const class FString& JoinPassword);
	void JoinGameByIP(const class FString& IPAddress, const class FString& JoinPassword);
	void OnNetworkFailure(class UWorld* World, class UNetDriver* NetDriver, ENetworkFailure FailureType, const class FString& ErrorString);
	void OnNetworkLagStateChanged(class UWorld* World, class UNetDriver* NetDriver, ENetworkLagState LagType);
	void OnTravelFailure(class UWorld* World, ETravelFailure FailureType, const class FString& ErrorString);

	bool IsHibernating() const;
	void ProjectVersion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseGameInstance">();
	}
	static class UDFBaseGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFBaseGameInstance>();
	}
};
static_assert(alignof(UDFBaseGameInstance) == 0x000008, "Wrong alignment on UDFBaseGameInstance");
static_assert(sizeof(UDFBaseGameInstance) == 0x000288, "Wrong size on UDFBaseGameInstance");
static_assert(offsetof(UDFBaseGameInstance, PendingReturnToMainMenuMessage) == 0x000208, "Member 'UDFBaseGameInstance::PendingReturnToMainMenuMessage' has a wrong offset!");
static_assert(offsetof(UDFBaseGameInstance, OnPlayerStateTalkingStateChanged) == 0x000278, "Member 'UDFBaseGameInstance::OnPlayerStateTalkingStateChanged' has a wrong offset!");

// Class DonkehFramework.DFPhysicsCollisionHandler
// 0x0000 (0x0040 - 0x0040)
class UDFPhysicsCollisionHandler : public UPhysicsCollisionHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFPhysicsCollisionHandler">();
	}
	static class UDFPhysicsCollisionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFPhysicsCollisionHandler>();
	}
};
static_assert(alignof(UDFPhysicsCollisionHandler) == 0x000008, "Wrong alignment on UDFPhysicsCollisionHandler");
static_assert(sizeof(UDFPhysicsCollisionHandler) == 0x000040, "Wrong size on UDFPhysicsCollisionHandler");

// Class DonkehFramework.DFBaseGameState
// 0x0080 (0x0310 - 0x0290)
class ADFBaseGameState : public AGameState
{
public:
	uint8                                         NumTeams;                                          // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTimerPaused;                                      // 0x0291(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_292[0x2];                                      // 0x0292(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RemainingTime;                                     // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReplicatedRemainingTime;                           // 0x0298(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 TeamScores;                                        // 0x02A0(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADFTeamState*>                   TeamArray;                                         // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamStateAdded;                                  // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamStateRemoved;                                // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerStateAdded;                                // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerStateRemoved;                              // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bAllowVoting : 1;                                  // 0x0300(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPlayerToChangeVote : 1;                      // 0x0300(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDFVotingComponent*                     GameStateVotingComponent;                          // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_NumTeams();
	void OnRep_ReplicatedRemainingTime();
	void SetRemainingTime(int32 NewRemainingTime);
	void SetTimerPauseState(bool bNewPauseState);

	class UDFVotingComponent* GetGameStateVotingComponent() const;
	class ADFTeamState* GetTeamStateById(const uint8 TeamIdNum) const;
	bool IsValidTeamId(const uint8 TeamId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseGameState">();
	}
	static class ADFBaseGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseGameState>();
	}
};
static_assert(alignof(ADFBaseGameState) == 0x000008, "Wrong alignment on ADFBaseGameState");
static_assert(sizeof(ADFBaseGameState) == 0x000310, "Wrong size on ADFBaseGameState");
static_assert(offsetof(ADFBaseGameState, NumTeams) == 0x000290, "Member 'ADFBaseGameState::NumTeams' has a wrong offset!");
static_assert(offsetof(ADFBaseGameState, bTimerPaused) == 0x000291, "Member 'ADFBaseGameState::bTimerPaused' has a wrong offset!");
static_assert(offsetof(ADFBaseGameState, RemainingTime) == 0x000294, "Member 'ADFBaseGameState::RemainingTime' has a wrong offset!");
static_assert(offsetof(ADFBaseGameState, ReplicatedRemainingTime) == 0x000298, "Member 'ADFBaseGameState::ReplicatedRemainingTime' has a wrong offset!");
static_assert(offsetof(ADFBaseGameState, TeamScores) == 0x0002A0, "Member 'ADFBaseGameState::TeamScores' has a wrong offset!");
static_assert(offsetof(ADFBaseGameState, TeamArray) == 0x0002B0, "Member 'ADFBaseGameState::TeamArray' has a wrong offset!");
static_assert(offsetof(ADFBaseGameState, OnTeamStateAdded) == 0x0002C0, "Member 'ADFBaseGameState::OnTeamStateAdded' has a wrong offset!");
static_assert(offsetof(ADFBaseGameState, OnTeamStateRemoved) == 0x0002D0, "Member 'ADFBaseGameState::OnTeamStateRemoved' has a wrong offset!");
static_assert(offsetof(ADFBaseGameState, OnPlayerStateAdded) == 0x0002E0, "Member 'ADFBaseGameState::OnPlayerStateAdded' has a wrong offset!");
static_assert(offsetof(ADFBaseGameState, OnPlayerStateRemoved) == 0x0002F0, "Member 'ADFBaseGameState::OnPlayerStateRemoved' has a wrong offset!");
static_assert(offsetof(ADFBaseGameState, GameStateVotingComponent) == 0x000308, "Member 'ADFBaseGameState::GameStateVotingComponent' has a wrong offset!");

// Class DonkehFramework.DFBaseWeapon
// 0x02A0 (0x0648 - 0x03A8)
class ADFBaseWeapon : public ADFBaseItem
{
public:
	FMulticastInlineDelegateProperty_             OnFire;                                            // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bFiring : 1;                                       // 0x03B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_3B8_1 : 5;                                  // 0x03B8(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bReadyToFirePendingRelease : 1;                    // 0x03B8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFireOnRelease : 1;                                // 0x03B8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrefireDelayMin;                                   // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPrefiring : 1;                                    // 0x03C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_3C0_1 : 7;                                  // 0x03C0(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_3C1[0x3F];                                     // 0x03C1(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bADSFireOnly : 1;                                  // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLastShotFired : 1;                                // 0x0400(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRepCounterPending : 1;                            // 0x0400(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_401[0x1];                                      // 0x0401(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRepShotInfo                           FireCounter;                                       // 0x0402(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, RepNotify, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FRepShotInfo                           PreviousRepFireCounter;                            // 0x0406(0x0004)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRepShotInfo                           PostStoppedFireCounter;                            // 0x040A(0x0004)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40E[0x2];                                      // 0x040E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastFireTime;                                      // 0x0410(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastShotFireTime;                                  // 0x0414(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x4];                                      // 0x0418(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseServerSideFiringLogic : 1;                     // 0x041C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSimulateWeaponFireOnDedicatedServer : 1;          // 0x041C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponAnimCollection                  WeaponAnimCollection;                              // 0x0420(0x00F0)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bStopAllFireAnimsAfterFireRateDelay : 1;           // 0x0510(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSimulate1PWeaponFireOnPawnOwner1PMesh : 1;        // 0x0510(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_511[0x7];                                      // 0x0511(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponSoundCollection                 WeaponSoundCollection;                             // 0x0518(0x0080)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bSingleAction : 1;                                 // 0x0598(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bSingleLoad : 1;                                   // 0x0598(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_599[0x7];                                      // 0x0599(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 WeaponMesh;                                        // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 WeaponMesh1P;                                      // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCanSprintWhilePrefiring : 1;                      // 0x05B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_5B1[0x7];                                      // 0x05B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     DamageFalloffCurve;                                // 0x05B8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x0640(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleFire();
	void OnRep_bPrefiring();
	void OnRep_FireCounter(const struct FRepShotInfo& PreviousValue);
	void OnStartFiring();
	void OnStopFiring();
	void PlayActionAnimations(bool bDontPlayAndReturnDominantPlayLengthOnly);
	float PlayCockAnimations(bool bDontPlayAndReturnDominantPlayLengthOnly);
	float PlayThrowAnimations(bool bOverhandThrow, bool bDontPlayAndReturnDominantPlayLengthOnly);
	float PlayWeaponActionMontage(class UAnimMontage* ActionMontageToPlay);
	float PlayWeaponCockMontage(class UAnimMontage* CockMontageToPlay);
	float PlayWeaponEquipMontage(class UAnimMontage* EquipMontageToPlay);
	float PlayWeaponFireMontage(class UAnimMontage* FireMontageToPlay, bool bFireLast, bool bFireADS);
	float PlayWeaponMontage(class UAnimMontage* WeapMontage, bool bForceDisableAutoBlendOut);
	float PlayWeaponPerspectiveAnimation(const struct FPerspectiveAnim& WeapAnim);
	class UAudioComponent* PlayWeaponSound(const struct FPerspectiveSound& Sound);
	float PlayWeaponThrowOverhandMontage(class UAnimMontage* ThrowOverhandMontageToPlay);
	float PlayWeaponThrowUnderhandMontage(class UAnimMontage* ThrowUnderhandMontageToPlay);
	float PlayWeaponUnEquipMontage(class UAnimMontage* UnEquipMontageToPlay);
	void PrefireDelayElapsed(bool bClientSimulation);
	void ReceiveFire();
	void ReceiveOnStartFiring();
	void ReceiveOnStopFiring();
	void ReceiveSimulateWeaponFire();
	void ReceiveStopSimulatingWeaponFire();
	void ServerFireShot(const struct FVector_NetQuantize& Origin, const struct FVector_NetQuantizeNormal& ShootDir, int32 RandomSeed, float Timestamp, int32 ShotID);
	void ServerPreFire();
	void SimulateWeaponFire();
	void StopSimulatingWeaponFire(bool bForceStopAll);
	void StopWeaponMontage(class UAnimMontage* WeapMontage);
	void StopWeaponPerspectiveAnimation(const struct FPerspectiveAnim& WeapAnim);

	float GetAnimPlayLengthToUseFromPerspectiveAnimPair(const struct FPerspectiveAnim& AnimationPair) const;
	class UAnimSequenceBase* GetAnimToUseFromPerspectiveAnimPair(const struct FPerspectiveAnim& AnimationPair) const;
	float GetMontagePlayLengthToUseFromPerspectiveAnimPair(const struct FPerspectiveAnim& AnimationPair) const;
	class UAnimMontage* GetMontageToUseFromPerspectiveAnimPair(const struct FPerspectiveAnim& AnimationPair) const;
	class USkeletalMeshComponent* GetWeaponMesh() const;
	class USkeletalMeshComponent* GetWeaponMesh1P() const;
	class USkeletalMeshComponent* GetWeaponMeshToUse(bool bIgnoreLocalControlOnServer) const;
	bool IsFiring() const;
	bool ShouldSimulateWeaponFire() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseWeapon">();
	}
	static class ADFBaseWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseWeapon>();
	}
};
static_assert(alignof(ADFBaseWeapon) == 0x000008, "Wrong alignment on ADFBaseWeapon");
static_assert(sizeof(ADFBaseWeapon) == 0x000648, "Wrong size on ADFBaseWeapon");
static_assert(offsetof(ADFBaseWeapon, OnFire) == 0x0003A8, "Member 'ADFBaseWeapon::OnFire' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, PrefireDelayMin) == 0x0003BC, "Member 'ADFBaseWeapon::PrefireDelayMin' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, FireCounter) == 0x000402, "Member 'ADFBaseWeapon::FireCounter' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, PreviousRepFireCounter) == 0x000406, "Member 'ADFBaseWeapon::PreviousRepFireCounter' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, PostStoppedFireCounter) == 0x00040A, "Member 'ADFBaseWeapon::PostStoppedFireCounter' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, LastFireTime) == 0x000410, "Member 'ADFBaseWeapon::LastFireTime' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, LastShotFireTime) == 0x000414, "Member 'ADFBaseWeapon::LastShotFireTime' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, WeaponAnimCollection) == 0x000420, "Member 'ADFBaseWeapon::WeaponAnimCollection' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, WeaponSoundCollection) == 0x000518, "Member 'ADFBaseWeapon::WeaponSoundCollection' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, WeaponMesh) == 0x0005A0, "Member 'ADFBaseWeapon::WeaponMesh' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, WeaponMesh1P) == 0x0005A8, "Member 'ADFBaseWeapon::WeaponMesh1P' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, DamageFalloffCurve) == 0x0005B8, "Member 'ADFBaseWeapon::DamageFalloffCurve' has a wrong offset!");
static_assert(offsetof(ADFBaseWeapon, DamageTypeClass) == 0x000640, "Member 'ADFBaseWeapon::DamageTypeClass' has a wrong offset!");

// Class DonkehFramework.DFPlayerCameraManager
// 0x0000 (0x2740 - 0x2740)
class ADFPlayerCameraManager : public APlayerCameraManager
{
public:
	float                                         AimingFOV;                                         // 0x2738(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimInterpSpeed;                                    // 0x273C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFPlayerCameraManager">();
	}
	static class ADFPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFPlayerCameraManager>();
	}
};
static_assert(alignof(ADFPlayerCameraManager) == 0x000010, "Wrong alignment on ADFPlayerCameraManager");
static_assert(sizeof(ADFPlayerCameraManager) == 0x002740, "Wrong size on ADFPlayerCameraManager");
static_assert(offsetof(ADFPlayerCameraManager, AimingFOV) == 0x002738, "Member 'ADFPlayerCameraManager::AimingFOV' has a wrong offset!");
static_assert(offsetof(ADFPlayerCameraManager, AimInterpSpeed) == 0x00273C, "Member 'ADFPlayerCameraManager::AimInterpSpeed' has a wrong offset!");

// Class DonkehFramework.DFBaseGun
// 0x01E8 (0x0830 - 0x0648)
class ADFBaseGun : public ADFBaseWeapon
{
public:
	FMulticastInlineDelegateProperty_             OnFireModeChanged;                                 // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_658[0x10];                                     // 0x0658(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerIntervalAdjustment;                           // 0x0668(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowAutomaticWeaponCatchup;                      // 0x066C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66D[0x3];                                      // 0x066D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FireRate;                                          // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShotsPerBurst;                                     // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         SupportedFireModes;                                // 0x0678(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFireMode                                     SelectedFireMode;                                  // 0x0679(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67A[0x6];                                      // 0x067A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDFGunRecoilHandler*                    RecoilHandler;                                     // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReloadStarted;                                   // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReloadFinished;                                  // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EGunReloadState                               PendingReloadState;                                // 0x06A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunReloadState                               PreviousReloadState;                               // 0x06A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bKeepLoadedAmmoOnLeaveInventory : 1;               // 0x06AA(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_6AA_1 : 2;                                  // 0x06AA(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bUsesAmmo : 1;                                     // 0x06AA(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bExhaustible : 1;                                  // 0x06AA(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCanSprintWhileReloading : 1;                      // 0x06AA(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         BitPad_6AA_6 : 2;                                  // 0x06AA(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_6AB[0x4D];                                     // 0x06AB(0x004D)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bReloadOnEquip : 1;                                // 0x06F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInstantReloadOnEquip : 1;                         // 0x06F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInstantReloadOnInitialEquip : 1;                  // 0x06F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInstantReloadOnInitialEnterInventory : 1;         // 0x06F8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReloadOnDryFire : 1;                              // 0x06F8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReloadOnStopFire : 1;                             // 0x06F8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSimulateGunReloadOnDedicatedServer : 1;           // 0x06F8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EAmmoClipReloadBehavior                       AmmoClipReloadBehavior;                            // 0x06F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6FA[0x6];                                      // 0x06FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class ADFBaseAmmoClip>>      SupportedAmmoClips;                                // 0x0700(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         StartingAmmoClips;                                 // 0x0750(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDispensedStartingAmmoClips : 1;                   // 0x0754(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_755[0x3];                                      // 0x0755(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ADFBaseAmmoClip*                        CurrentAmmoClip;                                   // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentAmmoClipInvIndex;                           // 0x0760(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_764[0x4];                                      // 0x0764(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADFBaseAmmoClip*                        PreviousAmmoClip;                                  // 0x0768(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentAmmoInClipBeforeReload;                     // 0x0770(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalAvailableAmmoBeforeReload;                    // 0x0774(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReloadCycleIterations;                             // 0x0778(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInfiniteClipAmmo : 1;                             // 0x077C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInfiniteAmmo : 1;                                 // 0x077C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoRecoil : 1;                                     // 0x077C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_77D[0x3];                                      // 0x077D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    CustomMuzzleAttachComponentToUse;                  // 0x0780(0x0028)(Edit, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPrivate)
	class FName                                   MuzzleAttachComponentName;                         // 0x07A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleAttachPoint;                                 // 0x07B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MuzzleFX;                                          // 0x07B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MuzzleLocationOffset;                              // 0x07C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               MuzzleRotationOffset;                              // 0x07CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bLoopedMuzzleFX : 1;                               // 0x07D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7D9[0x7];                                      // 0x07D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               MuzzlePSC;                                         // 0x07E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShellEjectAttachPoint;                             // 0x07E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ShellEjectFX;                                      // 0x07F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ShellEjectLocationOffset;                          // 0x07F8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ShellEjectRotationOffset;                          // 0x0804(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bLoopedShellEjectFX : 1;                           // 0x0810(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayShellEjectFXOnFireLast : 1;                   // 0x0810(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_811[0x3];                                      // 0x0811(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShellEjectDelay;                                   // 0x0814(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ShellEjectPSC;                                     // 0x0818(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_820[0x10];                                     // 0x0820(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientRejectFiredShot(int32 ShotID, class ADFBaseAmmoClip* ShotAmmoClip, int32 ServerClipAmmo);
	void LoadAmmoClip(class ADFBaseAmmoClip* ClipToLoad);
	void LoadNextAmmoClip();
	void LoadPreviousAmmoClip();
	void OnReload(bool bClientSimulation);
	void OnRep_CurrentAmmoClip(class ADFBaseAmmoClip* PrevAmmoClip);
	void OnRep_PendingReloadState(EGunReloadState PrevReloadState);
	void OnRep_SelectedFireMode(EFireMode PrevSelectedFireMode);
	float PlayReloadAnimations(bool bDryReload, bool bDontPlayAndReturnDominantPlayLengthOnly);
	float PlayReloadTransitionAnimations(bool bStartReload, bool bDontPlayAndReturnDominantPlayLengthOnly);
	float PlayWeaponEndReloadMontage(class UAnimMontage* EndReloadMontageToPlay, bool bDryReload);
	float PlayWeaponReloadMontage(bool bDryReload);
	float PlayWeaponStartReloadMontage(class UAnimMontage* StartReloadMontageToPlay, bool bDryReload);
	void ReceiveAmmoExhausted();
	void ReceiveFireModeChanged(EFireMode NewFireMode, EFireMode PrevFireMode, bool bFromPlayerInput);
	void ReceiveReloadFinished();
	void ReceiveReloadStarted();
	void ServerSetFireMode(EFireMode NewFireMode);
	void ServerStartReload();
	bool SetFireMode(EFireMode NewFireMode, bool bFromPlayerInput, bool bForce);
	void SetFireModeBP(EFireMode NewFireMode);
	void SetReloadState(EGunReloadState NewReloadState);
	void SimulateGunReload();
	void StartReload(bool bClientSimulation);
	void StopSimulatingGunReload();
	void UnloadCurrentAmmoClip();

	bool CanReload() const;
	int32 GetClipAmmo() const;
	class USceneComponent* GetMuzzleAttachComponent(bool bIgnoreLocalControlOnServer) const;
	class FName GetMuzzleAttachPoint() const;
	struct FVector GetMuzzleDirection(bool bIgnoreLocalControlOnServer) const;
	struct FVector GetMuzzleLocation(bool bIgnoreLocalControlOnServer) const;
	int32 GetNumFreeAmmoClips(bool bIncludeEmptyMags, bool bIncludeCurrentMag) const;
	int32 GetPostReloadClipAmmo() const;
	EGunReloadState GetPreviousReloadState() const;
	EGunReloadState GetReloadState() const;
	EFireMode GetSelectedFireMode() const;
	class FName GetShellEjectAttachPoint() const;
	uint8 GetSupportedFireModes() const;
	int32 GetTotalAmmo(bool bIncludeLoadedMags) const;
	bool HasAmmoClip() const;
	bool HasExhaustedAllAmmo() const;
	bool IsDryReloading() const;
	bool IsReloading() const;
	bool ShouldSimulateGunReload() const;
	bool ShouldUseRecoil() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseGun">();
	}
	static class ADFBaseGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseGun>();
	}
};
static_assert(alignof(ADFBaseGun) == 0x000008, "Wrong alignment on ADFBaseGun");
static_assert(sizeof(ADFBaseGun) == 0x000830, "Wrong size on ADFBaseGun");
static_assert(offsetof(ADFBaseGun, OnFireModeChanged) == 0x000648, "Member 'ADFBaseGun::OnFireModeChanged' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, TimerIntervalAdjustment) == 0x000668, "Member 'ADFBaseGun::TimerIntervalAdjustment' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, bAllowAutomaticWeaponCatchup) == 0x00066C, "Member 'ADFBaseGun::bAllowAutomaticWeaponCatchup' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, FireRate) == 0x000670, "Member 'ADFBaseGun::FireRate' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, ShotsPerBurst) == 0x000674, "Member 'ADFBaseGun::ShotsPerBurst' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, SupportedFireModes) == 0x000678, "Member 'ADFBaseGun::SupportedFireModes' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, SelectedFireMode) == 0x000679, "Member 'ADFBaseGun::SelectedFireMode' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, RecoilHandler) == 0x000680, "Member 'ADFBaseGun::RecoilHandler' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, OnReloadStarted) == 0x000688, "Member 'ADFBaseGun::OnReloadStarted' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, OnReloadFinished) == 0x000698, "Member 'ADFBaseGun::OnReloadFinished' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, PendingReloadState) == 0x0006A8, "Member 'ADFBaseGun::PendingReloadState' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, PreviousReloadState) == 0x0006A9, "Member 'ADFBaseGun::PreviousReloadState' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, AmmoClipReloadBehavior) == 0x0006F9, "Member 'ADFBaseGun::AmmoClipReloadBehavior' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, SupportedAmmoClips) == 0x000700, "Member 'ADFBaseGun::SupportedAmmoClips' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, StartingAmmoClips) == 0x000750, "Member 'ADFBaseGun::StartingAmmoClips' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, CurrentAmmoClip) == 0x000758, "Member 'ADFBaseGun::CurrentAmmoClip' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, CurrentAmmoClipInvIndex) == 0x000760, "Member 'ADFBaseGun::CurrentAmmoClipInvIndex' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, PreviousAmmoClip) == 0x000768, "Member 'ADFBaseGun::PreviousAmmoClip' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, CurrentAmmoInClipBeforeReload) == 0x000770, "Member 'ADFBaseGun::CurrentAmmoInClipBeforeReload' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, TotalAvailableAmmoBeforeReload) == 0x000774, "Member 'ADFBaseGun::TotalAvailableAmmoBeforeReload' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, ReloadCycleIterations) == 0x000778, "Member 'ADFBaseGun::ReloadCycleIterations' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, CustomMuzzleAttachComponentToUse) == 0x000780, "Member 'ADFBaseGun::CustomMuzzleAttachComponentToUse' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, MuzzleAttachComponentName) == 0x0007A8, "Member 'ADFBaseGun::MuzzleAttachComponentName' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, MuzzleAttachPoint) == 0x0007B0, "Member 'ADFBaseGun::MuzzleAttachPoint' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, MuzzleFX) == 0x0007B8, "Member 'ADFBaseGun::MuzzleFX' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, MuzzleLocationOffset) == 0x0007C0, "Member 'ADFBaseGun::MuzzleLocationOffset' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, MuzzleRotationOffset) == 0x0007CC, "Member 'ADFBaseGun::MuzzleRotationOffset' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, MuzzlePSC) == 0x0007E0, "Member 'ADFBaseGun::MuzzlePSC' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, ShellEjectAttachPoint) == 0x0007E8, "Member 'ADFBaseGun::ShellEjectAttachPoint' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, ShellEjectFX) == 0x0007F0, "Member 'ADFBaseGun::ShellEjectFX' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, ShellEjectLocationOffset) == 0x0007F8, "Member 'ADFBaseGun::ShellEjectLocationOffset' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, ShellEjectRotationOffset) == 0x000804, "Member 'ADFBaseGun::ShellEjectRotationOffset' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, ShellEjectDelay) == 0x000814, "Member 'ADFBaseGun::ShellEjectDelay' has a wrong offset!");
static_assert(offsetof(ADFBaseGun, ShellEjectPSC) == 0x000818, "Member 'ADFBaseGun::ShellEjectPSC' has a wrong offset!");

// Class DonkehFramework.DFPlayerComponent
// 0x0018 (0x00C8 - 0x00B0)
class UDFPlayerComponent : public UActorComponent
{
public:
	class AController*                            ControllerOwner;                                   // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bWantsToRestart : 1;                               // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_B9[0xF];                                       // 0x00B9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanRestartPlayer();
	float GetMinRestartDelay();
	void ReceiveGameHasEnded(class AActor* EndGameFocus, bool bIsWinner);
	void ReceivePawnLeavingGame();
	void ReceiveSeamlessTravelFromCommon(class AController* OldC, class UDFPlayerComponent* OldCPlayerComp);
	void ReceiveSeamlessTravelToCommon(class AController* NewC, class UDFPlayerComponent* NewCPlayerComp);
	void RestartPlayer();

	class APawn* GetPawnOwner() const;
	class APlayerState* GetPlayerState() const;
	class ADFTeamState* GetTeamState() const;
	bool IsPendingRestart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFPlayerComponent">();
	}
	static class UDFPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFPlayerComponent>();
	}
};
static_assert(alignof(UDFPlayerComponent) == 0x000008, "Wrong alignment on UDFPlayerComponent");
static_assert(sizeof(UDFPlayerComponent) == 0x0000C8, "Wrong size on UDFPlayerComponent");
static_assert(offsetof(UDFPlayerComponent, ControllerOwner) == 0x0000B0, "Member 'UDFPlayerComponent::ControllerOwner' has a wrong offset!");

// Class DonkehFramework.DFBaseGun_Projectile
// 0x0028 (0x0858 - 0x0830)
class ADFBaseGun_Projectile : public ADFBaseGun
{
public:
	TSubclassOf<class ADFBaseProjectile>          ProjectileClass;                                   // 0x0830(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileSpawnDistance;                           // 0x0838(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetTraceDistance;                               // 0x083C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMuzzleAsTrace;                                 // 0x0840(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_841[0x3];                                      // 0x0841(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MuzzleSightOffset;                                 // 0x0844(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastSparseDelegateProperty_             OnProcessValidProjCSHit;                           // 0x0850(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_851[0x7];                                      // 0x0851(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientDrawDebugFireCone(const struct FVector& ConeOrig, const struct FVector_NetQuantizeNormal& ConeDir);
	void ClientProjDebugImpactInfo(class ADFBaseProjectile* Proj, const struct FVector& ImpactLoc, const struct FVector_NetQuantizeNormal& ImpactNorm);
	void ClientProjDebugInfo(class ADFBaseProjectile* Proj, const struct FVector& NewProjLoc, const struct FVector& LastProjLoc, const struct FRotator& NewProjRot, const struct FVector& NewProjVel);
	void ServerNotifyCSHit(class ADFBaseProjectile* HitProj, const struct FCSHitInfo& HitInfo, int32 ShotID);
	void ServerNotifyCSHitPredicted(const struct FCSHitInfo& HitInfo, int32 ShotID);

	void CalcShotVector(struct FVector* OutProjOrigin, struct FVector* OutProjDir) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseGun_Projectile">();
	}
	static class ADFBaseGun_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseGun_Projectile>();
	}
};
static_assert(alignof(ADFBaseGun_Projectile) == 0x000008, "Wrong alignment on ADFBaseGun_Projectile");
static_assert(sizeof(ADFBaseGun_Projectile) == 0x000858, "Wrong size on ADFBaseGun_Projectile");
static_assert(offsetof(ADFBaseGun_Projectile, ProjectileClass) == 0x000830, "Member 'ADFBaseGun_Projectile::ProjectileClass' has a wrong offset!");
static_assert(offsetof(ADFBaseGun_Projectile, ProjectileSpawnDistance) == 0x000838, "Member 'ADFBaseGun_Projectile::ProjectileSpawnDistance' has a wrong offset!");
static_assert(offsetof(ADFBaseGun_Projectile, TargetTraceDistance) == 0x00083C, "Member 'ADFBaseGun_Projectile::TargetTraceDistance' has a wrong offset!");
static_assert(offsetof(ADFBaseGun_Projectile, bUseMuzzleAsTrace) == 0x000840, "Member 'ADFBaseGun_Projectile::bUseMuzzleAsTrace' has a wrong offset!");
static_assert(offsetof(ADFBaseGun_Projectile, MuzzleSightOffset) == 0x000844, "Member 'ADFBaseGun_Projectile::MuzzleSightOffset' has a wrong offset!");
static_assert(offsetof(ADFBaseGun_Projectile, OnProcessValidProjCSHit) == 0x000850, "Member 'ADFBaseGun_Projectile::OnProcessValidProjCSHit' has a wrong offset!");

// Class DonkehFramework.DFProjectileSubsystem
// 0x0028 (0x0058 - 0x0030)
class UDFProjectileSubsystem final : public UWorldSubsystem
{
public:
	TArray<class ADFBaseProjectile*>              PredictedProjectiles;                              // 0x0030(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFiredShots;                                     // 0x0040(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x14];                                      // 0x0044(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFProjectileSubsystem">();
	}
	static class UDFProjectileSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFProjectileSubsystem>();
	}
};
static_assert(alignof(UDFProjectileSubsystem) == 0x000008, "Wrong alignment on UDFProjectileSubsystem");
static_assert(sizeof(UDFProjectileSubsystem) == 0x000058, "Wrong size on UDFProjectileSubsystem");
static_assert(offsetof(UDFProjectileSubsystem, PredictedProjectiles) == 0x000030, "Member 'UDFProjectileSubsystem::PredictedProjectiles' has a wrong offset!");
static_assert(offsetof(UDFProjectileSubsystem, MaxFiredShots) == 0x000040, "Member 'UDFProjectileSubsystem::MaxFiredShots' has a wrong offset!");

// Class DonkehFramework.DFBaseImpactEffect
// 0x02C8 (0x04E8 - 0x0220)
class ADFBaseImpactEffect : public AActor
{
public:
	TArray<struct FDecalData>                     ConcreteDecals;                                    // 0x0220(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     MetalSolidDecals;                                  // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     WoodDecals;                                        // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     GlassBPDecals;                                     // 0x0250(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     GlassDecals;                                       // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     GlassWHDecals;                                     // 0x0270(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     MetalThinDecals;                                   // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     SandbagDecals;                                     // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     BrickWallDecals;                                   // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     RubberDecals;                                      // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     DrywallDecals;                                     // 0x02C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     ElectricDevicesDecals;                             // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDecalData>                     OilBarrelDecals;                                   // 0x02E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        SnowFX;                                            // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        WaterFX;                                           // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        ConcreteFX;                                        // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        DirtFX;                                            // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        MetalSolidFX;                                      // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        WoodFX;                                            // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        GlassBPFX;                                         // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        GlassFX;                                           // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        GlassWHFX;                                         // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        GrassFX;                                           // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        MetalThinFX;                                       // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        SandbagFX;                                         // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        BrickWallFX;                                       // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        RubberFX;                                          // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        DrywallFX;                                         // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        ElectricDevicesFX;                                 // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        OilBarrelFX;                                       // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        SandFX;                                            // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        SoftFX;                                            // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        GroundFX;                                          // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        RockFX;                                            // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        FleshFX;                                           // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              ConcreteSound;                                     // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              DirtSound;                                         // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              SnowSound;                                         // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              SandbagSound;                                      // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              BrickWallSound;                                    // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              WaterSound;                                        // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              MetalSolidSound;                                   // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              MetalThinSound;                                    // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              WoodSound;                                         // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              GlassSound;                                        // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              GlassBPSound;                                      // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              GlassWHSound;                                      // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              GrassSound;                                        // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              RubberSound;                                       // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              DrywallSound;                                      // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              GroundSound;                                       // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              ElectricDevicesSound;                              // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              OilBarrelSound;                                    // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              RockSound;                                         // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              FleshSound;                                        // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDecalData                             DefaultDecal;                                      // 0x0440(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        DefaultFX;                                         // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              DefaultSound;                                      // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FHitResult                             SurfaceHit;                                        // 0x0460(0x0088)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	class UParticleSystem* GetImpactFX(EPhysicalSurface SurfaceType) const;
	class USoundCue* GetImpactSound(EPhysicalSurface SurfaceType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseImpactEffect">();
	}
	static class ADFBaseImpactEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseImpactEffect>();
	}
};
static_assert(alignof(ADFBaseImpactEffect) == 0x000008, "Wrong alignment on ADFBaseImpactEffect");
static_assert(sizeof(ADFBaseImpactEffect) == 0x0004E8, "Wrong size on ADFBaseImpactEffect");
static_assert(offsetof(ADFBaseImpactEffect, ConcreteDecals) == 0x000220, "Member 'ADFBaseImpactEffect::ConcreteDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, MetalSolidDecals) == 0x000230, "Member 'ADFBaseImpactEffect::MetalSolidDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, WoodDecals) == 0x000240, "Member 'ADFBaseImpactEffect::WoodDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GlassBPDecals) == 0x000250, "Member 'ADFBaseImpactEffect::GlassBPDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GlassDecals) == 0x000260, "Member 'ADFBaseImpactEffect::GlassDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GlassWHDecals) == 0x000270, "Member 'ADFBaseImpactEffect::GlassWHDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, MetalThinDecals) == 0x000280, "Member 'ADFBaseImpactEffect::MetalThinDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, SandbagDecals) == 0x000290, "Member 'ADFBaseImpactEffect::SandbagDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, BrickWallDecals) == 0x0002A0, "Member 'ADFBaseImpactEffect::BrickWallDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, RubberDecals) == 0x0002B0, "Member 'ADFBaseImpactEffect::RubberDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, DrywallDecals) == 0x0002C0, "Member 'ADFBaseImpactEffect::DrywallDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, ElectricDevicesDecals) == 0x0002D0, "Member 'ADFBaseImpactEffect::ElectricDevicesDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, OilBarrelDecals) == 0x0002E0, "Member 'ADFBaseImpactEffect::OilBarrelDecals' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, SnowFX) == 0x0002F0, "Member 'ADFBaseImpactEffect::SnowFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, WaterFX) == 0x0002F8, "Member 'ADFBaseImpactEffect::WaterFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, ConcreteFX) == 0x000300, "Member 'ADFBaseImpactEffect::ConcreteFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, DirtFX) == 0x000308, "Member 'ADFBaseImpactEffect::DirtFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, MetalSolidFX) == 0x000310, "Member 'ADFBaseImpactEffect::MetalSolidFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, WoodFX) == 0x000318, "Member 'ADFBaseImpactEffect::WoodFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GlassBPFX) == 0x000320, "Member 'ADFBaseImpactEffect::GlassBPFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GlassFX) == 0x000328, "Member 'ADFBaseImpactEffect::GlassFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GlassWHFX) == 0x000330, "Member 'ADFBaseImpactEffect::GlassWHFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GrassFX) == 0x000338, "Member 'ADFBaseImpactEffect::GrassFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, MetalThinFX) == 0x000340, "Member 'ADFBaseImpactEffect::MetalThinFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, SandbagFX) == 0x000348, "Member 'ADFBaseImpactEffect::SandbagFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, BrickWallFX) == 0x000350, "Member 'ADFBaseImpactEffect::BrickWallFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, RubberFX) == 0x000358, "Member 'ADFBaseImpactEffect::RubberFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, DrywallFX) == 0x000360, "Member 'ADFBaseImpactEffect::DrywallFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, ElectricDevicesFX) == 0x000368, "Member 'ADFBaseImpactEffect::ElectricDevicesFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, OilBarrelFX) == 0x000370, "Member 'ADFBaseImpactEffect::OilBarrelFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, SandFX) == 0x000378, "Member 'ADFBaseImpactEffect::SandFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, SoftFX) == 0x000380, "Member 'ADFBaseImpactEffect::SoftFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GroundFX) == 0x000388, "Member 'ADFBaseImpactEffect::GroundFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, RockFX) == 0x000390, "Member 'ADFBaseImpactEffect::RockFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, FleshFX) == 0x000398, "Member 'ADFBaseImpactEffect::FleshFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, ConcreteSound) == 0x0003A0, "Member 'ADFBaseImpactEffect::ConcreteSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, DirtSound) == 0x0003A8, "Member 'ADFBaseImpactEffect::DirtSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, SnowSound) == 0x0003B0, "Member 'ADFBaseImpactEffect::SnowSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, SandbagSound) == 0x0003B8, "Member 'ADFBaseImpactEffect::SandbagSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, BrickWallSound) == 0x0003C0, "Member 'ADFBaseImpactEffect::BrickWallSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, WaterSound) == 0x0003C8, "Member 'ADFBaseImpactEffect::WaterSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, MetalSolidSound) == 0x0003D0, "Member 'ADFBaseImpactEffect::MetalSolidSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, MetalThinSound) == 0x0003D8, "Member 'ADFBaseImpactEffect::MetalThinSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, WoodSound) == 0x0003E0, "Member 'ADFBaseImpactEffect::WoodSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GlassSound) == 0x0003E8, "Member 'ADFBaseImpactEffect::GlassSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GlassBPSound) == 0x0003F0, "Member 'ADFBaseImpactEffect::GlassBPSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GlassWHSound) == 0x0003F8, "Member 'ADFBaseImpactEffect::GlassWHSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GrassSound) == 0x000400, "Member 'ADFBaseImpactEffect::GrassSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, RubberSound) == 0x000408, "Member 'ADFBaseImpactEffect::RubberSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, DrywallSound) == 0x000410, "Member 'ADFBaseImpactEffect::DrywallSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, GroundSound) == 0x000418, "Member 'ADFBaseImpactEffect::GroundSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, ElectricDevicesSound) == 0x000420, "Member 'ADFBaseImpactEffect::ElectricDevicesSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, OilBarrelSound) == 0x000428, "Member 'ADFBaseImpactEffect::OilBarrelSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, RockSound) == 0x000430, "Member 'ADFBaseImpactEffect::RockSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, FleshSound) == 0x000438, "Member 'ADFBaseImpactEffect::FleshSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, DefaultDecal) == 0x000440, "Member 'ADFBaseImpactEffect::DefaultDecal' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, DefaultFX) == 0x000450, "Member 'ADFBaseImpactEffect::DefaultFX' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, DefaultSound) == 0x000458, "Member 'ADFBaseImpactEffect::DefaultSound' has a wrong offset!");
static_assert(offsetof(ADFBaseImpactEffect, SurfaceHit) == 0x000460, "Member 'ADFBaseImpactEffect::SurfaceHit' has a wrong offset!");

// Class DonkehFramework.DFBasePickup
// 0x0038 (0x0258 - 0x0220)
class ADFBasePickup : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mesh;                                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bActive : 1;                                       // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADFBaseCharacter*                       InvokingPawn;                                      // 0x0238(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseable : 1;                                      // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverlap : 1;                                      // 0x0248(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_249[0x3];                                      // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnDelay;                                      // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              PickupSound;                                       // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GivePickupTo(class ADFBaseCharacter* PickupOwner);
	void InitializePickup();
	void OnPickup();
	void OnRep_Active();
	void OnRespawn();
	void RespawnPickup();
	void UpdatePickupState(bool bNewActive);

	bool CanBePickedUp(class ADFBaseCharacter* Invoker) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBasePickup">();
	}
	static class ADFBasePickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBasePickup>();
	}
};
static_assert(alignof(ADFBasePickup) == 0x000008, "Wrong alignment on ADFBasePickup");
static_assert(sizeof(ADFBasePickup) == 0x000258, "Wrong size on ADFBasePickup");
static_assert(offsetof(ADFBasePickup, Mesh) == 0x000228, "Member 'ADFBasePickup::Mesh' has a wrong offset!");
static_assert(offsetof(ADFBasePickup, InvokingPawn) == 0x000238, "Member 'ADFBasePickup::InvokingPawn' has a wrong offset!");
static_assert(offsetof(ADFBasePickup, RespawnDelay) == 0x00024C, "Member 'ADFBasePickup::RespawnDelay' has a wrong offset!");
static_assert(offsetof(ADFBasePickup, PickupSound) == 0x000250, "Member 'ADFBasePickup::PickupSound' has a wrong offset!");

// Class DonkehFramework.DFBasePickup_Health
// 0x0008 (0x0260 - 0x0258)
class ADFBasePickup_Health final : public ADFBasePickup
{
public:
	float                                         Health;                                            // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBasePickup_Health">();
	}
	static class ADFBasePickup_Health* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBasePickup_Health>();
	}
};
static_assert(alignof(ADFBasePickup_Health) == 0x000008, "Wrong alignment on ADFBasePickup_Health");
static_assert(sizeof(ADFBasePickup_Health) == 0x000260, "Wrong size on ADFBasePickup_Health");
static_assert(offsetof(ADFBasePickup_Health, Health) == 0x000258, "Member 'ADFBasePickup_Health::Health' has a wrong offset!");

// Class DonkehFramework.DFRecastNavMesh
// 0x0000 (0x04B8 - 0x04B8)
class ADFRecastNavMesh : public ARecastNavMesh
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFRecastNavMesh">();
	}
	static class ADFRecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFRecastNavMesh>();
	}
};
static_assert(alignof(ADFRecastNavMesh) == 0x000008, "Wrong alignment on ADFRecastNavMesh");
static_assert(sizeof(ADFRecastNavMesh) == 0x0004B8, "Wrong size on ADFRecastNavMesh");

// Class DonkehFramework.DFBasePickup_Item
// 0x0008 (0x0260 - 0x0258)
class ADFBasePickup_Item final : public ADFBasePickup
{
public:
	class UDFInventoryComponent*                  Inventory;                                         // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBasePickup_Item">();
	}
	static class ADFBasePickup_Item* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBasePickup_Item>();
	}
};
static_assert(alignof(ADFBasePickup_Item) == 0x000008, "Wrong alignment on ADFBasePickup_Item");
static_assert(sizeof(ADFBasePickup_Item) == 0x000260, "Wrong size on ADFBasePickup_Item");
static_assert(offsetof(ADFBasePickup_Item, Inventory) == 0x000258, "Member 'ADFBasePickup_Item::Inventory' has a wrong offset!");

// Class DonkehFramework.DFReplInfo
// 0x0000 (0x0220 - 0x0220)
class ADFReplInfo : public ADFInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFReplInfo">();
	}
	static class ADFReplInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFReplInfo>();
	}
};
static_assert(alignof(ADFReplInfo) == 0x000008, "Wrong alignment on ADFReplInfo");
static_assert(sizeof(ADFReplInfo) == 0x000220, "Wrong size on ADFReplInfo");

// Class DonkehFramework.DFBasePlayerCharacter
// 0x0060 (0x0970 - 0x0910)
class ADFBasePlayerCharacter : public ADFBaseCharacter
{
public:
	float                                         BaseTurnRate;                                      // 0x0908(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseLookUpRate;                                    // 0x090C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_910[0x8];                                      // 0x0910(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionDistance;                               // 0x0918(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bFirstPerson : 1;                                  // 0x091C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_91D[0x3];                                      // 0x091D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       Camera;                                            // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    CameraBoom;                                        // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       Camera1P;                                          // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bStartInFirstPerson : 1;                           // 0x0938(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTrueFirstPerson : 1;                              // 0x0938(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableOrientationOfRotationToMovementInFirstPerson : 1; // 0x0938(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableUsageOfControllerRotationYawInThirdPerson : 1; // 0x0938(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_939[0x7];                                      // 0x0939(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh1P;                                            // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseFirstPersonMesh : 1;                           // 0x0948(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_949[0x3];                                      // 0x0949(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemAttachPoint1P;                                 // 0x094C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_954[0x4];                                      // 0x0954(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerToggleFirstPerson;                         // 0x0958(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_968[0x8];                                      // 0x0968(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JumpVaultPressed();
	void LookUpAtRate(float Rate);
	void MoveForward(float Value);
	void MoveRight(float Value);
	void MoveUp(float Value);
	void OnFirePressed();
	void OnFireReleased();
	void OnToggleFirstPerson(bool bNewFirstPerson);
	void ServerOnToggleFirstPerson(bool bNewFirstPerson);
	void ServerUse(class AActor* UseTarget, const struct FVector_NetQuantize& UseTraceStart, const struct FVector_NetQuantize& UseTraceEnd);
	void SetMeshVisibility(bool bFirstPersonVisibility);
	void SwitchFireMode();
	void TurnAtRate(float Rate);
	void Use();

	class UCameraComponent* GetCamera() const;
	class UCameraComponent* GetCamera1P() const;
	class USpringArmComponent* GetCameraBoom() const;
	class USkeletalMesh* GetDefaultPawnMesh1P() const;
	class FName GetItemAttachPoint1P() const;
	class USkeletalMeshComponent* GetMesh1P() const;
	bool IsFirstPerson() const;
	bool IsLocalFirstPerson() const;
	bool IsTrueFirstPerson() const;
	bool IsUsingFirstPersonMesh() const;
	class USkeletalMesh* ReceiveGetDefaultPawnMesh1P() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBasePlayerCharacter">();
	}
	static class ADFBasePlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBasePlayerCharacter>();
	}
};
static_assert(alignof(ADFBasePlayerCharacter) == 0x000010, "Wrong alignment on ADFBasePlayerCharacter");
static_assert(sizeof(ADFBasePlayerCharacter) == 0x000970, "Wrong size on ADFBasePlayerCharacter");
static_assert(offsetof(ADFBasePlayerCharacter, BaseTurnRate) == 0x000908, "Member 'ADFBasePlayerCharacter::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerCharacter, BaseLookUpRate) == 0x00090C, "Member 'ADFBasePlayerCharacter::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerCharacter, InteractionDistance) == 0x000918, "Member 'ADFBasePlayerCharacter::InteractionDistance' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerCharacter, Camera) == 0x000920, "Member 'ADFBasePlayerCharacter::Camera' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerCharacter, CameraBoom) == 0x000928, "Member 'ADFBasePlayerCharacter::CameraBoom' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerCharacter, Camera1P) == 0x000930, "Member 'ADFBasePlayerCharacter::Camera1P' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerCharacter, Mesh1P) == 0x000940, "Member 'ADFBasePlayerCharacter::Mesh1P' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerCharacter, ItemAttachPoint1P) == 0x00094C, "Member 'ADFBasePlayerCharacter::ItemAttachPoint1P' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerCharacter, OnPlayerToggleFirstPerson) == 0x000958, "Member 'ADFBasePlayerCharacter::OnPlayerToggleFirstPerson' has a wrong offset!");

// Class DonkehFramework.DFBasePlayerController
// 0x0088 (0x05F8 - 0x0570)
class ADFBasePlayerController : public APlayerController
{
public:
	uint8                                         Pad_570[0x8];                                      // 0x0570(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPossessPawn;                                     // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnpossessPawn;                                   // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADFBaseCharacter*                       DFCharacter;                                       // 0x05A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A8[0x18];                                     // 0x05A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSetGameOnlyInputOnBeginPlay : 1;                  // 0x05C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_5C1[0x7];                                      // 0x05C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerTeamNumUpdated;                            // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerTeamStateUpdated;                          // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ADFTeamState*                           TeamState;                                         // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxChatMsgLen;                                     // 0x05F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F4[0x4];                                      // 0x05F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Admin(const class FString& Cmd);
	bool CastVote(int32 VoteSelectionIndex, EDFVotingChannel VotingChannel);
	void ClientEnableCheats();
	bool InitiateVote(TSubclassOf<class UDFVoteIssue> IssueClass, const struct FDFVoteIssueContext& IssueContext, int32 VoteSelectionIndex, EDFVotingChannel VotingChannel);
	bool IsGameInputAllowed();
	void OnFirePressed();
	void OnFireReleased();
	void ReceiveGameHasEnded(class AActor* EndGameFocus, bool bIsWinner);
	void ReceiveNewChatMsg(const struct FPlayerChatMsg& ChatMsg);
	void ReceiveOnRepPlayerState();
	void ReceivePlayerTeamNumUpdated(uint8 LastTeamNum, uint8 NewTeamNum);
	void ReceivePlayerTeamStateUpdated(class ADFTeamState* LastTeamState, class ADFTeamState* NewTeamState, bool bNewTeamStateInit);
	void ReceivePossessPawn(class APawn* NewPawn);
	void ReceivePreClientTravel(const class FString& PendingURL, bool bIsSeamlessTravelWithRelativeTravelType);
	void ReceiveUnpossessPawn(class APawn* UnpossessedPawn);
	void Say(const class FString& Msg);
	void ServerAdmin(const class FString& Cmd);
	void ServerCastVote(int32 VoteSelectionIndex, EDFVotingChannel VotingChannel);
	void ServerEnableCheats();
	void ServerInitiateVote(TSubclassOf<class UDFVoteIssue> IssueClass, const struct FDFVoteIssueContext& IssueContext, int32 VoteSelectionIndex, EDFVotingChannel VotingChannel);
	void ServerNotifyProjCSHit(class ADFBaseProjectile* HitProj, class APawn* HitProjDamageInstigator, const struct FCSHitInfo& HitInfo, int32 ShotID);
	void ServerSay(const class FString& Msg);
	void ServerTeamSay(const class FString& Msg);
	void TeamSay(const class FString& Msg);

	struct FTimerHandle GetUnFreezeTimerHandle() const;
	class UDFVotingComponent* GetVotingComponentByChannel(EDFVotingChannel VotingChannel) const;
	bool IsServerAdministrator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBasePlayerController">();
	}
	static class ADFBasePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBasePlayerController>();
	}
};
static_assert(alignof(ADFBasePlayerController) == 0x000008, "Wrong alignment on ADFBasePlayerController");
static_assert(sizeof(ADFBasePlayerController) == 0x0005F8, "Wrong size on ADFBasePlayerController");
static_assert(offsetof(ADFBasePlayerController, OnPossessPawn) == 0x000578, "Member 'ADFBasePlayerController::OnPossessPawn' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerController, OnUnpossessPawn) == 0x000588, "Member 'ADFBasePlayerController::OnUnpossessPawn' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerController, DFCharacter) == 0x0005A0, "Member 'ADFBasePlayerController::DFCharacter' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerController, OnPlayerTeamNumUpdated) == 0x0005C8, "Member 'ADFBasePlayerController::OnPlayerTeamNumUpdated' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerController, OnPlayerTeamStateUpdated) == 0x0005D8, "Member 'ADFBasePlayerController::OnPlayerTeamStateUpdated' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerController, TeamState) == 0x0005E8, "Member 'ADFBasePlayerController::TeamState' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerController, MaxChatMsgLen) == 0x0005F0, "Member 'ADFBasePlayerController::MaxChatMsgLen' has a wrong offset!");

// Class DonkehFramework.DFSingleActionWeapAnimInstInterface
// 0x0000 (0x0028 - 0x0028)
class IDFSingleActionWeapAnimInstInterface final : public IInterface
{
public:
	float PlayActionMontage(class UAnimMontage* MontageToPlay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFSingleActionWeapAnimInstInterface">();
	}
	static class IDFSingleActionWeapAnimInstInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDFSingleActionWeapAnimInstInterface>();
	}
};
static_assert(alignof(IDFSingleActionWeapAnimInstInterface) == 0x000008, "Wrong alignment on IDFSingleActionWeapAnimInstInterface");
static_assert(sizeof(IDFSingleActionWeapAnimInstInterface) == 0x000028, "Wrong size on IDFSingleActionWeapAnimInstInterface");

// Class DonkehFramework.DFBasePlayerState
// 0x0058 (0x0378 - 0x0320)
class ADFBasePlayerState : public APlayerState
{
public:
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRepPlayerName;                                   // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerTeamNumUpdated;                            // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         TeamNum;                                           // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PrevTeamNum;                                       // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34A[0x6];                                      // 0x034A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ADFTeamState*                           TeamState;                                         // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADFTeamState*                           PrevTeamState;                                     // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAdmin : 1;                                        // 0x0360(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_361[0x3];                                      // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumKills;                                          // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumAssists;                                        // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumDeaths;                                         // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamStartTime;                                     // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bAdmin(bool bAdminStatusBeforeUpdate);
	void OnRep_NumAssists(int32 PrevNumAssists);
	void OnRep_NumDeaths(int32 PrevNumDeaths);
	void OnRep_NumKills(int32 PrevNumKills);
	void OnRep_TeamNum(uint8 TeamNumBeforeUpdate);
	void OnRep_TeamState(class ADFTeamState* TeamStateBeforeUpdate);
	void OnTeamNumUpdated(uint8 TeamNumBeforeUpdate);
	void OnTeamStateUpdated(class ADFTeamState* TeamStateBeforeUpdate);
	void ReceiveOnRepPlayerName();
	void ScoreAssistPlayer(class ADFBasePlayerState* Killer, class ADFBasePlayerState* Victim, float Points);
	void ScoreDeath(class ADFBasePlayerState* KilledBy, float Points);
	void ScoreKillPlayer(class ADFBasePlayerState* Victim, float Points);
	void ScorePoints(float Points, bool bForceNetUpdate);
	void SetAdminStatus(bool bNewAdminStatus);
	void SetTeam(const uint8 NewTeamNum, bool bCopyToInactivePlayerState);

	int32 GetAssists() const;
	int32 GetDeaths() const;
	int32 GetKills() const;
	uint8 GetPreviousTeam() const;
	uint8 GetTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBasePlayerState">();
	}
	static class ADFBasePlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBasePlayerState>();
	}
};
static_assert(alignof(ADFBasePlayerState) == 0x000008, "Wrong alignment on ADFBasePlayerState");
static_assert(sizeof(ADFBasePlayerState) == 0x000378, "Wrong size on ADFBasePlayerState");
static_assert(offsetof(ADFBasePlayerState, OnRepPlayerName) == 0x000328, "Member 'ADFBasePlayerState::OnRepPlayerName' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerState, OnPlayerTeamNumUpdated) == 0x000338, "Member 'ADFBasePlayerState::OnPlayerTeamNumUpdated' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerState, TeamNum) == 0x000348, "Member 'ADFBasePlayerState::TeamNum' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerState, PrevTeamNum) == 0x000349, "Member 'ADFBasePlayerState::PrevTeamNum' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerState, TeamState) == 0x000350, "Member 'ADFBasePlayerState::TeamState' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerState, PrevTeamState) == 0x000358, "Member 'ADFBasePlayerState::PrevTeamState' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerState, NumKills) == 0x000364, "Member 'ADFBasePlayerState::NumKills' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerState, NumAssists) == 0x000368, "Member 'ADFBasePlayerState::NumAssists' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerState, NumDeaths) == 0x00036C, "Member 'ADFBasePlayerState::NumDeaths' has a wrong offset!");
static_assert(offsetof(ADFBasePlayerState, TeamStartTime) == 0x000370, "Member 'ADFBasePlayerState::TeamStartTime' has a wrong offset!");

// Class DonkehFramework.DFSingleLoadWeapAnimInstInterface
// 0x0000 (0x0028 - 0x0028)
class IDFSingleLoadWeapAnimInstInterface final : public IInterface
{
public:
	float PlayEndReloadMontage(class UAnimMontage* MontageToPlay, bool bFullReload);
	float PlayStartReloadMontage(class UAnimMontage* MontageToPlay, bool bFullReload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFSingleLoadWeapAnimInstInterface">();
	}
	static class IDFSingleLoadWeapAnimInstInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDFSingleLoadWeapAnimInstInterface>();
	}
};
static_assert(alignof(IDFSingleLoadWeapAnimInstInterface) == 0x000008, "Wrong alignment on IDFSingleLoadWeapAnimInstInterface");
static_assert(sizeof(IDFSingleLoadWeapAnimInstInterface) == 0x000028, "Wrong size on IDFSingleLoadWeapAnimInstInterface");

// Class DonkehFramework.DFBaseProjectile
// 0x0160 (0x0380 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) ADFBaseProjectile : public AActor
{
public:
	class UProjectileMovementComponent*           ProjectileMovement;                                // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADFBaseImpactEffect>        ProjectileImpactFXClass;                           // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             SpawnTransform;                                    // 0x0230(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         ShotID;                                            // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastLoc;                                           // 0x0264(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSpawnImpactFXOnHit : 1;                           // 0x0270(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysShootable : 1;                              // 0x0270(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreInstigator : 1;                             // 0x0270(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreInstigatorOnPayloadActivation : 1;          // 0x0270(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            InstigatingController;                             // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebug : 1;                                        // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	FMulticastSparseDelegateProperty_             OnProcessValidHit;                                 // 0x0281(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreInstigatorHitEventsOnly : 1;                // 0x0282(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProcessedAHit : 1;                                // 0x0282(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bClientSideHitDetectionEnabled : 1;                // 0x0282(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bClientSideHitDamageEnabled : 1;                   // 0x0282(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNotifyOfPredictedProjectileHits : 1;              // 0x0282(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOnlyNotifyOfPredictedProjectileHits : 1;          // 0x0282(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_283[0x1];                                      // 0x0283(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCSHitInfo                             PendingHitInfo;                                    // 0x0284(0x0070)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ImpactedActor;                                     // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyDamageOnImpact : 1;                          // 0x0300(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bApplyDamageOnBounceImpact : 1;                    // 0x0300(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bApplyDamageToInstigator : 1;                      // 0x0300(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDFDamageParams                        BaseDamageParams;                                  // 0x0304(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageType>                WeaponDamageTypeClass;                             // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RadialDamageOriginOffset;                          // 0x0320(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             RadialDamagePreventionChannel;                     // 0x032C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bWantsToUseClientSidePrediction : 1;               // 0x032D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReconcilePredictedProjWithServerProj : 1;         // 0x032D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPredictedClientProjectile : 1;                    // 0x032D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_32E[0x2];                                      // 0x032E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ADFBaseProjectile*                      MyPredictedClientProjectile;                       // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADFBaseProjectile*                      ServerAuthoritativeProjectile;                     // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x31];                                     // 0x0340(0x0031)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastSparseDelegateProperty_             OnTriggerPayload;                                  // 0x0371(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bPayloadTriggered : 1;                             // 0x0372(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bTriggerPayloadWhenStopped : 1;                    // 0x0372(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTearOffOnPayloadActivation : 1;                   // 0x0372(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableOnPayloadActivation : 1;                   // 0x0372(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_373[0x5];                                      // 0x0373(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float ApplyDamageToImpactedActor(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FHitResult& HitResult);
	void DisableAndDeferDestroy();
	void IgnoreInstigatorWhenMoving(bool bShouldIgnore, bool bBidirectional);
	void K2_PostProcessValidHit(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FHitResult& HitResult, bool bFromCSHitNotify);
	void ProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void ProjectileStop(const struct FHitResult& ImpactResult);
	void ReceivePayloadActivated(const struct FHitResult& ImpactHitResult);
	void SetProjectileUpdatedComponent(class USceneComponent* NewProjectileUpdatedComponent);
	void SpawnImpactFX(const struct FHitResult& Impact);
	void TriggerPayload(const struct FHitResult& ImpactHitResult, bool bFromTearOff);

	struct FDFDamageParams GetAdjustedDamageParams(class AActor* OtherActor, const struct FVector& HitLocation) const;
	TSubclassOf<class ADFBaseImpactEffect> GetImpactFXClass() const;
	class ADFBaseWeapon* GetOwningWeapon() const;
	class USceneComponent* GetProjectileUpdatedComponent() const;
	class UPrimitiveComponent* GetProjectileUpdatedPrimitive() const;
	bool HasValidPredictedClientProjectile() const;
	bool K2_ShouldIgnoreHit(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& HitResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseProjectile">();
	}
	static class ADFBaseProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseProjectile>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADFBaseProjectile) == 0x000010, "Wrong alignment on ADFBaseProjectile");
static_assert(sizeof(ADFBaseProjectile) == 0x000380, "Wrong size on ADFBaseProjectile");
static_assert(offsetof(ADFBaseProjectile, ProjectileMovement) == 0x000220, "Member 'ADFBaseProjectile::ProjectileMovement' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, ProjectileImpactFXClass) == 0x000228, "Member 'ADFBaseProjectile::ProjectileImpactFXClass' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, SpawnTransform) == 0x000230, "Member 'ADFBaseProjectile::SpawnTransform' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, ShotID) == 0x000260, "Member 'ADFBaseProjectile::ShotID' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, LastLoc) == 0x000264, "Member 'ADFBaseProjectile::LastLoc' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, InstigatingController) == 0x000278, "Member 'ADFBaseProjectile::InstigatingController' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, OnProcessValidHit) == 0x000281, "Member 'ADFBaseProjectile::OnProcessValidHit' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, PendingHitInfo) == 0x000284, "Member 'ADFBaseProjectile::PendingHitInfo' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, ImpactedActor) == 0x0002F8, "Member 'ADFBaseProjectile::ImpactedActor' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, BaseDamageParams) == 0x000304, "Member 'ADFBaseProjectile::BaseDamageParams' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, WeaponDamageTypeClass) == 0x000318, "Member 'ADFBaseProjectile::WeaponDamageTypeClass' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, RadialDamageOriginOffset) == 0x000320, "Member 'ADFBaseProjectile::RadialDamageOriginOffset' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, RadialDamagePreventionChannel) == 0x00032C, "Member 'ADFBaseProjectile::RadialDamagePreventionChannel' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, MyPredictedClientProjectile) == 0x000330, "Member 'ADFBaseProjectile::MyPredictedClientProjectile' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, ServerAuthoritativeProjectile) == 0x000338, "Member 'ADFBaseProjectile::ServerAuthoritativeProjectile' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectile, OnTriggerPayload) == 0x000371, "Member 'ADFBaseProjectile::OnTriggerPayload' has a wrong offset!");

// Class DonkehFramework.DFTableLibrary
// 0x0000 (0x0028 - 0x0028)
class UDFTableLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetColumnFromIndex(int32 Index_0, int32 TableWidth);
	static int32 GetColumnInvFromIndex(int32 Index_0, int32 TableHeight);
	static int32 GetIndexFromColumnRowPair(int32 Column, int32 Row, int32 TableHeight);
	static int32 GetIndexFromRowColumnPair(int32 Row, int32 Column, int32 TableWidth);
	static int32 GetRowFromIndex(int32 Index_0, int32 TableWidth);
	static int32 GetRowInvFromIndex(int32 Index_0, int32 TableHeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFTableLibrary">();
	}
	static class UDFTableLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFTableLibrary>();
	}
};
static_assert(alignof(UDFTableLibrary) == 0x000008, "Wrong alignment on UDFTableLibrary");
static_assert(sizeof(UDFTableLibrary) == 0x000028, "Wrong size on UDFTableLibrary");

// Class DonkehFramework.DFBaseProjectileLegacy
// 0x0120 (0x0340 - 0x0220)
class ADFBaseProjectileLegacy final : public AActor
{
public:
	class UPrimitiveComponent*                    ProjectileCollision;                               // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectileMovementComponent*           ProjectileMovement;                                // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADFBaseImpactEffect>        ProjectileImpactFXClass;                           // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0240(0x0030)(Edit, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LastLoc;                                           // 0x0270(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bListenForImpactEvents : 1;                        // 0x027C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreInstigator : 1;                             // 0x027C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            InstigatingController;                             // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActiveLifeSpan;                                    // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0xC];                                      // 0x028C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                WeaponDamageTypeClass;                             // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebug : 1;                                        // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyDamageFromPayload : 1;                       // 0x02A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitDamage;                                         // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bApplyRadialDamage : 1;                            // 0x02A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RadialDamageLocOffset;                             // 0x02AC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             RadialDamagePreventionChannel;                     // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageRadius;                                      // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPayloadTriggered : 1;                             // 0x02C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTriggerPayloadWhenStopped : 1;                    // 0x02C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTriggerPayloadOnDelay : 1;                        // 0x02C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PayloadTriggerDelay;                               // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        PayloadTriggerFX;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAttachTriggerFXToRoot : 1;                        // 0x02D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               TriggerFXPSC;                                      // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             PayloadTriggerSnd;                                 // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAttachTriggerSndToRoot : 1;                       // 0x02E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        TriggerSnd;                                        // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x48];                                     // 0x02F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bPayloadTriggered();
	void PayloadDelayElapsed();
	void ProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void ProjectileStop(const struct FHitResult& ImpactResult);
	void ReceivePayloadActivated(const struct FHitResult& ImpactHitResult);
	void ReceiveSimulatePayloadActivation();
	void ReceiveStopSimulatingPayloadActivation();
	void SimulatePayloadActivation();
	void SpawnImpactFX(const struct FHitResult& Impact);
	void StopSimulatingPayloadActivation();
	void TriggerPayload(const struct FHitResult& ImpactHitResult);

	class ADFBaseWeapon* GetOwningWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBaseProjectileLegacy">();
	}
	static class ADFBaseProjectileLegacy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFBaseProjectileLegacy>();
	}
};
static_assert(alignof(ADFBaseProjectileLegacy) == 0x000010, "Wrong alignment on ADFBaseProjectileLegacy");
static_assert(sizeof(ADFBaseProjectileLegacy) == 0x000340, "Wrong size on ADFBaseProjectileLegacy");
static_assert(offsetof(ADFBaseProjectileLegacy, ProjectileCollision) == 0x000220, "Member 'ADFBaseProjectileLegacy::ProjectileCollision' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, ProjectileMovement) == 0x000228, "Member 'ADFBaseProjectileLegacy::ProjectileMovement' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, ProjectileImpactFXClass) == 0x000230, "Member 'ADFBaseProjectileLegacy::ProjectileImpactFXClass' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, SpawnTransform) == 0x000240, "Member 'ADFBaseProjectileLegacy::SpawnTransform' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, LastLoc) == 0x000270, "Member 'ADFBaseProjectileLegacy::LastLoc' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, InstigatingController) == 0x000280, "Member 'ADFBaseProjectileLegacy::InstigatingController' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, ActiveLifeSpan) == 0x000288, "Member 'ADFBaseProjectileLegacy::ActiveLifeSpan' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, WeaponDamageTypeClass) == 0x000298, "Member 'ADFBaseProjectileLegacy::WeaponDamageTypeClass' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, HitDamage) == 0x0002A4, "Member 'ADFBaseProjectileLegacy::HitDamage' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, RadialDamageLocOffset) == 0x0002AC, "Member 'ADFBaseProjectileLegacy::RadialDamageLocOffset' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, RadialDamagePreventionChannel) == 0x0002B8, "Member 'ADFBaseProjectileLegacy::RadialDamagePreventionChannel' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, DamageRadius) == 0x0002BC, "Member 'ADFBaseProjectileLegacy::DamageRadius' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, PayloadTriggerDelay) == 0x0002C4, "Member 'ADFBaseProjectileLegacy::PayloadTriggerDelay' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, PayloadTriggerFX) == 0x0002C8, "Member 'ADFBaseProjectileLegacy::PayloadTriggerFX' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, TriggerFXPSC) == 0x0002D8, "Member 'ADFBaseProjectileLegacy::TriggerFXPSC' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, PayloadTriggerSnd) == 0x0002E0, "Member 'ADFBaseProjectileLegacy::PayloadTriggerSnd' has a wrong offset!");
static_assert(offsetof(ADFBaseProjectileLegacy, TriggerSnd) == 0x0002F0, "Member 'ADFBaseProjectileLegacy::TriggerSnd' has a wrong offset!");

// Class DonkehFramework.DFBlueprintFunctions
// 0x0000 (0x0028 - 0x0028)
class UDFBlueprintFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void Array_AssetDescriptorSort(TArray<struct FAssetDescriptor>& ArrayToSort, bool bDescending, bool bCompareDisplayText);
	static void Array_FloatSort(TArray<float>& ArrayToSort, bool bDescending);
	static void Array_Int32Sort(TArray<int32>& ArrayToSort, bool bDescending);
	static void Array_Int64Sort(TArray<int64>& ArrayToSort, bool bDescending);
	static void Array_NameSort(TArray<class FName>& ArrayToSort, bool bDescending);
	static void Array_Reverse(const TArray<int32>& TargetArray);
	static void Array_StringSort(TArray<class FString>& ArrayToSort, bool bDescending);
	static void Array_TextSort(TArray<class FText>& ArrayToSort, bool bDescending);
	static void Array_UInt8Sort(TArray<uint8>& ArrayToSort, bool bDescending);
	static struct FDFCharacterVariationDataHandle CharacterVariationDataFromTableRow(class UObject* WorldContextObject, const struct FDataTableRowHandle& RowHandle);
	static struct FDFCharacterVariationData CharacterVariationGetData(const struct FDFCharacterVariationDataHandle& VariationData);
	static bool CharacterVariationIsValid(const struct FDFCharacterVariationDataHandle& VariationData);
	static bool DoesMapIDSupportGMDefinition(const struct FPrimaryAssetId& MapId, const class UDFGameModeDefinition* GMDef);
	static bool EqualEqual_CharacterAnimCollection(const struct FCharacterAnimCollection& A, const struct FCharacterAnimCollection& B);
	static bool EqualEqual_CharacterSoundCollection(const struct FCharacterSoundCollection& A, const struct FCharacterSoundCollection& B);
	static bool EqualEqual_PerspectiveAnim(const struct FPerspectiveAnim& A, const struct FPerspectiveAnim& B);
	static bool EqualEqual_PerspectiveAnimSequence(const struct FPerspectiveAnimSequence& A, const struct FPerspectiveAnimSequence& B);
	static bool EqualEqual_PerspectiveSound(const struct FPerspectiveSound& A, const struct FPerspectiveSound& B);
	static bool EqualEqual_WeaponAnim(const struct FWeaponAnim& A, const struct FWeaponAnim& B);
	static bool EqualEqual_WeaponAnimCollection(const struct FWeaponAnimCollection& A, const struct FWeaponAnimCollection& B);
	static bool EqualEqual_WeaponAnimMontage(const struct FWeaponAnimMontage& A, const struct FWeaponAnimMontage& B);
	static bool EqualEqual_WeaponAnimSequence(const struct FWeaponAnimSequence& A, const struct FWeaponAnimSequence& B);
	static bool EqualEqual_WeaponSoundCollection(const struct FWeaponSoundCollection& A, const struct FWeaponSoundCollection& B);
	static struct FPrimaryAssetId FindMapIdByDisplayName(const class FText& MapDisplayName, const TArray<struct FPrimaryAssetId>& MapIds);
	static void FlushPressedKeys(class APlayerController* PC);
	static void GameHasEnded(class AController* Controller, class AActor* EndGameFocus, bool bIsWinner);
	static TArray<class FString> GetAllMapNames();
	static class FString GetCopyrightNotice();
	static void GetDefaultBoundingCylinder(const class AActor* Actor, float* CylinderRadius, float* CylinderHalfHeight);
	static struct FVector GetFocalPoint(const class AActor* Actor);
	static class FString GetGameBuildInfo();
	static class FString GetGameDefaultMap();
	static class FString GetGameModeForMapName(const class FString& MapName);
	static class FString GetGameModeForName(const class FString& GameModeName);
	static class FText GetGameNameForDisplay(class UObject* WorldContextObject);
	static class FString GetGameVersion();
	static class FString GetGlobalDefaultGameMode();
	static bool GetMapAssetDataDefaultGameMode(const struct FAssetData& WorldAsset, TSoftClassPtr<class UClass>* OutDefaultGameModeRef);
	static bool GetMapAssetDataDescription(const struct FAssetData& WorldAsset, class FString* OutMapDescription);
	static bool GetMapAssetDataDisplayName(const struct FAssetData& WorldAsset, class FText* OutMapDisplayName);
	static bool GetMapAssetDataGameRulesetClasses(const struct FAssetData& WorldAsset, TSet<TSoftClassPtr<class UClass>>* OutGameRulesetClasses);
	static class FText GetMapAssetDataNameForDisplay(const struct FAssetData& WorldAsset);
	static bool GetMapAssetDataPreviewBannerImg(const struct FAssetData& WorldAsset, TSoftObjectPtr<class UTexture2D>* OutMapPreviewBannerImgRef);
	static bool GetMapAssetDataPreviewImg(const struct FAssetData& WorldAsset, TSoftObjectPtr<class UTexture2D>* OutMapPreviewImgRef);
	static bool GetMapAssetDataSupportedGameModes(const struct FAssetData& WorldAsset, TSet<TSoftClassPtr<class UClass>>* OutSupportedGameModes);
	static bool GetMapAssetDefaultGameMode(const struct FPrimaryAssetId& WorldAssetId, TSoftClassPtr<class UClass>* OutDefaultGameModeRef);
	static bool GetMapAssetDescription(const struct FPrimaryAssetId& WorldAssetId, class FString* OutMapDescription);
	static bool GetMapAssetGameRulesetClasses(const struct FPrimaryAssetId& WorldAssetId, TSet<TSoftClassPtr<class UClass>>* OutGameRulesetClasses);
	static class FText GetMapAssetNameForDisplay(const struct FPrimaryAssetId& WorldAssetId);
	static bool GetMapAssetPreviewBannerImg(const struct FPrimaryAssetId& WorldAssetId, TSoftObjectPtr<class UTexture2D>* OutMapPreviewBannerImgRef);
	static bool GetMapAssetPreviewImg(const struct FPrimaryAssetId& WorldAssetId, TSoftObjectPtr<class UTexture2D>* OutMapPreviewImgRef);
	static bool GetMapAssetSupportedGameModes(const struct FPrimaryAssetId& WorldAssetId, TSet<TSoftClassPtr<class UClass>>* OutSupportedGameModes);
	static bool GetMapAssetVisibleInMapSelectUI(const struct FPrimaryAssetId& WorldAssetId, bool* bOutVisibleInMapSelectUI);
	static class FString GetMapName(class UObject* WorldContextObject);
	static class FText GetMapNameForDisplay(class UObject* WorldContextObject);
	static int32 GetNumShotsFiredBPCompat(const struct FRepShotInfo& Counter, const struct FRepShotInfo& PreviousCounter);
	static class FString GetPluginFriendlyName(const class FString& PluginName);
	static int32 GetShotCounterBPCompat(const struct FRepShotInfo& Counter);
	static class AActor* GetStartSpot(class AController* Controller);
	static class FName GetSurfaceName(EPhysicalSurface SurfaceType);
	static struct FVector GetTargetLocation(const class AActor* Actor, class AActor* RequestedBy);
	static uint8 GetTeamNum(const class AActor* Target);
	static class ADFTeamState* GetTeamStateFromTeamId(class UObject* WorldContextObject, const uint8 TeamIdNum);
	static ESlateVisibility GetVisibilityDefault(class UWidget* Widget);
	static class UVOIPTalker* GetVOIPTalkerForPlayer(class APlayerState* InPlayerState);
	static class AWorldSettings* GetWorldSettings(class UObject* WorldContextObject);
	static bool HasFiringStopped(const struct FRepShotInfo& Counter);
	static bool HasOptions(const class FString& Options, const TArray<class FString>& Keys, bool bMatchAll);
	static bool IsEmptyOrWhitespace(const class FString& InString);
	static bool IsLocallyPlayerControlled(const class APawn* Pawn);
	static bool IsPendingKillPending(const class AActor* Actor);
	static bool IsPlayerMuted(class APlayerController* PC, class APlayerState* PSToCheck);
	static bool IsPlayerTalking(class APlayerState* PlayerPS);
	static bool IsPlayInEditor(class UObject* WorldContextObject);
	static bool IsValidActor(const class AActor* Actor);
	static bool IsVOIPTalkerStillAlive(class UVOIPTalker* InTalker);
	static void PrintStringToLog(class UObject* WorldContextObject, const class FString& InString, ELogVerbosityBP InLogVerbosity, bool bPrintStackTrace);
	static void PrintTextToLog(class UObject* WorldContextObject, const class FText& InText, ELogVerbosityBP InLogVerbosity, bool bPrintStackTrace);
	static void ResetAllPlayerVoiceTalkers();
	static void ResetPlayerVoiceTalker(class APlayerState* InPlayerState);
	static void SetCastStaticShadow(class UPrimitiveComponent* PrimitiveComponent, bool bCastStaticShadow);
	static void SetNetAddressable(class UActorComponent* ActorComp);
	static void SetStartSpot(class AController* Controller, class AActor* NewStartSpot);
	static void SetTeamNum(class AActor* Target, const uint8 NewTeamNum);
	static class ADFBaseImpactEffect* SpawnImpactFXFromDamageEvent(class UObject* WorldContextObject, TSubclassOf<class ADFBaseImpactEffect> ImpactClass, float DamageTaken, const struct FDamageEvent& DamageEvent, const class AActor* HitActor, const class AActor* HitInstigator, const class AActor* DamageCauser);
	static class ADFBaseImpactEffect* SpawnImpactFXFromHitResult(class UObject* WorldContextObject, TSubclassOf<class ADFBaseImpactEffect> ImpactClass, const struct FHitResult& Impact);
	static bool TextIsEmptyOrWhitespace(const class FText& InText);
	static void TransferInventoryItems(class UDFInventoryComponent* FromInv, class UDFInventoryComponent* ToInv, bool bKeepLoadedAmmo);
	static bool WasShotFired(const struct FRepShotInfo& Counter, const struct FRepShotInfo& OtherCounter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFBlueprintFunctions">();
	}
	static class UDFBlueprintFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFBlueprintFunctions>();
	}
};
static_assert(alignof(UDFBlueprintFunctions) == 0x000008, "Wrong alignment on UDFBlueprintFunctions");
static_assert(sizeof(UDFBlueprintFunctions) == 0x000028, "Wrong size on UDFBlueprintFunctions");

// Class DonkehFramework.DFTeamAgentInterface
// 0x0000 (0x0028 - 0x0028)
class IDFTeamAgentInterface final : public IGenericTeamAgentInterface
{
public:
	void EventSetTeamNum(const uint8 NewTeamNum);

	uint8 EventGetTeamNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFTeamAgentInterface">();
	}
	static class IDFTeamAgentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDFTeamAgentInterface>();
	}
};
static_assert(alignof(IDFTeamAgentInterface) == 0x000008, "Wrong alignment on IDFTeamAgentInterface");
static_assert(sizeof(IDFTeamAgentInterface) == 0x000028, "Wrong size on IDFTeamAgentInterface");

// Class DonkehFramework.DFCharacterLeanHandler
// 0x0258 (0x0280 - 0x0028)
class UDFCharacterLeanHandler : public UObject
{
public:
	struct FRuntimeFloatCurve                     StationaryStandLeanCurve;                          // 0x0028(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     MobileStandLeanCurve;                              // 0x00B0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     StationaryCrouchLeanCurve;                         // 0x0138(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     MobileCrouchLeanCurve;                             // 0x01C0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         LeanTransitionSpeed;                               // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandLeanInYOffset;                                // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchLeanInYOffset;                               // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanRollAmount;                                    // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELeanDirection                                LeanDirection;                                     // 0x0258(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanTarget;                                        // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAtFullLeanTarget : 1;                             // 0x0260(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanAmount;                                        // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x18];                                     // 0x0268(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveReset();
	void ReceiveTick(float DeltaTime);
	void UpdateLeanDirection(ELeanDirection NewLeanDir);

	float DetermineLeanTargetAmount(ELeanDirection DesiredLeanDir, bool bMoving) const;
	float GetLeanRollRot(float DesiredLeanAmt) const;
	float GetLeanXOffset(float DesiredLeanAmt) const;
	float GetLeanYOffset(float DesiredLeanAmt) const;
	float GetMaxLeanXOffset(ELeanDirection NewLeanDir, ECharacterStance LeanStance, bool bMoving) const;
	class ADFBaseCharacter* GetOwningCharacter() const;
	class UDFCharacterMovementComponent* GetOwningCharacterMovement() const;
	ECharacterStance GetPreviousStance() const;
	ECharacterStance GetStance() const;
	bool IsLeaning() const;
	bool IsMoving() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFCharacterLeanHandler">();
	}
	static class UDFCharacterLeanHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFCharacterLeanHandler>();
	}
};
static_assert(alignof(UDFCharacterLeanHandler) == 0x000008, "Wrong alignment on UDFCharacterLeanHandler");
static_assert(sizeof(UDFCharacterLeanHandler) == 0x000280, "Wrong size on UDFCharacterLeanHandler");
static_assert(offsetof(UDFCharacterLeanHandler, StationaryStandLeanCurve) == 0x000028, "Member 'UDFCharacterLeanHandler::StationaryStandLeanCurve' has a wrong offset!");
static_assert(offsetof(UDFCharacterLeanHandler, MobileStandLeanCurve) == 0x0000B0, "Member 'UDFCharacterLeanHandler::MobileStandLeanCurve' has a wrong offset!");
static_assert(offsetof(UDFCharacterLeanHandler, StationaryCrouchLeanCurve) == 0x000138, "Member 'UDFCharacterLeanHandler::StationaryCrouchLeanCurve' has a wrong offset!");
static_assert(offsetof(UDFCharacterLeanHandler, MobileCrouchLeanCurve) == 0x0001C0, "Member 'UDFCharacterLeanHandler::MobileCrouchLeanCurve' has a wrong offset!");
static_assert(offsetof(UDFCharacterLeanHandler, LeanTransitionSpeed) == 0x000248, "Member 'UDFCharacterLeanHandler::LeanTransitionSpeed' has a wrong offset!");
static_assert(offsetof(UDFCharacterLeanHandler, StandLeanInYOffset) == 0x00024C, "Member 'UDFCharacterLeanHandler::StandLeanInYOffset' has a wrong offset!");
static_assert(offsetof(UDFCharacterLeanHandler, CrouchLeanInYOffset) == 0x000250, "Member 'UDFCharacterLeanHandler::CrouchLeanInYOffset' has a wrong offset!");
static_assert(offsetof(UDFCharacterLeanHandler, LeanRollAmount) == 0x000254, "Member 'UDFCharacterLeanHandler::LeanRollAmount' has a wrong offset!");
static_assert(offsetof(UDFCharacterLeanHandler, LeanDirection) == 0x000258, "Member 'UDFCharacterLeanHandler::LeanDirection' has a wrong offset!");
static_assert(offsetof(UDFCharacterLeanHandler, LeanTarget) == 0x00025C, "Member 'UDFCharacterLeanHandler::LeanTarget' has a wrong offset!");
static_assert(offsetof(UDFCharacterLeanHandler, LeanAmount) == 0x000264, "Member 'UDFCharacterLeanHandler::LeanAmount' has a wrong offset!");

// Class DonkehFramework.DFCharacterMovementComponent
// 0x0140 (0x0750 - 0x0610)
class UDFCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	class ADFBaseCharacter*                       DFCharacterOwner;                                  // 0x0610(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 LastMovementMode;                                  // 0x0618(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         LastCustomMovementMode;                            // 0x0619(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61A[0x2];                                      // 0x061A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            StandWalkSpeedMultiplierRange;                     // 0x061C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            CrouchedWalkSpeedMultiplierRange;                  // 0x062C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            ProneWalkSpeedMultiplierRange;                     // 0x063C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanSpeedMultiplier;                               // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseLeanSpeedMultiplierWhileAiming : 1;            // 0x0650(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanCrouchWhileFalling : 1;                        // 0x0650(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_650_2 : 6;                                  // 0x0650(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_651[0x3];                                      // 0x0651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseJumpStamina : 1;                               // 0x0654(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_655[0x3];                                      // 0x0655(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpMaxStamina;                                    // 0x0658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpStaminaCost;                                   // 0x065C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpStaminaRecoveryRate;                           // 0x0660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpStaminaThreshold;                              // 0x0664(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           VaultOverVelocityCurve;                            // 0x0668(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           SprintVaultOverVelocityCurve;                      // 0x0670(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           ClimbOntoVelocityCurve;                            // 0x0678(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           SprintClimbOntoVelocityCurve;                      // 0x0680(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultViewPitch;                                    // 0x0688(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultReachDistance;                                // 0x068C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintVaultReachDistance;                          // 0x0690(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultReachRadius;                                  // 0x0694(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultCapsuleLOSRadius;                             // 0x0698(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVaultObstacleVelocitySquared;                   // 0x069C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultOverDisplacementXOffset;                      // 0x06A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbOntoDisplacementXOffset;                      // 0x06A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultOverDisplacementZOffset;                      // 0x06A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbOntoDisplacementZOffset;                      // 0x06AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultOverLedgeSurfaceThreshold;                    // 0x06B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbOntoLedgeSurfaceThreshold;                    // 0x06B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVaultOverLedgeHeight;                           // 0x06B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVaultOverLedgeHeight;                           // 0x06BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinClimbOntoLedgeHeight;                           // 0x06C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxClimbOntoLedgeHeight;                           // 0x06C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWantsToSprint : 1;                                // 0x06C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6C9[0x3];                                      // 0x06C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintSpeedMultiplier;                             // 0x06CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintAccelerationMultiplier;                      // 0x06D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintStrafingThreshold;                           // 0x06D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSprintStamina : 1;                             // 0x06D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D9[0x3];                                      // 0x06D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintMaxStamina;                                  // 0x06DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintStaminaDelta;                                // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintStaminaThreshold;                            // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWantsToAim : 1;                                   // 0x06E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6E9[0x3];                                      // 0x06E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimSpeedMultiplier;                                // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWantsToLeanLeft : 1;                              // 0x06F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWantsToLeanRight : 1;                             // 0x06F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6F1[0x3];                                      // 0x06F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProneHalfHeight;                                   // 0x06F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanWalkOffLedgesWhenProne : 1;                    // 0x06F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanAimWhileCrawling : 1;                          // 0x06F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bProneMaintainsBaseLocation : 1;                   // 0x06F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6F9[0x3];                                      // 0x06F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxWalkSpeedProne;                                 // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWantsToBeProne : 1;                               // 0x0700(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanSwimUnderwater : 1;                            // 0x0700(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_701[0x3];                                      // 0x0701(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpStamina;                                       // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bCanSprint : 1;                                    // 0x0708(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_709[0x3];                                      // 0x0709(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintStamina;                                     // 0x070C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bCanAim : 1;                                       // 0x0710(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanLean : 1;                                      // 0x0710(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanBeProne : 1;                                   // 0x0710(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanVault : 1;                                     // 0x0710(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_710_4 : 4;                                  // 0x0710(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_711[0x2F];                                     // 0x0711(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bJustLeftWater : 1;                                // 0x0740(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_741[0xF];                                      // 0x0741(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float ClampSpeedMultiplier(float MultValue) const;
	class ADFBaseCharacter* GetDFCharacterOwner() const;
	float GetLeanAmount() const;
	ELeanDirection GetLeanDirection() const;
	ECharacterStance GetPreviousStance() const;
	ECharacterStance GetStance() const;
	bool IsAiming() const;
	bool IsAlive() const;
	bool IsCrawling() const;
	bool IsLeaning() const;
	bool IsMoving(bool bIgnoreZVel) const;
	bool IsMovingForward() const;
	bool IsProne() const;
	bool IsReloading() const;
	bool IsSprinting() const;
	bool IsStanding() const;
	bool IsStrafing(float Threshold) const;
	bool IsVaulting() const;
	struct FDFVaultTraceResult VaultTrace() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFCharacterMovementComponent">();
	}
	static class UDFCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFCharacterMovementComponent>();
	}
};
static_assert(alignof(UDFCharacterMovementComponent) == 0x000010, "Wrong alignment on UDFCharacterMovementComponent");
static_assert(sizeof(UDFCharacterMovementComponent) == 0x000750, "Wrong size on UDFCharacterMovementComponent");
static_assert(offsetof(UDFCharacterMovementComponent, DFCharacterOwner) == 0x000610, "Member 'UDFCharacterMovementComponent::DFCharacterOwner' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, LastMovementMode) == 0x000618, "Member 'UDFCharacterMovementComponent::LastMovementMode' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, LastCustomMovementMode) == 0x000619, "Member 'UDFCharacterMovementComponent::LastCustomMovementMode' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, StandWalkSpeedMultiplierRange) == 0x00061C, "Member 'UDFCharacterMovementComponent::StandWalkSpeedMultiplierRange' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, CrouchedWalkSpeedMultiplierRange) == 0x00062C, "Member 'UDFCharacterMovementComponent::CrouchedWalkSpeedMultiplierRange' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, ProneWalkSpeedMultiplierRange) == 0x00063C, "Member 'UDFCharacterMovementComponent::ProneWalkSpeedMultiplierRange' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, LeanSpeedMultiplier) == 0x00064C, "Member 'UDFCharacterMovementComponent::LeanSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, JumpMaxStamina) == 0x000658, "Member 'UDFCharacterMovementComponent::JumpMaxStamina' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, JumpStaminaCost) == 0x00065C, "Member 'UDFCharacterMovementComponent::JumpStaminaCost' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, JumpStaminaRecoveryRate) == 0x000660, "Member 'UDFCharacterMovementComponent::JumpStaminaRecoveryRate' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, JumpStaminaThreshold) == 0x000664, "Member 'UDFCharacterMovementComponent::JumpStaminaThreshold' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, VaultOverVelocityCurve) == 0x000668, "Member 'UDFCharacterMovementComponent::VaultOverVelocityCurve' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, SprintVaultOverVelocityCurve) == 0x000670, "Member 'UDFCharacterMovementComponent::SprintVaultOverVelocityCurve' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, ClimbOntoVelocityCurve) == 0x000678, "Member 'UDFCharacterMovementComponent::ClimbOntoVelocityCurve' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, SprintClimbOntoVelocityCurve) == 0x000680, "Member 'UDFCharacterMovementComponent::SprintClimbOntoVelocityCurve' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, VaultViewPitch) == 0x000688, "Member 'UDFCharacterMovementComponent::VaultViewPitch' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, VaultReachDistance) == 0x00068C, "Member 'UDFCharacterMovementComponent::VaultReachDistance' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, SprintVaultReachDistance) == 0x000690, "Member 'UDFCharacterMovementComponent::SprintVaultReachDistance' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, VaultReachRadius) == 0x000694, "Member 'UDFCharacterMovementComponent::VaultReachRadius' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, VaultCapsuleLOSRadius) == 0x000698, "Member 'UDFCharacterMovementComponent::VaultCapsuleLOSRadius' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, MaxVaultObstacleVelocitySquared) == 0x00069C, "Member 'UDFCharacterMovementComponent::MaxVaultObstacleVelocitySquared' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, VaultOverDisplacementXOffset) == 0x0006A0, "Member 'UDFCharacterMovementComponent::VaultOverDisplacementXOffset' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, ClimbOntoDisplacementXOffset) == 0x0006A4, "Member 'UDFCharacterMovementComponent::ClimbOntoDisplacementXOffset' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, VaultOverDisplacementZOffset) == 0x0006A8, "Member 'UDFCharacterMovementComponent::VaultOverDisplacementZOffset' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, ClimbOntoDisplacementZOffset) == 0x0006AC, "Member 'UDFCharacterMovementComponent::ClimbOntoDisplacementZOffset' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, VaultOverLedgeSurfaceThreshold) == 0x0006B0, "Member 'UDFCharacterMovementComponent::VaultOverLedgeSurfaceThreshold' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, ClimbOntoLedgeSurfaceThreshold) == 0x0006B4, "Member 'UDFCharacterMovementComponent::ClimbOntoLedgeSurfaceThreshold' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, MinVaultOverLedgeHeight) == 0x0006B8, "Member 'UDFCharacterMovementComponent::MinVaultOverLedgeHeight' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, MaxVaultOverLedgeHeight) == 0x0006BC, "Member 'UDFCharacterMovementComponent::MaxVaultOverLedgeHeight' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, MinClimbOntoLedgeHeight) == 0x0006C0, "Member 'UDFCharacterMovementComponent::MinClimbOntoLedgeHeight' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, MaxClimbOntoLedgeHeight) == 0x0006C4, "Member 'UDFCharacterMovementComponent::MaxClimbOntoLedgeHeight' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, SprintSpeedMultiplier) == 0x0006CC, "Member 'UDFCharacterMovementComponent::SprintSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, SprintAccelerationMultiplier) == 0x0006D0, "Member 'UDFCharacterMovementComponent::SprintAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, SprintStrafingThreshold) == 0x0006D4, "Member 'UDFCharacterMovementComponent::SprintStrafingThreshold' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, SprintMaxStamina) == 0x0006DC, "Member 'UDFCharacterMovementComponent::SprintMaxStamina' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, SprintStaminaDelta) == 0x0006E0, "Member 'UDFCharacterMovementComponent::SprintStaminaDelta' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, SprintStaminaThreshold) == 0x0006E4, "Member 'UDFCharacterMovementComponent::SprintStaminaThreshold' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, AimSpeedMultiplier) == 0x0006EC, "Member 'UDFCharacterMovementComponent::AimSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, ProneHalfHeight) == 0x0006F4, "Member 'UDFCharacterMovementComponent::ProneHalfHeight' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, MaxWalkSpeedProne) == 0x0006FC, "Member 'UDFCharacterMovementComponent::MaxWalkSpeedProne' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, JumpStamina) == 0x000704, "Member 'UDFCharacterMovementComponent::JumpStamina' has a wrong offset!");
static_assert(offsetof(UDFCharacterMovementComponent, SprintStamina) == 0x00070C, "Member 'UDFCharacterMovementComponent::SprintStamina' has a wrong offset!");

// Class DonkehFramework.DFCheatManager
// 0x0000 (0x0078 - 0x0078)
class UDFCheatManager : public UCheatManager
{
public:
	void ToggleGunInfiniteAmmo();
	void ToggleGunInfiniteClipAmmo();
	void ToggleGunRecoil();
	void ToggleItemDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFCheatManager">();
	}
	static class UDFCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFCheatManager>();
	}
};
static_assert(alignof(UDFCheatManager) == 0x000008, "Wrong alignment on UDFCheatManager");
static_assert(sizeof(UDFCheatManager) == 0x000078, "Wrong size on UDFCheatManager");

// Class DonkehFramework.DFDamageType
// 0x0008 (0x0048 - 0x0040)
class UDFDamageType : public UDamageType
{
public:
	TSubclassOf<class ADFBaseImpactEffect>        ImpactFXClass;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFDamageType">();
	}
	static class UDFDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFDamageType>();
	}
};
static_assert(alignof(UDFDamageType) == 0x000008, "Wrong alignment on UDFDamageType");
static_assert(sizeof(UDFDamageType) == 0x000048, "Wrong size on UDFDamageType");
static_assert(offsetof(UDFDamageType, ImpactFXClass) == 0x000040, "Member 'UDFDamageType::ImpactFXClass' has a wrong offset!");

// Class DonkehFramework.DFPrimaryDataAsset
// 0x0000 (0x0030 - 0x0030)
class UDFPrimaryDataAsset : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFPrimaryDataAsset">();
	}
	static class UDFPrimaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFPrimaryDataAsset>();
	}
};
static_assert(alignof(UDFPrimaryDataAsset) == 0x000008, "Wrong alignment on UDFPrimaryDataAsset");
static_assert(sizeof(UDFPrimaryDataAsset) == 0x000030, "Wrong size on UDFPrimaryDataAsset");

// Class DonkehFramework.DFFactionInfo
// 0x0060 (0x0090 - 0x0030)
class UDFFactionInfo : public UDFPrimaryDataAsset
{
public:
	struct FPrimaryAssetType                      FactionType;                                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FactionName;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bVisibleInFactionSelectUI : 1;                     // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   DisplayNameShort;                                  // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   DisplayNameAcronym;                                // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFFactionInfo">();
	}
	static class UDFFactionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFFactionInfo>();
	}
};
static_assert(alignof(UDFFactionInfo) == 0x000008, "Wrong alignment on UDFFactionInfo");
static_assert(sizeof(UDFFactionInfo) == 0x000090, "Wrong size on UDFFactionInfo");
static_assert(offsetof(UDFFactionInfo, FactionType) == 0x000030, "Member 'UDFFactionInfo::FactionType' has a wrong offset!");
static_assert(offsetof(UDFFactionInfo, FactionName) == 0x000038, "Member 'UDFFactionInfo::FactionName' has a wrong offset!");
static_assert(offsetof(UDFFactionInfo, DisplayName) == 0x000048, "Member 'UDFFactionInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(UDFFactionInfo, DisplayNameShort) == 0x000060, "Member 'UDFFactionInfo::DisplayNameShort' has a wrong offset!");
static_assert(offsetof(UDFFactionInfo, DisplayNameAcronym) == 0x000078, "Member 'UDFFactionInfo::DisplayNameAcronym' has a wrong offset!");

// Class DonkehFramework.DFFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UDFFunctionLibrary final : public UObject
{
public:
	static void ClearMeshAnimInstance(class USkeletalMeshComponent* MeshToClear);
	static void SetEnableAutoBlendOutForActiveMontage(const class UAnimMontage* AnimMontage, const class USkeletalMeshComponent* AnimSourceMesh, bool bNewEnableAutoBlendOut);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFFunctionLibrary">();
	}
	static class UDFFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFFunctionLibrary>();
	}
};
static_assert(alignof(UDFFunctionLibrary) == 0x000008, "Wrong alignment on UDFFunctionLibrary");
static_assert(sizeof(UDFFunctionLibrary) == 0x000028, "Wrong size on UDFFunctionLibrary");

// Class DonkehFramework.DFGameEngine
// 0x0000 (0x0E30 - 0x0E30)
class UDFGameEngine : public UGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFGameEngine">();
	}
	static class UDFGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFGameEngine>();
	}
};
static_assert(alignof(UDFGameEngine) == 0x000008, "Wrong alignment on UDFGameEngine");
static_assert(sizeof(UDFGameEngine) == 0x000E30, "Wrong size on UDFGameEngine");

// Class DonkehFramework.DFGameModeDefinition
// 0x00B8 (0x00E8 - 0x0030)
class UDFGameModeDefinition : public UPrimaryDataAsset
{
public:
	bool                                          bSupportsAllMaps;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FPrimaryAssetId>                  SpecificMapsToSupport;                             // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	bool                                          bShowInFrontEnd;                                   // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PreviewBannerImg;                                  // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFGameModeDefinition">();
	}
	static class UDFGameModeDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFGameModeDefinition>();
	}
};
static_assert(alignof(UDFGameModeDefinition) == 0x000008, "Wrong alignment on UDFGameModeDefinition");
static_assert(sizeof(UDFGameModeDefinition) == 0x0000E8, "Wrong size on UDFGameModeDefinition");
static_assert(offsetof(UDFGameModeDefinition, bSupportsAllMaps) == 0x000030, "Member 'UDFGameModeDefinition::bSupportsAllMaps' has a wrong offset!");
static_assert(offsetof(UDFGameModeDefinition, SpecificMapsToSupport) == 0x000038, "Member 'UDFGameModeDefinition::SpecificMapsToSupport' has a wrong offset!");
static_assert(offsetof(UDFGameModeDefinition, bShowInFrontEnd) == 0x000088, "Member 'UDFGameModeDefinition::bShowInFrontEnd' has a wrong offset!");
static_assert(offsetof(UDFGameModeDefinition, Title) == 0x000090, "Member 'UDFGameModeDefinition::Title' has a wrong offset!");
static_assert(offsetof(UDFGameModeDefinition, Description) == 0x0000A8, "Member 'UDFGameModeDefinition::Description' has a wrong offset!");
static_assert(offsetof(UDFGameModeDefinition, PreviewBannerImg) == 0x0000C0, "Member 'UDFGameModeDefinition::PreviewBannerImg' has a wrong offset!");

// Class DonkehFramework.DFGameRulesetBase
// 0x0030 (0x0058 - 0x0028)
class UDFGameRulesetBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTickable : 1;                                     // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         Priority;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init();
	void MatchHasEnded();
	void PlayerDied(class AController* Victim);
	void PlayerJoined(class APlayerController* NewPlayer);
	void PlayerJoinedTeam(class AController* JoiningPlayer, uint8 TeamNum);
	void PlayerKilled(class AController* Killer, class AController* Victim);
	void PlayerPostLogin(class APlayerController* NewPlayer);
	void PlayerPostLogout(class AController* ExitingPlayer);
	void PlayerSpawn(class AController* Player, class APawn* NewPlayerPawn);
	void PlayerSuicide(class AController* Victim);
	void PlayerWounded(class AController* Victim, float DamageAmount, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void ReceiveTick(float DeltaTime);
	void RegisterActor(class AActor* RegisteredActor);
	void UnregisterActor(class AActor* UnregisteredActor);

	class ADFBaseGameMode* GetGameMode() const;
	class ADFBaseGameState* GetGameState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFGameRulesetBase">();
	}
	static class UDFGameRulesetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFGameRulesetBase>();
	}
};
static_assert(alignof(UDFGameRulesetBase) == 0x000008, "Wrong alignment on UDFGameRulesetBase");
static_assert(sizeof(UDFGameRulesetBase) == 0x000058, "Wrong size on UDFGameRulesetBase");
static_assert(offsetof(UDFGameRulesetBase, DisplayName) == 0x000038, "Member 'UDFGameRulesetBase::DisplayName' has a wrong offset!");
static_assert(offsetof(UDFGameRulesetBase, Priority) == 0x000050, "Member 'UDFGameRulesetBase::Priority' has a wrong offset!");

// Class DonkehFramework.DFGameSession
// 0x0038 (0x0270 - 0x0238)
class ADFGameSession : public AGameSession
{
public:
	class FString                                 ServerName;                                        // 0x0238(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinPlayers;                                        // 0x0258(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Password;                                          // 0x0260(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFGameSession">();
	}
	static class ADFGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFGameSession>();
	}
};
static_assert(alignof(ADFGameSession) == 0x000008, "Wrong alignment on ADFGameSession");
static_assert(sizeof(ADFGameSession) == 0x000270, "Wrong size on ADFGameSession");
static_assert(offsetof(ADFGameSession, ServerName) == 0x000238, "Member 'ADFGameSession::ServerName' has a wrong offset!");
static_assert(offsetof(ADFGameSession, MinPlayers) == 0x000258, "Member 'ADFGameSession::MinPlayers' has a wrong offset!");
static_assert(offsetof(ADFGameSession, Password) == 0x000260, "Member 'ADFGameSession::Password' has a wrong offset!");

// Class DonkehFramework.DFInventoryComponent
// 0x0040 (0x00F0 - 0x00B0)
class UDFInventoryComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnItemAdded;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemRemoved;                                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	TArray<class ADFBaseItem*>                    Items;                                             // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ADFBaseItem>>        DefaultItemClasses;                                // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool Add(const class ADFBaseItem* Item);
	void AddDefaultInventoryItems();
	void Clear(bool bDestroyItems);
	bool Remove(const class ADFBaseItem* Item, bool bDestroyItem);
	bool RemoveItemAt(const int32 Index_0, class ADFBaseItem** OutRemovedItem, bool bDestroyItem);

	bool Find(const class ADFBaseItem* ItemToCompare, int32* OutIndex) const;
	bool FindItemByClass(const TSubclassOf<class ADFBaseItem>& ItemClass, class ADFBaseItem** OutItem) const;
	bool GetItem(const int32 Index_0, class ADFBaseItem** OutItem) const;
	bool IsValidIndex(int32 Index_0) const;
	int32 Size() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFInventoryComponent">();
	}
	static class UDFInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFInventoryComponent>();
	}
};
static_assert(alignof(UDFInventoryComponent) == 0x000008, "Wrong alignment on UDFInventoryComponent");
static_assert(sizeof(UDFInventoryComponent) == 0x0000F0, "Wrong size on UDFInventoryComponent");
static_assert(offsetof(UDFInventoryComponent, OnItemAdded) == 0x0000B0, "Member 'UDFInventoryComponent::OnItemAdded' has a wrong offset!");
static_assert(offsetof(UDFInventoryComponent, OnItemRemoved) == 0x0000C0, "Member 'UDFInventoryComponent::OnItemRemoved' has a wrong offset!");
static_assert(offsetof(UDFInventoryComponent, Items) == 0x0000D0, "Member 'UDFInventoryComponent::Items' has a wrong offset!");
static_assert(offsetof(UDFInventoryComponent, DefaultItemClasses) == 0x0000E0, "Member 'UDFInventoryComponent::DefaultItemClasses' has a wrong offset!");

// Class DonkehFramework.DFLevelScriptActor
// 0x0000 (0x0228 - 0x0228)
class ADFLevelScriptActor : public ALevelScriptActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFLevelScriptActor">();
	}
	static class ADFLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFLevelScriptActor>();
	}
};
static_assert(alignof(ADFLevelScriptActor) == 0x000008, "Wrong alignment on ADFLevelScriptActor");
static_assert(sizeof(ADFLevelScriptActor) == 0x000228, "Wrong size on ADFLevelScriptActor");

// Class DonkehFramework.DFLoadout
// 0x0010 (0x0040 - 0x0030)
class UDFLoadout : public UDataAsset
{
public:
	TArray<TSubclassOf<class ADFBaseItem>>        ItemClasses;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFLoadout">();
	}
	static class UDFLoadout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFLoadout>();
	}
};
static_assert(alignof(UDFLoadout) == 0x000008, "Wrong alignment on UDFLoadout");
static_assert(sizeof(UDFLoadout) == 0x000040, "Wrong size on UDFLoadout");
static_assert(offsetof(UDFLoadout, ItemClasses) == 0x000030, "Member 'UDFLoadout::ItemClasses' has a wrong offset!");

// Class DonkehFramework.DFNavigationSystemConfig
// 0x0008 (0x0060 - 0x0058)
class UDFNavigationSystemConfig : public UNavigationSystemModuleConfig
{
public:
	uint8                                         bGenerateNavigationOnlyAroundNavigationInvokers : 1; // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFNavigationSystemConfig">();
	}
	static class UDFNavigationSystemConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFNavigationSystemConfig>();
	}
};
static_assert(alignof(UDFNavigationSystemConfig) == 0x000008, "Wrong alignment on UDFNavigationSystemConfig");
static_assert(sizeof(UDFNavigationSystemConfig) == 0x000060, "Wrong size on UDFNavigationSystemConfig");

// Class DonkehFramework.DFOnlineSessionClient
// 0x0018 (0x01A8 - 0x0190)
class UDFOnlineSessionClient : public UOnlineSessionClient
{
public:
	uint8                                         Pad_190[0x18];                                     // 0x0190(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFOnlineSessionClient">();
	}
	static class UDFOnlineSessionClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFOnlineSessionClient>();
	}
};
static_assert(alignof(UDFOnlineSessionClient) == 0x000008, "Wrong alignment on UDFOnlineSessionClient");
static_assert(sizeof(UDFOnlineSessionClient) == 0x0001A8, "Wrong size on UDFOnlineSessionClient");

// Class DonkehFramework.DFPhysicalMaterial
// 0x0010 (0x0090 - 0x0080)
class UDFPhysicalMaterial final : public UPhysicalMaterial
{
public:
	class UParticleSystem*                        CollisionFX;                                       // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundCue*                              CollisionSound;                                    // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFPhysicalMaterial">();
	}
	static class UDFPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFPhysicalMaterial>();
	}
};
static_assert(alignof(UDFPhysicalMaterial) == 0x000008, "Wrong alignment on UDFPhysicalMaterial");
static_assert(sizeof(UDFPhysicalMaterial) == 0x000090, "Wrong size on UDFPhysicalMaterial");
static_assert(offsetof(UDFPhysicalMaterial, CollisionFX) == 0x000080, "Member 'UDFPhysicalMaterial::CollisionFX' has a wrong offset!");
static_assert(offsetof(UDFPhysicalMaterial, CollisionSound) == 0x000088, "Member 'UDFPhysicalMaterial::CollisionSound' has a wrong offset!");

// Class DonkehFramework.DFServerAdminSubsystem
// 0x0020 (0x0050 - 0x0030)
class UDFServerAdminSubsystem final : public UEngineSubsystem
{
public:
	TArray<class UDFCfgDataManager*>              DataMgrs;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFServerAdminSubsystem">();
	}
	static class UDFServerAdminSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFServerAdminSubsystem>();
	}
};
static_assert(alignof(UDFServerAdminSubsystem) == 0x000008, "Wrong alignment on UDFServerAdminSubsystem");
static_assert(sizeof(UDFServerAdminSubsystem) == 0x000050, "Wrong size on UDFServerAdminSubsystem");
static_assert(offsetof(UDFServerAdminSubsystem, DataMgrs) == 0x000030, "Member 'UDFServerAdminSubsystem::DataMgrs' has a wrong offset!");

// Class DonkehFramework.DFTeamDefinition
// 0x0030 (0x0058 - 0x0028)
class UDFTeamDefinition : public UObject
{
public:
	class FName                                   TeamName;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FactionInfoClass;                                  // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFTeamDefinition">();
	}
	static class UDFTeamDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFTeamDefinition>();
	}
};
static_assert(alignof(UDFTeamDefinition) == 0x000008, "Wrong alignment on UDFTeamDefinition");
static_assert(sizeof(UDFTeamDefinition) == 0x000058, "Wrong size on UDFTeamDefinition");
static_assert(offsetof(UDFTeamDefinition, TeamName) == 0x000028, "Member 'UDFTeamDefinition::TeamName' has a wrong offset!");
static_assert(offsetof(UDFTeamDefinition, FactionInfoClass) == 0x000030, "Member 'UDFTeamDefinition::FactionInfoClass' has a wrong offset!");

// Class DonkehFramework.DFTeamState
// 0x0030 (0x0250 - 0x0220)
class ADFTeamState : public AInfo
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bInitialized : 1;                                  // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDFFactionInfo>             FactionInfoClass;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         TeamNum;                                           // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPostInitTeam;                                    // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ReceiveInitTeam(const class UDFTeamDefinition* InTeamDef);
	void ReceivePostInitTeam();

	const class UDFFactionInfo* GetFactionInfo() const;
	bool IsPendingSetupBP() const;
	bool IsReadyToInitialize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFTeamState">();
	}
	static class ADFTeamState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFTeamState>();
	}
};
static_assert(alignof(ADFTeamState) == 0x000008, "Wrong alignment on ADFTeamState");
static_assert(sizeof(ADFTeamState) == 0x000250, "Wrong size on ADFTeamState");
static_assert(offsetof(ADFTeamState, FactionInfoClass) == 0x000230, "Member 'ADFTeamState::FactionInfoClass' has a wrong offset!");
static_assert(offsetof(ADFTeamState, TeamNum) == 0x000238, "Member 'ADFTeamState::TeamNum' has a wrong offset!");
static_assert(offsetof(ADFTeamState, OnPostInitTeam) == 0x000240, "Member 'ADFTeamState::OnPostInitTeam' has a wrong offset!");

// Class DonkehFramework.DFThrowableWeapAnimInstInterface
// 0x0000 (0x0028 - 0x0028)
class IDFThrowableWeapAnimInstInterface final : public IInterface
{
public:
	float PlayCockMontage(class UAnimMontage* MontageToPlay);
	float PlayThrowOverhandMontage(class UAnimMontage* MontageToPlay);
	float PlayThrowUnderhandMontage(class UAnimMontage* MontageToPlay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFThrowableWeapAnimInstInterface">();
	}
	static class IDFThrowableWeapAnimInstInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDFThrowableWeapAnimInstInterface>();
	}
};
static_assert(alignof(IDFThrowableWeapAnimInstInterface) == 0x000008, "Wrong alignment on IDFThrowableWeapAnimInstInterface");
static_assert(sizeof(IDFThrowableWeapAnimInstInterface) == 0x000028, "Wrong size on IDFThrowableWeapAnimInstInterface");

// Class DonkehFramework.DFTokenStore
// 0x0050 (0x00C8 - 0x0078)
class UDFTokenStore final : public UDFCfgDataManager
{
public:
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFTokenStore">();
	}
	static class UDFTokenStore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFTokenStore>();
	}
};
static_assert(alignof(UDFTokenStore) == 0x000008, "Wrong alignment on UDFTokenStore");
static_assert(sizeof(UDFTokenStore) == 0x0000C8, "Wrong size on UDFTokenStore");

// Class DonkehFramework.DFVoteIssue
// 0x00A0 (0x00C8 - 0x0028)
class UDFVoteIssue : public UObject
{
public:
	float                                         PassRatio;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PassedVoteCooldown;                                // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FailedVoteCooldown;                                // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDenyVACBannedUsersFromVoting;                     // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableVACBanCheckWhileAdminIsOnline;             // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyAdminsCanInitiateVote;                        // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   IssueDisplayNameText;                              // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   VotePromptFormatText;                              // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         NumEligibleVoters;                                 // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDFPlayerVote>                  Votes;                                             // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoteStartTime;                                     // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoteEndTime;                                       // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDFVoteStatus                                 VoteEndStatus;                                     // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           VoteOwner;                                         // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDFVoteIssueContext                    IssueContext;                                      // 0x00A0(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetVoteSelections(TArray<struct FDFPlayerVoteSelection>* OutVoteSelections);
	void ReceiveVoteInit();
	void ReceiveVoteReset();
	void ResetVote();
	void VoteFailed();
	void VotePassed();

	bool AllowsStartVoteBy(class APlayerState* InvokingPlayer) const;
	bool AllowsVoteFrom(class APlayerState* VoterPS) const;
	bool CanStartVote(class APlayerState* InvokingPlayer) const;
	bool CanVoteOn(class APlayerState* VoterPS) const;
	EDFVoteStatus DetermineVoteStatus() const;
	int32 GetEligibleVoterCount() const;
	void GetEligibleVoters(TArray<class APlayerState*>* OutEligibleVoters) const;
	class UDFVotingComponent* GetOwningVotingComponent() const;
	int32 GetRequiredVoteCountToPass() const;
	void GetYesNoVoteCounts(int32* OutYesVotes, int32* OutNoVotes) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFVoteIssue">();
	}
	static class UDFVoteIssue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFVoteIssue>();
	}
};
static_assert(alignof(UDFVoteIssue) == 0x000008, "Wrong alignment on UDFVoteIssue");
static_assert(sizeof(UDFVoteIssue) == 0x0000C8, "Wrong size on UDFVoteIssue");
static_assert(offsetof(UDFVoteIssue, PassRatio) == 0x000028, "Member 'UDFVoteIssue::PassRatio' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, Duration) == 0x00002C, "Member 'UDFVoteIssue::Duration' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, PassedVoteCooldown) == 0x000030, "Member 'UDFVoteIssue::PassedVoteCooldown' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, FailedVoteCooldown) == 0x000034, "Member 'UDFVoteIssue::FailedVoteCooldown' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, bDenyVACBannedUsersFromVoting) == 0x000038, "Member 'UDFVoteIssue::bDenyVACBannedUsersFromVoting' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, bDisableVACBanCheckWhileAdminIsOnline) == 0x000039, "Member 'UDFVoteIssue::bDisableVACBanCheckWhileAdminIsOnline' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, bOnlyAdminsCanInitiateVote) == 0x00003A, "Member 'UDFVoteIssue::bOnlyAdminsCanInitiateVote' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, IssueDisplayNameText) == 0x000040, "Member 'UDFVoteIssue::IssueDisplayNameText' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, VotePromptFormatText) == 0x000058, "Member 'UDFVoteIssue::VotePromptFormatText' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, NumEligibleVoters) == 0x000070, "Member 'UDFVoteIssue::NumEligibleVoters' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, Votes) == 0x000078, "Member 'UDFVoteIssue::Votes' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, VoteStartTime) == 0x000088, "Member 'UDFVoteIssue::VoteStartTime' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, VoteEndTime) == 0x00008C, "Member 'UDFVoteIssue::VoteEndTime' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, VoteEndStatus) == 0x000090, "Member 'UDFVoteIssue::VoteEndStatus' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, VoteOwner) == 0x000098, "Member 'UDFVoteIssue::VoteOwner' has a wrong offset!");
static_assert(offsetof(UDFVoteIssue, IssueContext) == 0x0000A0, "Member 'UDFVoteIssue::IssueContext' has a wrong offset!");

// Class DonkehFramework.DFVoteIssuePlayer
// 0x0008 (0x00D0 - 0x00C8)
class UDFVoteIssuePlayer : public UDFVoteIssue
{
public:
	bool                                          bAllowAdminTargets;                                // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanInitiateVoteWithTarget(class APlayerState* TargetPS) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFVoteIssuePlayer">();
	}
	static class UDFVoteIssuePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFVoteIssuePlayer>();
	}
};
static_assert(alignof(UDFVoteIssuePlayer) == 0x000008, "Wrong alignment on UDFVoteIssuePlayer");
static_assert(sizeof(UDFVoteIssuePlayer) == 0x0000D0, "Wrong size on UDFVoteIssuePlayer");
static_assert(offsetof(UDFVoteIssuePlayer, bAllowAdminTargets) == 0x0000C8, "Member 'UDFVoteIssuePlayer::bAllowAdminTargets' has a wrong offset!");

// Class DonkehFramework.DFVoteIssuePlayerKick
// 0x0008 (0x00D8 - 0x00D0)
class UDFVoteIssuePlayerKick final : public UDFVoteIssuePlayer
{
public:
	float                                         BanDuration;                                       // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFVoteIssuePlayerKick">();
	}
	static class UDFVoteIssuePlayerKick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFVoteIssuePlayerKick>();
	}
};
static_assert(alignof(UDFVoteIssuePlayerKick) == 0x000008, "Wrong alignment on UDFVoteIssuePlayerKick");
static_assert(sizeof(UDFVoteIssuePlayerKick) == 0x0000D8, "Wrong size on UDFVoteIssuePlayerKick");
static_assert(offsetof(UDFVoteIssuePlayerKick, BanDuration) == 0x0000D0, "Member 'UDFVoteIssuePlayerKick::BanDuration' has a wrong offset!");

// Class DonkehFramework.DFVotingComponent
// 0x0100 (0x01B0 - 0x00B0)
class UDFVotingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x48];                                      // 0x00B0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerVoteInitiatedDynamic;                      // 0x00F8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPlayerVoteEndedDynamic;                          // 0x0108(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPlayerVoteStateUpdatedDynamic;                   // 0x0118(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FDFActiveVoteInfo                      ActiveVoteInfo;                                    // 0x0128(0x0048)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UDFVoteIssue*                           ActiveVoteIssue;                                   // 0x0170(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDFVoteIssue*>                   VoteIssues;                                        // 0x0178(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDFVoteIssueDefinition>         VoteIssueDefinitions;                              // 0x0188(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x18];                                     // 0x0198(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CastVote(class APlayerState* InvokingPlayer, int32 VoteSelectionID);
	bool InitiateVote(class APlayerState* InvokingPlayer, TSubclassOf<class UDFVoteIssue> IssueClass, const struct FDFVoteIssueContext& IssueContext);
	void OnPlayerVoteIssueEventDynamic__DelegateSignature(class UDFVotingComponent* SourceVotingComponent);
	void OnRep_ActiveVoteInfo(const struct FDFActiveVoteInfo& PreviousValue);

	bool CanCastVote(class APlayerState* VotingPlayer, int32 VoteSelectionID) const;
	bool CanInitiateVote(class APlayerState* InvokingPlayer, TSubclassOf<class UDFVoteIssue> IssueClass) const;
	bool CanVoteTargetPlayer(class APlayerState* TargetPS, TSubclassOf<class UDFVoteIssue> IssueClass) const;
	bool GetVoteIssueDefinitionForClass(TSubclassOf<class UDFVoteIssue> IssueClass, struct FDFVoteIssueDefinition* OutIssueDefinition) const;
	class UDFVoteIssue* GetVoteIssueForClass(TSubclassOf<class UDFVoteIssue> IssueClass) const;
	bool IsVotingInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFVotingComponent">();
	}
	static class UDFVotingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFVotingComponent>();
	}
};
static_assert(alignof(UDFVotingComponent) == 0x000008, "Wrong alignment on UDFVotingComponent");
static_assert(sizeof(UDFVotingComponent) == 0x0001B0, "Wrong size on UDFVotingComponent");
static_assert(offsetof(UDFVotingComponent, OnPlayerVoteInitiatedDynamic) == 0x0000F8, "Member 'UDFVotingComponent::OnPlayerVoteInitiatedDynamic' has a wrong offset!");
static_assert(offsetof(UDFVotingComponent, OnPlayerVoteEndedDynamic) == 0x000108, "Member 'UDFVotingComponent::OnPlayerVoteEndedDynamic' has a wrong offset!");
static_assert(offsetof(UDFVotingComponent, OnPlayerVoteStateUpdatedDynamic) == 0x000118, "Member 'UDFVotingComponent::OnPlayerVoteStateUpdatedDynamic' has a wrong offset!");
static_assert(offsetof(UDFVotingComponent, ActiveVoteInfo) == 0x000128, "Member 'UDFVotingComponent::ActiveVoteInfo' has a wrong offset!");
static_assert(offsetof(UDFVotingComponent, ActiveVoteIssue) == 0x000170, "Member 'UDFVotingComponent::ActiveVoteIssue' has a wrong offset!");
static_assert(offsetof(UDFVotingComponent, VoteIssues) == 0x000178, "Member 'UDFVotingComponent::VoteIssues' has a wrong offset!");
static_assert(offsetof(UDFVotingComponent, VoteIssueDefinitions) == 0x000188, "Member 'UDFVotingComponent::VoteIssueDefinitions' has a wrong offset!");

// Class DonkehFramework.DFVotingStatics
// 0x0000 (0x0028 - 0x0028)
class UDFVotingStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UDFVotingComponent* GetGameStateVotingComponent(const class UObject* WorldContextObject);
	static bool IsValidVotingPlayer(class APlayerState* PlayerState);
	static struct FDFVoteIssueContext MakeVoteContext(class APlayerState* TargetPlayer);
	static class FText VoteInfoGetPromptTextForDisplay(const struct FDFActiveVoteInfo& VoteInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFVotingStatics">();
	}
	static class UDFVotingStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDFVotingStatics>();
	}
};
static_assert(alignof(UDFVotingStatics) == 0x000008, "Wrong alignment on UDFVotingStatics");
static_assert(sizeof(UDFVotingStatics) == 0x000028, "Wrong size on UDFVotingStatics");

// Class DonkehFramework.DFWorldSettings
// 0x0128 (0x04C8 - 0x03A0)
class ADFWorldSettings : public AWorldSettings
{
public:
	uint8                                         bVisibleInMapSelectUI : 1;                         // 0x03A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MapDisplayName;                                    // 0x03A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	class FText                                   MapDescription;                                    // 0x03C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              MapPreviewImg;                                     // 0x03D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              MapPreviewBannerImg;                               // 0x0400(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<TSoftClassPtr<class UClass>>             SupportedGameModes;                                // 0x0428(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSet<TSoftClassPtr<class UClass>>             GameRulesetClasses;                                // 0x0478(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NoClear, AssetRegistrySearchable, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DFWorldSettings">();
	}
	static class ADFWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADFWorldSettings>();
	}
};
static_assert(alignof(ADFWorldSettings) == 0x000008, "Wrong alignment on ADFWorldSettings");
static_assert(sizeof(ADFWorldSettings) == 0x0004C8, "Wrong size on ADFWorldSettings");
static_assert(offsetof(ADFWorldSettings, MapDisplayName) == 0x0003A8, "Member 'ADFWorldSettings::MapDisplayName' has a wrong offset!");
static_assert(offsetof(ADFWorldSettings, MapDescription) == 0x0003C0, "Member 'ADFWorldSettings::MapDescription' has a wrong offset!");
static_assert(offsetof(ADFWorldSettings, MapPreviewImg) == 0x0003D8, "Member 'ADFWorldSettings::MapPreviewImg' has a wrong offset!");
static_assert(offsetof(ADFWorldSettings, MapPreviewBannerImg) == 0x000400, "Member 'ADFWorldSettings::MapPreviewBannerImg' has a wrong offset!");
static_assert(offsetof(ADFWorldSettings, SupportedGameModes) == 0x000428, "Member 'ADFWorldSettings::SupportedGameModes' has a wrong offset!");
static_assert(offsetof(ADFWorldSettings, GameRulesetClasses) == 0x000478, "Member 'ADFWorldSettings::GameRulesetClasses' has a wrong offset!");

// Class DonkehFramework.GameSessionBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameSessionBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddAdmin(class UObject* WorldContextObj, class APlayerController* AdminPlayer);
	static int32 GetMaxPlayers(class UObject* WorldContextObj);
	static int32 GetMaxSpectators(class UObject* WorldContextObj);
	static int32 GetMinPlayers(class UObject* WorldContextObj);

	void RemoveAdmin(class UObject* WorldContextObj, class APlayerController* AdminPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSessionBlueprintLibrary">();
	}
	static class UGameSessionBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSessionBlueprintLibrary>();
	}
};
static_assert(alignof(UGameSessionBlueprintLibrary) == 0x000008, "Wrong alignment on UGameSessionBlueprintLibrary");
static_assert(sizeof(UGameSessionBlueprintLibrary) == 0x000028, "Wrong size on UGameSessionBlueprintLibrary");

// Class DonkehFramework.SpawnPointProviderInterface
// 0x0000 (0x0028 - 0x0028)
class ISpawnPointProviderInterface final : public IInterface
{
public:
	bool CanRestartPlayerFromSpawnPointBP(const struct FSpawnPointDef& SpawnPoint, class AController* Player, TSubclassOf<class APawn> PlayerPawnClass) const;
	bool CanSpawnActorFromSpawnPointBP(const struct FSpawnPointDef& SpawnPoint, TSubclassOf<class AActor> SpawnActorClass) const;
	bool FindSpawnPointBP(int32 SpawnPointID, struct FSpawnPointDef* FoundSpawnPoint) const;
	int32 GetAllSpawnPointsBP(TArray<struct FSpawnPointDef>* SpawnPoints) const;
	bool GetSpawnPointCollisionHandlingOverrideBP(const struct FSpawnPointDef& SpawnPoint, ESpawnActorCollisionHandlingMethod* OutSpawnCollisionMethod) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPointProviderInterface">();
	}
	static class ISpawnPointProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpawnPointProviderInterface>();
	}
};
static_assert(alignof(ISpawnPointProviderInterface) == 0x000008, "Wrong alignment on ISpawnPointProviderInterface");
static_assert(sizeof(ISpawnPointProviderInterface) == 0x000028, "Wrong size on ISpawnPointProviderInterface");

// Class DonkehFramework.SpawnPointStatics
// 0x0000 (0x0028 - 0x0028)
class USpawnPointStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool CanRestartPlayerFromAnySpawnPoint(const class UObject* Target, class AController* Player, const TSubclassOf<class APawn>& PlayerPawnClass);
	static bool CanRestartPlayerFromSpawnPoint(const class UObject* Target, const struct FSpawnPointDef& SpawnPoint, class AController* Player, const TSubclassOf<class APawn>& PlayerPawnClass);
	static bool CanSpawnActorFromAnySpawnPoint(const class UObject* Target, const TSubclassOf<class AActor>& SpawnActorClass);
	static bool CanSpawnActorFromSpawnPoint(const class UObject* Target, const struct FSpawnPointDef& SpawnPoint, const TSubclassOf<class AActor>& SpawnActorClass);
	static bool FindSpawnPoint(const class UObject* Target, int32 SpawnPointID, struct FSpawnPointDef* FoundSpawnPoint);
	static int32 GetAllSpawnPoints(const class UObject* Target, TArray<struct FSpawnPointDef>* SpawnPoints);
	static int32 GetAllSpawnPointTransforms(const class UObject* Target, TArray<struct FTransform>* SpawnPointTransforms);
	static bool GetSpawnPointCollisionHandlingOverride(const class UObject* Target, const struct FSpawnPointDef& SpawnPoint, ESpawnActorCollisionHandlingMethod* OutSpawnCollisionMethod);
	static bool SpawnPointExists(const class UObject* Target, int32 SpawnPointID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPointStatics">();
	}
	static class USpawnPointStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnPointStatics>();
	}
};
static_assert(alignof(USpawnPointStatics) == 0x000008, "Wrong alignment on USpawnPointStatics");
static_assert(sizeof(USpawnPointStatics) == 0x000028, "Wrong size on USpawnPointStatics");

// Class DonkehFramework.UseableInterface
// 0x0000 (0x0028 - 0x0028)
class IUseableInterface final : public IInterface
{
public:
	void Used(class AActor* Invoker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UseableInterface">();
	}
	static class IUseableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUseableInterface>();
	}
};
static_assert(alignof(IUseableInterface) == 0x000008, "Wrong alignment on IUseableInterface");
static_assert(sizeof(IUseableInterface) == 0x000028, "Wrong size on IUseableInterface");

// Class DonkehFramework.VisibilityInterface
// 0x0000 (0x0028 - 0x0028)
class IVisibilityInterface final : public IInterface
{
public:
	struct FVector EventGetFocalPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibilityInterface">();
	}
	static class IVisibilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVisibilityInterface>();
	}
};
static_assert(alignof(IVisibilityInterface) == 0x000008, "Wrong alignment on IVisibilityInterface");
static_assert(sizeof(IVisibilityInterface) == 0x000028, "Wrong size on IVisibilityInterface");

}

