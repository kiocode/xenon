#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1032

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1032.Config_103221
// 0x0FC8 (0x1060 - 0x0098)
class UConfig_103221 : public UMarvelAbilityConfig
{
public:
	class UCurveFloat*                            ChargeCurve;                                       // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00A0(0x0F90)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      TraceObjectType;                                   // 0x1030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x1040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1044[0x4];                                     // 0x1044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             ActorClassToIgnore;                                // 0x1048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bIsBound;                                          // 0x1058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1059[0x7];                                     // 0x1059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103221">();
	}
	static class UConfig_103221* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103221>();
	}
};
static_assert(alignof(UConfig_103221) == 0x000010, "Wrong alignment on UConfig_103221");
static_assert(sizeof(UConfig_103221) == 0x001060, "Wrong size on UConfig_103221");
static_assert(offsetof(UConfig_103221, ChargeCurve) == 0x000098, "Member 'UConfig_103221::ChargeCurve' has a wrong offset!");
static_assert(offsetof(UConfig_103221, TraceContext) == 0x0000A0, "Member 'UConfig_103221::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103221, TraceObjectType) == 0x001030, "Member 'UConfig_103221::TraceObjectType' has a wrong offset!");
static_assert(offsetof(UConfig_103221, TraceDistance) == 0x001040, "Member 'UConfig_103221::TraceDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103221, ActorClassToIgnore) == 0x001048, "Member 'UConfig_103221::ActorClassToIgnore' has a wrong offset!");
static_assert(offsetof(UConfig_103221, bIsBound) == 0x001058, "Member 'UConfig_103221::bIsBound' has a wrong offset!");

// Class Hero_1032.Ability_103221
// 0x0000 (0x2580 - 0x2580)
class UAbility_103221 : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103221">();
	}
	static class UAbility_103221* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103221>();
	}
};
static_assert(alignof(UAbility_103221) == 0x000008, "Wrong alignment on UAbility_103221");
static_assert(sizeof(UAbility_103221) == 0x002580, "Wrong size on UAbility_103221");

// Class Hero_1032.Cue_Ability_Loop_10322103
// 0x1018 (0x1E68 - 0x0E50)
class ACue_Ability_Loop_10322103 : public AMarvelCueNotify_Ability
{
public:
	class UMarvelSplineComponent*                 SplineComponent;                                   // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            TailStaticMesh;                                    // 0x0E58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BodyStaticMesh;                                    // 0x0E60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            HeadStaticMesh;                                    // 0x0E68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           SplineMeshCollection;                              // 0x0E70(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         MaxNumOfSplineMeshUsed;                            // 0x0E80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E84[0x4];                                      // 0x0E84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelProjectileAgentTable            ProjectileDate;                                    // 0x0E88(0x0FD8)(NativeAccessSpecifierPublic)
	class ASquirrelGirlCharacter*                 OwnCharacter;                                      // 0x1E60(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10322103">();
	}
	static class ACue_Ability_Loop_10322103* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10322103>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10322103) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10322103");
static_assert(sizeof(ACue_Ability_Loop_10322103) == 0x001E68, "Wrong size on ACue_Ability_Loop_10322103");
static_assert(offsetof(ACue_Ability_Loop_10322103, SplineComponent) == 0x000E50, "Member 'ACue_Ability_Loop_10322103::SplineComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, TailStaticMesh) == 0x000E58, "Member 'ACue_Ability_Loop_10322103::TailStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, BodyStaticMesh) == 0x000E60, "Member 'ACue_Ability_Loop_10322103::BodyStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, HeadStaticMesh) == 0x000E68, "Member 'ACue_Ability_Loop_10322103::HeadStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, SplineMeshCollection) == 0x000E70, "Member 'ACue_Ability_Loop_10322103::SplineMeshCollection' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, MaxNumOfSplineMeshUsed) == 0x000E80, "Member 'ACue_Ability_Loop_10322103::MaxNumOfSplineMeshUsed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, ProjectileDate) == 0x000E88, "Member 'ACue_Ability_Loop_10322103::ProjectileDate' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, OwnCharacter) == 0x001E60, "Member 'ACue_Ability_Loop_10322103::OwnCharacter' has a wrong offset!");

// Class Hero_1032.103221MovableSplineMeshComponent
// 0x0000 (0x0A30 - 0x0A30)
class UOne03221MovableSplineMeshComponent final : public USplineMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"103221MovableSplineMeshComponent">();
	}
	static class UOne03221MovableSplineMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOne03221MovableSplineMeshComponent>();
	}
};
static_assert(alignof(UOne03221MovableSplineMeshComponent) == 0x000010, "Wrong alignment on UOne03221MovableSplineMeshComponent");
static_assert(sizeof(UOne03221MovableSplineMeshComponent) == 0x000A30, "Wrong size on UOne03221MovableSplineMeshComponent");

// Class Hero_1032.SummonedMovementComponent_10324101
// 0x0010 (0x0A50 - 0x0A40)
class USummonedMovementComponent_10324101 final : public USummonedMovementComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSquirrelAttachDelegate;                          // 0x0A40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedMovementComponent_10324101">();
	}
	static class USummonedMovementComponent_10324101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedMovementComponent_10324101>();
	}
};
static_assert(alignof(USummonedMovementComponent_10324101) == 0x000010, "Wrong alignment on USummonedMovementComponent_10324101");
static_assert(sizeof(USummonedMovementComponent_10324101) == 0x000A50, "Wrong size on USummonedMovementComponent_10324101");
static_assert(offsetof(USummonedMovementComponent_10324101, OnSquirrelAttachDelegate) == 0x000A40, "Member 'USummonedMovementComponent_10324101::OnSquirrelAttachDelegate' has a wrong offset!");

// Class Hero_1032.Summoned_10324101
// 0x0010 (0x0970 - 0x0960)
class ASummoned_10324101 final : public AMarvelTraceableSummoner
{
public:
	class USummonedMovementComponent*             SummonedMovement_10324101;                         // 0x0960(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_968[0x8];                                      // 0x0968(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10324101">();
	}
	static class ASummoned_10324101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10324101>();
	}
};
static_assert(alignof(ASummoned_10324101) == 0x000010, "Wrong alignment on ASummoned_10324101");
static_assert(sizeof(ASummoned_10324101) == 0x000970, "Wrong size on ASummoned_10324101");
static_assert(offsetof(ASummoned_10324101, SummonedMovement_10324101) == 0x000960, "Member 'ASummoned_10324101::SummonedMovement_10324101' has a wrong offset!");

// Class Hero_1032.Summoned_V2_10325101
// 0x03B0 (0x1250 - 0x0EA0)
class ASummoned_V2_10325101 : public ASummonedCharacterBase
{
public:
	struct FVector                                CachedForward;                                     // 0x0E98(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActorHit;                                       // 0x0EB0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEndFlying;                                      // 0x0EB1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EB2[0x6];                                      // 0x0EB2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            Movement;                                          // 0x0EB8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ForwardVector;                                     // 0x0EC0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103251*                         AbilityConfig;                                     // 0x0ED8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueParameters                 Parameter;                                         // 0x0EE0(0x01B8)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FHitResult                             HitPoint;                                          // 0x1098(0x0170)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           SetModeHandle;                                     // 0x1208(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastHitPosition;                                   // 0x1220(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1238[0x18];                                    // 0x1238(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UConfig_103251* GetAbilityConfig();
	bool IsWallClimbing(const struct FHitResult& Hit);
	void MovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnSquirrelHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnSummonedKillOther(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void SetActorRotationOnForwardVectorChange();
	void SetMovementModeAndSmoothingMode();
	void SquirrelClimbingWall(const struct FHitResult& Hit);
	void SquirrelTurn(const struct FHitResult& Hit, float Angle, float ForceTurn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_V2_10325101">();
	}
	static class ASummoned_V2_10325101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_V2_10325101>();
	}
};
static_assert(alignof(ASummoned_V2_10325101) == 0x000010, "Wrong alignment on ASummoned_V2_10325101");
static_assert(sizeof(ASummoned_V2_10325101) == 0x001250, "Wrong size on ASummoned_V2_10325101");
static_assert(offsetof(ASummoned_V2_10325101, CachedForward) == 0x000E98, "Member 'ASummoned_V2_10325101::CachedForward' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, bIsActorHit) == 0x000EB0, "Member 'ASummoned_V2_10325101::bIsActorHit' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, bIsEndFlying) == 0x000EB1, "Member 'ASummoned_V2_10325101::bIsEndFlying' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, Movement) == 0x000EB8, "Member 'ASummoned_V2_10325101::Movement' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, ForwardVector) == 0x000EC0, "Member 'ASummoned_V2_10325101::ForwardVector' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, AbilityConfig) == 0x000ED8, "Member 'ASummoned_V2_10325101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, Parameter) == 0x000EE0, "Member 'ASummoned_V2_10325101::Parameter' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, HitPoint) == 0x001098, "Member 'ASummoned_V2_10325101::HitPoint' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, SetModeHandle) == 0x001208, "Member 'ASummoned_V2_10325101::SetModeHandle' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, LastHitPosition) == 0x001220, "Member 'ASummoned_V2_10325101::LastHitPosition' has a wrong offset!");

// Class Hero_1032.SummonedComp_10325101
// 0x0000 (0x0CA0 - 0x0CA0)
class USummonedComp_10325101 final : public UMarvelSummonedComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10325101">();
	}
	static class USummonedComp_10325101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10325101>();
	}
};
static_assert(alignof(USummonedComp_10325101) == 0x000010, "Wrong alignment on USummonedComp_10325101");
static_assert(sizeof(USummonedComp_10325101) == 0x000CA0, "Wrong size on USummonedComp_10325101");

// Class Hero_1032.Config_103251
// 0x2338 (0x23D0 - 0x0098)
class UConfig_103251 final : public UMarvelAbilityConfig
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00A0(0x0F90)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ClimbWallHeight;                                   // 0x1030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtensionDistance;                                 // 0x1034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitWalkSpeed;                                     // 0x1038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxWalkSpeed;                                      // 0x103C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x1040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1044[0x4];                                     // 0x1044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelTraceRule                       TraceRule;                                         // 0x1048(0x0390)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                SpawnOffset;                                       // 0x13D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x13F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F4[0x4];                                     // 0x13F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      TraceObjectType;                                   // 0x13F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                InitLocationOffset;                                // 0x1408(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnAfterTrace;                                   // 0x1420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1421[0xF];                                     // 0x1421(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TurnTraceContext;                                  // 0x1430(0x0F90)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TurnTraceMinAngle;                                 // 0x23C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnTraceMinDistance;                              // 0x23C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C8[0x8];                                     // 0x23C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103251">();
	}
	static class UConfig_103251* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103251>();
	}
};
static_assert(alignof(UConfig_103251) == 0x000010, "Wrong alignment on UConfig_103251");
static_assert(sizeof(UConfig_103251) == 0x0023D0, "Wrong size on UConfig_103251");
static_assert(offsetof(UConfig_103251, TraceContext) == 0x0000A0, "Member 'UConfig_103251::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103251, ClimbWallHeight) == 0x001030, "Member 'UConfig_103251::ClimbWallHeight' has a wrong offset!");
static_assert(offsetof(UConfig_103251, ExtensionDistance) == 0x001034, "Member 'UConfig_103251::ExtensionDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103251, InitWalkSpeed) == 0x001038, "Member 'UConfig_103251::InitWalkSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_103251, MaxWalkSpeed) == 0x00103C, "Member 'UConfig_103251::MaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_103251, DelayTime) == 0x001040, "Member 'UConfig_103251::DelayTime' has a wrong offset!");
static_assert(offsetof(UConfig_103251, TraceRule) == 0x001048, "Member 'UConfig_103251::TraceRule' has a wrong offset!");
static_assert(offsetof(UConfig_103251, SpawnOffset) == 0x0013D8, "Member 'UConfig_103251::SpawnOffset' has a wrong offset!");
static_assert(offsetof(UConfig_103251, SphereRadius) == 0x0013F0, "Member 'UConfig_103251::SphereRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103251, TraceObjectType) == 0x0013F8, "Member 'UConfig_103251::TraceObjectType' has a wrong offset!");
static_assert(offsetof(UConfig_103251, InitLocationOffset) == 0x001408, "Member 'UConfig_103251::InitLocationOffset' has a wrong offset!");
static_assert(offsetof(UConfig_103251, bTurnAfterTrace) == 0x001420, "Member 'UConfig_103251::bTurnAfterTrace' has a wrong offset!");
static_assert(offsetof(UConfig_103251, TurnTraceContext) == 0x001430, "Member 'UConfig_103251::TurnTraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103251, TurnTraceMinAngle) == 0x0023C0, "Member 'UConfig_103251::TurnTraceMinAngle' has a wrong offset!");
static_assert(offsetof(UConfig_103251, TurnTraceMinDistance) == 0x0023C4, "Member 'UConfig_103251::TurnTraceMinDistance' has a wrong offset!");

// Class Hero_1032.Ability_103251
// 0x0328 (0x28A8 - 0x2580)
class UAbility_103251 : public UMarvelGameplayAbility
{
public:
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                                      // 0x2580(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103251*                         AbilityConfig;                                     // 0x2588(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnUIControl;                                       // 0x2590(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputTaskCancel;                                   // 0x25A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputTaskConfirm;                                  // 0x25A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueParameters                 Parameter;                                         // 0x25B0(0x01B8)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FPredictionKey                         WaitTaskConfirmKey;                                // 0x2768(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         WaitTaskCancelKey;                                 // 0x2808(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnWaitTaskCancel_ThreadSafe(float TimeWaited);
	void OnWaitTaskConfirm(float TimeWaited);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103251">();
	}
	static class UAbility_103251* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103251>();
	}
};
static_assert(alignof(UAbility_103251) == 0x000008, "Wrong alignment on UAbility_103251");
static_assert(sizeof(UAbility_103251) == 0x0028A8, "Wrong size on UAbility_103251");
static_assert(offsetof(UAbility_103251, TimelineTask) == 0x002580, "Member 'UAbility_103251::TimelineTask' has a wrong offset!");
static_assert(offsetof(UAbility_103251, AbilityConfig) == 0x002588, "Member 'UAbility_103251::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103251, OnUIControl) == 0x002590, "Member 'UAbility_103251::OnUIControl' has a wrong offset!");
static_assert(offsetof(UAbility_103251, InputTaskCancel) == 0x0025A0, "Member 'UAbility_103251::InputTaskCancel' has a wrong offset!");
static_assert(offsetof(UAbility_103251, InputTaskConfirm) == 0x0025A8, "Member 'UAbility_103251::InputTaskConfirm' has a wrong offset!");
static_assert(offsetof(UAbility_103251, Parameter) == 0x0025B0, "Member 'UAbility_103251::Parameter' has a wrong offset!");
static_assert(offsetof(UAbility_103251, WaitTaskConfirmKey) == 0x002768, "Member 'UAbility_103251::WaitTaskConfirmKey' has a wrong offset!");
static_assert(offsetof(UAbility_103251, WaitTaskCancelKey) == 0x002808, "Member 'UAbility_103251::WaitTaskCancelKey' has a wrong offset!");

// Class Hero_1032.Cue_Buff_Loop_10328101
// 0x0070 (0x10A8 - 0x1038)
class ACue_Buff_Loop_10328101 final : public AMarvelCueNotify_Buff
{
public:
	float                                         FlightDuration;                                    // 0x1038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpawnSocket;                                       // 0x103C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SquirrelSocket;                                    // 0x1048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlightTimer;                                       // 0x1054(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StartLoc;                                          // 0x1058(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1070[0x30];                                    // 0x1070(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x10A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBuffOwnerDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnBuffOwnerReborn(class AActor* InSourceActor, const struct FCharacterRebornParam& RebornParam);
	void OnGameplayTagUpdate(const struct FGameplayTag& Tag, bool TagExists);
	void SetMeshHidden();
	void UpdateSquirrelTransform();

	void SetAnimPlaying(bool bIsPlaying) const;
	void SetMontageSection(class FName SectionName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_Loop_10328101">();
	}
	static class ACue_Buff_Loop_10328101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_Loop_10328101>();
	}
};
static_assert(alignof(ACue_Buff_Loop_10328101) == 0x000008, "Wrong alignment on ACue_Buff_Loop_10328101");
static_assert(sizeof(ACue_Buff_Loop_10328101) == 0x0010A8, "Wrong size on ACue_Buff_Loop_10328101");
static_assert(offsetof(ACue_Buff_Loop_10328101, FlightDuration) == 0x001038, "Member 'ACue_Buff_Loop_10328101::FlightDuration' has a wrong offset!");
static_assert(offsetof(ACue_Buff_Loop_10328101, SpawnSocket) == 0x00103C, "Member 'ACue_Buff_Loop_10328101::SpawnSocket' has a wrong offset!");
static_assert(offsetof(ACue_Buff_Loop_10328101, SquirrelSocket) == 0x001048, "Member 'ACue_Buff_Loop_10328101::SquirrelSocket' has a wrong offset!");
static_assert(offsetof(ACue_Buff_Loop_10328101, FlightTimer) == 0x001054, "Member 'ACue_Buff_Loop_10328101::FlightTimer' has a wrong offset!");
static_assert(offsetof(ACue_Buff_Loop_10328101, StartLoc) == 0x001058, "Member 'ACue_Buff_Loop_10328101::StartLoc' has a wrong offset!");
static_assert(offsetof(ACue_Buff_Loop_10328101, Mesh) == 0x0010A0, "Member 'ACue_Buff_Loop_10328101::Mesh' has a wrong offset!");

// Class Hero_1032.EpicMomentAction_1032
// 0x0018 (0x0138 - 0x0120)
class UEpicMomentAction_1032 : public UEpicMomentBaseAction
{
public:
	struct FEpicMomentNodeInfo                    ControlConfig;                                     // 0x0120(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ControlBuffID;                                     // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QSummonerID;                                       // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);
	void OnSummonerBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Summoned, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnSummonerEnd(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1032">();
	}
	static class UEpicMomentAction_1032* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1032>();
	}
};
static_assert(alignof(UEpicMomentAction_1032) == 0x000008, "Wrong alignment on UEpicMomentAction_1032");
static_assert(sizeof(UEpicMomentAction_1032) == 0x000138, "Wrong size on UEpicMomentAction_1032");
static_assert(offsetof(UEpicMomentAction_1032, ControlConfig) == 0x000120, "Member 'UEpicMomentAction_1032::ControlConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1032, ControlBuffID) == 0x00012C, "Member 'UEpicMomentAction_1032::ControlBuffID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1032, QSummonerID) == 0x000130, "Member 'UEpicMomentAction_1032::QSummonerID' has a wrong offset!");

// Class Hero_1032.SquirrelGirlAnimInstance
// 0x0090 (0x09A0 - 0x0910)
class USquirrelGirlAnimInstance : public UMarvelAnimInstance
{
public:
	float                                         InterpolationSpeed;                                // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_914[0x4];                                      // 0x0914(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LandBlendCurve;                                    // 0x0918(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaskLandBlendFactorCurveName;                      // 0x0920(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92C[0x4];                                      // 0x092C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartVelocity;                                     // 0x0930(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFalling;                                         // 0x0948(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLandStop;                                        // 0x0949(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsJumping;                                         // 0x094A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDead;                                            // 0x094B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LandBlendFactor;                                   // 0x094C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJumpFallingToLand;                                // 0x0950(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_951[0x4F];                                     // 0x0951(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirrelGirlAnimInstance">();
	}
	static class USquirrelGirlAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquirrelGirlAnimInstance>();
	}
};
static_assert(alignof(USquirrelGirlAnimInstance) == 0x000010, "Wrong alignment on USquirrelGirlAnimInstance");
static_assert(sizeof(USquirrelGirlAnimInstance) == 0x0009A0, "Wrong size on USquirrelGirlAnimInstance");
static_assert(offsetof(USquirrelGirlAnimInstance, InterpolationSpeed) == 0x000910, "Member 'USquirrelGirlAnimInstance::InterpolationSpeed' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, LandBlendCurve) == 0x000918, "Member 'USquirrelGirlAnimInstance::LandBlendCurve' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, MaskLandBlendFactorCurveName) == 0x000920, "Member 'USquirrelGirlAnimInstance::MaskLandBlendFactorCurveName' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, StartVelocity) == 0x000930, "Member 'USquirrelGirlAnimInstance::StartVelocity' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, IsFalling) == 0x000948, "Member 'USquirrelGirlAnimInstance::IsFalling' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, IsLandStop) == 0x000949, "Member 'USquirrelGirlAnimInstance::IsLandStop' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, IsJumping) == 0x00094A, "Member 'USquirrelGirlAnimInstance::IsJumping' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, IsDead) == 0x00094B, "Member 'USquirrelGirlAnimInstance::IsDead' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, LandBlendFactor) == 0x00094C, "Member 'USquirrelGirlAnimInstance::LandBlendFactor' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, bJumpFallingToLand) == 0x000950, "Member 'USquirrelGirlAnimInstance::bJumpFallingToLand' has a wrong offset!");

// Class Hero_1032.TippyToeAnimInstance
// 0x0050 (0x09F0 - 0x09A0)
class UTippyToeAnimInstance final : public USquirrelGirlAnimInstance
{
public:
	TArray<class UAnimMontage*>                   AnimMontages;                                      // 0x09A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         AbilityIDList;                                     // 0x09B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ShiftAbilityIDList;                                // 0x09C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         LoopAbilityIDList;                                 // 0x09D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HitDirection;                                      // 0x09E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E4[0x4];                                      // 0x09E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentMontage;                                    // 0x09E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AbilityMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void AbilityMontageStarted(class UAnimMontage* Montage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TippyToeAnimInstance">();
	}
	static class UTippyToeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTippyToeAnimInstance>();
	}
};
static_assert(alignof(UTippyToeAnimInstance) == 0x000010, "Wrong alignment on UTippyToeAnimInstance");
static_assert(sizeof(UTippyToeAnimInstance) == 0x0009F0, "Wrong size on UTippyToeAnimInstance");
static_assert(offsetof(UTippyToeAnimInstance, AnimMontages) == 0x0009A0, "Member 'UTippyToeAnimInstance::AnimMontages' has a wrong offset!");
static_assert(offsetof(UTippyToeAnimInstance, AbilityIDList) == 0x0009B0, "Member 'UTippyToeAnimInstance::AbilityIDList' has a wrong offset!");
static_assert(offsetof(UTippyToeAnimInstance, ShiftAbilityIDList) == 0x0009C0, "Member 'UTippyToeAnimInstance::ShiftAbilityIDList' has a wrong offset!");
static_assert(offsetof(UTippyToeAnimInstance, LoopAbilityIDList) == 0x0009D0, "Member 'UTippyToeAnimInstance::LoopAbilityIDList' has a wrong offset!");
static_assert(offsetof(UTippyToeAnimInstance, HitDirection) == 0x0009E0, "Member 'UTippyToeAnimInstance::HitDirection' has a wrong offset!");
static_assert(offsetof(UTippyToeAnimInstance, CurrentMontage) == 0x0009E8, "Member 'UTippyToeAnimInstance::CurrentMontage' has a wrong offset!");

// Class Hero_1032.SquirrelGirlCharacter
// 0x0020 (0x1830 - 0x1810)
class ASquirrelGirlCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bIsShiftJumping;                                   // 0x1810(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1811[0x7];                                     // 0x1811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TempInstigator;                                    // 0x1818(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USquirrelGirlMoveLogicBaseComponent*    SquirrelGirlMoveLogic;                             // 0x1820(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1828[0x8];                                     // 0x1828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSquirrelGirlJump(bool NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirrelGirlCharacter">();
	}
	static class ASquirrelGirlCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquirrelGirlCharacter>();
	}
};
static_assert(alignof(ASquirrelGirlCharacter) == 0x000010, "Wrong alignment on ASquirrelGirlCharacter");
static_assert(sizeof(ASquirrelGirlCharacter) == 0x001830, "Wrong size on ASquirrelGirlCharacter");
static_assert(offsetof(ASquirrelGirlCharacter, bIsShiftJumping) == 0x001810, "Member 'ASquirrelGirlCharacter::bIsShiftJumping' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlCharacter, TempInstigator) == 0x001818, "Member 'ASquirrelGirlCharacter::TempInstigator' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlCharacter, SquirrelGirlMoveLogic) == 0x001820, "Member 'ASquirrelGirlCharacter::SquirrelGirlMoveLogic' has a wrong offset!");

// Class Hero_1032.SquirrelGirlChildActor
// 0x0050 (0x0AB0 - 0x0A60)
class ASquirrelGirlChildActor final : public AMarvelCharacterChildActor
{
public:
	class UPhysicalAnimationComponent*            PhysicalAnimation;                                 // 0x0A60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName1;                                         // 0x0A68(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName2;                                         // 0x0A74(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsBlendWeight1;                               // 0x0A80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsBlendWeight2;                               // 0x0A84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TippyToeName;                                      // 0x0A88(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          TippyToePhysicsAssetOnDeath;                       // 0x0A98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          TippyToePhysicsAssetOnReborn;                      // 0x0AA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA8[0x8];                                      // 0x0AA8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeactivatePhysicalAnimation(bool bNeedPhysics, class FName InBoneName1, class FName InBoneName2);
	void SetPhysicalAnimation(class FName InBoneName1, float InPhysicsBlendWeight1, class FName InBoneName2, float PhysicsBlendWeight2_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirrelGirlChildActor">();
	}
	static class ASquirrelGirlChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquirrelGirlChildActor>();
	}
};
static_assert(alignof(ASquirrelGirlChildActor) == 0x000008, "Wrong alignment on ASquirrelGirlChildActor");
static_assert(sizeof(ASquirrelGirlChildActor) == 0x000AB0, "Wrong size on ASquirrelGirlChildActor");
static_assert(offsetof(ASquirrelGirlChildActor, PhysicalAnimation) == 0x000A60, "Member 'ASquirrelGirlChildActor::PhysicalAnimation' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, BoneName1) == 0x000A68, "Member 'ASquirrelGirlChildActor::BoneName1' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, BoneName2) == 0x000A74, "Member 'ASquirrelGirlChildActor::BoneName2' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, PhysicsBlendWeight1) == 0x000A80, "Member 'ASquirrelGirlChildActor::PhysicsBlendWeight1' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, PhysicsBlendWeight2) == 0x000A84, "Member 'ASquirrelGirlChildActor::PhysicsBlendWeight2' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, TippyToeName) == 0x000A88, "Member 'ASquirrelGirlChildActor::TippyToeName' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, TippyToePhysicsAssetOnDeath) == 0x000A98, "Member 'ASquirrelGirlChildActor::TippyToePhysicsAssetOnDeath' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, TippyToePhysicsAssetOnReborn) == 0x000AA0, "Member 'ASquirrelGirlChildActor::TippyToePhysicsAssetOnReborn' has a wrong offset!");

// Class Hero_1032.SquirrelGirlMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class USquirrelGirlMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirrelGirlMoveLogicBaseComponent">();
	}
	static class USquirrelGirlMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquirrelGirlMoveLogicBaseComponent>();
	}
};
static_assert(alignof(USquirrelGirlMoveLogicBaseComponent) == 0x000008, "Wrong alignment on USquirrelGirlMoveLogicBaseComponent");
static_assert(sizeof(USquirrelGirlMoveLogicBaseComponent) == 0x0003F0, "Wrong size on USquirrelGirlMoveLogicBaseComponent");

// Class Hero_1032.SquirrelGirlMovementComponent
// 0x0000 (0x1B60 - 0x1B60)
class USquirrelGirlMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirrelGirlMovementComponent">();
	}
	static class USquirrelGirlMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquirrelGirlMovementComponent>();
	}
};
static_assert(alignof(USquirrelGirlMovementComponent) == 0x000010, "Wrong alignment on USquirrelGirlMovementComponent");
static_assert(sizeof(USquirrelGirlMovementComponent) == 0x001B60, "Wrong size on USquirrelGirlMovementComponent");

}

