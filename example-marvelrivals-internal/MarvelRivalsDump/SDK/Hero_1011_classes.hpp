#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1011

#include "Basic.hpp"

#include "Hero_Synergy_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Hero_1011_structs.hpp"


namespace SDK
{

// Class Hero_1011.Cue_Ability_Loop_Morph
// 0x0100 (0x0F50 - 0x0E50)
class ACue_Ability_Loop_Morph final : public AMarvelCueNotify_Ability
{
public:
	struct FGameplayTag                           HulkStateTag;                                      // 0x0E50(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimerTotal;                                        // 0x0E5C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 HeroSourcePrefix;                                  // 0x0E60(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              SourceBody;                                        // 0x0E70(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              SourceHead;                                        // 0x0E78(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 HeroTargetPrefix;                                  // 0x0E80(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              TargetBody;                                        // 0x0E90(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              TargetHead;                                        // 0x0E98(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DynamicMaterialBodySlotName;                       // 0x0EA0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EAC[0x4];                                      // 0x0EAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceConstant*              BodyMorphSourceMaterial;                           // 0x0EB0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BodyMorphMask;                                     // 0x0EB8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DynamicMaterialHeadSlotName;                       // 0x0EC0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ECC[0x4];                                      // 0x0ECC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceConstant*              HeadMorphSourceMaterial;                           // 0x0ED0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             HeadMorphMask;                                     // 0x0ED8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMTPositionForCurve;                            // 0x0EE0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE1[0x7];                                      // 0x0EE1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MorphWeightCurve;                                  // 0x0EE8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           HeroShadowParameterNames;                          // 0x0EF0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle;                                       // 0x0F00(0x0018)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MorphMesh;                                         // 0x0F18(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0F20(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMorphSuccess;                                     // 0x0F28(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F29[0x3];                                      // 0x0F29(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerSpent;                                        // 0x0F2C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimerFrequence;                                    // 0x0F30(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F34[0x4];                                      // 0x0F34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DynamicMaterialBody;                               // 0x0F38(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DynamicMaterialHead;                               // 0x0F40(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DynamicMaterialBodyElementIndex;                   // 0x0F48(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DynamicMaterialHeadElementIndex;                   // 0x0F4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_Morph">();
	}
	static class ACue_Ability_Loop_Morph* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_Morph>();
	}
};
static_assert(alignof(ACue_Ability_Loop_Morph) == 0x000008, "Wrong alignment on ACue_Ability_Loop_Morph");
static_assert(sizeof(ACue_Ability_Loop_Morph) == 0x000F50, "Wrong size on ACue_Ability_Loop_Morph");
static_assert(offsetof(ACue_Ability_Loop_Morph, HulkStateTag) == 0x000E50, "Member 'ACue_Ability_Loop_Morph::HulkStateTag' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TimerTotal) == 0x000E5C, "Member 'ACue_Ability_Loop_Morph::TimerTotal' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, HeroSourcePrefix) == 0x000E60, "Member 'ACue_Ability_Loop_Morph::HeroSourcePrefix' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, SourceBody) == 0x000E70, "Member 'ACue_Ability_Loop_Morph::SourceBody' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, SourceHead) == 0x000E78, "Member 'ACue_Ability_Loop_Morph::SourceHead' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, HeroTargetPrefix) == 0x000E80, "Member 'ACue_Ability_Loop_Morph::HeroTargetPrefix' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TargetBody) == 0x000E90, "Member 'ACue_Ability_Loop_Morph::TargetBody' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TargetHead) == 0x000E98, "Member 'ACue_Ability_Loop_Morph::TargetHead' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialBodySlotName) == 0x000EA0, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialBodySlotName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, BodyMorphSourceMaterial) == 0x000EB0, "Member 'ACue_Ability_Loop_Morph::BodyMorphSourceMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, BodyMorphMask) == 0x000EB8, "Member 'ACue_Ability_Loop_Morph::BodyMorphMask' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialHeadSlotName) == 0x000EC0, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialHeadSlotName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, HeadMorphSourceMaterial) == 0x000ED0, "Member 'ACue_Ability_Loop_Morph::HeadMorphSourceMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, HeadMorphMask) == 0x000ED8, "Member 'ACue_Ability_Loop_Morph::HeadMorphMask' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, bUseMTPositionForCurve) == 0x000EE0, "Member 'ACue_Ability_Loop_Morph::bUseMTPositionForCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, MorphWeightCurve) == 0x000EE8, "Member 'ACue_Ability_Loop_Morph::MorphWeightCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, HeroShadowParameterNames) == 0x000EF0, "Member 'ACue_Ability_Loop_Morph::HeroShadowParameterNames' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TimerHandle) == 0x000F00, "Member 'ACue_Ability_Loop_Morph::TimerHandle' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, MorphMesh) == 0x000F18, "Member 'ACue_Ability_Loop_Morph::MorphMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, OwnerCharacter) == 0x000F20, "Member 'ACue_Ability_Loop_Morph::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, bMorphSuccess) == 0x000F28, "Member 'ACue_Ability_Loop_Morph::bMorphSuccess' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TimerSpent) == 0x000F2C, "Member 'ACue_Ability_Loop_Morph::TimerSpent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TimerFrequence) == 0x000F30, "Member 'ACue_Ability_Loop_Morph::TimerFrequence' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialBody) == 0x000F38, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialBody' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialHead) == 0x000F40, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialHead' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialBodyElementIndex) == 0x000F48, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialBodyElementIndex' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialHeadElementIndex) == 0x000F4C, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialHeadElementIndex' has a wrong offset!");

// Class Hero_1011.Ability_HulkSculpt
// 0x0000 (0x2838 - 0x2838)
class UAbility_HulkSculpt final : public UAbility_109
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_HulkSculpt">();
	}
	static class UAbility_HulkSculpt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_HulkSculpt>();
	}
};
static_assert(alignof(UAbility_HulkSculpt) == 0x000008, "Wrong alignment on UAbility_HulkSculpt");
static_assert(sizeof(UAbility_HulkSculpt) == 0x002838, "Wrong size on UAbility_HulkSculpt");

// Class Hero_1011.Cue_Weapon_Loop_101111
// 0x0048 (0x10F0 - 0x10A8)
class ACue_Weapon_Loop_101111 final : public AMarvelCueNotify_Weapon_Loop
{
public:
	class UStaticMeshComponent*                   Container;                                         // 0x10A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               Mid;                                               // 0x10B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHulkBannerCharacter*                   BannerChar;                                        // 0x10B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x10C0(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D8[0x18];                                    // 0x10D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeContainerState();
	void OnOwnedTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Weapon_Loop_101111">();
	}
	static class ACue_Weapon_Loop_101111* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Weapon_Loop_101111>();
	}
};
static_assert(alignof(ACue_Weapon_Loop_101111) == 0x000008, "Wrong alignment on ACue_Weapon_Loop_101111");
static_assert(sizeof(ACue_Weapon_Loop_101111) == 0x0010F0, "Wrong size on ACue_Weapon_Loop_101111");
static_assert(offsetof(ACue_Weapon_Loop_101111, Container) == 0x0010A8, "Member 'ACue_Weapon_Loop_101111::Container' has a wrong offset!");
static_assert(offsetof(ACue_Weapon_Loop_101111, Mid) == 0x0010B0, "Member 'ACue_Weapon_Loop_101111::Mid' has a wrong offset!");
static_assert(offsetof(ACue_Weapon_Loop_101111, BannerChar) == 0x0010B8, "Member 'ACue_Weapon_Loop_101111::BannerChar' has a wrong offset!");
static_assert(offsetof(ACue_Weapon_Loop_101111, LoopTimerHandle) == 0x0010C0, "Member 'ACue_Weapon_Loop_101111::LoopTimerHandle' has a wrong offset!");

// Class Hero_1011.Config_101141
// 0x0030 (0x00C8 - 0x0098)
class UConfig_101141 final : public UMarvelAbilityConfig
{
public:
	int32                                         SelfSummonedID;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SelfBuffID;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TeammateSummonedID;                                // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TeammateBuffID;                                    // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101141">();
	}
	static class UConfig_101141* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101141>();
	}
};
static_assert(alignof(UConfig_101141) == 0x000008, "Wrong alignment on UConfig_101141");
static_assert(sizeof(UConfig_101141) == 0x0000C8, "Wrong size on UConfig_101141");
static_assert(offsetof(UConfig_101141, SelfSummonedID) == 0x000098, "Member 'UConfig_101141::SelfSummonedID' has a wrong offset!");
static_assert(offsetof(UConfig_101141, SelfBuffID) == 0x0000A0, "Member 'UConfig_101141::SelfBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101141, TeammateSummonedID) == 0x0000B0, "Member 'UConfig_101141::TeammateSummonedID' has a wrong offset!");
static_assert(offsetof(UConfig_101141, TeammateBuffID) == 0x0000B8, "Member 'UConfig_101141::TeammateBuffID' has a wrong offset!");

// Class Hero_1011.EffectiveComponent_10114101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10114101 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10114101">();
	}
	static class UEffectiveComponent_10114101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10114101>();
	}
};
static_assert(alignof(UEffectiveComponent_10114101) == 0x000010, "Wrong alignment on UEffectiveComponent_10114101");
static_assert(sizeof(UEffectiveComponent_10114101) == 0x001C00, "Wrong size on UEffectiveComponent_10114101");

// Class Hero_1011.Cue_Ability_Instant_10114101
// 0x0008 (0x0370 - 0x0368)
class UCue_Ability_Instant_10114101 final : public UMarvelCueNotify_Base
{
public:
	int32                                         ScopeId;                                           // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FXInitRadius;                                      // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Instant_10114101">();
	}
	static class UCue_Ability_Instant_10114101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Ability_Instant_10114101>();
	}
};
static_assert(alignof(UCue_Ability_Instant_10114101) == 0x000008, "Wrong alignment on UCue_Ability_Instant_10114101");
static_assert(sizeof(UCue_Ability_Instant_10114101) == 0x000370, "Wrong size on UCue_Ability_Instant_10114101");
static_assert(offsetof(UCue_Ability_Instant_10114101, ScopeId) == 0x000368, "Member 'UCue_Ability_Instant_10114101::ScopeId' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10114101, FXInitRadius) == 0x00036C, "Member 'UCue_Ability_Instant_10114101::FXInitRadius' has a wrong offset!");

// Class Hero_1011.Ability_101171
// 0x0008 (0x2588 - 0x2580)
class UAbility_101171 : public UMarvelGameplayAbility
{
public:
	class UMarvelAbilityTask_SelectTarget*        SelectTask;                                        // 0x2580(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector CalcSmashLocation(const class AActor* TargetActor, class AMarvelBaseCharacter* OutHulk);
	class AActor* GetTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101171">();
	}
	static class UAbility_101171* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101171>();
	}
};
static_assert(alignof(UAbility_101171) == 0x000008, "Wrong alignment on UAbility_101171");
static_assert(sizeof(UAbility_101171) == 0x002588, "Wrong size on UAbility_101171");
static_assert(offsetof(UAbility_101171, SelectTask) == 0x002580, "Member 'UAbility_101171::SelectTask' has a wrong offset!");

// Class Hero_1011.Config_101171
// 0x10D8 (0x1170 - 0x0098)
class UConfig_101171 : public UMarvelAbilityConfig
{
public:
	float                                         SmashBeginTime;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SmashEndLocationOffset;                            // 0x00A0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmashLookingPitch;                                 // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmashTargetArmLength;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmashSpringArmSpeed;                               // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmashCameraLagSpeed;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSelectTaskParam                       SelectTaskParam;                                   // 0x00D0(0x10A0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101171">();
	}
	static class UConfig_101171* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101171>();
	}
};
static_assert(alignof(UConfig_101171) == 0x000010, "Wrong alignment on UConfig_101171");
static_assert(sizeof(UConfig_101171) == 0x001170, "Wrong size on UConfig_101171");
static_assert(offsetof(UConfig_101171, SmashBeginTime) == 0x000098, "Member 'UConfig_101171::SmashBeginTime' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SmashEndLocationOffset) == 0x0000A0, "Member 'UConfig_101171::SmashEndLocationOffset' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SmashLookingPitch) == 0x0000B8, "Member 'UConfig_101171::SmashLookingPitch' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SmashTargetArmLength) == 0x0000BC, "Member 'UConfig_101171::SmashTargetArmLength' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SmashSpringArmSpeed) == 0x0000C0, "Member 'UConfig_101171::SmashSpringArmSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SmashCameraLagSpeed) == 0x0000C4, "Member 'UConfig_101171::SmashCameraLagSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SelectTaskParam) == 0x0000D0, "Member 'UConfig_101171::SelectTaskParam' has a wrong offset!");

// Class Hero_1011.Cue_Buff_10117101
// 0x0088 (0x10C0 - 0x1038)
class ACue_Buff_10117101 : public AMarvelCueNotify_Buff
{
public:
	class AActor*                                 OwnerCharacter;                                    // 0x1038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x1040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 OwnerCharacterMesh;                                // 0x1048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SmashMeshTransform;                                // 0x1050(0x0060)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSmashing;                                       // 0x10B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B1[0xF];                                     // 0x10B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnRecycle();
	void LoopCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10117101">();
	}
	static class ACue_Buff_10117101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10117101>();
	}
};
static_assert(alignof(ACue_Buff_10117101) == 0x000010, "Wrong alignment on ACue_Buff_10117101");
static_assert(sizeof(ACue_Buff_10117101) == 0x0010C0, "Wrong size on ACue_Buff_10117101");
static_assert(offsetof(ACue_Buff_10117101, OwnerCharacter) == 0x001038, "Member 'ACue_Buff_10117101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10117101, InstigatorCharacter) == 0x001040, "Member 'ACue_Buff_10117101::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10117101, OwnerCharacterMesh) == 0x001048, "Member 'ACue_Buff_10117101::OwnerCharacterMesh' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10117101, SmashMeshTransform) == 0x001050, "Member 'ACue_Buff_10117101::SmashMeshTransform' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10117101, bIsSmashing) == 0x0010B0, "Member 'ACue_Buff_10117101::bIsSmashing' has a wrong offset!");

// Class Hero_1011.EffectAbility_101171
// 0x0030 (0x1128 - 0x10F8)
class UEffectAbility_101171 : public UMarvelEffectGameplayAbility
{
public:
	int32                                         InstigatorAbilityId;                               // 0x10F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10FC[0x4];                                     // 0x10FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerCharacter;                                    // 0x1100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 OwnerCharacterMesh;                                // 0x1108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x1110(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 InstigatorCharacterMesh;                           // 0x1118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReadyToSmash;                                   // 0x1120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1121[0x7];                                     // 0x1121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectAbility_101171">();
	}
	static class UEffectAbility_101171* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectAbility_101171>();
	}
};
static_assert(alignof(UEffectAbility_101171) == 0x000008, "Wrong alignment on UEffectAbility_101171");
static_assert(sizeof(UEffectAbility_101171) == 0x001128, "Wrong size on UEffectAbility_101171");
static_assert(offsetof(UEffectAbility_101171, InstigatorAbilityId) == 0x0010F8, "Member 'UEffectAbility_101171::InstigatorAbilityId' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101171, OwnerCharacter) == 0x001100, "Member 'UEffectAbility_101171::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101171, OwnerCharacterMesh) == 0x001108, "Member 'UEffectAbility_101171::OwnerCharacterMesh' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101171, InstigatorCharacter) == 0x001110, "Member 'UEffectAbility_101171::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101171, InstigatorCharacterMesh) == 0x001118, "Member 'UEffectAbility_101171::InstigatorCharacterMesh' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101171, bIsReadyToSmash) == 0x001120, "Member 'UEffectAbility_101171::bIsReadyToSmash' has a wrong offset!");

// Class Hero_1011.UIC_SelectTarget_101181
// 0x0000 (0x0158 - 0x0158)
class UUIC_SelectTarget_101181 final : public UUIC_SelectTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIC_SelectTarget_101181">();
	}
	static class UUIC_SelectTarget_101181* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIC_SelectTarget_101181>();
	}
};
static_assert(alignof(UUIC_SelectTarget_101181) == 0x000008, "Wrong alignment on UUIC_SelectTarget_101181");
static_assert(sizeof(UUIC_SelectTarget_101181) == 0x000158, "Wrong size on UUIC_SelectTarget_101181");

// Class Hero_1011.Cue_Projectile_Loop_101182
// 0x0068 (0x0EA8 - 0x0E40)
class ACue_Projectile_Loop_101182 final : public ACue_Physics_Projectile_Loop
{
public:
	TMap<EPhysicsWeaponType, float>               ParticleNumMap;                                    // 0x0E40(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   ParticleNumName;                                   // 0x0E90(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9C[0x4];                                      // 0x0E9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_Trajectory;                                     // 0x0EA0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_101182">();
	}
	static class ACue_Projectile_Loop_101182* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_101182>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_101182) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_101182");
static_assert(sizeof(ACue_Projectile_Loop_101182) == 0x000EA8, "Wrong size on ACue_Projectile_Loop_101182");
static_assert(offsetof(ACue_Projectile_Loop_101182, ParticleNumMap) == 0x000E40, "Member 'ACue_Projectile_Loop_101182::ParticleNumMap' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_101182, ParticleNumName) == 0x000E90, "Member 'ACue_Projectile_Loop_101182::ParticleNumName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_101182, NS_Trajectory) == 0x000EA0, "Member 'ACue_Projectile_Loop_101182::NS_Trajectory' has a wrong offset!");

// Class Hero_1011.Ability_101191
// 0x00B8 (0x2650 - 0x2598)
class UAbility_101191 : public UMarvelAbility_LongPressTrigger
{
public:
	class UHulkBannerMoveLogicBaseComponent*      MoveLogicCom;                                      // 0x2598(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x25A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         LaunchKey;                                         // 0x25A8(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelBaseAbilitySystemComponent*      ASC;                                               // 0x2648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void K2_OnShiftJumpLaunched();
	void LaunchCharacter();
	void OnServerReceiveLaunchVelocity(const struct FGameplayAbilityTargetDataHandle& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101191">();
	}
	static class UAbility_101191* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101191>();
	}
};
static_assert(alignof(UAbility_101191) == 0x000008, "Wrong alignment on UAbility_101191");
static_assert(sizeof(UAbility_101191) == 0x002650, "Wrong size on UAbility_101191");
static_assert(offsetof(UAbility_101191, MoveLogicCom) == 0x002598, "Member 'UAbility_101191::MoveLogicCom' has a wrong offset!");
static_assert(offsetof(UAbility_101191, OwnerCharacter) == 0x0025A0, "Member 'UAbility_101191::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_101191, LaunchKey) == 0x0025A8, "Member 'UAbility_101191::LaunchKey' has a wrong offset!");
static_assert(offsetof(UAbility_101191, ASC) == 0x002648, "Member 'UAbility_101191::ASC' has a wrong offset!");

// Class Hero_1011.Cue_Ability_Loop_10119101
// 0x0068 (0x0EB8 - 0x0E50)
class ACue_Ability_Loop_10119101 : public AMarvelCueNotify_Ability
{
public:
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x0E50(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumpLineVisible;                                // 0x0E68(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCharging;                                       // 0x0E69(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6A[0x6];                                      // 0x0E6A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelGameplayAbility*                 OwnerAbility;                                      // 0x0E70(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHulkBannerCharacter*                   OwnerCharacter;                                    // 0x0E78(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfigPressedSecondsMin;                           // 0x0E80(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E84[0x4];                                      // 0x0E84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULegacyCameraShake>         ConfigJumpLandCameraShakeClass;                    // 0x0E88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         ConfigJumpGrabHitCameraShakeClass;                 // 0x0E90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         ConfigGrabHitParticle;                             // 0x0E98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGrabHitParticleAttach;                          // 0x0EA0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA1[0x3];                                      // 0x0EA1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OwningAbilityID;                                   // 0x0EA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JumpChargeAudioID;                                 // 0x0EA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EAC[0x4];                                      // 0x0EAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_BasisTrack;                                     // 0x0EB0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClearLoopTimer();
	class UMarvelGameplayAbility* GetOwnerAbility();
	class AHulkBannerCharacter* GetOwnerChar();
	void LoopSetJumpParams();
	void SetAudio(bool bReset);
	void SetJumpLineVisible(bool bIsVisible);
	void SetLoopTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10119101">();
	}
	static class ACue_Ability_Loop_10119101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10119101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10119101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10119101");
static_assert(sizeof(ACue_Ability_Loop_10119101) == 0x000EB8, "Wrong size on ACue_Ability_Loop_10119101");
static_assert(offsetof(ACue_Ability_Loop_10119101, LoopTimerHandle) == 0x000E50, "Member 'ACue_Ability_Loop_10119101::LoopTimerHandle' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, bIsJumpLineVisible) == 0x000E68, "Member 'ACue_Ability_Loop_10119101::bIsJumpLineVisible' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, bIsCharging) == 0x000E69, "Member 'ACue_Ability_Loop_10119101::bIsCharging' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, OwnerAbility) == 0x000E70, "Member 'ACue_Ability_Loop_10119101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, OwnerCharacter) == 0x000E78, "Member 'ACue_Ability_Loop_10119101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, ConfigPressedSecondsMin) == 0x000E80, "Member 'ACue_Ability_Loop_10119101::ConfigPressedSecondsMin' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, ConfigJumpLandCameraShakeClass) == 0x000E88, "Member 'ACue_Ability_Loop_10119101::ConfigJumpLandCameraShakeClass' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, ConfigJumpGrabHitCameraShakeClass) == 0x000E90, "Member 'ACue_Ability_Loop_10119101::ConfigJumpGrabHitCameraShakeClass' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, ConfigGrabHitParticle) == 0x000E98, "Member 'ACue_Ability_Loop_10119101::ConfigGrabHitParticle' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, bIsGrabHitParticleAttach) == 0x000EA0, "Member 'ACue_Ability_Loop_10119101::bIsGrabHitParticleAttach' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, OwningAbilityID) == 0x000EA4, "Member 'ACue_Ability_Loop_10119101::OwningAbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, JumpChargeAudioID) == 0x000EA8, "Member 'ACue_Ability_Loop_10119101::JumpChargeAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, NS_BasisTrack) == 0x000EB0, "Member 'ACue_Ability_Loop_10119101::NS_BasisTrack' has a wrong offset!");

// Class Hero_1011.UIController_101191
// 0x0120 (0x0D80 - 0x0C60)
class UUIController_101191 : public UUIC_Ability
{
public:
	struct FTimerHandle                           LoopSetChargePerTimerHandle;                       // 0x0C60(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCueHintData                           HintData;                                          // 0x0C78(0x0098)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UWidget_AbilityEnergy*                  WidgetAbilityEnergyRight;                          // 0x0D10(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHulkBannerCharacter*                   HulkBannerChar;                                    // 0x0D18(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHulkBannerMoveLogicBaseComponent*      MoveLogic;                                         // 0x0D20(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinChargeHulk;                                     // 0x0D28(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxChargeHulk;                                     // 0x0D2C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinChargeMonster;                                  // 0x0D30(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxChargeMonster;                                  // 0x0D34(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelGameplayAbility*                 Ability101191;                                     // 0x0D38(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelGameplayAbility*                 Ability101193;                                     // 0x0D40(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCharge;                                         // 0x0D48(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClimbing;                                       // 0x0D49(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHanging;                                        // 0x0D4A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasShowHint;                                      // 0x0D4B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInitHulkParam;                                 // 0x0D4C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInitMonsterParam;                              // 0x0D4D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4E[0x2];                                      // 0x0D4E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelUserWidget*                      WidgetTipLeft;                                     // 0x0D50(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelUserWidget*                      WidgetTipRight;                                    // 0x0D58(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget_AbilityStatusPanel*             AbilityPanel;                                      // 0x0D60(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           LoopCheckTipsAndHintTimerHandle;                   // 0x0D68(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CanGetAbility();
	void Clear101191LoopTimer();
	void Clear101192LoopTimer();
	bool IsAbilityCharging();
	void LoopSetChargePer();
	bool PyInitChargeParam(bool bIsHulk);
	void Set101191LoopTimer();
	void Set101192LoopTimer();
	bool TryInitChargeParam(bool bIsHulk);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIController_101191">();
	}
	static class UUIController_101191* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIController_101191>();
	}
};
static_assert(alignof(UUIController_101191) == 0x000008, "Wrong alignment on UUIController_101191");
static_assert(sizeof(UUIController_101191) == 0x000D80, "Wrong size on UUIController_101191");
static_assert(offsetof(UUIController_101191, LoopSetChargePerTimerHandle) == 0x000C60, "Member 'UUIController_101191::LoopSetChargePerTimerHandle' has a wrong offset!");
static_assert(offsetof(UUIController_101191, HintData) == 0x000C78, "Member 'UUIController_101191::HintData' has a wrong offset!");
static_assert(offsetof(UUIController_101191, WidgetAbilityEnergyRight) == 0x000D10, "Member 'UUIController_101191::WidgetAbilityEnergyRight' has a wrong offset!");
static_assert(offsetof(UUIController_101191, HulkBannerChar) == 0x000D18, "Member 'UUIController_101191::HulkBannerChar' has a wrong offset!");
static_assert(offsetof(UUIController_101191, MoveLogic) == 0x000D20, "Member 'UUIController_101191::MoveLogic' has a wrong offset!");
static_assert(offsetof(UUIController_101191, MinChargeHulk) == 0x000D28, "Member 'UUIController_101191::MinChargeHulk' has a wrong offset!");
static_assert(offsetof(UUIController_101191, MaxChargeHulk) == 0x000D2C, "Member 'UUIController_101191::MaxChargeHulk' has a wrong offset!");
static_assert(offsetof(UUIController_101191, MinChargeMonster) == 0x000D30, "Member 'UUIController_101191::MinChargeMonster' has a wrong offset!");
static_assert(offsetof(UUIController_101191, MaxChargeMonster) == 0x000D34, "Member 'UUIController_101191::MaxChargeMonster' has a wrong offset!");
static_assert(offsetof(UUIController_101191, Ability101191) == 0x000D38, "Member 'UUIController_101191::Ability101191' has a wrong offset!");
static_assert(offsetof(UUIController_101191, Ability101193) == 0x000D40, "Member 'UUIController_101191::Ability101193' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bIsCharge) == 0x000D48, "Member 'UUIController_101191::bIsCharge' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bIsClimbing) == 0x000D49, "Member 'UUIController_101191::bIsClimbing' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bIsHanging) == 0x000D4A, "Member 'UUIController_101191::bIsHanging' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bHasShowHint) == 0x000D4B, "Member 'UUIController_101191::bHasShowHint' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bHasInitHulkParam) == 0x000D4C, "Member 'UUIController_101191::bHasInitHulkParam' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bHasInitMonsterParam) == 0x000D4D, "Member 'UUIController_101191::bHasInitMonsterParam' has a wrong offset!");
static_assert(offsetof(UUIController_101191, WidgetTipLeft) == 0x000D50, "Member 'UUIController_101191::WidgetTipLeft' has a wrong offset!");
static_assert(offsetof(UUIController_101191, WidgetTipRight) == 0x000D58, "Member 'UUIController_101191::WidgetTipRight' has a wrong offset!");
static_assert(offsetof(UUIController_101191, AbilityPanel) == 0x000D60, "Member 'UUIController_101191::AbilityPanel' has a wrong offset!");
static_assert(offsetof(UUIController_101191, LoopCheckTipsAndHintTimerHandle) == 0x000D68, "Member 'UUIController_101191::LoopCheckTipsAndHintTimerHandle' has a wrong offset!");

// Class Hero_1011.Cue_Ability_Loop_10119103
// 0x0088 (0x0ED8 - 0x0E50)
class ACue_Ability_Loop_10119103 : public AMarvelCueNotify_Ability
{
public:
	bool                                          IsAuxiliaryLineOn;                                 // 0x0E50(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E51[0x3];                                      // 0x0E51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PressedTimeInterpAlpha;                            // 0x0E54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSegmentLength;                                 // 0x0E58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpSeconds;                                    // 0x0E5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpHeightDown;                                 // 0x0E60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumOfSplineMeshUsed;                            // 0x0E64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            TailStaticMesh;                                    // 0x0E68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BodyStaticMesh;                                    // 0x0E70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            HeadStaticMesh;                                    // 0x0E78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartFromCapsuleBottom;                           // 0x0E80(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E81[0x3];                                      // 0x0E81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x0E84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Gathering;                                      // 0x0E88(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelSplineComponent*                 SplineComponent;                                   // 0x0E90(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           SplineMeshCollection;                              // 0x0E98(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAbility_101191*                        OwnerAbility;                                      // 0x0EA8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHulkBannerCharacter*                   OwnerCharacter;                                    // 0x0EB0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHulkBannerMoveLogicBaseComponent*      MoveLogicComponent;                                // 0x0EB8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedCurve;                                        // 0x0EC0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressedSecondsMin;                                 // 0x0EC8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ECC[0xC];                                      // 0x0ECC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPressRelease(float TimeWaited);
	void OnPressTimeMin(float TimeWaited);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10119103">();
	}
	static class ACue_Ability_Loop_10119103* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10119103>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10119103) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10119103");
static_assert(sizeof(ACue_Ability_Loop_10119103) == 0x000ED8, "Wrong size on ACue_Ability_Loop_10119103");
static_assert(offsetof(ACue_Ability_Loop_10119103, IsAuxiliaryLineOn) == 0x000E50, "Member 'ACue_Ability_Loop_10119103::IsAuxiliaryLineOn' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, PressedTimeInterpAlpha) == 0x000E54, "Member 'ACue_Ability_Loop_10119103::PressedTimeInterpAlpha' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, LastSegmentLength) == 0x000E58, "Member 'ACue_Ability_Loop_10119103::LastSegmentLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, MaxJumpSeconds) == 0x000E5C, "Member 'ACue_Ability_Loop_10119103::MaxJumpSeconds' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, MaxJumpHeightDown) == 0x000E60, "Member 'ACue_Ability_Loop_10119103::MaxJumpHeightDown' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, MaxNumOfSplineMeshUsed) == 0x000E64, "Member 'ACue_Ability_Loop_10119103::MaxNumOfSplineMeshUsed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, TailStaticMesh) == 0x000E68, "Member 'ACue_Ability_Loop_10119103::TailStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, BodyStaticMesh) == 0x000E70, "Member 'ACue_Ability_Loop_10119103::BodyStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, HeadStaticMesh) == 0x000E78, "Member 'ACue_Ability_Loop_10119103::HeadStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, bStartFromCapsuleBottom) == 0x000E80, "Member 'ACue_Ability_Loop_10119103::bStartFromCapsuleBottom' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, AbilityID) == 0x000E84, "Member 'ACue_Ability_Loop_10119103::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, NS_Gathering) == 0x000E88, "Member 'ACue_Ability_Loop_10119103::NS_Gathering' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, SplineComponent) == 0x000E90, "Member 'ACue_Ability_Loop_10119103::SplineComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, SplineMeshCollection) == 0x000E98, "Member 'ACue_Ability_Loop_10119103::SplineMeshCollection' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, OwnerAbility) == 0x000EA8, "Member 'ACue_Ability_Loop_10119103::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, OwnerCharacter) == 0x000EB0, "Member 'ACue_Ability_Loop_10119103::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, MoveLogicComponent) == 0x000EB8, "Member 'ACue_Ability_Loop_10119103::MoveLogicComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, SpeedCurve) == 0x000EC0, "Member 'ACue_Ability_Loop_10119103::SpeedCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, PressedSecondsMin) == 0x000EC8, "Member 'ACue_Ability_Loop_10119103::PressedSecondsMin' has a wrong offset!");

// Class Hero_1011.MovableSplineMeshComponent
// 0x0000 (0x0A30 - 0x0A30)
class UMovableSplineMeshComponent final : public USplineMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovableSplineMeshComponent">();
	}
	static class UMovableSplineMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovableSplineMeshComponent>();
	}
};
static_assert(alignof(UMovableSplineMeshComponent) == 0x000010, "Wrong alignment on UMovableSplineMeshComponent");
static_assert(sizeof(UMovableSplineMeshComponent) == 0x000A30, "Wrong size on UMovableSplineMeshComponent");

// Class Hero_1011.ConfigHulkClimb
// 0x0018 (0x00B0 - 0x0098)
class UConfigHulkClimb final : public UMarvelAbilityConfig
{
public:
	struct FHulkClimbParam                        ClimbParam;                                        // 0x0098(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ServerWaitCollisionTime;                           // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfigHulkClimb">();
	}
	static class UConfigHulkClimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfigHulkClimb>();
	}
};
static_assert(alignof(UConfigHulkClimb) == 0x000008, "Wrong alignment on UConfigHulkClimb");
static_assert(sizeof(UConfigHulkClimb) == 0x0000B0, "Wrong size on UConfigHulkClimb");
static_assert(offsetof(UConfigHulkClimb, ClimbParam) == 0x000098, "Member 'UConfigHulkClimb::ClimbParam' has a wrong offset!");
static_assert(offsetof(UConfigHulkClimb, ServerWaitCollisionTime) == 0x0000A8, "Member 'UConfigHulkClimb::ServerWaitCollisionTime' has a wrong offset!");

// Class Hero_1011.Ability_101192
// 0x0120 (0x26A0 - 0x2580)
class UAbility_101192 : public UMarvelGameplayAbility
{
public:
	class UHulkBannerMoveLogicBaseComponent*      MoveLogicCom;                                      // 0x2580(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x2588(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfigHulkClimb*                       ClimbConfig;                                       // 0x2590(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClimbLocation;                                     // 0x2598(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  ClimbOrient;                                       // 0x25B0(0x0020)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D0[0x8];                                     // 0x25D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           WaitTimeOutTimer;                                  // 0x25D8(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         LeaveClimbKey;                                     // 0x25F0(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedCheckKey;                                     // 0x2690(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClimbKeyDown;                                     // 0x2691(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2692[0xE];                                     // 0x2692(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanActivateClimb();
	class UConfigHulkClimb* GetClimbConfig();
	class UHulkBannerMoveLogicBaseComponent* GetMoveComponent();
	class AMarvelBaseCharacter* GetOwnerChar();
	void OnClimbKeyPress(float Time);
	void OnClimbKeyRelease(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101192">();
	}
	static class UAbility_101192* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101192>();
	}
};
static_assert(alignof(UAbility_101192) == 0x000010, "Wrong alignment on UAbility_101192");
static_assert(sizeof(UAbility_101192) == 0x0026A0, "Wrong size on UAbility_101192");
static_assert(offsetof(UAbility_101192, MoveLogicCom) == 0x002580, "Member 'UAbility_101192::MoveLogicCom' has a wrong offset!");
static_assert(offsetof(UAbility_101192, OwnerCharacter) == 0x002588, "Member 'UAbility_101192::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_101192, ClimbConfig) == 0x002590, "Member 'UAbility_101192::ClimbConfig' has a wrong offset!");
static_assert(offsetof(UAbility_101192, ClimbLocation) == 0x002598, "Member 'UAbility_101192::ClimbLocation' has a wrong offset!");
static_assert(offsetof(UAbility_101192, ClimbOrient) == 0x0025B0, "Member 'UAbility_101192::ClimbOrient' has a wrong offset!");
static_assert(offsetof(UAbility_101192, WaitTimeOutTimer) == 0x0025D8, "Member 'UAbility_101192::WaitTimeOutTimer' has a wrong offset!");
static_assert(offsetof(UAbility_101192, LeaveClimbKey) == 0x0025F0, "Member 'UAbility_101192::LeaveClimbKey' has a wrong offset!");
static_assert(offsetof(UAbility_101192, bNeedCheckKey) == 0x002690, "Member 'UAbility_101192::bNeedCheckKey' has a wrong offset!");
static_assert(offsetof(UAbility_101192, bClimbKeyDown) == 0x002691, "Member 'UAbility_101192::bClimbKeyDown' has a wrong offset!");

// Class Hero_1011.Ability_101198
// 0x0018 (0x25F8 - 0x25E0)
class UAbility_101198 : public UAbility_100016
{
public:
	EAbilityState_101198                          CurrentAbilityState;                               // 0x25E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityState_101198                          LastAbilityState;                                  // 0x25E1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E2[0x6];                                     // 0x25E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x25E8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                                      // 0x25F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SwitchTimelineTask(const class FName& SectionName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101198">();
	}
	static class UAbility_101198* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101198>();
	}
};
static_assert(alignof(UAbility_101198) == 0x000008, "Wrong alignment on UAbility_101198");
static_assert(sizeof(UAbility_101198) == 0x0025F8, "Wrong size on UAbility_101198");
static_assert(offsetof(UAbility_101198, CurrentAbilityState) == 0x0025E0, "Member 'UAbility_101198::CurrentAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_101198, LastAbilityState) == 0x0025E1, "Member 'UAbility_101198::LastAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_101198, OwnerChar) == 0x0025E8, "Member 'UAbility_101198::OwnerChar' has a wrong offset!");
static_assert(offsetof(UAbility_101198, TimelineTask) == 0x0025F0, "Member 'UAbility_101198::TimelineTask' has a wrong offset!");

// Class Hero_1011.EpicMomentAction_1011
// 0x0088 (0x01A8 - 0x0120)
class UEpicMomentAction_1011 : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0xC];                                      // 0x0120(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    GrabConfig;                                        // 0x012C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    GrabKillConfig;                                    // 0x0138(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    GammaShieldConfig;                                 // 0x0144(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    RadiationCageConfig;                               // 0x0150(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GrabKillInterval;                                  // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 GrabBuffIDs;                                       // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         GammaShieldBlockDamageThreshold;                   // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 GammaShieldIDs;                                    // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 RadiationCageInterruptAbilities;                   // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 RadiationCageBuffIDs;                              // 0x0198(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void OnActorAbilityCancel(class AActor* Source, int32 AbilityID, const class FString& SessionID, class UMarvelGameplayAbility* SourceAbility);
	void OnActorTakeDamage(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnEffectImmunityOrInhibitedCallback(class AActor* Source, const struct FGameplayEffectSpec& BlockedSpec);
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1011">();
	}
	static class UEpicMomentAction_1011* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1011>();
	}
};
static_assert(alignof(UEpicMomentAction_1011) == 0x000008, "Wrong alignment on UEpicMomentAction_1011");
static_assert(sizeof(UEpicMomentAction_1011) == 0x0001A8, "Wrong size on UEpicMomentAction_1011");
static_assert(offsetof(UEpicMomentAction_1011, GrabConfig) == 0x00012C, "Member 'UEpicMomentAction_1011::GrabConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GrabKillConfig) == 0x000138, "Member 'UEpicMomentAction_1011::GrabKillConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GammaShieldConfig) == 0x000144, "Member 'UEpicMomentAction_1011::GammaShieldConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, RadiationCageConfig) == 0x000150, "Member 'UEpicMomentAction_1011::RadiationCageConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GrabKillInterval) == 0x00015C, "Member 'UEpicMomentAction_1011::GrabKillInterval' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GrabBuffIDs) == 0x000160, "Member 'UEpicMomentAction_1011::GrabBuffIDs' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GammaShieldBlockDamageThreshold) == 0x000170, "Member 'UEpicMomentAction_1011::GammaShieldBlockDamageThreshold' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GammaShieldIDs) == 0x000178, "Member 'UEpicMomentAction_1011::GammaShieldIDs' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, RadiationCageInterruptAbilities) == 0x000188, "Member 'UEpicMomentAction_1011::RadiationCageInterruptAbilities' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, RadiationCageBuffIDs) == 0x000198, "Member 'UEpicMomentAction_1011::RadiationCageBuffIDs' has a wrong offset!");

// Class Hero_1011.HulkAnimInstance
// 0x0130 (0x0A40 - 0x0910)
class UHulkAnimInstance : public UMarvelAnimInstance
{
public:
	struct FGameplayTag                           SynergyRideTag;                                    // 0x0910(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SynergyRideGatheringTag;                           // 0x091C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VJumpLandAnimStartHeight;                          // 0x0928(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbilityYawInterpSpeed;                             // 0x092C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedToClipLowerBodyYaw;                           // 0x0930(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_931[0x3];                                      // 0x0931(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LandMovementToGround;                              // 0x0934(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VIsClimbing;                                       // 0x0938(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VShiftJumpfromWall;                                // 0x0939(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_93A[0x2];                                      // 0x093A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VClimbDirection;                                   // 0x093C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RootYawForTransition;                              // 0x0940(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VIsInShiftJump;                                    // 0x0944(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VIsInShiftJumpLand;                                // 0x0945(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_946[0x2];                                      // 0x0946(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShiftJumpDirection;                                // 0x0948(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInSynergyRideState;                               // 0x094C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94D[0x1];                                      // 0x094D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInSynergyRideStateBlend;                          // 0x094E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInSynergyRideStartBlend;                          // 0x094F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSynergyRideState_Enter;                           // 0x0950(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSynergyRideState_Exit;                            // 0x0951(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInSynergyRideState_Gathering;                     // 0x0952(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SynergyRideState_BeRide;                           // 0x0953(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFullSpace_ShiftJumps_To_Ground;                   // 0x0954(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFullSpace_ShiftJumps_To_LandRecovery;             // 0x0955(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFullSpace_LandRecovery_To_Ground;                 // 0x0956(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShiftJumps_Start_To_Other;                        // 0x0957(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_Center_To_ToLeft;                           // 0x0958(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_CenterToLeft_To_LeftIdle;                   // 0x0959(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_CenterToLeft_To_Center;                     // 0x095A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_LeftIdle_To_ReverseToLeft;                  // 0x095B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_LeftIdle_To_LeftToCenter;                   // 0x095C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_LeftToCenter_To_Center;                     // 0x095D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_Center_To_ToRight;                          // 0x095E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_RightIdle_To_RightToCenter;                 // 0x095F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_RightIdle_To_ReverseToRight;                // 0x0960(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_LeftToRightConduit_To_Center;               // 0x0961(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_LeftToRightConduit_To_RightIdle;            // 0x0962(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseAO;                                      // 0x0963(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_964[0x4];                                      // 0x0964(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SynergyRideStartBlendDistanceRange;                // 0x0968(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_978[0x90];                                     // 0x0978(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UHulkBannerMoveLogicBaseComponent*      HulkMoveLogicBaseComponent;                        // 0x0A08(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A10[0x18];                                     // 0x0A10(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_101198*                        Ability_101198;                                    // 0x0A28(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A30[0x10];                                     // 0x0A30(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterFury(bool bOp);
	void FClipLowerBodyYawByDirection();
	void FShiftSecondJump();
	void GetSynergyRideAnimation(const struct FAnimUpdateContext& PoseContext);
	void GetSynergyRideStartAnimation(const struct FAnimUpdateContext& PoseContext);
	void OnTagUpdated(const struct FGameplayTag& TagUpdated, bool TagExists);
	void UpdateSynergyRideStartNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkAnimInstance">();
	}
	static class UHulkAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkAnimInstance>();
	}
};
static_assert(alignof(UHulkAnimInstance) == 0x000010, "Wrong alignment on UHulkAnimInstance");
static_assert(sizeof(UHulkAnimInstance) == 0x000A40, "Wrong size on UHulkAnimInstance");
static_assert(offsetof(UHulkAnimInstance, SynergyRideTag) == 0x000910, "Member 'UHulkAnimInstance::SynergyRideTag' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, SynergyRideGatheringTag) == 0x00091C, "Member 'UHulkAnimInstance::SynergyRideGatheringTag' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VJumpLandAnimStartHeight) == 0x000928, "Member 'UHulkAnimInstance::VJumpLandAnimStartHeight' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, AbilityYawInterpSpeed) == 0x00092C, "Member 'UHulkAnimInstance::AbilityYawInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bNeedToClipLowerBodyYaw) == 0x000930, "Member 'UHulkAnimInstance::bNeedToClipLowerBodyYaw' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, LandMovementToGround) == 0x000934, "Member 'UHulkAnimInstance::LandMovementToGround' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VIsClimbing) == 0x000938, "Member 'UHulkAnimInstance::VIsClimbing' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VShiftJumpfromWall) == 0x000939, "Member 'UHulkAnimInstance::VShiftJumpfromWall' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VClimbDirection) == 0x00093C, "Member 'UHulkAnimInstance::VClimbDirection' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, RootYawForTransition) == 0x000940, "Member 'UHulkAnimInstance::RootYawForTransition' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VIsInShiftJump) == 0x000944, "Member 'UHulkAnimInstance::VIsInShiftJump' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VIsInShiftJumpLand) == 0x000945, "Member 'UHulkAnimInstance::VIsInShiftJumpLand' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, ShiftJumpDirection) == 0x000948, "Member 'UHulkAnimInstance::ShiftJumpDirection' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bInSynergyRideState) == 0x00094C, "Member 'UHulkAnimInstance::bInSynergyRideState' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bInSynergyRideStateBlend) == 0x00094E, "Member 'UHulkAnimInstance::bInSynergyRideStateBlend' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bInSynergyRideStartBlend) == 0x00094F, "Member 'UHulkAnimInstance::bInSynergyRideStartBlend' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bSynergyRideState_Enter) == 0x000950, "Member 'UHulkAnimInstance::bSynergyRideState_Enter' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bSynergyRideState_Exit) == 0x000951, "Member 'UHulkAnimInstance::bSynergyRideState_Exit' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bInSynergyRideState_Gathering) == 0x000952, "Member 'UHulkAnimInstance::bInSynergyRideState_Gathering' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, SynergyRideState_BeRide) == 0x000953, "Member 'UHulkAnimInstance::SynergyRideState_BeRide' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bFullSpace_ShiftJumps_To_Ground) == 0x000954, "Member 'UHulkAnimInstance::bFullSpace_ShiftJumps_To_Ground' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bFullSpace_ShiftJumps_To_LandRecovery) == 0x000955, "Member 'UHulkAnimInstance::bFullSpace_ShiftJumps_To_LandRecovery' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bFullSpace_LandRecovery_To_Ground) == 0x000956, "Member 'UHulkAnimInstance::bFullSpace_LandRecovery_To_Ground' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bShiftJumps_Start_To_Other) == 0x000957, "Member 'UHulkAnimInstance::bShiftJumps_Start_To_Other' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_Center_To_ToLeft) == 0x000958, "Member 'UHulkAnimInstance::bClimb_Center_To_ToLeft' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_CenterToLeft_To_LeftIdle) == 0x000959, "Member 'UHulkAnimInstance::bClimb_CenterToLeft_To_LeftIdle' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_CenterToLeft_To_Center) == 0x00095A, "Member 'UHulkAnimInstance::bClimb_CenterToLeft_To_Center' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_LeftIdle_To_ReverseToLeft) == 0x00095B, "Member 'UHulkAnimInstance::bClimb_LeftIdle_To_ReverseToLeft' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_LeftIdle_To_LeftToCenter) == 0x00095C, "Member 'UHulkAnimInstance::bClimb_LeftIdle_To_LeftToCenter' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_LeftToCenter_To_Center) == 0x00095D, "Member 'UHulkAnimInstance::bClimb_LeftToCenter_To_Center' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_Center_To_ToRight) == 0x00095E, "Member 'UHulkAnimInstance::bClimb_Center_To_ToRight' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_RightIdle_To_RightToCenter) == 0x00095F, "Member 'UHulkAnimInstance::bClimb_RightIdle_To_RightToCenter' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_RightIdle_To_ReverseToRight) == 0x000960, "Member 'UHulkAnimInstance::bClimb_RightIdle_To_ReverseToRight' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_LeftToRightConduit_To_Center) == 0x000961, "Member 'UHulkAnimInstance::bClimb_LeftToRightConduit_To_Center' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_LeftToRightConduit_To_RightIdle) == 0x000962, "Member 'UHulkAnimInstance::bClimb_LeftToRightConduit_To_RightIdle' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bShouldUseAO) == 0x000963, "Member 'UHulkAnimInstance::bShouldUseAO' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, SynergyRideStartBlendDistanceRange) == 0x000968, "Member 'UHulkAnimInstance::SynergyRideStartBlendDistanceRange' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, HulkMoveLogicBaseComponent) == 0x000A08, "Member 'UHulkAnimInstance::HulkMoveLogicBaseComponent' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, Ability_101198) == 0x000A28, "Member 'UHulkAnimInstance::Ability_101198' has a wrong offset!");

// Class Hero_1011.HulkAnimInstance_101197
// 0x0020 (0x0450 - 0x0430)
class UHulkAnimInstance_101197 final : public UAnimInstance
{
public:
	uint8                                         Pad_428[0x18];                                     // 0x0428(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsAccelerating;                                    // 0x0440(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState;                               // 0x0441(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState_Gathering;                     // 0x0442(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState_Turning;                       // 0x0443(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState_Gathering_Turning;             // 0x0444(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForward;                                        // 0x0445(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_446[0x2];                                      // 0x0446(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Velocity;                                          // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReleantSynergyRideNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkAnimInstance_101197">();
	}
	static class UHulkAnimInstance_101197* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkAnimInstance_101197>();
	}
};
static_assert(alignof(UHulkAnimInstance_101197) == 0x000010, "Wrong alignment on UHulkAnimInstance_101197");
static_assert(sizeof(UHulkAnimInstance_101197) == 0x000450, "Wrong size on UHulkAnimInstance_101197");
static_assert(offsetof(UHulkAnimInstance_101197, IsAccelerating) == 0x000440, "Member 'UHulkAnimInstance_101197::IsAccelerating' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, bInSynergyRideState) == 0x000441, "Member 'UHulkAnimInstance_101197::bInSynergyRideState' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, bInSynergyRideState_Gathering) == 0x000442, "Member 'UHulkAnimInstance_101197::bInSynergyRideState_Gathering' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, bInSynergyRideState_Turning) == 0x000443, "Member 'UHulkAnimInstance_101197::bInSynergyRideState_Turning' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, bInSynergyRideState_Gathering_Turning) == 0x000444, "Member 'UHulkAnimInstance_101197::bInSynergyRideState_Gathering_Turning' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, bIsForward) == 0x000445, "Member 'UHulkAnimInstance_101197::bIsForward' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, Velocity) == 0x000448, "Member 'UHulkAnimInstance_101197::Velocity' has a wrong offset!");

// Class Hero_1011.HulkBannerAnimInstance
// 0x0010 (0x0920 - 0x0910)
class UHulkBannerAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsBattlingOrUsingWeapon;                          // 0x0910(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_911[0xF];                                      // 0x0911(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetermineGroundMotionAnim_Implementation(int32* AnimIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkBannerAnimInstance">();
	}
	static class UHulkBannerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkBannerAnimInstance>();
	}
};
static_assert(alignof(UHulkBannerAnimInstance) == 0x000010, "Wrong alignment on UHulkBannerAnimInstance");
static_assert(sizeof(UHulkBannerAnimInstance) == 0x000920, "Wrong size on UHulkBannerAnimInstance");
static_assert(offsetof(UHulkBannerAnimInstance, bIsBattlingOrUsingWeapon) == 0x000910, "Member 'UHulkBannerAnimInstance::bIsBattlingOrUsingWeapon' has a wrong offset!");

// Class Hero_1011.Projectile_101121_AnimInstance
// 0x0010 (0x0920 - 0x0910)
class UProjectile_101121_AnimInstance final : public UMarvelAnimInstance
{
public:
	float                                         CurrentTime;                                       // 0x0910(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendValue;                                        // 0x0914(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BlendAlphaCurve;                                   // 0x0918(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_101121_AnimInstance">();
	}
	static class UProjectile_101121_AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectile_101121_AnimInstance>();
	}
};
static_assert(alignof(UProjectile_101121_AnimInstance) == 0x000010, "Wrong alignment on UProjectile_101121_AnimInstance");
static_assert(sizeof(UProjectile_101121_AnimInstance) == 0x000920, "Wrong size on UProjectile_101121_AnimInstance");
static_assert(offsetof(UProjectile_101121_AnimInstance, CurrentTime) == 0x000910, "Member 'UProjectile_101121_AnimInstance::CurrentTime' has a wrong offset!");
static_assert(offsetof(UProjectile_101121_AnimInstance, BlendValue) == 0x000914, "Member 'UProjectile_101121_AnimInstance::BlendValue' has a wrong offset!");
static_assert(offsetof(UProjectile_101121_AnimInstance, BlendAlphaCurve) == 0x000918, "Member 'UProjectile_101121_AnimInstance::BlendAlphaCurve' has a wrong offset!");

// Class Hero_1011.HulkBannerCharacter
// 0x00B0 (0x18C0 - 0x1810)
class AHulkBannerCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bNeedResetRoolbackInfo;                            // 0x1810(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1811[0x7];                                     // 0x1811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRecoverBuffApplyFailedDelegate;                  // 0x1818(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BannaerTag;                                        // 0x1828(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           HeroHulkTag;                                       // 0x1834(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MonsterHulkTag;                                    // 0x1840(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MorphTag;                                          // 0x184C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HeroToBannerID;                                    // 0x1858(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MonsterToHeroID;                                   // 0x185C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MonsterToBannerID;                                 // 0x1860(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BannerSculptAbility;                               // 0x1864(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerStartSmashTime;                              // 0x1868(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviousSculptID;                                  // 0x186C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRecoverBuffApplyFailed;                         // 0x1870(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1871[0x3];                                     // 0x1871(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnergyRegenStartTime;                              // 0x1874(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1878[0x8];                                     // 0x1878(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHulkBannerMoveLogicBaseComponent*      HulkBannerMoveLogic;                               // 0x1880(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelMultiCapsuleComponent*           SynergyExtraCapsuleComponent;                      // 0x1888(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SynergyRideTag;                                    // 0x1890(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_189C[0x4];                                     // 0x189C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SynergyExtraCapsuleRelativeLocation;               // 0x18A0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18B8[0x8];                                     // 0x18B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetServerStartSmashTime();
	bool IsRecoverBuffApplyFailed();
	bool IsShiftJump();
	void K2_CacheEnergyData();
	void OnRep_IsRecoverBuffApplyFailed();
	void OnSculptChanged(const int32 SculptID);
	void OnSingleAbilityInitialized(int32 AbilityID);
	void RecoverEnergyFromPreviousDeath();
	void RecoverHealthFromMonster(float InHealth);
	void SetEnergyWhenSpawn();
	void SetHeroHulkCachedEnergy(float InValue);
	void SetIsRecoverBuffApplyFailed(bool InFailed);
	void SetServerStartSmashTime(float InTime);
	void SetSynergyExtraCapsuleComponentEnabled(bool bEnabled);
	void TryCancelAbility(const TArray<int32>& AbilityIDs);
	void TryToClimbWhenHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

	float GetHeroHulkCachedEnergy() const;
	bool IsBanner() const;
	bool IsHeroHulk() const;
	bool IsMonsterHulk() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkBannerCharacter">();
	}
	static class AHulkBannerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHulkBannerCharacter>();
	}
};
static_assert(alignof(AHulkBannerCharacter) == 0x000010, "Wrong alignment on AHulkBannerCharacter");
static_assert(sizeof(AHulkBannerCharacter) == 0x0018C0, "Wrong size on AHulkBannerCharacter");
static_assert(offsetof(AHulkBannerCharacter, bNeedResetRoolbackInfo) == 0x001810, "Member 'AHulkBannerCharacter::bNeedResetRoolbackInfo' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, OnRecoverBuffApplyFailedDelegate) == 0x001818, "Member 'AHulkBannerCharacter::OnRecoverBuffApplyFailedDelegate' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, BannaerTag) == 0x001828, "Member 'AHulkBannerCharacter::BannaerTag' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, HeroHulkTag) == 0x001834, "Member 'AHulkBannerCharacter::HeroHulkTag' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, MonsterHulkTag) == 0x001840, "Member 'AHulkBannerCharacter::MonsterHulkTag' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, MorphTag) == 0x00184C, "Member 'AHulkBannerCharacter::MorphTag' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, HeroToBannerID) == 0x001858, "Member 'AHulkBannerCharacter::HeroToBannerID' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, MonsterToHeroID) == 0x00185C, "Member 'AHulkBannerCharacter::MonsterToHeroID' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, MonsterToBannerID) == 0x001860, "Member 'AHulkBannerCharacter::MonsterToBannerID' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, BannerSculptAbility) == 0x001864, "Member 'AHulkBannerCharacter::BannerSculptAbility' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, ServerStartSmashTime) == 0x001868, "Member 'AHulkBannerCharacter::ServerStartSmashTime' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, PreviousSculptID) == 0x00186C, "Member 'AHulkBannerCharacter::PreviousSculptID' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, bIsRecoverBuffApplyFailed) == 0x001870, "Member 'AHulkBannerCharacter::bIsRecoverBuffApplyFailed' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, EnergyRegenStartTime) == 0x001874, "Member 'AHulkBannerCharacter::EnergyRegenStartTime' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, HulkBannerMoveLogic) == 0x001880, "Member 'AHulkBannerCharacter::HulkBannerMoveLogic' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, SynergyExtraCapsuleComponent) == 0x001888, "Member 'AHulkBannerCharacter::SynergyExtraCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, SynergyRideTag) == 0x001890, "Member 'AHulkBannerCharacter::SynergyRideTag' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, SynergyExtraCapsuleRelativeLocation) == 0x0018A0, "Member 'AHulkBannerCharacter::SynergyExtraCapsuleRelativeLocation' has a wrong offset!");

// Class Hero_1011.HulkBannerChildActor
// 0x0000 (0x0A60 - 0x0A60)
class AHulkBannerChildActor : public AMarvelCharacterChildActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkBannerChildActor">();
	}
	static class AHulkBannerChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHulkBannerChildActor>();
	}
};
static_assert(alignof(AHulkBannerChildActor) == 0x000008, "Wrong alignment on AHulkBannerChildActor");
static_assert(sizeof(AHulkBannerChildActor) == 0x000A60, "Wrong size on AHulkBannerChildActor");

// Class Hero_1011.BannerBaseChildActor
// 0x0028 (0x0A88 - 0x0A60)
class ABannerBaseChildActor : public AHulkBannerChildActor
{
public:
	class USkeletalMeshComponent*                 GrenadeAMesh;                                      // 0x0A60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0A68(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x0A70(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ChangeContainerState();
	void ClearLoopTimer();
	void SetLoopTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannerBaseChildActor">();
	}
	static class ABannerBaseChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABannerBaseChildActor>();
	}
};
static_assert(alignof(ABannerBaseChildActor) == 0x000008, "Wrong alignment on ABannerBaseChildActor");
static_assert(sizeof(ABannerBaseChildActor) == 0x000A88, "Wrong size on ABannerBaseChildActor");
static_assert(offsetof(ABannerBaseChildActor, GrenadeAMesh) == 0x000A60, "Member 'ABannerBaseChildActor::GrenadeAMesh' has a wrong offset!");
static_assert(offsetof(ABannerBaseChildActor, Mid) == 0x000A68, "Member 'ABannerBaseChildActor::Mid' has a wrong offset!");
static_assert(offsetof(ABannerBaseChildActor, LoopTimerHandle) == 0x000A70, "Member 'ABannerBaseChildActor::LoopTimerHandle' has a wrong offset!");

// Class Hero_1011.HulkBannerAudioComponent
// 0x0000 (0x0C90 - 0x0C90)
class UHulkBannerAudioComponent final : public UCharacterAudioComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkBannerAudioComponent">();
	}
	static class UHulkBannerAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkBannerAudioComponent>();
	}
};
static_assert(alignof(UHulkBannerAudioComponent) == 0x000008, "Wrong alignment on UHulkBannerAudioComponent");
static_assert(sizeof(UHulkBannerAudioComponent) == 0x000C90, "Wrong size on UHulkBannerAudioComponent");

// Class Hero_1011.HulkBannerMoveLogicBaseComponent
// 0x0260 (0x0650 - 0x03F0)
class UHulkBannerMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	struct FHulkJumpParam                         JumpParam;                                         // 0x03F0(0x0078)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         VRunningAbilityYaw;                                // 0x0468(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VLowerBodyYaw;                                     // 0x046C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInShiftJump;                                    // 0x0470(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShiftJumpLaunched;                              // 0x0471(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInShiftJumpUpState;                             // 0x0472(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_473[0x1];                                      // 0x0473(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShiftJumpInitialSpeed;                             // 0x0474(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShiftJumpInitialPitch;                             // 0x0478(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterShiftJumpLand;                            // 0x047C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47D[0x3];                                      // 0x047D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpPrediction_UpHeight;                           // 0x0480(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpPrediction_DownHeight;                         // 0x0484(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpPrediction_UpSeconds;                          // 0x0488(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpPrediction_DownSeconds;                        // 0x048C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ShiftJumpPawnCollisionRecoveryTimer;               // 0x0490(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ShiftJumpRecoveryTimer;                            // 0x04A8(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShiftJumpAilityCancelled;                       // 0x04C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C1[0x7];                                      // 0x04C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHulkShiftJumpLaunched;                           // 0x04C8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHulkShiftJumpLanded;                             // 0x04D8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHulkShiftJumpInterrupted;                        // 0x04E8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHulkShiftJumpStopped;                            // 0x04F8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         ShiftJumpCurrentCount;                             // 0x0508(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShiftJumpMaxCount;                                 // 0x050C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CacheGravityScale;                                 // 0x0510(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasRecoveryShiftJumpCamera;                       // 0x0514(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_515[0x3];                                      // 0x0515(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CacheMaxAcceleration;                              // 0x0518(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedLandAnimInShiftJump;                          // 0x051C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPreShiftJump;                                   // 0x051D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51E[0x2];                                      // 0x051E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShiftJumpHoldingTime;                              // 0x0520(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFallingBlocked;                                 // 0x0524(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_525[0x3];                                      // 0x0525(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      HulkClimbableTypes;                                // 0x0528(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsClimbDebugDrawEnable;                           // 0x0538(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_539[0x7];                                      // 0x0539(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        CheckPointRelaitiveLocations;                      // 0x0540(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FHulkClimbParam                        ClimbParam;                                        // 0x0550(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_560[0x10];                                     // 0x0560(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EMovementMode                                 MovementMode;                                      // 0x0570(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x1F];                                     // 0x0571(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	ECLIMBSTATE                                   CLIMBSTATE;                                        // 0x0590(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_591[0x3];                                      // 0x0591(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbYaw;                                          // 0x0594(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       SphereComponent;                                   // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A0[0x4];                                      // 0x05A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsShiftJumpfromWall;                              // 0x05A4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A5[0x3];                                      // 0x05A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           IgnorePawnCollisionTag;                            // 0x05A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x14];                                     // 0x05B4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ClimbCompCache;                                    // 0x05C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             ClimbCompTransform;                                // 0x05D0(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ClimbLocation;                                     // 0x0630(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckClimbedWallValid();
	void ClientEnterClimb(const struct FVector& Location, const struct FQuat& Rotation);
	void ClientLeaveClimb(const struct FVector& Location);
	void ClientOnLanded(const struct FHitResult& Hit, bool IsServerShiftJumpCancelled);
	void IgnorePawnCollision(bool bIgnoreCollision);
	bool IsShiftJumping();
	void MulticastActivateShiftJump(float JumpUpSeconds, float JumpDownSeconds, float JumpUpHeight, float JumpDownHeight, bool bInOnWall);
	void MulticastCancelShiftJump();
	void OnFallingBlockedCallback(const struct FHitResult& Hit);
	void OnLandedCallback(const struct FHitResult& Hit);
	void OnRep_InShiftJumpUpState();
	void OnTagUpdated(const struct FGameplayTag& TagUpdated, bool TagExists);
	void PredictShiftJumpDataWhenPressed(const struct FVector& PredictVelocity, bool bFromWall, TArray<struct FVector>* PredictionPath, float MaxFallSeconds, float MaxJumpHeightDown);
	struct FVector PredictShiftJumpVelocity(float PredictSpeed, bool bRemoteRole, const struct FRotator& InRotator);
	void ResetCachedMoveParam();
	void ServerSetClimbDirection(float Yaw);
	void ServerSetClimbState(ECLIMBSTATE State);
	void SetClimbParam(const struct FHulkClimbParam& InClimbParam);
	void SetGravityScale(float InGravityScale);
	void SetHulkJumpParam(const struct FHulkJumpParam& InJumpParam);
	void ShiftJump(bool bInOnWall, float PawnCollisionIgnoreDuration);
	void ShiftJumpLaunchCharacter();
	void ShiftJumpWithCustomSpeed(float InitSpeed, bool bIsOnWall, float PawnCollisionIgnoreDuration);
	void StopShiftJump(bool bCancelNormalJump, bool bResetCacheParam);
	void StopShiftJumpMoving();
	void TriggerClimbToShiftTurn();
	void TryToClimb();
	void UpdateClimbCustomMove(float DeltaTime);
	void UpdateShiftJumpUpState(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);

	bool IsClimbing() const;
	bool IsClimbingWithAbilityStateCheck() const;
	bool IsHanging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkBannerMoveLogicBaseComponent">();
	}
	static class UHulkBannerMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkBannerMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UHulkBannerMoveLogicBaseComponent) == 0x000010, "Wrong alignment on UHulkBannerMoveLogicBaseComponent");
static_assert(sizeof(UHulkBannerMoveLogicBaseComponent) == 0x000650, "Wrong size on UHulkBannerMoveLogicBaseComponent");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, JumpParam) == 0x0003F0, "Member 'UHulkBannerMoveLogicBaseComponent::JumpParam' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, VRunningAbilityYaw) == 0x000468, "Member 'UHulkBannerMoveLogicBaseComponent::VRunningAbilityYaw' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, VLowerBodyYaw) == 0x00046C, "Member 'UHulkBannerMoveLogicBaseComponent::VLowerBodyYaw' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsInShiftJump) == 0x000470, "Member 'UHulkBannerMoveLogicBaseComponent::bIsInShiftJump' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsShiftJumpLaunched) == 0x000471, "Member 'UHulkBannerMoveLogicBaseComponent::bIsShiftJumpLaunched' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsInShiftJumpUpState) == 0x000472, "Member 'UHulkBannerMoveLogicBaseComponent::bIsInShiftJumpUpState' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpInitialSpeed) == 0x000474, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpInitialSpeed' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpInitialPitch) == 0x000478, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpInitialPitch' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bCanEnterShiftJumpLand) == 0x00047C, "Member 'UHulkBannerMoveLogicBaseComponent::bCanEnterShiftJumpLand' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, JumpPrediction_UpHeight) == 0x000480, "Member 'UHulkBannerMoveLogicBaseComponent::JumpPrediction_UpHeight' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, JumpPrediction_DownHeight) == 0x000484, "Member 'UHulkBannerMoveLogicBaseComponent::JumpPrediction_DownHeight' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, JumpPrediction_UpSeconds) == 0x000488, "Member 'UHulkBannerMoveLogicBaseComponent::JumpPrediction_UpSeconds' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, JumpPrediction_DownSeconds) == 0x00048C, "Member 'UHulkBannerMoveLogicBaseComponent::JumpPrediction_DownSeconds' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpPawnCollisionRecoveryTimer) == 0x000490, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpPawnCollisionRecoveryTimer' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpRecoveryTimer) == 0x0004A8, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpRecoveryTimer' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsShiftJumpAilityCancelled) == 0x0004C0, "Member 'UHulkBannerMoveLogicBaseComponent::bIsShiftJumpAilityCancelled' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, OnHulkShiftJumpLaunched) == 0x0004C8, "Member 'UHulkBannerMoveLogicBaseComponent::OnHulkShiftJumpLaunched' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, OnHulkShiftJumpLanded) == 0x0004D8, "Member 'UHulkBannerMoveLogicBaseComponent::OnHulkShiftJumpLanded' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, OnHulkShiftJumpInterrupted) == 0x0004E8, "Member 'UHulkBannerMoveLogicBaseComponent::OnHulkShiftJumpInterrupted' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, OnHulkShiftJumpStopped) == 0x0004F8, "Member 'UHulkBannerMoveLogicBaseComponent::OnHulkShiftJumpStopped' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpCurrentCount) == 0x000508, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpCurrentCount' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpMaxCount) == 0x00050C, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpMaxCount' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, CacheGravityScale) == 0x000510, "Member 'UHulkBannerMoveLogicBaseComponent::CacheGravityScale' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bHasRecoveryShiftJumpCamera) == 0x000514, "Member 'UHulkBannerMoveLogicBaseComponent::bHasRecoveryShiftJumpCamera' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, CacheMaxAcceleration) == 0x000518, "Member 'UHulkBannerMoveLogicBaseComponent::CacheMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bNeedLandAnimInShiftJump) == 0x00051C, "Member 'UHulkBannerMoveLogicBaseComponent::bNeedLandAnimInShiftJump' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsPreShiftJump) == 0x00051D, "Member 'UHulkBannerMoveLogicBaseComponent::bIsPreShiftJump' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpHoldingTime) == 0x000520, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpHoldingTime' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsFallingBlocked) == 0x000524, "Member 'UHulkBannerMoveLogicBaseComponent::bIsFallingBlocked' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, HulkClimbableTypes) == 0x000528, "Member 'UHulkBannerMoveLogicBaseComponent::HulkClimbableTypes' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsClimbDebugDrawEnable) == 0x000538, "Member 'UHulkBannerMoveLogicBaseComponent::bIsClimbDebugDrawEnable' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, CheckPointRelaitiveLocations) == 0x000540, "Member 'UHulkBannerMoveLogicBaseComponent::CheckPointRelaitiveLocations' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ClimbParam) == 0x000550, "Member 'UHulkBannerMoveLogicBaseComponent::ClimbParam' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, MovementMode) == 0x000570, "Member 'UHulkBannerMoveLogicBaseComponent::MovementMode' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, CLIMBSTATE) == 0x000590, "Member 'UHulkBannerMoveLogicBaseComponent::CLIMBSTATE' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ClimbYaw) == 0x000594, "Member 'UHulkBannerMoveLogicBaseComponent::ClimbYaw' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, SphereComponent) == 0x000598, "Member 'UHulkBannerMoveLogicBaseComponent::SphereComponent' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsShiftJumpfromWall) == 0x0005A4, "Member 'UHulkBannerMoveLogicBaseComponent::bIsShiftJumpfromWall' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, IgnorePawnCollisionTag) == 0x0005A8, "Member 'UHulkBannerMoveLogicBaseComponent::IgnorePawnCollisionTag' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ClimbCompCache) == 0x0005C8, "Member 'UHulkBannerMoveLogicBaseComponent::ClimbCompCache' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ClimbCompTransform) == 0x0005D0, "Member 'UHulkBannerMoveLogicBaseComponent::ClimbCompTransform' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ClimbLocation) == 0x000630, "Member 'UHulkBannerMoveLogicBaseComponent::ClimbLocation' has a wrong offset!");

// Class Hero_1011.HulkCharacterMovementComponent
// 0x0000 (0x1B60 - 0x1B60)
class UHulkCharacterMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkCharacterMovementComponent">();
	}
	static class UHulkCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkCharacterMovementComponent>();
	}
};
static_assert(alignof(UHulkCharacterMovementComponent) == 0x000010, "Wrong alignment on UHulkCharacterMovementComponent");
static_assert(sizeof(UHulkCharacterMovementComponent) == 0x001B60, "Wrong size on UHulkCharacterMovementComponent");

// Class Hero_1011.HulkHeroAnimInstance
// 0x0010 (0x0A50 - 0x0A40)
class UHulkHeroAnimInstance final : public UHulkAnimInstance
{
public:
	bool                                          bVClimbDirectionGreaterThan180;                    // 0x0A40(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShiftJumpHoldTimeGreaterThanZero;                 // 0x0A41(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A42[0xE];                                      // 0x0A42(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkHeroAnimInstance">();
	}
	static class UHulkHeroAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkHeroAnimInstance>();
	}
};
static_assert(alignof(UHulkHeroAnimInstance) == 0x000010, "Wrong alignment on UHulkHeroAnimInstance");
static_assert(sizeof(UHulkHeroAnimInstance) == 0x000A50, "Wrong size on UHulkHeroAnimInstance");
static_assert(offsetof(UHulkHeroAnimInstance, bVClimbDirectionGreaterThan180) == 0x000A40, "Member 'UHulkHeroAnimInstance::bVClimbDirectionGreaterThan180' has a wrong offset!");
static_assert(offsetof(UHulkHeroAnimInstance, bShiftJumpHoldTimeGreaterThanZero) == 0x000A41, "Member 'UHulkHeroAnimInstance::bShiftJumpHoldTimeGreaterThanZero' has a wrong offset!");

// Class Hero_1011.HulkMonsterAnimInstance
// 0x0010 (0x0A50 - 0x0A40)
class UHulkMonsterAnimInstance final : public UHulkAnimInstance
{
public:
	bool                                          bVClimbDirectionGreaterThan180;                    // 0x0A40(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShiftJumpHoldTimeGreaterThanZero;                 // 0x0A41(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A42[0xE];                                      // 0x0A42(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkMonsterAnimInstance">();
	}
	static class UHulkMonsterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkMonsterAnimInstance>();
	}
};
static_assert(alignof(UHulkMonsterAnimInstance) == 0x000010, "Wrong alignment on UHulkMonsterAnimInstance");
static_assert(sizeof(UHulkMonsterAnimInstance) == 0x000A50, "Wrong size on UHulkMonsterAnimInstance");
static_assert(offsetof(UHulkMonsterAnimInstance, bVClimbDirectionGreaterThan180) == 0x000A40, "Member 'UHulkMonsterAnimInstance::bVClimbDirectionGreaterThan180' has a wrong offset!");
static_assert(offsetof(UHulkMonsterAnimInstance, bShiftJumpHoldTimeGreaterThanZero) == 0x000A41, "Member 'UHulkMonsterAnimInstance::bShiftJumpHoldTimeGreaterThanZero' has a wrong offset!");

// Class Hero_1011.TabData_1011
// 0x0000 (0x0050 - 0x0050)
class UTabData_1011 : public UHeroTabDataBase
{
public:
	void AddTabDataValue(class AActor* InSource, class AActor* InTarget, int32 BuffID);
	void OnActorDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnBuffApplied(class UAbilitySystemComponent* Source, class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& EffectSpecStackHandle, const struct FActiveGameplayEffectHandle& EffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1011">();
	}
	static class UTabData_1011* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1011>();
	}
};
static_assert(alignof(UTabData_1011) == 0x000008, "Wrong alignment on UTabData_1011");
static_assert(sizeof(UTabData_1011) == 0x000050, "Wrong size on UTabData_1011");

}

