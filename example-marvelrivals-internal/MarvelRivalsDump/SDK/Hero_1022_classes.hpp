#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1022

#include "Basic.hpp"

#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Hero_1022_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Class Hero_1022.Cue_Projectile_Loop_10223301
// 0x0088 (0x0E38 - 0x0DB0)
class ACue_Projectile_Loop_10223301 final : public AMarvelCueNotify_Projectile
{
public:
	class UNiagaraComponent*                      NS_Loop1;                                          // 0x0DB0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Loop2;                                          // 0x0DB8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0DC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceTime;                                         // 0x0DC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0DC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HomingAttachMeshComName;                           // 0x0DCC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ThreeEffectOffset;                                 // 0x0DD8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FourEffectOffset;                                  // 0x0DF0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E08[0x20];                                     // 0x0E08(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        HomingAttachMeshCom;                               // 0x0E28(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      CurrentNiagara;                                    // 0x0E30(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DelayShowFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10223301">();
	}
	static class ACue_Projectile_Loop_10223301* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10223301>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10223301) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10223301");
static_assert(sizeof(ACue_Projectile_Loop_10223301) == 0x000E38, "Wrong size on ACue_Projectile_Loop_10223301");
static_assert(offsetof(ACue_Projectile_Loop_10223301, NS_Loop1) == 0x000DB0, "Member 'ACue_Projectile_Loop_10223301::NS_Loop1' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, NS_Loop2) == 0x000DB8, "Member 'ACue_Projectile_Loop_10223301::NS_Loop2' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, DelayTime) == 0x000DC0, "Member 'ACue_Projectile_Loop_10223301::DelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, TraceTime) == 0x000DC4, "Member 'ACue_Projectile_Loop_10223301::TraceTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, EndDistance) == 0x000DC8, "Member 'ACue_Projectile_Loop_10223301::EndDistance' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, HomingAttachMeshComName) == 0x000DCC, "Member 'ACue_Projectile_Loop_10223301::HomingAttachMeshComName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, ThreeEffectOffset) == 0x000DD8, "Member 'ACue_Projectile_Loop_10223301::ThreeEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, FourEffectOffset) == 0x000DF0, "Member 'ACue_Projectile_Loop_10223301::FourEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, HomingAttachMeshCom) == 0x000E28, "Member 'ACue_Projectile_Loop_10223301::HomingAttachMeshCom' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, CurrentNiagara) == 0x000E30, "Member 'ACue_Projectile_Loop_10223301::CurrentNiagara' has a wrong offset!");

// Class Hero_1022.Config_102261
// 0x1018 (0x10B0 - 0x0098)
class UConfig_102261 : public UMarvelAbilityConfig
{
public:
	float                                         MaxFlyRadius;                                      // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingSpeed;                                       // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingAcceleration;                                // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReductionPerBounce1;                         // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReductionPerBounce2;                         // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReductionPerBounce3;                         // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00B0(0x0F90)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CancelHomingTag;                                   // 0x1040(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A8[0x8];                                     // 0x10A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102261">();
	}
	static class UConfig_102261* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102261>();
	}
};
static_assert(alignof(UConfig_102261) == 0x000010, "Wrong alignment on UConfig_102261");
static_assert(sizeof(UConfig_102261) == 0x0010B0, "Wrong size on UConfig_102261");
static_assert(offsetof(UConfig_102261, MaxFlyRadius) == 0x000098, "Member 'UConfig_102261::MaxFlyRadius' has a wrong offset!");
static_assert(offsetof(UConfig_102261, HomingSpeed) == 0x00009C, "Member 'UConfig_102261::HomingSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_102261, HomingAcceleration) == 0x0000A0, "Member 'UConfig_102261::HomingAcceleration' has a wrong offset!");
static_assert(offsetof(UConfig_102261, DamageReductionPerBounce1) == 0x0000A4, "Member 'UConfig_102261::DamageReductionPerBounce1' has a wrong offset!");
static_assert(offsetof(UConfig_102261, DamageReductionPerBounce2) == 0x0000A8, "Member 'UConfig_102261::DamageReductionPerBounce2' has a wrong offset!");
static_assert(offsetof(UConfig_102261, DamageReductionPerBounce3) == 0x0000AC, "Member 'UConfig_102261::DamageReductionPerBounce3' has a wrong offset!");
static_assert(offsetof(UConfig_102261, TraceContext) == 0x0000B0, "Member 'UConfig_102261::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_102261, CancelHomingTag) == 0x001040, "Member 'UConfig_102261::CancelHomingTag' has a wrong offset!");

// Class Hero_1022.Config_102235
// 0x0F90 (0x2040 - 0x10B0)
class UConfig_102235 : public UConfig_102261
{
public:
	struct FMarvelAbilityTraceContext             BeginTraceContext;                                 // 0x10B0(0x0F90)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102235">();
	}
	static class UConfig_102235* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102235>();
	}
};
static_assert(alignof(UConfig_102235) == 0x000010, "Wrong alignment on UConfig_102235");
static_assert(sizeof(UConfig_102235) == 0x002040, "Wrong size on UConfig_102235");
static_assert(offsetof(UConfig_102235, BeginTraceContext) == 0x0010B0, "Member 'UConfig_102235::BeginTraceContext' has a wrong offset!");

// Class Hero_1022.Projectile_10226101
// 0x0030 (0x3080 - 0x3050)
class AProjectile_10226101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	TArray<class ACharacter*>                     VisitedTargets;                                    // 0x3050(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3060[0x18];                                    // 0x3060(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelBaseAbilitySystemComponent*      CurrentASC;                                        // 0x3078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOwnerTagUpdate(const struct FGameplayTag& Tag, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10226101">();
	}
	static class AProjectile_10226101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10226101>();
	}
};
static_assert(alignof(AProjectile_10226101) == 0x000010, "Wrong alignment on AProjectile_10226101");
static_assert(sizeof(AProjectile_10226101) == 0x003080, "Wrong size on AProjectile_10226101");
static_assert(offsetof(AProjectile_10226101, VisitedTargets) == 0x003050, "Member 'AProjectile_10226101::VisitedTargets' has a wrong offset!");
static_assert(offsetof(AProjectile_10226101, CurrentASC) == 0x003078, "Member 'AProjectile_10226101::CurrentASC' has a wrong offset!");

// Class Hero_1022.Projectile_10223101
// 0x0000 (0x3080 - 0x3080)
class AProjectile_10223101 final : public AProjectile_10226101
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10223101">();
	}
	static class AProjectile_10223101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10223101>();
	}
};
static_assert(alignof(AProjectile_10223101) == 0x000010, "Wrong alignment on AProjectile_10223101");
static_assert(sizeof(AProjectile_10223101) == 0x003080, "Wrong size on AProjectile_10223101");

// Class Hero_1022.UIC_Controller_102235
// 0x0028 (0x0C88 - 0x0C60)
class UUIC_Controller_102235 : public UUIC_Ability
{
public:
	struct FGameplayTag                           AbilityCountTag;                                   // 0x0C60(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BuffTag;                                           // 0x0C6C(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C78[0x10];                                     // 0x0C78(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityCountUpdate(const struct FGameplayTag& Tag, int32 NewCount);
	void OnBuffTagUpdate(const struct FGameplayTag& Tag, int32 NewCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIC_Controller_102235">();
	}
	static class UUIC_Controller_102235* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIC_Controller_102235>();
	}
};
static_assert(alignof(UUIC_Controller_102235) == 0x000008, "Wrong alignment on UUIC_Controller_102235");
static_assert(sizeof(UUIC_Controller_102235) == 0x000C88, "Wrong size on UUIC_Controller_102235");
static_assert(offsetof(UUIC_Controller_102235, AbilityCountTag) == 0x000C60, "Member 'UUIC_Controller_102235::AbilityCountTag' has a wrong offset!");
static_assert(offsetof(UUIC_Controller_102235, BuffTag) == 0x000C6C, "Member 'UUIC_Controller_102235::BuffTag' has a wrong offset!");

// Class Hero_1022.Config_102241
// 0x0018 (0x00B0 - 0x0098)
class UConfig_102241 : public UMarvelAbilityConfig
{
public:
	bool                                          bEnableAttachSocket;                               // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackwardWalkSpeedRatio;                            // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 BuffList;                                          // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102241">();
	}
	static class UConfig_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102241>();
	}
};
static_assert(alignof(UConfig_102241) == 0x000008, "Wrong alignment on UConfig_102241");
static_assert(sizeof(UConfig_102241) == 0x0000B0, "Wrong size on UConfig_102241");
static_assert(offsetof(UConfig_102241, bEnableAttachSocket) == 0x000098, "Member 'UConfig_102241::bEnableAttachSocket' has a wrong offset!");
static_assert(offsetof(UConfig_102241, BackwardWalkSpeedRatio) == 0x00009C, "Member 'UConfig_102241::BackwardWalkSpeedRatio' has a wrong offset!");
static_assert(offsetof(UConfig_102241, BuffList) == 0x0000A0, "Member 'UConfig_102241::BuffList' has a wrong offset!");

// Class Hero_1022.ReflexReceiverComponent_102241
// 0x0000 (0x03E0 - 0x03E0)
class UReflexReceiverComponent_102241 final : public UMarvelReflexReceiverComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReflexReceiverComponent_102241">();
	}
	static class UReflexReceiverComponent_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReflexReceiverComponent_102241>();
	}
};
static_assert(alignof(UReflexReceiverComponent_102241) == 0x000008, "Wrong alignment on UReflexReceiverComponent_102241");
static_assert(sizeof(UReflexReceiverComponent_102241) == 0x0003E0, "Wrong size on UReflexReceiverComponent_102241");

// Class Hero_1022.SummonedComp_102241
// 0x0000 (0x0CA0 - 0x0CA0)
class USummonedComp_102241 : public UMarvelSummonedComponent
{
public:
	void OnApplyBuff(class UAbilitySystemComponent* Source, class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& EffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_102241">();
	}
	static class USummonedComp_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_102241>();
	}
};
static_assert(alignof(USummonedComp_102241) == 0x000010, "Wrong alignment on USummonedComp_102241");
static_assert(sizeof(USummonedComp_102241) == 0x000CA0, "Wrong size on USummonedComp_102241");

// Class Hero_1022.Summoned_102241
// 0x0070 (0x0900 - 0x0890)
class ASummoned_102241 : public AMarvelSummonerBase
{
public:
	class UReflexReceiverComponent_102241*        ReflexReceiverComponent;                           // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShieldActive;                                   // 0x0898(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_899[0x7];                                      // 0x0899(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BodyOffset;                                        // 0x08A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BodyRotation;                                      // 0x08B8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalOriginCoordinates;                            // 0x08D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x08E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x08EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitch;                                          // 0x08F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F4[0x4];                                      // 0x08F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_102241*                         AbilityConfig;                                     // 0x08F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UConfig_102241* GetConfig();
	void K2_SetAlive(bool bInAlive);
	void OnRep_IsShieldActive();
	void OnSummonedCompBeginAgentTask();
	void OnSummonedCompEndAgentTask();
	void ResetHealth();
	void SetShieldActive(bool bIsActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_102241">();
	}
	static class ASummoned_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_102241>();
	}
};
static_assert(alignof(ASummoned_102241) == 0x000010, "Wrong alignment on ASummoned_102241");
static_assert(sizeof(ASummoned_102241) == 0x000900, "Wrong size on ASummoned_102241");
static_assert(offsetof(ASummoned_102241, ReflexReceiverComponent) == 0x000890, "Member 'ASummoned_102241::ReflexReceiverComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, bIsShieldActive) == 0x000898, "Member 'ASummoned_102241::bIsShieldActive' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, BodyOffset) == 0x0008A0, "Member 'ASummoned_102241::BodyOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, BodyRotation) == 0x0008B8, "Member 'ASummoned_102241::BodyRotation' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, LocalOriginCoordinates) == 0x0008D0, "Member 'ASummoned_102241::LocalOriginCoordinates' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, Length) == 0x0008E8, "Member 'ASummoned_102241::Length' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, MaxPitch) == 0x0008EC, "Member 'ASummoned_102241::MaxPitch' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, MinPitch) == 0x0008F0, "Member 'ASummoned_102241::MinPitch' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, AbilityConfig) == 0x0008F8, "Member 'ASummoned_102241::AbilityConfig' has a wrong offset!");

// Class Hero_1022.Cue_Summoner_Damaged_10224102
// 0x0010 (0x04E0 - 0x04D0)
class UCue_Summoner_Damaged_10224102 final : public UMarvelCueNotify_HitImpact
{
public:
	TArray<struct FAmplitudeRange>                AmplitudeRangeArray;                               // 0x04D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Damaged_10224102">();
	}
	static class UCue_Summoner_Damaged_10224102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Summoner_Damaged_10224102>();
	}
};
static_assert(alignof(UCue_Summoner_Damaged_10224102) == 0x000008, "Wrong alignment on UCue_Summoner_Damaged_10224102");
static_assert(sizeof(UCue_Summoner_Damaged_10224102) == 0x0004E0, "Wrong size on UCue_Summoner_Damaged_10224102");
static_assert(offsetof(UCue_Summoner_Damaged_10224102, AmplitudeRangeArray) == 0x0004D0, "Member 'UCue_Summoner_Damaged_10224102::AmplitudeRangeArray' has a wrong offset!");

// Class Hero_1022.Config_102251
// 0x0010 (0x00A8 - 0x0098)
class UConfig_102251 final : public UMarvelAbilityConfig
{
public:
	class UCurveFloat*                            SpeedCurve;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102251">();
	}
	static class UConfig_102251* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102251>();
	}
};
static_assert(alignof(UConfig_102251) == 0x000008, "Wrong alignment on UConfig_102251");
static_assert(sizeof(UConfig_102251) == 0x0000A8, "Wrong size on UConfig_102251");
static_assert(offsetof(UConfig_102251, SpeedCurve) == 0x000098, "Member 'UConfig_102251::SpeedCurve' has a wrong offset!");
static_assert(offsetof(UConfig_102251, BuffID) == 0x0000A0, "Member 'UConfig_102251::BuffID' has a wrong offset!");

// Class Hero_1022.Ability_102251
// 0x0008 (0x2588 - 0x2580)
class UAbility_102251 : public UMarvelGameplayAbility
{
public:
	class UConfig_102251*                         Config102251;                                      // 0x2580(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnGameplayEvent(const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102251">();
	}
	static class UAbility_102251* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102251>();
	}
};
static_assert(alignof(UAbility_102251) == 0x000008, "Wrong alignment on UAbility_102251");
static_assert(sizeof(UAbility_102251) == 0x002588, "Wrong size on UAbility_102251");
static_assert(offsetof(UAbility_102251, Config102251) == 0x002580, "Member 'UAbility_102251::Config102251' has a wrong offset!");

// Class Hero_1022.MarvelCueNotify_CaptainShadow
// 0x0110 (0x0F60 - 0x0E50)
class AMarvelCueNotify_CaptainShadow : public AMarvelCueNotify_Ability
{
public:
	class UPoseableMeshComponent*                 Mesh1;                                             // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh2;                                             // 0x0E58(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh3;                                             // 0x0E60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh4;                                             // 0x0E68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh5;                                             // 0x0E70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FShadowMeshInfo                        MeshInfo;                                          // 0x0E78(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FShadowMeshInfo>                ChildsMeshInfo;                                    // 0x0EC8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ShadowMeshLOD;                                     // 0x0ED8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SimulateShadowMeshLOD;                             // 0x0EDC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ShadowShowTime;                                    // 0x0EE0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCurveVector*                           ShadowScaleCurve;                                  // 0x0EF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShadowOpacityCurve;                                // 0x0EF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpacityName;                                       // 0x0F00(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MovePositionName;                                  // 0x0F0C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveOffset;                                        // 0x0F18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1C[0x4];                                      // 0x0F1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPoseableMeshComponent*>         ShadowMeshComponents;                              // 0x0F20(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F30[0x30];                                     // 0x0F30(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecordCharacterSprintInfo(float DeltaSeconds);
	void ResetParameter();
	void SetCharacterMeshHidden(class UPoseableMeshComponent* Mesh, bool NewHidden);
	void SetCharacterMeshMovePosition(class UPoseableMeshComponent* Mesh, const struct FVector& MoveDir);
	void SetCharacterMeshOpacity(class UPoseableMeshComponent* Mesh, float Opacity);
	void SetShadowMeshMaterial(struct FShadowMeshInfo* ShadowMeshInfo, TArray<struct FShadowMeshInfo>* ChildShadowMeshInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelCueNotify_CaptainShadow">();
	}
	static class AMarvelCueNotify_CaptainShadow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelCueNotify_CaptainShadow>();
	}
};
static_assert(alignof(AMarvelCueNotify_CaptainShadow) == 0x000008, "Wrong alignment on AMarvelCueNotify_CaptainShadow");
static_assert(sizeof(AMarvelCueNotify_CaptainShadow) == 0x000F60, "Wrong size on AMarvelCueNotify_CaptainShadow");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh1) == 0x000E50, "Member 'AMarvelCueNotify_CaptainShadow::Mesh1' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh2) == 0x000E58, "Member 'AMarvelCueNotify_CaptainShadow::Mesh2' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh3) == 0x000E60, "Member 'AMarvelCueNotify_CaptainShadow::Mesh3' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh4) == 0x000E68, "Member 'AMarvelCueNotify_CaptainShadow::Mesh4' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh5) == 0x000E70, "Member 'AMarvelCueNotify_CaptainShadow::Mesh5' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, MeshInfo) == 0x000E78, "Member 'AMarvelCueNotify_CaptainShadow::MeshInfo' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ChildsMeshInfo) == 0x000EC8, "Member 'AMarvelCueNotify_CaptainShadow::ChildsMeshInfo' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowMeshLOD) == 0x000ED8, "Member 'AMarvelCueNotify_CaptainShadow::ShadowMeshLOD' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, SimulateShadowMeshLOD) == 0x000EDC, "Member 'AMarvelCueNotify_CaptainShadow::SimulateShadowMeshLOD' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowShowTime) == 0x000EE0, "Member 'AMarvelCueNotify_CaptainShadow::ShadowShowTime' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowScaleCurve) == 0x000EF0, "Member 'AMarvelCueNotify_CaptainShadow::ShadowScaleCurve' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowOpacityCurve) == 0x000EF8, "Member 'AMarvelCueNotify_CaptainShadow::ShadowOpacityCurve' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, OpacityName) == 0x000F00, "Member 'AMarvelCueNotify_CaptainShadow::OpacityName' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, MovePositionName) == 0x000F0C, "Member 'AMarvelCueNotify_CaptainShadow::MovePositionName' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, MoveOffset) == 0x000F18, "Member 'AMarvelCueNotify_CaptainShadow::MoveOffset' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowMeshComponents) == 0x000F20, "Member 'AMarvelCueNotify_CaptainShadow::ShadowMeshComponents' has a wrong offset!");

// Class Hero_1022.Cue_Ability_Loop_10225101
// 0x00C0 (0x0F10 - 0x0E50)
class ACue_Ability_Loop_10225101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E50[0x18];                                     // 0x0E50(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      VelocityLineFX;                                    // 0x0E68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartFXDelayTime;                                  // 0x0E70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E74[0xC];                                      // 0x0E74(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartFXRelativeTransform;                          // 0x0E80(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         DelayStartFX;                                      // 0x0EE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     PostProcessingMaterial;                            // 0x0EE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF0[0x20];                                     // 0x0EF0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10225101">();
	}
	static class ACue_Ability_Loop_10225101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10225101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10225101) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10225101");
static_assert(sizeof(ACue_Ability_Loop_10225101) == 0x000F10, "Wrong size on ACue_Ability_Loop_10225101");
static_assert(offsetof(ACue_Ability_Loop_10225101, VelocityLineFX) == 0x000E68, "Member 'ACue_Ability_Loop_10225101::VelocityLineFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, StartFXDelayTime) == 0x000E70, "Member 'ACue_Ability_Loop_10225101::StartFXDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, StartFXRelativeTransform) == 0x000E80, "Member 'ACue_Ability_Loop_10225101::StartFXRelativeTransform' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, DelayStartFX) == 0x000EE0, "Member 'ACue_Ability_Loop_10225101::DelayStartFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, PostProcessingMaterial) == 0x000EE8, "Member 'ACue_Ability_Loop_10225101::PostProcessingMaterial' has a wrong offset!");

// Class Hero_1022.Ability_102252
// 0x0000 (0x2588 - 0x2588)
class UAbility_102252 final : public UAbility_102
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102252">();
	}
	static class UAbility_102252* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102252>();
	}
};
static_assert(alignof(UAbility_102252) == 0x000008, "Wrong alignment on UAbility_102252");
static_assert(sizeof(UAbility_102252) == 0x002588, "Wrong size on UAbility_102252");

// Class Hero_1022.Config_102253
// 0x1B58 (0x1BF0 - 0x0098)
class UConfig_102253 final : public UMarvelAbilityConfig
{
public:
	struct FVector                                ScopePosOffset;                                    // 0x0098(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceAimContext;                                   // 0x00B0(0x0F90)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDashAbilityInfo                       DashInfo;                                          // 0x1040(0x0BA8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BE8[0x8];                                     // 0x1BE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102253">();
	}
	static class UConfig_102253* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102253>();
	}
};
static_assert(alignof(UConfig_102253) == 0x000010, "Wrong alignment on UConfig_102253");
static_assert(sizeof(UConfig_102253) == 0x001BF0, "Wrong size on UConfig_102253");
static_assert(offsetof(UConfig_102253, ScopePosOffset) == 0x000098, "Member 'UConfig_102253::ScopePosOffset' has a wrong offset!");
static_assert(offsetof(UConfig_102253, TraceAimContext) == 0x0000B0, "Member 'UConfig_102253::TraceAimContext' has a wrong offset!");
static_assert(offsetof(UConfig_102253, DashInfo) == 0x001040, "Member 'UConfig_102253::DashInfo' has a wrong offset!");

// Class Hero_1022.Ability_102253
// 0x0150 (0x26D0 - 0x2580)
class UAbility_102253 final : public UMarvelGameplayAbility
{
public:
	uint8                                         Pad_2580[0x8];                                     // 0x2580(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                                      // 0x2588(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         InitializeAbilityKey;                              // 0x2590(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         OnApplyDashKey;                                    // 0x2630(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnDashFinish(EDashStopReason Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102253">();
	}
	static class UAbility_102253* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102253>();
	}
};
static_assert(alignof(UAbility_102253) == 0x000008, "Wrong alignment on UAbility_102253");
static_assert(sizeof(UAbility_102253) == 0x0026D0, "Wrong size on UAbility_102253");
static_assert(offsetof(UAbility_102253, TimelineTask) == 0x002588, "Member 'UAbility_102253::TimelineTask' has a wrong offset!");
static_assert(offsetof(UAbility_102253, InitializeAbilityKey) == 0x002590, "Member 'UAbility_102253::InitializeAbilityKey' has a wrong offset!");
static_assert(offsetof(UAbility_102253, OnApplyDashKey) == 0x002630, "Member 'UAbility_102253::OnApplyDashKey' has a wrong offset!");

// Class Hero_1022.Config_102254
// 0x1F58 (0x1FF0 - 0x0098)
class UConfig_102254 final : public UMarvelAbilityConfig
{
public:
	float                                         MaxCharacterHeightToActivate;                      // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCharacterHeightToActivate;                      // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAimHeightToActivate;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSmashRadius;                                    // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckAngle;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SmashPermissionBuffID;                             // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SmashCooldownTag;                                  // 0x00B0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRate;                                         // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTraceDistance;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceDownContext;                                  // 0x00D0(0x0F90)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceAimContext;                                   // 0x1060(0x0F90)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102254">();
	}
	static class UConfig_102254* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102254>();
	}
};
static_assert(alignof(UConfig_102254) == 0x000010, "Wrong alignment on UConfig_102254");
static_assert(sizeof(UConfig_102254) == 0x001FF0, "Wrong size on UConfig_102254");
static_assert(offsetof(UConfig_102254, MaxCharacterHeightToActivate) == 0x000098, "Member 'UConfig_102254::MaxCharacterHeightToActivate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, MinCharacterHeightToActivate) == 0x00009C, "Member 'UConfig_102254::MinCharacterHeightToActivate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, MinAimHeightToActivate) == 0x0000A0, "Member 'UConfig_102254::MinAimHeightToActivate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, MaxSmashRadius) == 0x0000A4, "Member 'UConfig_102254::MaxSmashRadius' has a wrong offset!");
static_assert(offsetof(UConfig_102254, GroundCheckAngle) == 0x0000A8, "Member 'UConfig_102254::GroundCheckAngle' has a wrong offset!");
static_assert(offsetof(UConfig_102254, SmashPermissionBuffID) == 0x0000AC, "Member 'UConfig_102254::SmashPermissionBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102254, SmashCooldownTag) == 0x0000B0, "Member 'UConfig_102254::SmashCooldownTag' has a wrong offset!");
static_assert(offsetof(UConfig_102254, TraceRate) == 0x0000BC, "Member 'UConfig_102254::TraceRate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, BackTraceDistance) == 0x0000C0, "Member 'UConfig_102254::BackTraceDistance' has a wrong offset!");
static_assert(offsetof(UConfig_102254, TraceDownContext) == 0x0000D0, "Member 'UConfig_102254::TraceDownContext' has a wrong offset!");
static_assert(offsetof(UConfig_102254, TraceAimContext) == 0x001060, "Member 'UConfig_102254::TraceAimContext' has a wrong offset!");

// Class Hero_1022.Ability_102254
// 0x0060 (0x25E0 - 0x2580)
class UAbility_102254 : public UMarvelGameplayAbility
{
public:
	uint8                                         Pad_2580[0x60];                                    // 0x2580(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetCurrentAimImpactPoint();
	TArray<struct FHitResult> GetTraceResults();
	void UpdateState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102254">();
	}
	static class UAbility_102254* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102254>();
	}
};
static_assert(alignof(UAbility_102254) == 0x000008, "Wrong alignment on UAbility_102254");
static_assert(sizeof(UAbility_102254) == 0x0025E0, "Wrong size on UAbility_102254");

// Class Hero_1022.Cue_Ability_Loop_10225401
// 0x0020 (0x0E70 - 0x0E50)
class ACue_Ability_Loop_10225401 final : public AMarvelCueNotify_Ability
{
public:
	class UDecalComponent*                        DecalComponent;                                    // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistToSmooth;                                   // 0x0E58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpMaxSpeed;                                      // 0x0E5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpMinSpeed;                                      // 0x0E60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateRate;                                        // 0x0E64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E68[0x8];                                      // 0x0E68(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerBuffApplied(class UAbilitySystemComponent* InASC, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& Handle);
	void OnOwnerBuffRemove(const class UAbilitySystemComponent* ASC, const struct FActiveGameplayEffect& Age);
	void OnViewingCharChanged(class AMarvelBaseCharacter* ViewingChar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10225401">();
	}
	static class ACue_Ability_Loop_10225401* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10225401>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10225401) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10225401");
static_assert(sizeof(ACue_Ability_Loop_10225401) == 0x000E70, "Wrong size on ACue_Ability_Loop_10225401");
static_assert(offsetof(ACue_Ability_Loop_10225401, DecalComponent) == 0x000E50, "Member 'ACue_Ability_Loop_10225401::DecalComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, MaxDistToSmooth) == 0x000E58, "Member 'ACue_Ability_Loop_10225401::MaxDistToSmooth' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, LerpMaxSpeed) == 0x000E5C, "Member 'ACue_Ability_Loop_10225401::LerpMaxSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, LerpMinSpeed) == 0x000E60, "Member 'ACue_Ability_Loop_10225401::LerpMinSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, UpdateRate) == 0x000E64, "Member 'ACue_Ability_Loop_10225401::UpdateRate' has a wrong offset!");

// Class Hero_1022.Config_102255
// 0x0030 (0x00C8 - 0x0098)
class UConfig_102255 final : public UMarvelAbilityConfig
{
public:
	bool                                          bIsWaitStateChanged;                               // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStateChangedTaskParam                 TaskParam;                                         // 0x009C(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102255">();
	}
	static class UConfig_102255* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102255>();
	}
};
static_assert(alignof(UConfig_102255) == 0x000008, "Wrong alignment on UConfig_102255");
static_assert(sizeof(UConfig_102255) == 0x0000C8, "Wrong size on UConfig_102255");
static_assert(offsetof(UConfig_102255, bIsWaitStateChanged) == 0x000098, "Member 'UConfig_102255::bIsWaitStateChanged' has a wrong offset!");
static_assert(offsetof(UConfig_102255, TaskParam) == 0x00009C, "Member 'UConfig_102255::TaskParam' has a wrong offset!");

// Class Hero_1022.Ability_102255
// 0x0010 (0x2590 - 0x2580)
class UAbility_102255 : public UMarvelGameplayAbility
{
public:
	uint8                                         Pad_2580[0x8];                                     // 0x2580(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_WaitInputStateChanged* WaitActivationInputStateTask;                      // 0x2588(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActivatePress(float TimeWaited);
	void OnActivateRelease(float TimeWaited);
	void OnKey102235Press(float TimeWaited);
	void OnKey102235Release(float TimeWaited);
	void OnMoveForwardInput(uint8 InMovementInputs, float DeltaTime);
	void SetActivatePressing(bool bIsPressing);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102255">();
	}
	static class UAbility_102255* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102255>();
	}
};
static_assert(alignof(UAbility_102255) == 0x000008, "Wrong alignment on UAbility_102255");
static_assert(sizeof(UAbility_102255) == 0x002590, "Wrong size on UAbility_102255");
static_assert(offsetof(UAbility_102255, WaitActivationInputStateTask) == 0x002588, "Member 'UAbility_102255::WaitActivationInputStateTask' has a wrong offset!");

// Class Hero_1022.Cue_Ability_Loop_10225501
// 0x0088 (0x0FE8 - 0x0F60)
class ACue_Ability_Loop_10225501 final : public AMarvelCueNotify_CaptainShadow
{
public:
	uint8                                         Pad_F60[0x18];                                     // 0x0F60(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RemoveTags;                                        // 0x0F78(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE0[0x8];                                      // 0x0FE0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10225501">();
	}
	static class ACue_Ability_Loop_10225501* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10225501>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10225501) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10225501");
static_assert(sizeof(ACue_Ability_Loop_10225501) == 0x000FE8, "Wrong size on ACue_Ability_Loop_10225501");
static_assert(offsetof(ACue_Ability_Loop_10225501, RemoveTags) == 0x000F78, "Member 'ACue_Ability_Loop_10225501::RemoveTags' has a wrong offset!");

// Class Hero_1022.Ability_102261
// 0x0000 (0x2588 - 0x2588)
class UAbility_102261 : public UAbility_108
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102261">();
	}
	static class UAbility_102261* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102261>();
	}
};
static_assert(alignof(UAbility_102261) == 0x000008, "Wrong alignment on UAbility_102261");
static_assert(sizeof(UAbility_102261) == 0x002588, "Wrong size on UAbility_102261");

// Class Hero_1022.Config_102271
// 0x0028 (0x00C0 - 0x0098)
class UConfig_102271 final : public UMarvelAbilityConfig
{
public:
	float                                         ScopeDuration;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmorBuffID;                                       // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisposableTeammateArmorBuffValue;                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisposableSelfArmorBuffValue;                      // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeammateArmorBuffValue;                            // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelfArmorBuffValue;                                // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorTimeGap;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeammateSpeedBuffID;                               // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelfSpeedBuffID;                                   // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102271">();
	}
	static class UConfig_102271* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102271>();
	}
};
static_assert(alignof(UConfig_102271) == 0x000008, "Wrong alignment on UConfig_102271");
static_assert(sizeof(UConfig_102271) == 0x0000C0, "Wrong size on UConfig_102271");
static_assert(offsetof(UConfig_102271, ScopeDuration) == 0x000098, "Member 'UConfig_102271::ScopeDuration' has a wrong offset!");
static_assert(offsetof(UConfig_102271, ArmorBuffID) == 0x00009C, "Member 'UConfig_102271::ArmorBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102271, DisposableTeammateArmorBuffValue) == 0x0000A0, "Member 'UConfig_102271::DisposableTeammateArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, DisposableSelfArmorBuffValue) == 0x0000A4, "Member 'UConfig_102271::DisposableSelfArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, TeammateArmorBuffValue) == 0x0000A8, "Member 'UConfig_102271::TeammateArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, SelfArmorBuffValue) == 0x0000AC, "Member 'UConfig_102271::SelfArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, ArmorTimeGap) == 0x0000B0, "Member 'UConfig_102271::ArmorTimeGap' has a wrong offset!");
static_assert(offsetof(UConfig_102271, TeammateSpeedBuffID) == 0x0000B4, "Member 'UConfig_102271::TeammateSpeedBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102271, SelfSpeedBuffID) == 0x0000B8, "Member 'UConfig_102271::SelfSpeedBuffID' has a wrong offset!");

// Class Hero_1022.Ability_102271
// 0x0020 (0x25A0 - 0x2580)
class UAbility_102271 : public UMarvelGameplayAbility
{
public:
	class AScope_10227101*                        Scope;                                             // 0x2580(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2588[0x18];                                    // 0x2588(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102271">();
	}
	static class UAbility_102271* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102271>();
	}
};
static_assert(alignof(UAbility_102271) == 0x000008, "Wrong alignment on UAbility_102271");
static_assert(sizeof(UAbility_102271) == 0x0025A0, "Wrong size on UAbility_102271");
static_assert(offsetof(UAbility_102271, Scope) == 0x002580, "Member 'UAbility_102271::Scope' has a wrong offset!");

// Class Hero_1022.Scope_10227101
// 0x0110 (0x1810 - 0x1700)
class AScope_10227101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	TMap<class AMarvelBaseCharacter*, class UArmorAttenuation_102271*> CachedAttenuationAbility;                          // 0x1700(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_1750[0x8];                                     // 0x1750(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Path;                                              // 0x1758(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 PathTime;                                          // 0x1768(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelBaseCharacter*>           Teammates;                                         // 0x1778(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelBaseCharacter*>           TeammatesOnPath;                                   // 0x1788(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelBaseCharacter*>           TeammatesOffPath;                                  // 0x1798(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class AMarvelBaseCharacter*, struct FTimerHandle> AddArmorTimerMap;                                  // 0x17A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         MaxPathLength;                                     // 0x17F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceBetweenPointsSquared;                      // 0x17FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1800[0x10];                                    // 0x1800(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyArmorToTarget(class AMarvelBaseCharacter* Target);
	const TArray<struct FVector> GetQPath();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10227101">();
	}
	static class AScope_10227101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10227101>();
	}
};
static_assert(alignof(AScope_10227101) == 0x000010, "Wrong alignment on AScope_10227101");
static_assert(sizeof(AScope_10227101) == 0x001810, "Wrong size on AScope_10227101");
static_assert(offsetof(AScope_10227101, CachedAttenuationAbility) == 0x001700, "Member 'AScope_10227101::CachedAttenuationAbility' has a wrong offset!");
static_assert(offsetof(AScope_10227101, Path) == 0x001758, "Member 'AScope_10227101::Path' has a wrong offset!");
static_assert(offsetof(AScope_10227101, PathTime) == 0x001768, "Member 'AScope_10227101::PathTime' has a wrong offset!");
static_assert(offsetof(AScope_10227101, Teammates) == 0x001778, "Member 'AScope_10227101::Teammates' has a wrong offset!");
static_assert(offsetof(AScope_10227101, TeammatesOnPath) == 0x001788, "Member 'AScope_10227101::TeammatesOnPath' has a wrong offset!");
static_assert(offsetof(AScope_10227101, TeammatesOffPath) == 0x001798, "Member 'AScope_10227101::TeammatesOffPath' has a wrong offset!");
static_assert(offsetof(AScope_10227101, AddArmorTimerMap) == 0x0017A8, "Member 'AScope_10227101::AddArmorTimerMap' has a wrong offset!");
static_assert(offsetof(AScope_10227101, MaxPathLength) == 0x0017F8, "Member 'AScope_10227101::MaxPathLength' has a wrong offset!");
static_assert(offsetof(AScope_10227101, DistanceBetweenPointsSquared) == 0x0017FC, "Member 'AScope_10227101::DistanceBetweenPointsSquared' has a wrong offset!");

// Class Hero_1022.Scope_10227102
// 0x0000 (0x1700 - 0x1700)
class AScope_10227102 final : public AMarvelAbilityTargetActor_Scope
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10227102">();
	}
	static class AScope_10227102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10227102>();
	}
};
static_assert(alignof(AScope_10227102) == 0x000010, "Wrong alignment on AScope_10227102");
static_assert(sizeof(AScope_10227102) == 0x001700, "Wrong size on AScope_10227102");

// Class Hero_1022.ArmorAttenuation_102271
// 0x0000 (0x12B8 - 0x12B8)
class UArmorAttenuation_102271 : public UMarvelNotTreatFallAbility
{
public:
	void AddArmor(float DeltaValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmorAttenuation_102271">();
	}
	static class UArmorAttenuation_102271* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmorAttenuation_102271>();
	}
};
static_assert(alignof(UArmorAttenuation_102271) == 0x000008, "Wrong alignment on UArmorAttenuation_102271");
static_assert(sizeof(UArmorAttenuation_102271) == 0x0012B8, "Wrong size on UArmorAttenuation_102271");

// Class Hero_1022.Cue_Ability_Loop_10227101
// 0x0070 (0x0EC0 - 0x0E50)
class ACue_Ability_Loop_10227101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E50[0x18];                                     // 0x0E50(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      CueNiagara;                                        // 0x0E68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ReleaseNiagara;                                    // 0x0E70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DisCurve;                                          // 0x0E78(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShieldMaterialName;                                // 0x0E80(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8C[0x4];                                      // 0x0E8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ShieldMaterialShowCurve;                           // 0x0E90(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShieldMaterialHideCurve;                           // 0x0E98(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SprintShieldRaiseID;                               // 0x0EA0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SprintShieldReleaseID;                             // 0x0EA4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SprintShieldRaiseLoopID;                           // 0x0EA8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EAC[0x14];                                     // 0x0EAC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);
	void SetShieldMaterial(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10227101">();
	}
	static class ACue_Ability_Loop_10227101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10227101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10227101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10227101");
static_assert(sizeof(ACue_Ability_Loop_10227101) == 0x000EC0, "Wrong size on ACue_Ability_Loop_10227101");
static_assert(offsetof(ACue_Ability_Loop_10227101, CueNiagara) == 0x000E68, "Member 'ACue_Ability_Loop_10227101::CueNiagara' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ReleaseNiagara) == 0x000E70, "Member 'ACue_Ability_Loop_10227101::ReleaseNiagara' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, DisCurve) == 0x000E78, "Member 'ACue_Ability_Loop_10227101::DisCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ShieldMaterialName) == 0x000E80, "Member 'ACue_Ability_Loop_10227101::ShieldMaterialName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ShieldMaterialShowCurve) == 0x000E90, "Member 'ACue_Ability_Loop_10227101::ShieldMaterialShowCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ShieldMaterialHideCurve) == 0x000E98, "Member 'ACue_Ability_Loop_10227101::ShieldMaterialHideCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, SprintShieldRaiseID) == 0x000EA0, "Member 'ACue_Ability_Loop_10227101::SprintShieldRaiseID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, SprintShieldReleaseID) == 0x000EA4, "Member 'ACue_Ability_Loop_10227101::SprintShieldReleaseID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, SprintShieldRaiseLoopID) == 0x000EA8, "Member 'ACue_Ability_Loop_10227101::SprintShieldRaiseLoopID' has a wrong offset!");

// Class Hero_1022.Cue_Ability_Loop_10227102
// 0x0000 (0x0F60 - 0x0F60)
class ACue_Ability_Loop_10227102 final : public AMarvelCueNotify_CaptainShadow
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10227102">();
	}
	static class ACue_Ability_Loop_10227102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10227102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10227102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10227102");
static_assert(sizeof(ACue_Ability_Loop_10227102) == 0x000F60, "Wrong size on ACue_Ability_Loop_10227102");

// Class Hero_1022.CaptainAmericaAnimInstance
// 0x0040 (0x0950 - 0x0910)
class UCaptainAmericaAnimInstance final : public UMarvelAnimInstance
{
public:
	class FString                                 ShieldMontageName;                                 // 0x0910(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShieldMontageLoopSectionName;                      // 0x0920(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShieldMontageLoopRunSectionName;                   // 0x092C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SmoothDirSpeed;                                    // 0x0938(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSprint;                                         // 0x093C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_93D[0x3];                                      // 0x093D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintDir;                                         // 0x0940(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSpecialJump;                                    // 0x0944(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSprintAndShieldRaised;                          // 0x0945(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpInAir;                                          // 0x0946(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsJumping;                                        // 0x0947(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFalling;                                          // 0x0948(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFlash;                                            // 0x0949(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFallingInPlace;                                 // 0x094A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnGround;                                         // 0x094B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintToGround;                                   // 0x094C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBackOnGround;                                     // 0x094D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94E[0x2];                                      // 0x094E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaAnimInstance">();
	}
	static class UCaptainAmericaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptainAmericaAnimInstance>();
	}
};
static_assert(alignof(UCaptainAmericaAnimInstance) == 0x000010, "Wrong alignment on UCaptainAmericaAnimInstance");
static_assert(sizeof(UCaptainAmericaAnimInstance) == 0x000950, "Wrong size on UCaptainAmericaAnimInstance");
static_assert(offsetof(UCaptainAmericaAnimInstance, ShieldMontageName) == 0x000910, "Member 'UCaptainAmericaAnimInstance::ShieldMontageName' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, ShieldMontageLoopSectionName) == 0x000920, "Member 'UCaptainAmericaAnimInstance::ShieldMontageLoopSectionName' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, ShieldMontageLoopRunSectionName) == 0x00092C, "Member 'UCaptainAmericaAnimInstance::ShieldMontageLoopRunSectionName' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, SmoothDirSpeed) == 0x000938, "Member 'UCaptainAmericaAnimInstance::SmoothDirSpeed' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsSprint) == 0x00093C, "Member 'UCaptainAmericaAnimInstance::bIsSprint' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, SprintDir) == 0x000940, "Member 'UCaptainAmericaAnimInstance::SprintDir' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsSpecialJump) == 0x000944, "Member 'UCaptainAmericaAnimInstance::bIsSpecialJump' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsSprintAndShieldRaised) == 0x000945, "Member 'UCaptainAmericaAnimInstance::bIsSprintAndShieldRaised' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bUpInAir) == 0x000946, "Member 'UCaptainAmericaAnimInstance::bUpInAir' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsJumping) == 0x000947, "Member 'UCaptainAmericaAnimInstance::bIsJumping' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bFalling) == 0x000948, "Member 'UCaptainAmericaAnimInstance::bFalling' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bFlash) == 0x000949, "Member 'UCaptainAmericaAnimInstance::bFlash' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsFallingInPlace) == 0x00094A, "Member 'UCaptainAmericaAnimInstance::bIsFallingInPlace' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bOnGround) == 0x00094B, "Member 'UCaptainAmericaAnimInstance::bOnGround' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bSprintToGround) == 0x00094C, "Member 'UCaptainAmericaAnimInstance::bSprintToGround' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bBackOnGround) == 0x00094D, "Member 'UCaptainAmericaAnimInstance::bBackOnGround' has a wrong offset!");

// Class Hero_1022.CaptainAmericaChildActor
// 0x0058 (0x0AB8 - 0x0A60)
class ACaptainAmericaChildActor final : public AMarvelCharacterChildActor
{
public:
	bool                                          bSprint;                                           // 0x0A60(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecialJump;                                      // 0x0A61(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalJump;                                       // 0x0A62(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlash;                                            // 0x0A63(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShieldSocket;                                      // 0x0A64(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     NormalShieldMaterial;                              // 0x0A70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SpecialShieldMaterial;                             // 0x0A78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Shield;                                            // 0x0A80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ThunderBuffFX;                                     // 0x0A88(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      RightHandArmorFX;                                  // 0x0A90(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ChestBackArmorFX;                                  // 0x0A98(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA0[0x18];                                     // 0x0AA0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USkeletalMeshComponent* GetShieldMesh();
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaChildActor">();
	}
	static class ACaptainAmericaChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptainAmericaChildActor>();
	}
};
static_assert(alignof(ACaptainAmericaChildActor) == 0x000008, "Wrong alignment on ACaptainAmericaChildActor");
static_assert(sizeof(ACaptainAmericaChildActor) == 0x000AB8, "Wrong size on ACaptainAmericaChildActor");
static_assert(offsetof(ACaptainAmericaChildActor, bSprint) == 0x000A60, "Member 'ACaptainAmericaChildActor::bSprint' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, bSpecialJump) == 0x000A61, "Member 'ACaptainAmericaChildActor::bSpecialJump' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, bNormalJump) == 0x000A62, "Member 'ACaptainAmericaChildActor::bNormalJump' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, bFlash) == 0x000A63, "Member 'ACaptainAmericaChildActor::bFlash' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, ShieldSocket) == 0x000A64, "Member 'ACaptainAmericaChildActor::ShieldSocket' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, NormalShieldMaterial) == 0x000A70, "Member 'ACaptainAmericaChildActor::NormalShieldMaterial' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, SpecialShieldMaterial) == 0x000A78, "Member 'ACaptainAmericaChildActor::SpecialShieldMaterial' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, Shield) == 0x000A80, "Member 'ACaptainAmericaChildActor::Shield' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, ThunderBuffFX) == 0x000A88, "Member 'ACaptainAmericaChildActor::ThunderBuffFX' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, RightHandArmorFX) == 0x000A90, "Member 'ACaptainAmericaChildActor::RightHandArmorFX' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, ChestBackArmorFX) == 0x000A98, "Member 'ACaptainAmericaChildActor::ChestBackArmorFX' has a wrong offset!");

// Class Hero_1022.CaptainAmericaCharacter
// 0x0010 (0x1820 - 0x1810)
class ACaptainAmericaCharacter : public AMarvelBaseCharacter
{
public:
	class UCaptainAmericaMoveLogicBaseComponent*  CaptainAmericaMoveLogic;                           // 0x1810(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsShieldActive;                                   // 0x1818(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1819[0x7];                                     // 0x1819(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceSetActorAndMeshRotation();
	class USkeletalMeshComponent* GetShieldMesh();
	void SetShieldActive(bool NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaCharacter">();
	}
	static class ACaptainAmericaCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptainAmericaCharacter>();
	}
};
static_assert(alignof(ACaptainAmericaCharacter) == 0x000010, "Wrong alignment on ACaptainAmericaCharacter");
static_assert(sizeof(ACaptainAmericaCharacter) == 0x001820, "Wrong size on ACaptainAmericaCharacter");
static_assert(offsetof(ACaptainAmericaCharacter, CaptainAmericaMoveLogic) == 0x001810, "Member 'ACaptainAmericaCharacter::CaptainAmericaMoveLogic' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaCharacter, bIsShieldActive) == 0x001818, "Member 'ACaptainAmericaCharacter::bIsShieldActive' has a wrong offset!");

// Class Hero_1022.CaptainAmericaMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UCaptainAmericaMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	void ResetBackwardWalkSpeedRatio();
	void SetBackwardWalkSpeedRatio(float NewBackwardWalkSpeedRatio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaMoveLogicBaseComponent">();
	}
	static class UCaptainAmericaMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptainAmericaMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UCaptainAmericaMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UCaptainAmericaMoveLogicBaseComponent");
static_assert(sizeof(UCaptainAmericaMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UCaptainAmericaMoveLogicBaseComponent");

// Class Hero_1022.CaptainAmericaMovementComponent
// 0x0000 (0x1B60 - 0x1B60)
class UCaptainAmericaMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaMovementComponent">();
	}
	static class UCaptainAmericaMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptainAmericaMovementComponent>();
	}
};
static_assert(alignof(UCaptainAmericaMovementComponent) == 0x000010, "Wrong alignment on UCaptainAmericaMovementComponent");
static_assert(sizeof(UCaptainAmericaMovementComponent) == 0x001B60, "Wrong size on UCaptainAmericaMovementComponent");

// Class Hero_1022.EpicMomentAction_1022
// 0x0010 (0x0130 - 0x0120)
class UEpicMomentAction_1022 : public UEpicMomentBaseAction
{
public:
	struct FEpicMomentNodeInfo                    ShieldConfig;                                      // 0x0120(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1022">();
	}
	static class UEpicMomentAction_1022* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1022>();
	}
};
static_assert(alignof(UEpicMomentAction_1022) == 0x000008, "Wrong alignment on UEpicMomentAction_1022");
static_assert(sizeof(UEpicMomentAction_1022) == 0x000130, "Wrong size on UEpicMomentAction_1022");
static_assert(offsetof(UEpicMomentAction_1022, ShieldConfig) == 0x000120, "Member 'UEpicMomentAction_1022::ShieldConfig' has a wrong offset!");

}

