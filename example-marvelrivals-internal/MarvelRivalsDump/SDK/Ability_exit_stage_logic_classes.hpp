#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Ability_exit_stage_logic

#include "Basic.hpp"

#include "Marvel_structs.hpp"
#include "MarvelAI_structs.hpp"
#include "MarvelAI_classes.hpp"


namespace SDK
{

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStageLogicBase
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStageLogicBase : public UAIAbilityExitStageLogic
{
public:
	void InitLogic();
	bool CheckLogic(const struct FAIAbilityUsage& AbilityUsage, class AMarvelAIController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStageLogicBase">();
	}
	static class UPyAIAbilityExitStageLogicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStageLogicBase>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStageLogicBase) == 0x000008, "Wrong alignment on UPyAIAbilityExitStageLogicBase");
//static_assert(sizeof(UPyAIAbilityExitStageLogicBase) == 0x000038, "Wrong size on UPyAIAbilityExitStageLogicBase");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanNotSeeTarget
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_CanNotSeeTarget final : public UPyAIAbilityExitStageLogicBase
{
public:
	bool                                          bShouldHaveSeenTarget;                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanNotSeeTarget">();
	}
	static class UPyAIAbilityExitStage_CanNotSeeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanNotSeeTarget>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_CanNotSeeTarget) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanNotSeeTarget");
//static_assert(sizeof(UPyAIAbilityExitStage_CanNotSeeTarget) == 0x000040, "Wrong size on UPyAIAbilityExitStage_CanNotSeeTarget");
//static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeTarget, bShouldHaveSeenTarget) == 0x000038, "Member 'UPyAIAbilityExitStage_CanNotSeeTarget::bShouldHaveSeenTarget' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_AbilityBreak
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_AbilityBreak : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_AbilityBreak">();
	}
	static class UPyAIAbilityExitStage_AbilityBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_AbilityBreak>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_AbilityBreak) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_AbilityBreak");
//static_assert(sizeof(UPyAIAbilityExitStage_AbilityBreak) == 0x000038, "Wrong size on UPyAIAbilityExitStage_AbilityBreak");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanNotExecute
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_CanNotExecute final : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanNotExecute">();
	}
	static class UPyAIAbilityExitStage_CanNotExecute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanNotExecute>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_CanNotExecute) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanNotExecute");
//static_assert(sizeof(UPyAIAbilityExitStage_CanNotExecute) == 0x000038, "Wrong size on UPyAIAbilityExitStage_CanNotExecute");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_AbilityPreMissile
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_AbilityPreMissile final : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_AbilityPreMissile">();
	}
	static class UPyAIAbilityExitStage_AbilityPreMissile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_AbilityPreMissile>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_AbilityPreMissile) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_AbilityPreMissile");
//static_assert(sizeof(UPyAIAbilityExitStage_AbilityPreMissile) == 0x000038, "Wrong size on UPyAIAbilityExitStage_AbilityPreMissile");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_NoEnemy
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_NoEnemy final : public UPyAIAbilityExitStageLogicBase
{
public:
	struct FRange_FloatValue                      CheckRadius;                                       // 0x0038(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_NoEnemy">();
	}
	static class UPyAIAbilityExitStage_NoEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_NoEnemy>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_NoEnemy) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_NoEnemy");
//static_assert(sizeof(UPyAIAbilityExitStage_NoEnemy) == 0x000040, "Wrong size on UPyAIAbilityExitStage_NoEnemy");
//static_assert(offsetof(UPyAIAbilityExitStage_NoEnemy, CheckRadius) == 0x000038, "Member 'UPyAIAbilityExitStage_NoEnemy::CheckRadius' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_AbilityMissile
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_AbilityMissile final : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_AbilityMissile">();
	}
	static class UPyAIAbilityExitStage_AbilityMissile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_AbilityMissile>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_AbilityMissile) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_AbilityMissile");
//static_assert(sizeof(UPyAIAbilityExitStage_AbilityMissile) == 0x000038, "Wrong size on UPyAIAbilityExitStage_AbilityMissile");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_AbilityEnd
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_AbilityEnd : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_AbilityEnd">();
	}
	static class UPyAIAbilityExitStage_AbilityEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_AbilityEnd>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_AbilityEnd) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_AbilityEnd");
//static_assert(sizeof(UPyAIAbilityExitStage_AbilityEnd) == 0x000038, "Wrong size on UPyAIAbilityExitStage_AbilityEnd");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanNotSeeTargetTimeLimit
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit final : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         TimeLimit;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHaveSeenTarget;                             // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanNotSeeTargetTimeLimit">();
	}
	static class UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit");
//static_assert(sizeof(UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit) == 0x000040, "Wrong size on UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit");
//static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit, TimeLimit) == 0x000038, "Member 'UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit::TimeLimit' has a wrong offset!");
//static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit, bShouldHaveSeenTarget) == 0x00003C, "Member 'UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit::bShouldHaveSeenTarget' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanNotSeeEnemy
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_CanNotSeeEnemy : public UPyAIAbilityExitStageLogicBase
{
public:
	bool                                          bShouldHaveSeenEnemy;                              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanNotSeeEnemy">();
	}
	static class UPyAIAbilityExitStage_CanNotSeeEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanNotSeeEnemy>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_CanNotSeeEnemy) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanNotSeeEnemy");
//static_assert(sizeof(UPyAIAbilityExitStage_CanNotSeeEnemy) == 0x000040, "Wrong size on UPyAIAbilityExitStage_CanNotSeeEnemy");
//static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeEnemy, bShouldHaveSeenEnemy) == 0x000038, "Member 'UPyAIAbilityExitStage_CanNotSeeEnemy::bShouldHaveSeenEnemy' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanSeeEnemy
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_CanSeeEnemy final : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanSeeEnemy">();
	}
	static class UPyAIAbilityExitStage_CanSeeEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanSeeEnemy>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_CanSeeEnemy) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanSeeEnemy");
//static_assert(sizeof(UPyAIAbilityExitStage_CanSeeEnemy) == 0x000038, "Wrong size on UPyAIAbilityExitStage_CanSeeEnemy");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanNotSeeEnemyTimeLimit
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit final : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         TimeLimit;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHaveSeenEnemy;                              // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanNotSeeEnemyTimeLimit">();
	}
	static class UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit");
//static_assert(sizeof(UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit) == 0x000040, "Wrong size on UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit");
//static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit, TimeLimit) == 0x000038, "Member 'UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit::TimeLimit' has a wrong offset!");
//static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit, bShouldHaveSeenEnemy) == 0x00003C, "Member 'UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit::bShouldHaveSeenEnemy' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_NearTarget
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_NearTarget : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         AccessRange;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_NearTarget">();
	}
	static class UPyAIAbilityExitStage_NearTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_NearTarget>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_NearTarget) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_NearTarget");
//static_assert(sizeof(UPyAIAbilityExitStage_NearTarget) == 0x000040, "Wrong size on UPyAIAbilityExitStage_NearTarget");
//static_assert(offsetof(UPyAIAbilityExitStage_NearTarget, AccessRange) == 0x000038, "Member 'UPyAIAbilityExitStage_NearTarget::AccessRange' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_TooCloseToEnemy
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_TooCloseToEnemy final : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         AccessRange;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_TooCloseToEnemy">();
	}
	static class UPyAIAbilityExitStage_TooCloseToEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_TooCloseToEnemy>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_TooCloseToEnemy) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_TooCloseToEnemy");
//static_assert(sizeof(UPyAIAbilityExitStage_TooCloseToEnemy) == 0x000040, "Wrong size on UPyAIAbilityExitStage_TooCloseToEnemy");
//static_assert(offsetof(UPyAIAbilityExitStage_TooCloseToEnemy, AccessRange) == 0x000038, "Member 'UPyAIAbilityExitStage_TooCloseToEnemy::AccessRange' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_VelocityLessThan
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_VelocityLessThan : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         Velocity;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_VelocityLessThan">();
	}
	static class UPyAIAbilityExitStage_VelocityLessThan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_VelocityLessThan>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_VelocityLessThan) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_VelocityLessThan");
//static_assert(sizeof(UPyAIAbilityExitStage_VelocityLessThan) == 0x000040, "Wrong size on UPyAIAbilityExitStage_VelocityLessThan");
//static_assert(offsetof(UPyAIAbilityExitStage_VelocityLessThan, Velocity) == 0x000038, "Member 'UPyAIAbilityExitStage_VelocityLessThan::Velocity' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_AmmoNumCheck
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_AmmoNumCheck final : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         AmmoNumThreshold;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAmmoClipType                                 AmmoType;                                          // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InverseResult;                                     // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_AmmoNumCheck">();
	}
	static class UPyAIAbilityExitStage_AmmoNumCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_AmmoNumCheck>();
	}
};
//static_assert(alignof(UPyAIAbilityExitStage_AmmoNumCheck) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_AmmoNumCheck");
//static_assert(sizeof(UPyAIAbilityExitStage_AmmoNumCheck) == 0x000040, "Wrong size on UPyAIAbilityExitStage_AmmoNumCheck");
//static_assert(offsetof(UPyAIAbilityExitStage_AmmoNumCheck, AmmoNumThreshold) == 0x000038, "Member 'UPyAIAbilityExitStage_AmmoNumCheck::AmmoNumThreshold' has a wrong offset!");
//static_assert(offsetof(UPyAIAbilityExitStage_AmmoNumCheck, AmmoType) == 0x00003C, "Member 'UPyAIAbilityExitStage_AmmoNumCheck::AmmoType' has a wrong offset!");
//static_assert(offsetof(UPyAIAbilityExitStage_AmmoNumCheck, InverseResult) == 0x00003D, "Member 'UPyAIAbilityExitStage_AmmoNumCheck::InverseResult' has a wrong offset!");

}

