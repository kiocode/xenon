#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1046

#include "Basic.hpp"

#include "Hero_1046_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Hero_1046.Config_104621
// 0x0078 (0x0110 - 0x0098)
class UConfig_104621 final : public UMarvelAbilityConfig
{
public:
	int32                                         ReloadAbilityID;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumeAmmosForEachEnergy;                         // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmitInterval;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GatherInterval;                                    // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileID;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ProjectileOffset;                                  // 0x00B0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104621">();
	}
	static class UConfig_104621* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104621>();
	}
};
static_assert(alignof(UConfig_104621) == 0x000010, "Wrong alignment on UConfig_104621");
static_assert(sizeof(UConfig_104621) == 0x000110, "Wrong size on UConfig_104621");
static_assert(offsetof(UConfig_104621, ReloadAbilityID) == 0x000098, "Member 'UConfig_104621::ReloadAbilityID' has a wrong offset!");
static_assert(offsetof(UConfig_104621, ConsumeAmmosForEachEnergy) == 0x00009C, "Member 'UConfig_104621::ConsumeAmmosForEachEnergy' has a wrong offset!");
static_assert(offsetof(UConfig_104621, EmitInterval) == 0x0000A0, "Member 'UConfig_104621::EmitInterval' has a wrong offset!");
static_assert(offsetof(UConfig_104621, GatherInterval) == 0x0000A4, "Member 'UConfig_104621::GatherInterval' has a wrong offset!");
static_assert(offsetof(UConfig_104621, ProjectileID) == 0x0000A8, "Member 'UConfig_104621::ProjectileID' has a wrong offset!");
static_assert(offsetof(UConfig_104621, ProjectileOffset) == 0x0000B0, "Member 'UConfig_104621::ProjectileOffset' has a wrong offset!");

// Class Hero_1046.Ability_104621
// 0x0020 (0x25B8 - 0x2598)
class UAbility_104621 : public UMarvelAbility_LongPressTrigger
{
public:
	FMulticastInlineDelegateProperty_             HasGatherEnergyBallNumDelegate;                    // 0x2598(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	int32                                         MaxEnergyBallNum;                                  // 0x25A8(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25AC[0xC];                                     // 0x25AC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxEnergyBallNum(int32 InNum);

	void OnAbilityActiveFailed(const class UGameplayAbility* InAbility, const struct FGameplayTagContainer& Tags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104621">();
	}
	static class UAbility_104621* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104621>();
	}
};
static_assert(alignof(UAbility_104621) == 0x000008, "Wrong alignment on UAbility_104621");
static_assert(sizeof(UAbility_104621) == 0x0025B8, "Wrong size on UAbility_104621");
static_assert(offsetof(UAbility_104621, HasGatherEnergyBallNumDelegate) == 0x002598, "Member 'UAbility_104621::HasGatherEnergyBallNumDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_104621, MaxEnergyBallNum) == 0x0025A8, "Member 'UAbility_104621::MaxEnergyBallNum' has a wrong offset!");

// Class Hero_1046.Cue_Ability_Loop_10462101
// 0x0140 (0x0F90 - 0x0E50)
class ACue_Ability_Loop_10462101 final : public AMarvelCueNotify_Ability
{
public:
	struct FGameplayTag                           DeactivateEventTag;                                // 0x0E50(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5C[0x4];                                      // 0x0E5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         ReleaseFXAsset;                                    // 0x0E60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         LoopFXAsset;                                       // 0x0E68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             ReleaseFXOffset;                                   // 0x0E70(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             LoopFXOffset;                                      // 0x0ED0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketAttachedName;                                // 0x0F30(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioSwitchGroup;                                  // 0x0F3C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioSwitchState;                                  // 0x0F48(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReleaseAudioID;                                    // 0x0F54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0F58(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     WeaponReleaseFX;                                   // 0x0F60(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     WeaponLoopFX;                                      // 0x0F68(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F70[0x8];                                      // 0x0F70(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_104621*                        OwningAbility;                                     // 0x0F78(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F80[0x10];                                     // 0x0F80(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10462101">();
	}
	static class ACue_Ability_Loop_10462101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10462101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10462101) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10462101");
static_assert(sizeof(ACue_Ability_Loop_10462101) == 0x000F90, "Wrong size on ACue_Ability_Loop_10462101");
static_assert(offsetof(ACue_Ability_Loop_10462101, DeactivateEventTag) == 0x000E50, "Member 'ACue_Ability_Loop_10462101::DeactivateEventTag' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, ReleaseFXAsset) == 0x000E60, "Member 'ACue_Ability_Loop_10462101::ReleaseFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, LoopFXAsset) == 0x000E68, "Member 'ACue_Ability_Loop_10462101::LoopFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, ReleaseFXOffset) == 0x000E70, "Member 'ACue_Ability_Loop_10462101::ReleaseFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, LoopFXOffset) == 0x000ED0, "Member 'ACue_Ability_Loop_10462101::LoopFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, SocketAttachedName) == 0x000F30, "Member 'ACue_Ability_Loop_10462101::SocketAttachedName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, AudioSwitchGroup) == 0x000F3C, "Member 'ACue_Ability_Loop_10462101::AudioSwitchGroup' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, AudioSwitchState) == 0x000F48, "Member 'ACue_Ability_Loop_10462101::AudioSwitchState' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, ReleaseAudioID) == 0x000F54, "Member 'ACue_Ability_Loop_10462101::ReleaseAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, OwnerCharacter) == 0x000F58, "Member 'ACue_Ability_Loop_10462101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, WeaponReleaseFX) == 0x000F60, "Member 'ACue_Ability_Loop_10462101::WeaponReleaseFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, WeaponLoopFX) == 0x000F68, "Member 'ACue_Ability_Loop_10462101::WeaponLoopFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, OwningAbility) == 0x000F78, "Member 'ACue_Ability_Loop_10462101::OwningAbility' has a wrong offset!");

// Class Hero_1046.AnimNotify_SpawnProjectileFromWeapon
// 0x0010 (0x0088 - 0x0078)
class UAnimNotify_SpawnProjectileFromWeapon final : public UAnimNotify_SpawnProjectile
{
public:
	class FName                                   WeaponSocketName;                                  // 0x0078(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SpawnProjectileFromWeapon">();
	}
	static class UAnimNotify_SpawnProjectileFromWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SpawnProjectileFromWeapon>();
	}
};
static_assert(alignof(UAnimNotify_SpawnProjectileFromWeapon) == 0x000008, "Wrong alignment on UAnimNotify_SpawnProjectileFromWeapon");
static_assert(sizeof(UAnimNotify_SpawnProjectileFromWeapon) == 0x000088, "Wrong size on UAnimNotify_SpawnProjectileFromWeapon");
static_assert(offsetof(UAnimNotify_SpawnProjectileFromWeapon, WeaponSocketName) == 0x000078, "Member 'UAnimNotify_SpawnProjectileFromWeapon::WeaponSocketName' has a wrong offset!");

// Class Hero_1046.AnimNotify_WeaponPlayNiagaraEffectEx
// 0x0000 (0x0360 - 0x0360)
class UAnimNotify_WeaponPlayNiagaraEffectEx final : public UAnimNotify_PlayNiagaraEffectEx
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WeaponPlayNiagaraEffectEx">();
	}
	static class UAnimNotify_WeaponPlayNiagaraEffectEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WeaponPlayNiagaraEffectEx>();
	}
};
static_assert(alignof(UAnimNotify_WeaponPlayNiagaraEffectEx) == 0x000010, "Wrong alignment on UAnimNotify_WeaponPlayNiagaraEffectEx");
static_assert(sizeof(UAnimNotify_WeaponPlayNiagaraEffectEx) == 0x000360, "Wrong size on UAnimNotify_WeaponPlayNiagaraEffectEx");

// Class Hero_1046.Config_104641
// 0x1128 (0x11C0 - 0x0098)
class UConfig_104641 final : public UMarvelAbilityConfig
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSelectTaskParam                       SelectTaskParams;                                  // 0x00A0(0x10A0)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bCanSelectPreTarget;                               // 0x1140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1141[0x3];                                     // 0x1141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TreatmentBuffID;                                   // 0x1144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBounceTime;                                     // 0x1148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreatmentAttenuation;                              // 0x114C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETreatPriorityType                            PriorityOne;                                       // 0x1150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETreatPriorityType                            PriorityTwo;                                       // 0x1151(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETreatPriorityType                            PriorityThree;                                     // 0x1152(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETreatPriorityType                            PriorityFour;                                      // 0x1153(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1154[0x4];                                     // 0x1154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagContainer;                                      // 0x1158(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104641">();
	}
	static class UConfig_104641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104641>();
	}
};
static_assert(alignof(UConfig_104641) == 0x000010, "Wrong alignment on UConfig_104641");
static_assert(sizeof(UConfig_104641) == 0x0011C0, "Wrong size on UConfig_104641");
static_assert(offsetof(UConfig_104641, SelectTaskParams) == 0x0000A0, "Member 'UConfig_104641::SelectTaskParams' has a wrong offset!");
static_assert(offsetof(UConfig_104641, bCanSelectPreTarget) == 0x001140, "Member 'UConfig_104641::bCanSelectPreTarget' has a wrong offset!");
static_assert(offsetof(UConfig_104641, TreatmentBuffID) == 0x001144, "Member 'UConfig_104641::TreatmentBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104641, MaxBounceTime) == 0x001148, "Member 'UConfig_104641::MaxBounceTime' has a wrong offset!");
static_assert(offsetof(UConfig_104641, TreatmentAttenuation) == 0x00114C, "Member 'UConfig_104641::TreatmentAttenuation' has a wrong offset!");
static_assert(offsetof(UConfig_104641, PriorityOne) == 0x001150, "Member 'UConfig_104641::PriorityOne' has a wrong offset!");
static_assert(offsetof(UConfig_104641, PriorityTwo) == 0x001151, "Member 'UConfig_104641::PriorityTwo' has a wrong offset!");
static_assert(offsetof(UConfig_104641, PriorityThree) == 0x001152, "Member 'UConfig_104641::PriorityThree' has a wrong offset!");
static_assert(offsetof(UConfig_104641, PriorityFour) == 0x001153, "Member 'UConfig_104641::PriorityFour' has a wrong offset!");
static_assert(offsetof(UConfig_104641, TagContainer) == 0x001158, "Member 'UConfig_104641::TagContainer' has a wrong offset!");

// Class Hero_1046.Ability_104641
// 0x0190 (0x2718 - 0x2588)
class UAbility_104641 : public UAbility_108
{
public:
	class UMarvelAbilityTask_SelectTarget*        SelectTargetTask;                                  // 0x2588(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104641*                         Config;                                            // 0x2590(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             FirstTreatResult;                                  // 0x2598(0x0170)(Net, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TreatNextTargetDelegate;                           // 0x2708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104641">();
	}
	static class UAbility_104641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104641>();
	}
};
static_assert(alignof(UAbility_104641) == 0x000008, "Wrong alignment on UAbility_104641");
static_assert(sizeof(UAbility_104641) == 0x002718, "Wrong size on UAbility_104641");
static_assert(offsetof(UAbility_104641, SelectTargetTask) == 0x002588, "Member 'UAbility_104641::SelectTargetTask' has a wrong offset!");
static_assert(offsetof(UAbility_104641, Config) == 0x002590, "Member 'UAbility_104641::Config' has a wrong offset!");
static_assert(offsetof(UAbility_104641, FirstTreatResult) == 0x002598, "Member 'UAbility_104641::FirstTreatResult' has a wrong offset!");
static_assert(offsetof(UAbility_104641, TreatNextTargetDelegate) == 0x002708, "Member 'UAbility_104641::TreatNextTargetDelegate' has a wrong offset!");

// Class Hero_1046.Scope_10464101
// 0x01F0 (0x18F0 - 0x1700)
class AScope_10464101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	class UAbility_104641*                        OwnerAbility;                                      // 0x1700(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104641*                         AbilityConfig;                                     // 0x1708(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x1710(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ACharacter*>                     TreatedTargets;                                    // 0x1718(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1728[0x28];                                    // 0x1728(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             FirstTreatTarget;                                  // 0x1750(0x0170)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FTreatTarget_104641                    NextTreatTarget;                                   // 0x18C0(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D0[0x20];                                    // 0x18D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FirstTreatTarget();
	void OnRep_NextTreatTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10464101">();
	}
	static class AScope_10464101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10464101>();
	}
};
static_assert(alignof(AScope_10464101) == 0x000010, "Wrong alignment on AScope_10464101");
static_assert(sizeof(AScope_10464101) == 0x0018F0, "Wrong size on AScope_10464101");
static_assert(offsetof(AScope_10464101, OwnerAbility) == 0x001700, "Member 'AScope_10464101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(AScope_10464101, AbilityConfig) == 0x001708, "Member 'AScope_10464101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(AScope_10464101, OwnerCharacter) == 0x001710, "Member 'AScope_10464101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AScope_10464101, TreatedTargets) == 0x001718, "Member 'AScope_10464101::TreatedTargets' has a wrong offset!");
static_assert(offsetof(AScope_10464101, FirstTreatTarget) == 0x001750, "Member 'AScope_10464101::FirstTreatTarget' has a wrong offset!");
static_assert(offsetof(AScope_10464101, NextTreatTarget) == 0x0018C0, "Member 'AScope_10464101::NextTreatTarget' has a wrong offset!");

// Class Hero_1046.TraceComponent_10464101
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10464101 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10464101">();
	}
	static class UTraceComponent_10464101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10464101>();
	}
};
static_assert(alignof(UTraceComponent_10464101) == 0x000010, "Wrong alignment on UTraceComponent_10464101");
static_assert(sizeof(UTraceComponent_10464101) == 0x001710, "Wrong size on UTraceComponent_10464101");

// Class Hero_1046.Cue_Buff_10464101
// 0x0008 (0x1040 - 0x1038)
class ACue_Buff_10464101 final : public AMarvelCueNotify_Buff
{
public:
	class UFXSystemAsset*                         HealEffect;                                        // 0x1038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10464101">();
	}
	static class ACue_Buff_10464101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10464101>();
	}
};
static_assert(alignof(ACue_Buff_10464101) == 0x000008, "Wrong alignment on ACue_Buff_10464101");
static_assert(sizeof(ACue_Buff_10464101) == 0x001040, "Wrong size on ACue_Buff_10464101");
static_assert(offsetof(ACue_Buff_10464101, HealEffect) == 0x001038, "Member 'ACue_Buff_10464101::HealEffect' has a wrong offset!");

// Class Hero_1046.Cue_Scope_Loop_10464101
// 0x0090 (0x0E00 - 0x0D70)
class ACue_Scope_Loop_10464101 final : public AMarvelCueNotify_Scope
{
public:
	class UAbility_104641*                        OwnerAbility;                                      // 0x0D70(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AScope_10464101*                        OwningScope;                                       // 0x0D78(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0D80(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         LinkEffectTemplate;                                // 0x0D88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         LinkEffectTemplateSelf;                            // 0x0D90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         HealthEffectTemplate;                              // 0x0D98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinkEffectPair>                LinkEffects;                                       // 0x0DA0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                FirstLinkEffectOffset;                             // 0x0DB0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstLinkEffectSocketName;                         // 0x0DC8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD4[0x4];                                      // 0x0DD4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LinkEffectOffset;                                  // 0x0DD8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LinkEffectSocketName;                              // 0x0DF0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DFC[0x4];                                      // 0x0DFC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SpawnLinkEffect(class ACharacter* FromCharacter, class ACharacter* ToCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10464101">();
	}
	static class ACue_Scope_Loop_10464101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10464101>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10464101) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10464101");
static_assert(sizeof(ACue_Scope_Loop_10464101) == 0x000E00, "Wrong size on ACue_Scope_Loop_10464101");
static_assert(offsetof(ACue_Scope_Loop_10464101, OwnerAbility) == 0x000D70, "Member 'ACue_Scope_Loop_10464101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, OwningScope) == 0x000D78, "Member 'ACue_Scope_Loop_10464101::OwningScope' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, OwnerCharacter) == 0x000D80, "Member 'ACue_Scope_Loop_10464101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, LinkEffectTemplate) == 0x000D88, "Member 'ACue_Scope_Loop_10464101::LinkEffectTemplate' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, LinkEffectTemplateSelf) == 0x000D90, "Member 'ACue_Scope_Loop_10464101::LinkEffectTemplateSelf' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, HealthEffectTemplate) == 0x000D98, "Member 'ACue_Scope_Loop_10464101::HealthEffectTemplate' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, LinkEffects) == 0x000DA0, "Member 'ACue_Scope_Loop_10464101::LinkEffects' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, FirstLinkEffectOffset) == 0x000DB0, "Member 'ACue_Scope_Loop_10464101::FirstLinkEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, FirstLinkEffectSocketName) == 0x000DC8, "Member 'ACue_Scope_Loop_10464101::FirstLinkEffectSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, LinkEffectOffset) == 0x000DD8, "Member 'ACue_Scope_Loop_10464101::LinkEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, LinkEffectSocketName) == 0x000DF0, "Member 'ACue_Scope_Loop_10464101::LinkEffectSocketName' has a wrong offset!");

// Class Hero_1046.Cue_Ability_Instant_10464101
// 0x0000 (0x0368 - 0x0368)
class UCue_Ability_Instant_10464101 final : public UMarvelCueNotify_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Instant_10464101">();
	}
	static class UCue_Ability_Instant_10464101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Ability_Instant_10464101>();
	}
};
static_assert(alignof(UCue_Ability_Instant_10464101) == 0x000008, "Wrong alignment on UCue_Ability_Instant_10464101");
static_assert(sizeof(UCue_Ability_Instant_10464101) == 0x000368, "Wrong size on UCue_Ability_Instant_10464101");

// Class Hero_1046.Config_104651
// 0x0030 (0x00C8 - 0x0098)
class UConfig_104651 final : public UMarvelAbilityConfig
{
public:
	float                                         BuffRemoveDelay;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHealthRatioForRemoveBuff;                       // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SymbioticScopeID;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SymbioticBuffID;                                   // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDeltaRadius;                                  // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinkTargetPerTarget;                            // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HealthLinkTreatBuffID;                             // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLinkSelf;                                         // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           EffectTag;                                         // 0x00B8(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104651">();
	}
	static class UConfig_104651* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104651>();
	}
};
static_assert(alignof(UConfig_104651) == 0x000008, "Wrong alignment on UConfig_104651");
static_assert(sizeof(UConfig_104651) == 0x0000C8, "Wrong size on UConfig_104651");
static_assert(offsetof(UConfig_104651, BuffRemoveDelay) == 0x000098, "Member 'UConfig_104651::BuffRemoveDelay' has a wrong offset!");
static_assert(offsetof(UConfig_104651, MinHealthRatioForRemoveBuff) == 0x00009C, "Member 'UConfig_104651::MinHealthRatioForRemoveBuff' has a wrong offset!");
static_assert(offsetof(UConfig_104651, SymbioticScopeID) == 0x0000A0, "Member 'UConfig_104651::SymbioticScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_104651, SymbioticBuffID) == 0x0000A4, "Member 'UConfig_104651::SymbioticBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104651, TraceDeltaRadius) == 0x0000A8, "Member 'UConfig_104651::TraceDeltaRadius' has a wrong offset!");
static_assert(offsetof(UConfig_104651, MaxLinkTargetPerTarget) == 0x0000AC, "Member 'UConfig_104651::MaxLinkTargetPerTarget' has a wrong offset!");
static_assert(offsetof(UConfig_104651, HealthLinkTreatBuffID) == 0x0000B0, "Member 'UConfig_104651::HealthLinkTreatBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104651, bLinkSelf) == 0x0000B4, "Member 'UConfig_104651::bLinkSelf' has a wrong offset!");
static_assert(offsetof(UConfig_104651, EffectTag) == 0x0000B8, "Member 'UConfig_104651::EffectTag' has a wrong offset!");

// Class Hero_1046.Ability_104651
// 0x0010 (0x2598 - 0x2588)
class UAbility_104651 : public UAbility_108
{
public:
	uint8                                         Pad_2588[0x10];                                    // 0x2588(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOriginLinkGroupEnd(const class AActor* BuffInstigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104651">();
	}
	static class UAbility_104651* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104651>();
	}
};
static_assert(alignof(UAbility_104651) == 0x000008, "Wrong alignment on UAbility_104651");
static_assert(sizeof(UAbility_104651) == 0x002598, "Wrong size on UAbility_104651");

// Class Hero_1046.Scope_10465102
// 0x0050 (0x1750 - 0x1700)
class AScope_10465102 final : public AMarvelAbilityTargetActor_Scope
{
public:
	class UAbility_104651*                        OwnerAbility;                                      // 0x1700(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104651*                         AbilityConfig;                                     // 0x1708(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x1710(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelBaseAbilitySystemComponent*      OwnerABS;                                          // 0x1718(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinkedBuffInfo>                LinkedTargetsInfo;                                 // 0x1720(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         LinkTargets;                                       // 0x1730(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1740[0x10];                                    // 0x1740(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10465102">();
	}
	static class AScope_10465102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10465102>();
	}
};
static_assert(alignof(AScope_10465102) == 0x000010, "Wrong alignment on AScope_10465102");
static_assert(sizeof(AScope_10465102) == 0x001750, "Wrong size on AScope_10465102");
static_assert(offsetof(AScope_10465102, OwnerAbility) == 0x001700, "Member 'AScope_10465102::OwnerAbility' has a wrong offset!");
static_assert(offsetof(AScope_10465102, AbilityConfig) == 0x001708, "Member 'AScope_10465102::AbilityConfig' has a wrong offset!");
static_assert(offsetof(AScope_10465102, OwnerCharacter) == 0x001710, "Member 'AScope_10465102::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AScope_10465102, OwnerABS) == 0x001718, "Member 'AScope_10465102::OwnerABS' has a wrong offset!");
static_assert(offsetof(AScope_10465102, LinkedTargetsInfo) == 0x001720, "Member 'AScope_10465102::LinkedTargetsInfo' has a wrong offset!");
static_assert(offsetof(AScope_10465102, LinkTargets) == 0x001730, "Member 'AScope_10465102::LinkTargets' has a wrong offset!");

// Class Hero_1046.HealthLinkAbility_104651
// 0x0028 (0x1140 - 0x1118)
class UHealthLinkAbility_104651 : public UMarvelHealthLinkAbility
{
public:
	float                                         MinHealthRatio;                                    // 0x1118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111C[0x14];                                    // 0x111C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelBaseAbilitySystemComponent*      OwnerASC;                                          // 0x1130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelBaseAbilitySystemComponent*      InstigatorASC;                                     // 0x1138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthLinkAbility_104651">();
	}
	static class UHealthLinkAbility_104651* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthLinkAbility_104651>();
	}
};
static_assert(alignof(UHealthLinkAbility_104651) == 0x000008, "Wrong alignment on UHealthLinkAbility_104651");
static_assert(sizeof(UHealthLinkAbility_104651) == 0x001140, "Wrong size on UHealthLinkAbility_104651");
static_assert(offsetof(UHealthLinkAbility_104651, MinHealthRatio) == 0x001118, "Member 'UHealthLinkAbility_104651::MinHealthRatio' has a wrong offset!");
static_assert(offsetof(UHealthLinkAbility_104651, OwnerASC) == 0x001130, "Member 'UHealthLinkAbility_104651::OwnerASC' has a wrong offset!");
static_assert(offsetof(UHealthLinkAbility_104651, InstigatorASC) == 0x001138, "Member 'UHealthLinkAbility_104651::InstigatorASC' has a wrong offset!");

// Class Hero_1046.Cue_Scope_Loop_10465102
// 0x0050 (0x0DC0 - 0x0D70)
class ACue_Scope_Loop_10465102 final : public AMarvelCueNotify_Scope
{
public:
	class UMaterialInterface*                     RangeMaterial;                                     // 0x0D70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalInnerRadius;                                  // 0x0D78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DecalVisible;                                      // 0x0D7C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7D[0x3];                                      // 0x0D7D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDecalSizeYZ;                                   // 0x0D80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D84[0x4];                                      // 0x0D84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ViewTarget;                                        // 0x0D88(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AScope_10465102*                        OwnerScope;                                        // 0x0D90(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAgentTraceComponent*             TraceComponent;                                    // 0x0D98(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0DA0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               RangeMID;                                          // 0x0DA8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        RangeDecal;                                        // 0x0DB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB8[0x8];                                      // 0x0DB8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10465102">();
	}
	static class ACue_Scope_Loop_10465102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10465102>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10465102) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10465102");
static_assert(sizeof(ACue_Scope_Loop_10465102) == 0x000DC0, "Wrong size on ACue_Scope_Loop_10465102");
static_assert(offsetof(ACue_Scope_Loop_10465102, RangeMaterial) == 0x000D70, "Member 'ACue_Scope_Loop_10465102::RangeMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, DecalInnerRadius) == 0x000D78, "Member 'ACue_Scope_Loop_10465102::DecalInnerRadius' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, DecalVisible) == 0x000D7C, "Member 'ACue_Scope_Loop_10465102::DecalVisible' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, BaseDecalSizeYZ) == 0x000D80, "Member 'ACue_Scope_Loop_10465102::BaseDecalSizeYZ' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, ViewTarget) == 0x000D88, "Member 'ACue_Scope_Loop_10465102::ViewTarget' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, OwnerScope) == 0x000D90, "Member 'ACue_Scope_Loop_10465102::OwnerScope' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, TraceComponent) == 0x000D98, "Member 'ACue_Scope_Loop_10465102::TraceComponent' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, OwnerCharacter) == 0x000DA0, "Member 'ACue_Scope_Loop_10465102::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, RangeMID) == 0x000DA8, "Member 'ACue_Scope_Loop_10465102::RangeMID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, RangeDecal) == 0x000DB0, "Member 'ACue_Scope_Loop_10465102::RangeDecal' has a wrong offset!");

// Class Hero_1046.Cue_Ability_Loop_10465101
// 0x0058 (0x0EA8 - 0x0E50)
class ACue_Ability_Loop_10465101 final : public AMarvelCueNotify_Ability
{
public:
	class UFXSystemAsset*                         LinkEffectTemplate;                                // 0x0E50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LinkEffectOffset;                                  // 0x0E58(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LinkEffectSocketName;                              // 0x0E70(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponAttachedSocketName;                          // 0x0E7C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbility_104651*                        OwnerAbility;                                      // 0x0E88(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0E90(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinkEffectPair>                LinkEffects;                                       // 0x0E98(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void SpawnLinkEffects(const TArray<class AActor*>& LinkTargets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10465101">();
	}
	static class ACue_Ability_Loop_10465101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10465101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10465101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10465101");
static_assert(sizeof(ACue_Ability_Loop_10465101) == 0x000EA8, "Wrong size on ACue_Ability_Loop_10465101");
static_assert(offsetof(ACue_Ability_Loop_10465101, LinkEffectTemplate) == 0x000E50, "Member 'ACue_Ability_Loop_10465101::LinkEffectTemplate' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, LinkEffectOffset) == 0x000E58, "Member 'ACue_Ability_Loop_10465101::LinkEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, LinkEffectSocketName) == 0x000E70, "Member 'ACue_Ability_Loop_10465101::LinkEffectSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, WeaponAttachedSocketName) == 0x000E7C, "Member 'ACue_Ability_Loop_10465101::WeaponAttachedSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, OwnerAbility) == 0x000E88, "Member 'ACue_Ability_Loop_10465101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, OwnerCharacter) == 0x000E90, "Member 'ACue_Ability_Loop_10465101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, LinkEffects) == 0x000E98, "Member 'ACue_Ability_Loop_10465101::LinkEffects' has a wrong offset!");

// Class Hero_1046.Cue_Buff_10465101
// 0x00C0 (0x10F8 - 0x1038)
class ACue_Buff_10465101 final : public AMarvelCueNotify_Buff
{
public:
	class FName                                   TopParamName;                                      // 0x1038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomParamName;                                   // 0x1044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TopBoneName;                                       // 0x1050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomBoneName;                                    // 0x105C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpenParamName;                                     // 0x1068(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickUpdateParam;                                  // 0x1074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1075[0x3];                                     // 0x1075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FadeParamName;                                     // 0x1078(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x1084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         LinkEffectTemp;                                    // 0x1088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LinkEffectEndPoint;                                // 0x1090(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LinkEffectStartPoint;                              // 0x109C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x10A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinkEffectPair                        LinkEffectPair;                                    // 0x10B0(0x0020)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D0[0x28];                                    // 0x10D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBuffOwnerDeath(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10465101">();
	}
	static class ACue_Buff_10465101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10465101>();
	}
};
static_assert(alignof(ACue_Buff_10465101) == 0x000008, "Wrong alignment on ACue_Buff_10465101");
static_assert(sizeof(ACue_Buff_10465101) == 0x0010F8, "Wrong size on ACue_Buff_10465101");
static_assert(offsetof(ACue_Buff_10465101, TopParamName) == 0x001038, "Member 'ACue_Buff_10465101::TopParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, BottomParamName) == 0x001044, "Member 'ACue_Buff_10465101::BottomParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, TopBoneName) == 0x001050, "Member 'ACue_Buff_10465101::TopBoneName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, BottomBoneName) == 0x00105C, "Member 'ACue_Buff_10465101::BottomBoneName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, OpenParamName) == 0x001068, "Member 'ACue_Buff_10465101::OpenParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, bTickUpdateParam) == 0x001074, "Member 'ACue_Buff_10465101::bTickUpdateParam' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, FadeParamName) == 0x001078, "Member 'ACue_Buff_10465101::FadeParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, FadeTime) == 0x001084, "Member 'ACue_Buff_10465101::FadeTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, LinkEffectTemp) == 0x001088, "Member 'ACue_Buff_10465101::LinkEffectTemp' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, LinkEffectEndPoint) == 0x001090, "Member 'ACue_Buff_10465101::LinkEffectEndPoint' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, LinkEffectStartPoint) == 0x00109C, "Member 'ACue_Buff_10465101::LinkEffectStartPoint' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, NiagaraComponent) == 0x0010A8, "Member 'ACue_Buff_10465101::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, LinkEffectPair) == 0x0010B0, "Member 'ACue_Buff_10465101::LinkEffectPair' has a wrong offset!");

// Class Hero_1046.Ability_104661
// 0x00D0 (0x5CD0 - 0x5C00)
class UAbility_104661 : public UMarvelAeroBaseAbility
{
public:
	struct FTransform                             TraceStartTransform;                               // 0x5C00(0x0060)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             TraceEndTransform;                                 // 0x5C60(0x0060)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ResurrectedActors;                                 // 0x5CC0(0x0010)(BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	bool GetTraceTransform();
	void SetResurrectedActors(const TArray<int32>& InActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104661">();
	}
	static class UAbility_104661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104661>();
	}
};
static_assert(alignof(UAbility_104661) == 0x000010, "Wrong alignment on UAbility_104661");
static_assert(sizeof(UAbility_104661) == 0x005CD0, "Wrong size on UAbility_104661");
static_assert(offsetof(UAbility_104661, TraceStartTransform) == 0x005C00, "Member 'UAbility_104661::TraceStartTransform' has a wrong offset!");
static_assert(offsetof(UAbility_104661, TraceEndTransform) == 0x005C60, "Member 'UAbility_104661::TraceEndTransform' has a wrong offset!");
static_assert(offsetof(UAbility_104661, ResurrectedActors) == 0x005CC0, "Member 'UAbility_104661::ResurrectedActors' has a wrong offset!");

// Class Hero_1046.ResurrectionAbility_10466101
// 0x0018 (0x11A8 - 0x1190)
class UResurrectionAbility_10466101 : public UMarvelBaseResurrectionAbility
{
public:
	float                                         MaxResurrectionHeight;                             // 0x1190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResurrectionAreaRadius;                            // 0x1194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPositionSearchTime;                             // 0x1198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionDetectHeight;                             // 0x119C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathAnimationTime;                                // 0x11A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A4[0x4];                                     // 0x11A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResurrectionAbility_10466101">();
	}
	static class UResurrectionAbility_10466101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResurrectionAbility_10466101>();
	}
};
static_assert(alignof(UResurrectionAbility_10466101) == 0x000008, "Wrong alignment on UResurrectionAbility_10466101");
static_assert(sizeof(UResurrectionAbility_10466101) == 0x0011A8, "Wrong size on UResurrectionAbility_10466101");
static_assert(offsetof(UResurrectionAbility_10466101, MaxResurrectionHeight) == 0x001190, "Member 'UResurrectionAbility_10466101::MaxResurrectionHeight' has a wrong offset!");
static_assert(offsetof(UResurrectionAbility_10466101, ResurrectionAreaRadius) == 0x001194, "Member 'UResurrectionAbility_10466101::ResurrectionAreaRadius' has a wrong offset!");
static_assert(offsetof(UResurrectionAbility_10466101, MaxPositionSearchTime) == 0x001198, "Member 'UResurrectionAbility_10466101::MaxPositionSearchTime' has a wrong offset!");
static_assert(offsetof(UResurrectionAbility_10466101, OcclusionDetectHeight) == 0x00119C, "Member 'UResurrectionAbility_10466101::OcclusionDetectHeight' has a wrong offset!");
static_assert(offsetof(UResurrectionAbility_10466101, DeathAnimationTime) == 0x0011A0, "Member 'UResurrectionAbility_10466101::DeathAnimationTime' has a wrong offset!");

// Class Hero_1046.EffectAbility_104661
// 0x0008 (0x1100 - 0x10F8)
class UEffectAbility_104661 : public UMarvelEffectGameplayAbility
{
public:
	uint8                                         Pad_10F8[0x8];                                     // 0x10F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StopKillCamImmediately(bool bSet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectAbility_104661">();
	}
	static class UEffectAbility_104661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectAbility_104661>();
	}
};
static_assert(alignof(UEffectAbility_104661) == 0x000008, "Wrong alignment on UEffectAbility_104661");
static_assert(sizeof(UEffectAbility_104661) == 0x001100, "Wrong size on UEffectAbility_104661");

// Class Hero_1046.Summoned_10466101
// 0x0020 (0x08B0 - 0x0890)
class ASummoned_10466101 : public AMarvelSummonerBase
{
public:
	struct FVector                                InitLocation;                                      // 0x0890(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A8[0x8];                                      // 0x08A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10466101">();
	}
	static class ASummoned_10466101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10466101>();
	}
};
static_assert(alignof(ASummoned_10466101) == 0x000010, "Wrong alignment on ASummoned_10466101");
static_assert(sizeof(ASummoned_10466101) == 0x0008B0, "Wrong size on ASummoned_10466101");
static_assert(offsetof(ASummoned_10466101, InitLocation) == 0x000890, "Member 'ASummoned_10466101::InitLocation' has a wrong offset!");

// Class Hero_1046.Cue_Buff_10466103
// 0x00A8 (0x10F8 - 0x1050)
class ACue_Buff_10466103 final : public ACue_Buff_Resurrection
{
public:
	class UTexture2D*                             Icon;                                              // 0x1050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OnRespawningText;                                  // 0x1058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   OnRespawningFinishText;                            // 0x1070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   OnRespawningAbortText;                             // 0x1088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     RevivingMaterial;                                  // 0x10A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightColumnDelay;                                  // 0x10A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10AC[0x4];                                     // 0x10AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         LightColumnAsset;                                  // 0x10B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         ExplodeFXAsset;                                    // 0x10B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TextureParamName;                                  // 0x10C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ResurrectionAudioID;                               // 0x10D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D4[0x1C];                                    // 0x10D4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterAudioComponent*               AudioComp;                                         // 0x10F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOwnerRebornReset(class AActor* Target, const struct FCharacterRebornParam& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10466103">();
	}
	static class ACue_Buff_10466103* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10466103>();
	}
};
static_assert(alignof(ACue_Buff_10466103) == 0x000008, "Wrong alignment on ACue_Buff_10466103");
static_assert(sizeof(ACue_Buff_10466103) == 0x0010F8, "Wrong size on ACue_Buff_10466103");
static_assert(offsetof(ACue_Buff_10466103, Icon) == 0x001050, "Member 'ACue_Buff_10466103::Icon' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, OnRespawningText) == 0x001058, "Member 'ACue_Buff_10466103::OnRespawningText' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, OnRespawningFinishText) == 0x001070, "Member 'ACue_Buff_10466103::OnRespawningFinishText' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, OnRespawningAbortText) == 0x001088, "Member 'ACue_Buff_10466103::OnRespawningAbortText' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, RevivingMaterial) == 0x0010A0, "Member 'ACue_Buff_10466103::RevivingMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, LightColumnDelay) == 0x0010A8, "Member 'ACue_Buff_10466103::LightColumnDelay' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, LightColumnAsset) == 0x0010B0, "Member 'ACue_Buff_10466103::LightColumnAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, ExplodeFXAsset) == 0x0010B8, "Member 'ACue_Buff_10466103::ExplodeFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, TextureParamName) == 0x0010C0, "Member 'ACue_Buff_10466103::TextureParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, ResurrectionAudioID) == 0x0010D0, "Member 'ACue_Buff_10466103::ResurrectionAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, AudioComp) == 0x0010F0, "Member 'ACue_Buff_10466103::AudioComp' has a wrong offset!");

// Class Hero_1046.Cue_Scope_Loop_10466101
// 0x0128 (0x0E98 - 0x0D70)
class ACue_Scope_Loop_10466101 final : public AMarvelCueNotify_Scope
{
public:
	float                                         UpdateFXInterval;                                  // 0x0D70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D74[0x4];                                      // 0x0D74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWidgetStyle_BattleTransientTip        TipEnter;                                          // 0x0D78(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FWidgetStyle_BattleTransientTip        TipLeave;                                          // 0x0DC0(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_E08[0x28];                                     // 0x0E08(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_104661*                        Ability_104661;                                    // 0x0E30(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           PreTracedActors;                                   // 0x0E38(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E88[0x10];                                     // 0x0E88(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10466101">();
	}
	static class ACue_Scope_Loop_10466101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10466101>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10466101) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10466101");
static_assert(sizeof(ACue_Scope_Loop_10466101) == 0x000E98, "Wrong size on ACue_Scope_Loop_10466101");
static_assert(offsetof(ACue_Scope_Loop_10466101, UpdateFXInterval) == 0x000D70, "Member 'ACue_Scope_Loop_10466101::UpdateFXInterval' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10466101, TipEnter) == 0x000D78, "Member 'ACue_Scope_Loop_10466101::TipEnter' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10466101, TipLeave) == 0x000DC0, "Member 'ACue_Scope_Loop_10466101::TipLeave' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10466101, Ability_104661) == 0x000E30, "Member 'ACue_Scope_Loop_10466101::Ability_104661' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10466101, PreTracedActors) == 0x000E38, "Member 'ACue_Scope_Loop_10466101::PreTracedActors' has a wrong offset!");

// Class Hero_1046.AdamWarlockAnimInstance
// 0x0010 (0x0920 - 0x0910)
class UAdamWarlockAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsInSoulStatus;                                   // 0x0910(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_911[0xF];                                      // 0x0911(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockAnimInstance">();
	}
	static class UAdamWarlockAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdamWarlockAnimInstance>();
	}
};
static_assert(alignof(UAdamWarlockAnimInstance) == 0x000010, "Wrong alignment on UAdamWarlockAnimInstance");
static_assert(sizeof(UAdamWarlockAnimInstance) == 0x000920, "Wrong size on UAdamWarlockAnimInstance");
static_assert(offsetof(UAdamWarlockAnimInstance, bIsInSoulStatus) == 0x000910, "Member 'UAdamWarlockAnimInstance::bIsInSoulStatus' has a wrong offset!");

// Class Hero_1046.AdamWarlockSoulAnimData
// 0x0028 (0x0068 - 0x0040)
class UAdamWarlockSoulAnimData final : public UAnimationDataCollection
{
public:
	class UAnimSequence*                          Idle_Seq;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Ascending_Seq;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Hovering_2D;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Descending_2D;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Ascending_Lean_2D;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockSoulAnimData">();
	}
	static class UAdamWarlockSoulAnimData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdamWarlockSoulAnimData>();
	}
};
static_assert(alignof(UAdamWarlockSoulAnimData) == 0x000008, "Wrong alignment on UAdamWarlockSoulAnimData");
static_assert(sizeof(UAdamWarlockSoulAnimData) == 0x000068, "Wrong size on UAdamWarlockSoulAnimData");
static_assert(offsetof(UAdamWarlockSoulAnimData, Idle_Seq) == 0x000040, "Member 'UAdamWarlockSoulAnimData::Idle_Seq' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulAnimData, Ascending_Seq) == 0x000048, "Member 'UAdamWarlockSoulAnimData::Ascending_Seq' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulAnimData, Hovering_2D) == 0x000050, "Member 'UAdamWarlockSoulAnimData::Hovering_2D' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulAnimData, Descending_2D) == 0x000058, "Member 'UAdamWarlockSoulAnimData::Descending_2D' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulAnimData, Ascending_Lean_2D) == 0x000060, "Member 'UAdamWarlockSoulAnimData::Ascending_Lean_2D' has a wrong offset!");

// Class Hero_1046.AdamWarlockSoulSubAnimInstance
// 0x00B0 (0x09C0 - 0x0910)
class UAdamWarlockSoulSubAnimInstance final : public UMarvelAnimInstance
{
public:
	float                                         VelocityZThreshold;                                // 0x0910(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccZThreshold;                                     // 0x0914(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAccTransition;                                 // 0x0918(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_919[0x7];                                      // 0x0919(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAdamWarlockSoulAnimData*               SoulFreeFlyData;                                   // 0x0920(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAccelerating;                                   // 0x0928(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInAscending;                                    // 0x0929(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInDescending;                                   // 0x092A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInHovering;                                     // 0x092B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x092C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanX;                                             // 0x0930(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanY;                                             // 0x0934(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLean;                                          // 0x0938(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_939[0x7];                                      // 0x0939(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MovingVelocityNormal;                              // 0x0940(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentAcceleration;                               // 0x0958(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentAccelerationNormal;                         // 0x0970(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Idle_Seq;                                          // 0x0988(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Ascending_Seq;                                     // 0x0990(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Hovering_2D;                                       // 0x0998(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Descending_2D;                                     // 0x09A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Ascending_Lean_2D;                                 // 0x09A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B0[0x10];                                     // 0x09B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockSoulSubAnimInstance">();
	}
	static class UAdamWarlockSoulSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdamWarlockSoulSubAnimInstance>();
	}
};
static_assert(alignof(UAdamWarlockSoulSubAnimInstance) == 0x000010, "Wrong alignment on UAdamWarlockSoulSubAnimInstance");
static_assert(sizeof(UAdamWarlockSoulSubAnimInstance) == 0x0009C0, "Wrong size on UAdamWarlockSoulSubAnimInstance");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, VelocityZThreshold) == 0x000910, "Member 'UAdamWarlockSoulSubAnimInstance::VelocityZThreshold' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, AccZThreshold) == 0x000914, "Member 'UAdamWarlockSoulSubAnimInstance::AccZThreshold' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bUseAccTransition) == 0x000918, "Member 'UAdamWarlockSoulSubAnimInstance::bUseAccTransition' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, SoulFreeFlyData) == 0x000920, "Member 'UAdamWarlockSoulSubAnimInstance::SoulFreeFlyData' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bIsAccelerating) == 0x000928, "Member 'UAdamWarlockSoulSubAnimInstance::bIsAccelerating' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bIsInAscending) == 0x000929, "Member 'UAdamWarlockSoulSubAnimInstance::bIsInAscending' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bIsInDescending) == 0x00092A, "Member 'UAdamWarlockSoulSubAnimInstance::bIsInDescending' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bIsInHovering) == 0x00092B, "Member 'UAdamWarlockSoulSubAnimInstance::bIsInHovering' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, MaxSpeed) == 0x00092C, "Member 'UAdamWarlockSoulSubAnimInstance::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, LeanX) == 0x000930, "Member 'UAdamWarlockSoulSubAnimInstance::LeanX' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, LeanY) == 0x000934, "Member 'UAdamWarlockSoulSubAnimInstance::LeanY' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bUseLean) == 0x000938, "Member 'UAdamWarlockSoulSubAnimInstance::bUseLean' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, MovingVelocityNormal) == 0x000940, "Member 'UAdamWarlockSoulSubAnimInstance::MovingVelocityNormal' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, CurrentAcceleration) == 0x000958, "Member 'UAdamWarlockSoulSubAnimInstance::CurrentAcceleration' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, CurrentAccelerationNormal) == 0x000970, "Member 'UAdamWarlockSoulSubAnimInstance::CurrentAccelerationNormal' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, Idle_Seq) == 0x000988, "Member 'UAdamWarlockSoulSubAnimInstance::Idle_Seq' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, Ascending_Seq) == 0x000990, "Member 'UAdamWarlockSoulSubAnimInstance::Ascending_Seq' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, Hovering_2D) == 0x000998, "Member 'UAdamWarlockSoulSubAnimInstance::Hovering_2D' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, Descending_2D) == 0x0009A0, "Member 'UAdamWarlockSoulSubAnimInstance::Descending_2D' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, Ascending_Lean_2D) == 0x0009A8, "Member 'UAdamWarlockSoulSubAnimInstance::Ascending_Lean_2D' has a wrong offset!");

// Class Hero_1046.AdamWarlockCharacter
// 0x0030 (0x1840 - 0x1810)
class AAdamWarlockCharacter : public AMarvelBaseCharacter
{
public:
	int32                                         ResurrectAbilityID;                                // 0x1810(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfLinkTargets;                                  // 0x1814(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FullGatherReleaseDispatcher;                       // 0x1818(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAdamWarlockMoveLogicBaseComponent*     AdamWarlockMoveLogic;                              // 0x1828(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1830[0x10];                                    // 0x1830(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignDeathCueTag(const struct FGameplayTag& InDeathCue);
	bool CanResurrectSelf(const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockCharacter">();
	}
	static class AAdamWarlockCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAdamWarlockCharacter>();
	}
};
static_assert(alignof(AAdamWarlockCharacter) == 0x000010, "Wrong alignment on AAdamWarlockCharacter");
static_assert(sizeof(AAdamWarlockCharacter) == 0x001840, "Wrong size on AAdamWarlockCharacter");
static_assert(offsetof(AAdamWarlockCharacter, ResurrectAbilityID) == 0x001810, "Member 'AAdamWarlockCharacter::ResurrectAbilityID' has a wrong offset!");
static_assert(offsetof(AAdamWarlockCharacter, NumOfLinkTargets) == 0x001814, "Member 'AAdamWarlockCharacter::NumOfLinkTargets' has a wrong offset!");
static_assert(offsetof(AAdamWarlockCharacter, FullGatherReleaseDispatcher) == 0x001818, "Member 'AAdamWarlockCharacter::FullGatherReleaseDispatcher' has a wrong offset!");
static_assert(offsetof(AAdamWarlockCharacter, AdamWarlockMoveLogic) == 0x001828, "Member 'AAdamWarlockCharacter::AdamWarlockMoveLogic' has a wrong offset!");

// Class Hero_1046.AdamWarlockMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UAdamWarlockMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockMoveLogicBaseComponent">();
	}
	static class UAdamWarlockMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdamWarlockMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UAdamWarlockMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UAdamWarlockMoveLogicBaseComponent");
static_assert(sizeof(UAdamWarlockMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UAdamWarlockMoveLogicBaseComponent");

// Class Hero_1046.AdamWarlockMovementComponent
// 0x0000 (0x1B60 - 0x1B60)
class UAdamWarlockMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockMovementComponent">();
	}
	static class UAdamWarlockMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdamWarlockMovementComponent>();
	}
};
static_assert(alignof(UAdamWarlockMovementComponent) == 0x000010, "Wrong alignment on UAdamWarlockMovementComponent");
static_assert(sizeof(UAdamWarlockMovementComponent) == 0x001B60, "Wrong size on UAdamWarlockMovementComponent");

// Class Hero_1046.EpicMomentAction_1046
// 0x0040 (0x01B0 - 0x0170)
class UEpicMomentAction_1046 : public UEpicMomentAction_Treat
{
public:
	uint8                                         Pad_170[0x28];                                     // 0x0170(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    QConfig;                                           // 0x0198(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ResurrectedDelay;                                  // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfResurrectedActors;                            // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorResurrected(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierParameter& ModifierParameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1046">();
	}
	static class UEpicMomentAction_1046* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1046>();
	}
};
static_assert(alignof(UEpicMomentAction_1046) == 0x000008, "Wrong alignment on UEpicMomentAction_1046");
static_assert(sizeof(UEpicMomentAction_1046) == 0x0001B0, "Wrong size on UEpicMomentAction_1046");
static_assert(offsetof(UEpicMomentAction_1046, QConfig) == 0x000198, "Member 'UEpicMomentAction_1046::QConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1046, ResurrectedDelay) == 0x0001A4, "Member 'UEpicMomentAction_1046::ResurrectedDelay' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1046, NumOfResurrectedActors) == 0x0001A8, "Member 'UEpicMomentAction_1046::NumOfResurrectedActors' has a wrong offset!");

}

