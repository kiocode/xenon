#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1018

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Hero_1018_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class Hero_1018.Projectile_101811
// 0x0050 (0x30A0 - 0x3050)
class AProjectile_101811 : public AMarvelAbilityTargetActor_Projectile
{
public:
	bool                                          bIsCauserChanged;                                  // 0x3050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3051[0x4F];                                    // 0x3051(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FVector GetAimDirection();
	const struct FVector GetAimStart();
	void ResetDefaut();
	void ResetTimeElapsed();
	void SetAimLine(const struct FVector& InAimStart, const struct FVector& InAimDirection);
	void SetProjectileSpreadRotateInfo(const struct FProjectileSpreadRotateInfo& InProjectileSpreadRotateInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_101811">();
	}
	static class AProjectile_101811* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_101811>();
	}
};
static_assert(alignof(AProjectile_101811) == 0x000010, "Wrong alignment on AProjectile_101811");
static_assert(sizeof(AProjectile_101811) == 0x0030A0, "Wrong size on AProjectile_101811");
static_assert(offsetof(AProjectile_101811, bIsCauserChanged) == 0x003050, "Member 'AProjectile_101811::bIsCauserChanged' has a wrong offset!");

// Class Hero_1018.Cue_Ability_Loop_10181901
// 0x00B0 (0x0F00 - 0x0E50)
class ACue_Ability_Loop_10181901 final : public AMarvelCueNotify_Ability
{
public:
	TMap<class USkeletalMeshComponent*, struct FCustomMeshMaterialMap> HandShadowMeshMaterialMap;                         // 0x0E50(0x0050)(BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<uint8, struct FCustomMaterialCurveMap>   MaterialParamMap;                                  // 0x0EA0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 MaterialMultiFactorList;                           // 0x0EF0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void CreateCustomMaterial(class USkeletalMeshComponent* InHandShadowComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10181901">();
	}
	static class ACue_Ability_Loop_10181901* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10181901>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10181901) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10181901");
static_assert(sizeof(ACue_Ability_Loop_10181901) == 0x000F00, "Wrong size on ACue_Ability_Loop_10181901");
static_assert(offsetof(ACue_Ability_Loop_10181901, HandShadowMeshMaterialMap) == 0x000E50, "Member 'ACue_Ability_Loop_10181901::HandShadowMeshMaterialMap' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10181901, MaterialParamMap) == 0x000EA0, "Member 'ACue_Ability_Loop_10181901::MaterialParamMap' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10181901, MaterialMultiFactorList) == 0x000EF0, "Member 'ACue_Ability_Loop_10181901::MaterialMultiFactorList' has a wrong offset!");

// Class Hero_1018.Cue_Ability_Loop_10182101
// 0x0020 (0x0E70 - 0x0E50)
class ACue_Ability_Loop_10182101 final : public AMarvelCueNotify_Ability
{
public:
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMesh1;                                     // 0x0E58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddLength;                                         // 0x0E60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E64[0x4];                                      // 0x0E64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         HitFXSystemAsset;                                  // 0x0E68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10182101">();
	}
	static class ACue_Ability_Loop_10182101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10182101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10182101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10182101");
static_assert(sizeof(ACue_Ability_Loop_10182101) == 0x000E70, "Wrong size on ACue_Ability_Loop_10182101");
static_assert(offsetof(ACue_Ability_Loop_10182101, SkeletalMesh) == 0x000E50, "Member 'ACue_Ability_Loop_10182101::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10182101, SkeletalMesh1) == 0x000E58, "Member 'ACue_Ability_Loop_10182101::SkeletalMesh1' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10182101, AddLength) == 0x000E60, "Member 'ACue_Ability_Loop_10182101::AddLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10182101, HitFXSystemAsset) == 0x000E68, "Member 'ACue_Ability_Loop_10182101::HitFXSystemAsset' has a wrong offset!");

// Class Hero_1018.Config_101841
// 0x1F98 (0x2030 - 0x0098)
class UConfig_101841 : public UMarvelAbilityConfig
{
public:
	struct FVector                                BarrierOffset;                                     // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestoreSpeed;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitSpeed;                                        // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAngle;                                          // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSkyMinAngle;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSkyMaxAngle;                                     // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierGroundTraceLength;                          // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierRadius;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierHeight;                                     // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeedAdjustCollisionAngle;                          // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardOffset;                                     // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierRecoveryDelay;                              // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierReactiveDelay;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateCollisionTime;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FreeCamBuffID;                                     // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierMoveCollisionRadius;                        // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             MoveCollisionTraceContext;                         // 0x00F0(0x0F90)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                MoveCollisionOffset;                               // 0x1080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1098[0x8];                                     // 0x1098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x10A0(0x0F90)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101841">();
	}
	static class UConfig_101841* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101841>();
	}
};
static_assert(alignof(UConfig_101841) == 0x000010, "Wrong alignment on UConfig_101841");
static_assert(sizeof(UConfig_101841) == 0x002030, "Wrong size on UConfig_101841");
static_assert(offsetof(UConfig_101841, BarrierOffset) == 0x000098, "Member 'UConfig_101841::BarrierOffset' has a wrong offset!");
static_assert(offsetof(UConfig_101841, RestoreSpeed) == 0x0000B0, "Member 'UConfig_101841::RestoreSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101841, LimitSpeed) == 0x0000B4, "Member 'UConfig_101841::LimitSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101841, MinAngle) == 0x0000B8, "Member 'UConfig_101841::MinAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101841, MaxAngle) == 0x0000BC, "Member 'UConfig_101841::MaxAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101841, InSkyMinAngle) == 0x0000C0, "Member 'UConfig_101841::InSkyMinAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101841, InSkyMaxAngle) == 0x0000C4, "Member 'UConfig_101841::InSkyMaxAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierGroundTraceLength) == 0x0000C8, "Member 'UConfig_101841::BarrierGroundTraceLength' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierRadius) == 0x0000CC, "Member 'UConfig_101841::BarrierRadius' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierHeight) == 0x0000D0, "Member 'UConfig_101841::BarrierHeight' has a wrong offset!");
static_assert(offsetof(UConfig_101841, NeedAdjustCollisionAngle) == 0x0000D4, "Member 'UConfig_101841::NeedAdjustCollisionAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101841, ForwardOffset) == 0x0000D8, "Member 'UConfig_101841::ForwardOffset' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierRecoveryDelay) == 0x0000DC, "Member 'UConfig_101841::BarrierRecoveryDelay' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierReactiveDelay) == 0x0000E0, "Member 'UConfig_101841::BarrierReactiveDelay' has a wrong offset!");
static_assert(offsetof(UConfig_101841, UpdateCollisionTime) == 0x0000E4, "Member 'UConfig_101841::UpdateCollisionTime' has a wrong offset!");
static_assert(offsetof(UConfig_101841, FreeCamBuffID) == 0x0000E8, "Member 'UConfig_101841::FreeCamBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierMoveCollisionRadius) == 0x0000EC, "Member 'UConfig_101841::BarrierMoveCollisionRadius' has a wrong offset!");
static_assert(offsetof(UConfig_101841, MoveCollisionTraceContext) == 0x0000F0, "Member 'UConfig_101841::MoveCollisionTraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_101841, MoveCollisionOffset) == 0x001080, "Member 'UConfig_101841::MoveCollisionOffset' has a wrong offset!");
static_assert(offsetof(UConfig_101841, TraceContext) == 0x0010A0, "Member 'UConfig_101841::TraceContext' has a wrong offset!");

// Class Hero_1018.Summoned_10184101
// 0x00A0 (0x09B0 - 0x0910)
class ASummoned_10184101 : public AMarvelBarrierBase
{
public:
	class UConfig_101841*                         AbilityConfig;                                     // 0x0910(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   SummonerInstigator;                                // 0x0918(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelGameplayAbility*                 OwningSummonerAbility;                             // 0x0920(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierTraceDistance;                              // 0x0928(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92C[0x4];                                      // 0x092C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CameraRotator;                                     // 0x0930(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentRotator;                                    // 0x0948(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                InitLocation;                                      // 0x0960(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalInitLocation;                                 // 0x0978(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAngle;                                       // 0x0990(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0994(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CollisionInitRelativeLocation;                     // 0x0998(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool BarrierTraceGround();
	class AMarvelBaseCharacter* GetOwnerCharacter();
	class UMarvelBaseGameplayAbility* GetOwningAbility();
	class UMarvelAbilityConfig* GetOwningAbilityConfig();
	bool HasFreeCamBuff();
	void K2_OnBeginAgentTask();
	void K2_SetAlive(bool bInAlive);
	void SetBarrierTrans();
	void SetInstigatorAOYaw();
	void SetPitchLimit(float DeltaTime);
	void UpdateBarrierCollisionOffset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10184101">();
	}
	static class ASummoned_10184101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10184101>();
	}
};
static_assert(alignof(ASummoned_10184101) == 0x000010, "Wrong alignment on ASummoned_10184101");
static_assert(sizeof(ASummoned_10184101) == 0x0009B0, "Wrong size on ASummoned_10184101");
static_assert(offsetof(ASummoned_10184101, AbilityConfig) == 0x000910, "Member 'ASummoned_10184101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, SummonerInstigator) == 0x000918, "Member 'ASummoned_10184101::SummonerInstigator' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, OwningSummonerAbility) == 0x000920, "Member 'ASummoned_10184101::OwningSummonerAbility' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, BarrierTraceDistance) == 0x000928, "Member 'ASummoned_10184101::BarrierTraceDistance' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, CameraRotator) == 0x000930, "Member 'ASummoned_10184101::CameraRotator' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, CurrentRotator) == 0x000948, "Member 'ASummoned_10184101::CurrentRotator' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, InitLocation) == 0x000960, "Member 'ASummoned_10184101::InitLocation' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, LocalInitLocation) == 0x000978, "Member 'ASummoned_10184101::LocalInitLocation' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, OffsetAngle) == 0x000990, "Member 'ASummoned_10184101::OffsetAngle' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, Length) == 0x000994, "Member 'ASummoned_10184101::Length' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, CollisionInitRelativeLocation) == 0x000998, "Member 'ASummoned_10184101::CollisionInitRelativeLocation' has a wrong offset!");

// Class Hero_1018.SummonedComp_10184101
// 0x0010 (0x0CB0 - 0x0CA0)
class USummonedComp_10184101 : public UMarvelSummonedComponent
{
public:
	int32                                         OwningAbilityID;                                   // 0x0CA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA4[0x4];                                      // 0x0CA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASummoned_10184101*                     OwnerBarrierSummoned;                              // 0x0CA8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10184101">();
	}
	static class USummonedComp_10184101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10184101>();
	}
};
static_assert(alignof(USummonedComp_10184101) == 0x000010, "Wrong alignment on USummonedComp_10184101");
static_assert(sizeof(USummonedComp_10184101) == 0x000CB0, "Wrong size on USummonedComp_10184101");
static_assert(offsetof(USummonedComp_10184101, OwningAbilityID) == 0x000CA0, "Member 'USummonedComp_10184101::OwningAbilityID' has a wrong offset!");
static_assert(offsetof(USummonedComp_10184101, OwnerBarrierSummoned) == 0x000CA8, "Member 'USummonedComp_10184101::OwnerBarrierSummoned' has a wrong offset!");

// Class Hero_1018.Config_101851
// 0x0008 (0x00A0 - 0x0098)
class UConfig_101851 : public UMarvelAbilityConfig
{
public:
	float                                         DarkHealthRate;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarkDamageRate;                                    // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101851">();
	}
	static class UConfig_101851* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101851>();
	}
};
static_assert(alignof(UConfig_101851) == 0x000008, "Wrong alignment on UConfig_101851");
static_assert(sizeof(UConfig_101851) == 0x0000A0, "Wrong size on UConfig_101851");
static_assert(offsetof(UConfig_101851, DarkHealthRate) == 0x000098, "Member 'UConfig_101851::DarkHealthRate' has a wrong offset!");
static_assert(offsetof(UConfig_101851, DarkDamageRate) == 0x00009C, "Member 'UConfig_101851::DarkDamageRate' has a wrong offset!");

// Class Hero_1018.Ability_101851
// 0x0008 (0x2590 - 0x2588)
class UAbility_101851 : public UAbility_108
{
public:
	uint8                                         Pad_2588[0x8];                                     // 0x2588(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCurrentDarkManaValue();
	float GetDarkManaValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101851">();
	}
	static class UAbility_101851* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101851>();
	}
};
static_assert(alignof(UAbility_101851) == 0x000008, "Wrong alignment on UAbility_101851");
static_assert(sizeof(UAbility_101851) == 0x002590, "Wrong size on UAbility_101851");

// Class Hero_1018.Scope_10185101
// 0x0010 (0x1710 - 0x1700)
class AScope_10185101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	uint8                                         Pad_1700[0x10];                                    // 0x1700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10185101">();
	}
	static class AScope_10185101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10185101>();
	}
};
static_assert(alignof(AScope_10185101) == 0x000010, "Wrong alignment on AScope_10185101");
static_assert(sizeof(AScope_10185101) == 0x001710, "Wrong size on AScope_10185101");

// Class Hero_1018.Config_101861
// 0x00B8 (0x0150 - 0x0098)
class UConfig_101861 final : public UMarvelAbilityConfig
{
public:
	struct FVector                                LandscapeCameraTranslation;                        // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FirstDefaultPlacedTranslation;                     // 0x00B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterToLandscapeInterp;                        // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandscapeToCharacterInterp;                        // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 CameraMovingMaxSpeeds;                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DefaultSpeedLevel;                                 // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandscapeCullDistanceSquared;                      // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TracePortalRadius;                                 // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalSummonerId;                                  // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSolvePenetration;                                 // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionShrinkFactor;                             // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionBoostFactor;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     BlockChannels;                                     // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATracePortalCameraActor_101861> CameraActorClass;                                  // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     PrePlaceActorClass;                                // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckLevelPenetration;                            // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RequiredPenetrationCompTag;                        // 0x012C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtend;                                         // 0x0138(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101861">();
	}
	static class UConfig_101861* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101861>();
	}
};
static_assert(alignof(UConfig_101861) == 0x000008, "Wrong alignment on UConfig_101861");
static_assert(sizeof(UConfig_101861) == 0x000150, "Wrong size on UConfig_101861");
static_assert(offsetof(UConfig_101861, LandscapeCameraTranslation) == 0x000098, "Member 'UConfig_101861::LandscapeCameraTranslation' has a wrong offset!");
static_assert(offsetof(UConfig_101861, FirstDefaultPlacedTranslation) == 0x0000B0, "Member 'UConfig_101861::FirstDefaultPlacedTranslation' has a wrong offset!");
static_assert(offsetof(UConfig_101861, CharacterToLandscapeInterp) == 0x0000C8, "Member 'UConfig_101861::CharacterToLandscapeInterp' has a wrong offset!");
static_assert(offsetof(UConfig_101861, LandscapeToCharacterInterp) == 0x0000CC, "Member 'UConfig_101861::LandscapeToCharacterInterp' has a wrong offset!");
static_assert(offsetof(UConfig_101861, CameraMovingMaxSpeeds) == 0x0000D0, "Member 'UConfig_101861::CameraMovingMaxSpeeds' has a wrong offset!");
static_assert(offsetof(UConfig_101861, DefaultSpeedLevel) == 0x0000E0, "Member 'UConfig_101861::DefaultSpeedLevel' has a wrong offset!");
static_assert(offsetof(UConfig_101861, LandscapeCullDistanceSquared) == 0x0000E4, "Member 'UConfig_101861::LandscapeCullDistanceSquared' has a wrong offset!");
static_assert(offsetof(UConfig_101861, TracePortalRadius) == 0x0000E8, "Member 'UConfig_101861::TracePortalRadius' has a wrong offset!");
static_assert(offsetof(UConfig_101861, PortalSummonerId) == 0x0000EC, "Member 'UConfig_101861::PortalSummonerId' has a wrong offset!");
static_assert(offsetof(UConfig_101861, bSolvePenetration) == 0x0000F0, "Member 'UConfig_101861::bSolvePenetration' has a wrong offset!");
static_assert(offsetof(UConfig_101861, CollisionShrinkFactor) == 0x0000F4, "Member 'UConfig_101861::CollisionShrinkFactor' has a wrong offset!");
static_assert(offsetof(UConfig_101861, CollisionBoostFactor) == 0x0000F8, "Member 'UConfig_101861::CollisionBoostFactor' has a wrong offset!");
static_assert(offsetof(UConfig_101861, BlockChannels) == 0x000100, "Member 'UConfig_101861::BlockChannels' has a wrong offset!");
static_assert(offsetof(UConfig_101861, TraceChannel) == 0x000110, "Member 'UConfig_101861::TraceChannel' has a wrong offset!");
static_assert(offsetof(UConfig_101861, CameraActorClass) == 0x000118, "Member 'UConfig_101861::CameraActorClass' has a wrong offset!");
static_assert(offsetof(UConfig_101861, PrePlaceActorClass) == 0x000120, "Member 'UConfig_101861::PrePlaceActorClass' has a wrong offset!");
static_assert(offsetof(UConfig_101861, bCheckLevelPenetration) == 0x000128, "Member 'UConfig_101861::bCheckLevelPenetration' has a wrong offset!");
static_assert(offsetof(UConfig_101861, RequiredPenetrationCompTag) == 0x00012C, "Member 'UConfig_101861::RequiredPenetrationCompTag' has a wrong offset!");
static_assert(offsetof(UConfig_101861, BoxExtend) == 0x000138, "Member 'UConfig_101861::BoxExtend' has a wrong offset!");

// Class Hero_1018.Ability_101861
// 0x0190 (0x2710 - 0x2580)
class UAbility_101861 : public UMarvelGameplayAbility
{
public:
	class UConfig_101861*                         Config;                                            // 0x2580(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATracePortalCameraActor_101861*         CameraActor;                                       // 0x2588(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlacedPortalActor_101861*              PrePlaceActor;                                     // 0x2590(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeyReleaseEndAbilityAudioID;                       // 0x2598(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259C[0x4];                                     // 0x259C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnExpectPlaceEventChange;                          // 0x25A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APortalViewActor*                       StartPortal;                                       // 0x25B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APortalViewActor*                       EndPortal;                                         // 0x25B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C0[0x10];                                    // 0x25C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityPlaceMsg_101861                PlaceMsg;                                          // 0x25D0(0x0130)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2700[0x10];                                    // 0x2700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EmptyEventOnPressOrReleaseInput(float TimeWaited);
	void OnPressCameraDrop(float TimeWaited);
	void OnPressCameraRise(float TimeWaited);
	void OnPressCameraSpeedDown(float TimeWaited);
	void OnPressCameraSpeedUp(float TimeWaited);
	void OnPressEndAbility(float TimeWaited);
	void OnReleaseCameraDrop(float TimeWaited);
	void OnReleaseCameraRise(float TimeWaited);
	void OnReleaseEndAbility(float TimeWaited);
	void OnReleasePlaceOrRemovePortal(float TimeWaited);
	void OnRep_ReplicateCameraActor();
	void OnServerSpawnPortalSuccess(class AActor* SpawnActor);
	void OnViewingCharacterChanged(class AMarvelBaseCharacter* ViewingTarget);
	void ServerHandleEventAndMsg(EPlaceEvent_101861 NewPlaceEvent, const struct FAbilityPlaceMsg_101861& NewPlaceMsg);
	void SimulatedHandleEventAndMsg(EPlaceEvent_101861 NewPlaceEvent, const struct FAbilityPlaceMsg_101861& NewPlaceMsg);

	EPlaceEvent_101861 GetPlaceEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101861">();
	}
	static class UAbility_101861* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101861>();
	}
};
static_assert(alignof(UAbility_101861) == 0x000010, "Wrong alignment on UAbility_101861");
static_assert(sizeof(UAbility_101861) == 0x002710, "Wrong size on UAbility_101861");
static_assert(offsetof(UAbility_101861, Config) == 0x002580, "Member 'UAbility_101861::Config' has a wrong offset!");
static_assert(offsetof(UAbility_101861, CameraActor) == 0x002588, "Member 'UAbility_101861::CameraActor' has a wrong offset!");
static_assert(offsetof(UAbility_101861, PrePlaceActor) == 0x002590, "Member 'UAbility_101861::PrePlaceActor' has a wrong offset!");
static_assert(offsetof(UAbility_101861, KeyReleaseEndAbilityAudioID) == 0x002598, "Member 'UAbility_101861::KeyReleaseEndAbilityAudioID' has a wrong offset!");
static_assert(offsetof(UAbility_101861, OnExpectPlaceEventChange) == 0x0025A0, "Member 'UAbility_101861::OnExpectPlaceEventChange' has a wrong offset!");
static_assert(offsetof(UAbility_101861, StartPortal) == 0x0025B0, "Member 'UAbility_101861::StartPortal' has a wrong offset!");
static_assert(offsetof(UAbility_101861, EndPortal) == 0x0025B8, "Member 'UAbility_101861::EndPortal' has a wrong offset!");
static_assert(offsetof(UAbility_101861, PlaceMsg) == 0x0025D0, "Member 'UAbility_101861::PlaceMsg' has a wrong offset!");

// Class Hero_1018.TracePortalCameraActor_101861
// 0x0360 (0x1200 - 0x0EA0)
class ATracePortalCameraActor_101861 : public AMovingCameraActor
{
public:
	uint8                                         Pad_E98[0x78];                                     // 0x0E98(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsActive;                                         // 0x0F10(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F11[0x7];                                      // 0x0F11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRepSummonedMovement                   CustomRepMovement;                                 // 0x0F18(0x0200)(Net, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1118[0x1];                                     // 0x1118(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTracingPlacedPortal;                              // 0x1119(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111A[0x6];                                     // 0x111A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_101861*                        OwningAbility;                                     // 0x1120(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_101861*                         AbilityConfig;                                     // 0x1128(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateChange;                                     // 0x1130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComp;                                          // 0x1140(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    SpringArmComponent;                                // 0x1148(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  LastHitActor;                                      // 0x1150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class AActor*>                           IntersectedTransparentActors;                      // 0x1158(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_11A8[0x58];                                    // 0x11A8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NetMulticastInitTransform(const struct FTransform& InitTransform);
	void OnBirthBaseActiveDispatch(class AActor* InBirthBase);
	void OnRep_bIsActive();
	void OnRep_CustomRepMovement();
	void OnRep_OwningAbility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TracePortalCameraActor_101861">();
	}
	static class ATracePortalCameraActor_101861* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATracePortalCameraActor_101861>();
	}
};
static_assert(alignof(ATracePortalCameraActor_101861) == 0x000010, "Wrong alignment on ATracePortalCameraActor_101861");
static_assert(sizeof(ATracePortalCameraActor_101861) == 0x001200, "Wrong size on ATracePortalCameraActor_101861");
static_assert(offsetof(ATracePortalCameraActor_101861, bIsActive) == 0x000F10, "Member 'ATracePortalCameraActor_101861::bIsActive' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, CustomRepMovement) == 0x000F18, "Member 'ATracePortalCameraActor_101861::CustomRepMovement' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, bTracingPlacedPortal) == 0x001119, "Member 'ATracePortalCameraActor_101861::bTracingPlacedPortal' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, OwningAbility) == 0x001120, "Member 'ATracePortalCameraActor_101861::OwningAbility' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, AbilityConfig) == 0x001128, "Member 'ATracePortalCameraActor_101861::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, OnStateChange) == 0x001130, "Member 'ATracePortalCameraActor_101861::OnStateChange' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, MeshComp) == 0x001140, "Member 'ATracePortalCameraActor_101861::MeshComp' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, SpringArmComponent) == 0x001148, "Member 'ATracePortalCameraActor_101861::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, LastHitActor) == 0x001150, "Member 'ATracePortalCameraActor_101861::LastHitActor' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, IntersectedTransparentActors) == 0x001158, "Member 'ATracePortalCameraActor_101861::IntersectedTransparentActors' has a wrong offset!");

// Class Hero_1018.PlacedPortalActor_101861
// 0x02C0 (0x0750 - 0x0490)
class APlacedPortalActor_101861 : public AActor
{
public:
	uint8                                         Pad_490[0x80];                                     // 0x0490(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CueTag;                                            // 0x0510(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStateChange;                                     // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USphereComponent*                       RootSphereComp;                                    // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_101861*                         AbilityConfig;                                     // 0x0538(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0540(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRepSummonedMovement                   CustomRepMovement;                                 // 0x0548(0x0200)(Net, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_748[0x8];                                      // 0x0748(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bIsActive();
	void OnRep_CustomRepMovement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacedPortalActor_101861">();
	}
	static class APlacedPortalActor_101861* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlacedPortalActor_101861>();
	}
};
static_assert(alignof(APlacedPortalActor_101861) == 0x000008, "Wrong alignment on APlacedPortalActor_101861");
static_assert(sizeof(APlacedPortalActor_101861) == 0x000750, "Wrong size on APlacedPortalActor_101861");
static_assert(offsetof(APlacedPortalActor_101861, CueTag) == 0x000510, "Member 'APlacedPortalActor_101861::CueTag' has a wrong offset!");
static_assert(offsetof(APlacedPortalActor_101861, OnStateChange) == 0x000520, "Member 'APlacedPortalActor_101861::OnStateChange' has a wrong offset!");
static_assert(offsetof(APlacedPortalActor_101861, RootSphereComp) == 0x000530, "Member 'APlacedPortalActor_101861::RootSphereComp' has a wrong offset!");
static_assert(offsetof(APlacedPortalActor_101861, AbilityConfig) == 0x000538, "Member 'APlacedPortalActor_101861::AbilityConfig' has a wrong offset!");
static_assert(offsetof(APlacedPortalActor_101861, bIsActive) == 0x000540, "Member 'APlacedPortalActor_101861::bIsActive' has a wrong offset!");
static_assert(offsetof(APlacedPortalActor_101861, CustomRepMovement) == 0x000548, "Member 'APlacedPortalActor_101861::CustomRepMovement' has a wrong offset!");

// Class Hero_1018.Cue_Ability_Loop_10186101
// 0x0008 (0x0E58 - 0x0E50)
class ACue_Ability_Loop_10186101 final : public AMarvelCueNotify_Ability
{
public:
	int32                                         CameraMoveAudio;                                   // 0x0E50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E54[0x4];                                      // 0x0E54(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10186101">();
	}
	static class ACue_Ability_Loop_10186101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10186101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10186101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10186101");
static_assert(sizeof(ACue_Ability_Loop_10186101) == 0x000E58, "Wrong size on ACue_Ability_Loop_10186101");
static_assert(offsetof(ACue_Ability_Loop_10186101, CameraMoveAudio) == 0x000E50, "Member 'ACue_Ability_Loop_10186101::CameraMoveAudio' has a wrong offset!");

// Class Hero_1018.Ability_101871
// 0x0008 (0x2590 - 0x2588)
class UAbility_101871 : public UAbility_108
{
public:
	uint8                                         Pad_2588[0x8];                                     // 0x2588(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101871">();
	}
	static class UAbility_101871* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101871>();
	}
};
static_assert(alignof(UAbility_101871) == 0x000008, "Wrong alignment on UAbility_101871");
static_assert(sizeof(UAbility_101871) == 0x002590, "Wrong size on UAbility_101871");

// Class Hero_1018.Summoned_10187101
// 0x0010 (0x08A0 - 0x0890)
class ASummoned_10187101 : public AMarvelSummonerBase
{
public:
	class UCapsuleComponent*                      SoulCollision;                                     // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_898[0x8];                                      // 0x0898(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10187101">();
	}
	static class ASummoned_10187101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10187101>();
	}
};
static_assert(alignof(ASummoned_10187101) == 0x000010, "Wrong alignment on ASummoned_10187101");
static_assert(sizeof(ASummoned_10187101) == 0x0008A0, "Wrong size on ASummoned_10187101");
static_assert(offsetof(ASummoned_10187101, SoulCollision) == 0x000890, "Member 'ASummoned_10187101::SoulCollision' has a wrong offset!");

// Class Hero_1018.SummonedMovementComponent_10187101
// 0x0010 (0x0A50 - 0x0A40)
class USummonedMovementComponent_10187101 final : public USummonedMovementComponent
{
public:
	float                                         DownTraceDistance;                                 // 0x0A40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A44[0xC];                                      // 0x0A44(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedMovementComponent_10187101">();
	}
	static class USummonedMovementComponent_10187101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedMovementComponent_10187101>();
	}
};
static_assert(alignof(USummonedMovementComponent_10187101) == 0x000010, "Wrong alignment on USummonedMovementComponent_10187101");
static_assert(sizeof(USummonedMovementComponent_10187101) == 0x000A50, "Wrong size on USummonedMovementComponent_10187101");
static_assert(offsetof(USummonedMovementComponent_10187101, DownTraceDistance) == 0x000A40, "Member 'USummonedMovementComponent_10187101::DownTraceDistance' has a wrong offset!");

// Class Hero_1018.SummonedComp_10187101
// 0x1050 (0x1CF0 - 0x0CA0)
class USummonedComp_10187101 : public UMarvelSummonedComponent
{
public:
	float                                         DamageRatio;                                       // 0x0CA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CA4[0x4];                                      // 0x0CA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           SoulOffsetCurve;                                   // 0x0CA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMarvelAbilityTraceContext             CollisionCheckContext;                             // 0x0CB0(0x0F90)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         CapsuleHalfHeightCut;                              // 0x1C40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C44[0x4];                                     // 0x1C44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         UpdateOffsetKey;                                   // 0x1C48(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CE8[0x8];                                     // 0x1CE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSoulOffset(const struct FVector& OutValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10187101">();
	}
	static class USummonedComp_10187101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10187101>();
	}
};
static_assert(alignof(USummonedComp_10187101) == 0x000010, "Wrong alignment on USummonedComp_10187101");
static_assert(sizeof(USummonedComp_10187101) == 0x001CF0, "Wrong size on USummonedComp_10187101");
static_assert(offsetof(USummonedComp_10187101, DamageRatio) == 0x000CA0, "Member 'USummonedComp_10187101::DamageRatio' has a wrong offset!");
static_assert(offsetof(USummonedComp_10187101, SoulOffsetCurve) == 0x000CA8, "Member 'USummonedComp_10187101::SoulOffsetCurve' has a wrong offset!");
static_assert(offsetof(USummonedComp_10187101, CollisionCheckContext) == 0x000CB0, "Member 'USummonedComp_10187101::CollisionCheckContext' has a wrong offset!");
static_assert(offsetof(USummonedComp_10187101, CapsuleHalfHeightCut) == 0x001C40, "Member 'USummonedComp_10187101::CapsuleHalfHeightCut' has a wrong offset!");
static_assert(offsetof(USummonedComp_10187101, UpdateOffsetKey) == 0x001C48, "Member 'USummonedComp_10187101::UpdateOffsetKey' has a wrong offset!");

// Class Hero_1018.EffectAbility_101871
// 0x0018 (0x1110 - 0x10F8)
class UEffectAbility_101871 final : public UMarvelEffectGameplayAbility
{
public:
	int32                                         SummonID;                                          // 0x10F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10FC[0x4];                                     // 0x10FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_101871*                        OwnAbility;                                        // 0x1100(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   SourceCharacter;                                   // 0x1108(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCharacterPreDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectAbility_101871">();
	}
	static class UEffectAbility_101871* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectAbility_101871>();
	}
};
static_assert(alignof(UEffectAbility_101871) == 0x000008, "Wrong alignment on UEffectAbility_101871");
static_assert(sizeof(UEffectAbility_101871) == 0x001110, "Wrong size on UEffectAbility_101871");
static_assert(offsetof(UEffectAbility_101871, SummonID) == 0x0010F8, "Member 'UEffectAbility_101871::SummonID' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101871, OwnAbility) == 0x001100, "Member 'UEffectAbility_101871::OwnAbility' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101871, SourceCharacter) == 0x001108, "Member 'UEffectAbility_101871::SourceCharacter' has a wrong offset!");

// Class Hero_1018.MarvelCueNotify_101871_Actor
// 0x0070 (0x0D38 - 0x0CC8)
class AMarvelCueNotify_101871_Actor final : public AMarvelCueNotify_Actor
{
public:
	int32                                         CameraControlPriority;                             // 0x0CC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInterpSpringArmLength;                      // 0x0CCC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CCD[0x3];                                      // 0x0CCD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpringArmTargetLength;                             // 0x0CD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmInterpInitSpeed;                          // 0x0CD4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmInterpMaxSpeed;                           // 0x0CD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmInterpAcceleration;                       // 0x0CDC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmRecoveryInterpInitSpeed;                  // 0x0CE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmRecoveryInterpMaxSpeed;                   // 0x0CE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmRecoveryInterpAcceleration;               // 0x0CE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInterpSpringArmSocketOffset;                // 0x0CEC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CED[0x3];                                      // 0x0CED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpringArmSocketOffset;                             // 0x0CF0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmSocketInterpSpeed;                        // 0x0D08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmSocketInterpRecoverySpeed;                // 0x0D0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFOVInterp;                                  // 0x0D10(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D11[0x3];                                      // 0x0D11(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOVTarget;                                         // 0x0D14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVInterpSpeed;                                    // 0x0D18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVInterpRecoverSpeed;                             // 0x0D1C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               PPMInstanceDynamic;                                // 0x0D20(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D28[0x10];                                     // 0x0D28(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelCueNotify_101871_Actor">();
	}
	static class AMarvelCueNotify_101871_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelCueNotify_101871_Actor>();
	}
};
static_assert(alignof(AMarvelCueNotify_101871_Actor) == 0x000008, "Wrong alignment on AMarvelCueNotify_101871_Actor");
static_assert(sizeof(AMarvelCueNotify_101871_Actor) == 0x000D38, "Wrong size on AMarvelCueNotify_101871_Actor");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, CameraControlPriority) == 0x000CC8, "Member 'AMarvelCueNotify_101871_Actor::CameraControlPriority' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, bEnableInterpSpringArmLength) == 0x000CCC, "Member 'AMarvelCueNotify_101871_Actor::bEnableInterpSpringArmLength' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmTargetLength) == 0x000CD0, "Member 'AMarvelCueNotify_101871_Actor::SpringArmTargetLength' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmInterpInitSpeed) == 0x000CD4, "Member 'AMarvelCueNotify_101871_Actor::SpringArmInterpInitSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmInterpMaxSpeed) == 0x000CD8, "Member 'AMarvelCueNotify_101871_Actor::SpringArmInterpMaxSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmInterpAcceleration) == 0x000CDC, "Member 'AMarvelCueNotify_101871_Actor::SpringArmInterpAcceleration' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmRecoveryInterpInitSpeed) == 0x000CE0, "Member 'AMarvelCueNotify_101871_Actor::SpringArmRecoveryInterpInitSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmRecoveryInterpMaxSpeed) == 0x000CE4, "Member 'AMarvelCueNotify_101871_Actor::SpringArmRecoveryInterpMaxSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmRecoveryInterpAcceleration) == 0x000CE8, "Member 'AMarvelCueNotify_101871_Actor::SpringArmRecoveryInterpAcceleration' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, bEnableInterpSpringArmSocketOffset) == 0x000CEC, "Member 'AMarvelCueNotify_101871_Actor::bEnableInterpSpringArmSocketOffset' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmSocketOffset) == 0x000CF0, "Member 'AMarvelCueNotify_101871_Actor::SpringArmSocketOffset' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmSocketInterpSpeed) == 0x000D08, "Member 'AMarvelCueNotify_101871_Actor::SpringArmSocketInterpSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmSocketInterpRecoverySpeed) == 0x000D0C, "Member 'AMarvelCueNotify_101871_Actor::SpringArmSocketInterpRecoverySpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, bEnableFOVInterp) == 0x000D10, "Member 'AMarvelCueNotify_101871_Actor::bEnableFOVInterp' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, FOVTarget) == 0x000D14, "Member 'AMarvelCueNotify_101871_Actor::FOVTarget' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, FOVInterpSpeed) == 0x000D18, "Member 'AMarvelCueNotify_101871_Actor::FOVInterpSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, FOVInterpRecoverSpeed) == 0x000D1C, "Member 'AMarvelCueNotify_101871_Actor::FOVInterpRecoverSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, PPMInstanceDynamic) == 0x000D20, "Member 'AMarvelCueNotify_101871_Actor::PPMInstanceDynamic' has a wrong offset!");

// Class Hero_1018.Cue_Summoner_Loop_10187101
// 0x0060 (0x0EF0 - 0x0E90)
class ACue_Summoner_Loop_10187101 final : public AMarvelCueNotify_Summoned
{
public:
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0E90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 BoundSkeletalMesh;                                 // 0x0E98(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA0[0x50];                                     // 0x0EA0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindMeshMaterialVisibleChanged(class USkeletalMeshComponent* SkeletalMeshComponent);
	TArray<class FName> GetHideBones(class USkeletalMeshComponent* TargetMesh);
	void SetMaterialHidden(class USkeletalMeshComponent* SkeletalMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10187101">();
	}
	static class ACue_Summoner_Loop_10187101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10187101>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10187101) == 0x000008, "Wrong alignment on ACue_Summoner_Loop_10187101");
static_assert(sizeof(ACue_Summoner_Loop_10187101) == 0x000EF0, "Wrong size on ACue_Summoner_Loop_10187101");
static_assert(offsetof(ACue_Summoner_Loop_10187101, SkeletalMesh) == 0x000E90, "Member 'ACue_Summoner_Loop_10187101::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10187101, BoundSkeletalMesh) == 0x000E98, "Member 'ACue_Summoner_Loop_10187101::BoundSkeletalMesh' has a wrong offset!");

// Class Hero_1018.Config_101881
// 0x00A0 (0x0138 - 0x0098)
class UConfig_101881 final : public UMarvelAbilityConfig
{
public:
	float                                         StartDecreasingAfterSeconds;                       // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarkManaDecreasingVelocity;                        // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DarkManaMaxLimit;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarkManaAfterReachMaxDecreasingVelocity;           // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayDecreasingTime;                               // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbilityManaConfig_101881>      DarkManaIncreasementConfig;                        // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BondAbilityTags;                                   // 0x00C0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BondAbilityManaIncreaseVelocity;                   // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTriggerFastDecreasingOnBondState;           // 0x012C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTriggerDeBuffOnBondState;                   // 0x012D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12E[0x2];                                      // 0x012E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnergyMultiplierOnBondState;                       // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayDecreasingTimeOnBondState;                    // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101881">();
	}
	static class UConfig_101881* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101881>();
	}
};
static_assert(alignof(UConfig_101881) == 0x000008, "Wrong alignment on UConfig_101881");
static_assert(sizeof(UConfig_101881) == 0x000138, "Wrong size on UConfig_101881");
static_assert(offsetof(UConfig_101881, StartDecreasingAfterSeconds) == 0x000098, "Member 'UConfig_101881::StartDecreasingAfterSeconds' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DarkManaDecreasingVelocity) == 0x00009C, "Member 'UConfig_101881::DarkManaDecreasingVelocity' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DarkManaMaxLimit) == 0x0000A0, "Member 'UConfig_101881::DarkManaMaxLimit' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DarkManaAfterReachMaxDecreasingVelocity) == 0x0000A4, "Member 'UConfig_101881::DarkManaAfterReachMaxDecreasingVelocity' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DelayDecreasingTime) == 0x0000A8, "Member 'UConfig_101881::DelayDecreasingTime' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DarkManaIncreasementConfig) == 0x0000B0, "Member 'UConfig_101881::DarkManaIncreasementConfig' has a wrong offset!");
static_assert(offsetof(UConfig_101881, BondAbilityTags) == 0x0000C0, "Member 'UConfig_101881::BondAbilityTags' has a wrong offset!");
static_assert(offsetof(UConfig_101881, BondAbilityManaIncreaseVelocity) == 0x000128, "Member 'UConfig_101881::BondAbilityManaIncreaseVelocity' has a wrong offset!");
static_assert(offsetof(UConfig_101881, bShouldTriggerFastDecreasingOnBondState) == 0x00012C, "Member 'UConfig_101881::bShouldTriggerFastDecreasingOnBondState' has a wrong offset!");
static_assert(offsetof(UConfig_101881, bShouldTriggerDeBuffOnBondState) == 0x00012D, "Member 'UConfig_101881::bShouldTriggerDeBuffOnBondState' has a wrong offset!");
static_assert(offsetof(UConfig_101881, EnergyMultiplierOnBondState) == 0x000130, "Member 'UConfig_101881::EnergyMultiplierOnBondState' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DelayDecreasingTimeOnBondState) == 0x000134, "Member 'UConfig_101881::DelayDecreasingTimeOnBondState' has a wrong offset!");

// Class Hero_1018.Ability_101881
// 0x0148 (0x26C8 - 0x2580)
class UAbility_101881 : public UMarvelGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             DarkManaValueChangedDelegate;                      // 0x2580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	EAbilityState_101881                          AbilityState;                                      // 0x2590(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2591[0x7];                                     // 0x2591(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             AbilityStateChangedDelegate;                       // 0x2598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBondAbilityStateChanged;                         // 0x25A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UConfig_101881*                         Config;                                            // 0x25B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C0[0x108];                                   // 0x25C0(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAntiHealBuff();
	void ClearDarkMana();
	float GetCurrentDarkMana();
	float GetCurrentManaPercentage();
	void OnAbilityDamage(class UGameplayAbility* Ability, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnAbilityHit(class UGameplayAbility* Ability, const TArray<struct FHitResult>& HitResults);
	void OnAbilityStateUpdate();
	void OnBondAbilityTagUpdate(const struct FGameplayTag& Tag, bool TagExists);
	void OnManaAttributeChanged(class AActor* InSourceAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnManaReachMax();
	void OnOwnerAbilityMissile(class UGameplayAbility* Ability);
	void OnOwnerActivateAbility(int32 AbilityID);
	void OnOwnerCharactorReborn(class AActor* TargetActor, const struct FCharacterRebornParam& Param);
	void OnOwnerDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void ServerClearDarkMana();
	void SetDarkManaValue(float InDarkManaValue);

	bool IsBondAbilityState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101881">();
	}
	static class UAbility_101881* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101881>();
	}
};
static_assert(alignof(UAbility_101881) == 0x000008, "Wrong alignment on UAbility_101881");
static_assert(sizeof(UAbility_101881) == 0x0026C8, "Wrong size on UAbility_101881");
static_assert(offsetof(UAbility_101881, DarkManaValueChangedDelegate) == 0x002580, "Member 'UAbility_101881::DarkManaValueChangedDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_101881, AbilityState) == 0x002590, "Member 'UAbility_101881::AbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_101881, AbilityStateChangedDelegate) == 0x002598, "Member 'UAbility_101881::AbilityStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_101881, OnBondAbilityStateChanged) == 0x0025A8, "Member 'UAbility_101881::OnBondAbilityStateChanged' has a wrong offset!");
static_assert(offsetof(UAbility_101881, Config) == 0x0025B8, "Member 'UAbility_101881::Config' has a wrong offset!");

// Class Hero_1018.Cue_Ability_Loop_10188101
// 0x0148 (0x0F98 - 0x0E50)
class ACue_Ability_Loop_10188101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E50[0x8];                                      // 0x0E50(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeginAppearValue;                                  // 0x0E58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5C[0x4];                                      // 0x0E5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ManaCurveFloat;                                    // 0x0E60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MaterialStartCurve;                                // 0x0E68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MaterialEndCurve;                                  // 0x0E70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MaterialIntervalCurve;                             // 0x0E78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialStartAudioID;                              // 0x0E80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialEndAudioID;                                // 0x0E84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RTPCAudioName;                                     // 0x0E88(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TipsAudioID;                                       // 0x0E98(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FullAudioID;                                       // 0x0E9C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TipsAudioTrigger;                                  // 0x0EA0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECueAbilityState_101881                       EffectState;                                       // 0x0EA4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA5[0x3];                                      // 0x0EA5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   MyCharacter;                                       // 0x0EA8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbility_101881*                        Ability_101881;                                    // 0x0EB0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 CurrentMesh;                                       // 0x0EB8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BondAbilitySwitchCurve;                            // 0x0EC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloakColorParameterName;                           // 0x0EC8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBondAbility;                                   // 0x0ED4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerFullAudio;                                 // 0x0ED5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED6[0xC2];                                     // 0x0ED6(0x00C2)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBondAbilityStateChanged();
	void OnBondAbilityTagUpdate(const struct FGameplayTag& Tag, bool TagExists);
	void OnChildActorResetMaterial();
	void OnCloakColorChanged(class FName TrackName, class FName PropertyName, float OutValue);
	void OnCloakColorChangedEnd();
	void OnDarkManaValueChanged(float ManaPercentage);
	void SetCloseState();
	void SetEndCenterEdgeMaterialValue(class FName TrackName, class FName PropertyName, float OutValue);
	void SetOpenState();
	void SetStartCenterEdgeMaterialValue(class FName TrackName, class FName PropertyName, float OutValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10188101">();
	}
	static class ACue_Ability_Loop_10188101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10188101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10188101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10188101");
static_assert(sizeof(ACue_Ability_Loop_10188101) == 0x000F98, "Wrong size on ACue_Ability_Loop_10188101");
static_assert(offsetof(ACue_Ability_Loop_10188101, BeginAppearValue) == 0x000E58, "Member 'ACue_Ability_Loop_10188101::BeginAppearValue' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, ManaCurveFloat) == 0x000E60, "Member 'ACue_Ability_Loop_10188101::ManaCurveFloat' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MaterialStartCurve) == 0x000E68, "Member 'ACue_Ability_Loop_10188101::MaterialStartCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MaterialEndCurve) == 0x000E70, "Member 'ACue_Ability_Loop_10188101::MaterialEndCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MaterialIntervalCurve) == 0x000E78, "Member 'ACue_Ability_Loop_10188101::MaterialIntervalCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MaterialStartAudioID) == 0x000E80, "Member 'ACue_Ability_Loop_10188101::MaterialStartAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MaterialEndAudioID) == 0x000E84, "Member 'ACue_Ability_Loop_10188101::MaterialEndAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, RTPCAudioName) == 0x000E88, "Member 'ACue_Ability_Loop_10188101::RTPCAudioName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, TipsAudioID) == 0x000E98, "Member 'ACue_Ability_Loop_10188101::TipsAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, FullAudioID) == 0x000E9C, "Member 'ACue_Ability_Loop_10188101::FullAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, TipsAudioTrigger) == 0x000EA0, "Member 'ACue_Ability_Loop_10188101::TipsAudioTrigger' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, EffectState) == 0x000EA4, "Member 'ACue_Ability_Loop_10188101::EffectState' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MyCharacter) == 0x000EA8, "Member 'ACue_Ability_Loop_10188101::MyCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, Ability_101881) == 0x000EB0, "Member 'ACue_Ability_Loop_10188101::Ability_101881' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, CurrentMesh) == 0x000EB8, "Member 'ACue_Ability_Loop_10188101::CurrentMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, BondAbilitySwitchCurve) == 0x000EC0, "Member 'ACue_Ability_Loop_10188101::BondAbilitySwitchCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, CloakColorParameterName) == 0x000EC8, "Member 'ACue_Ability_Loop_10188101::CloakColorParameterName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, bHasBondAbility) == 0x000ED4, "Member 'ACue_Ability_Loop_10188101::bHasBondAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, bTriggerFullAudio) == 0x000ED5, "Member 'ACue_Ability_Loop_10188101::bTriggerFullAudio' has a wrong offset!");

// Class Hero_1018.DoctorStrangeAnimInstance
// 0x0020 (0x0930 - 0x0910)
class UDoctorStrangeAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsFlying;                                         // 0x0910(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFloating;                                       // 0x0911(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDefending;                                      // 0x0912(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_913[0x1];                                      // 0x0913(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AimOffsetAnimIndex;                                // 0x0914(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFloatDefending;                                   // 0x0918(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_919[0x3];                                      // 0x0919(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VFloatForward;                                     // 0x091C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VFloatRight;                                       // 0x0920(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKnockWhenDefence;                                 // 0x0924(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_925[0xB];                                      // 0x0925(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStrangeAnimInstance">();
	}
	static class UDoctorStrangeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorStrangeAnimInstance>();
	}
};
static_assert(alignof(UDoctorStrangeAnimInstance) == 0x000010, "Wrong alignment on UDoctorStrangeAnimInstance");
static_assert(sizeof(UDoctorStrangeAnimInstance) == 0x000930, "Wrong size on UDoctorStrangeAnimInstance");
static_assert(offsetof(UDoctorStrangeAnimInstance, bIsFlying) == 0x000910, "Member 'UDoctorStrangeAnimInstance::bIsFlying' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, bIsFloating) == 0x000911, "Member 'UDoctorStrangeAnimInstance::bIsFloating' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, bIsDefending) == 0x000912, "Member 'UDoctorStrangeAnimInstance::bIsDefending' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, AimOffsetAnimIndex) == 0x000914, "Member 'UDoctorStrangeAnimInstance::AimOffsetAnimIndex' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, bFloatDefending) == 0x000918, "Member 'UDoctorStrangeAnimInstance::bFloatDefending' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, VFloatForward) == 0x00091C, "Member 'UDoctorStrangeAnimInstance::VFloatForward' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, VFloatRight) == 0x000920, "Member 'UDoctorStrangeAnimInstance::VFloatRight' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, bKnockWhenDefence) == 0x000924, "Member 'UDoctorStrangeAnimInstance::bKnockWhenDefence' has a wrong offset!");

// Class Hero_1018.DoctorStrangeChildActor
// 0x0020 (0x0A80 - 0x0A60)
class ADoctorStrangeChildActor final : public AMarvelCharacterChildActor
{
public:
	class UPhysicalAnimationComponent*            PhysicalAnimation;                                 // 0x0A60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneName;                                          // 0x0A68(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_A78[0x8];                                      // 0x0A78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPhysicalAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStrangeChildActor">();
	}
	static class ADoctorStrangeChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoctorStrangeChildActor>();
	}
};
static_assert(alignof(ADoctorStrangeChildActor) == 0x000008, "Wrong alignment on ADoctorStrangeChildActor");
static_assert(sizeof(ADoctorStrangeChildActor) == 0x000A80, "Wrong size on ADoctorStrangeChildActor");
static_assert(offsetof(ADoctorStrangeChildActor, PhysicalAnimation) == 0x000A60, "Member 'ADoctorStrangeChildActor::PhysicalAnimation' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeChildActor, BoneName) == 0x000A68, "Member 'ADoctorStrangeChildActor::BoneName' has a wrong offset!");

// Class Hero_1018.DoctorStrangeCharacter
// 0x0080 (0x1890 - 0x1810)
class ADoctorStrangeCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bIsDefending;                                      // 0x1810(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlying;                                         // 0x1811(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x1812(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1813[0x1];                                     // 0x1813(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentPitch;                                      // 0x1814(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDoctorStrangeMoveLogicBaseComponent*   DoctorStrangeMoveLogic;                            // 0x1818(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelMultiCapsuleComponent*           ShieldCollision;                                   // 0x1820(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1828[0x68];                                    // 0x1828(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagUpdate(const struct FGameplayTag& Tag, bool bTagExists);
	void SetIsDefending(bool bInShield);
	void SetIsFloating(bool bIsFloating_0);
	void SetIsFlying(bool bFlying);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStrangeCharacter">();
	}
	static class ADoctorStrangeCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoctorStrangeCharacter>();
	}
};
static_assert(alignof(ADoctorStrangeCharacter) == 0x000010, "Wrong alignment on ADoctorStrangeCharacter");
static_assert(sizeof(ADoctorStrangeCharacter) == 0x001890, "Wrong size on ADoctorStrangeCharacter");
static_assert(offsetof(ADoctorStrangeCharacter, bIsDefending) == 0x001810, "Member 'ADoctorStrangeCharacter::bIsDefending' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeCharacter, bIsFlying) == 0x001811, "Member 'ADoctorStrangeCharacter::bIsFlying' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeCharacter, bIsFloating) == 0x001812, "Member 'ADoctorStrangeCharacter::bIsFloating' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeCharacter, CurrentPitch) == 0x001814, "Member 'ADoctorStrangeCharacter::CurrentPitch' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeCharacter, DoctorStrangeMoveLogic) == 0x001818, "Member 'ADoctorStrangeCharacter::DoctorStrangeMoveLogic' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeCharacter, ShieldCollision) == 0x001820, "Member 'ADoctorStrangeCharacter::ShieldCollision' has a wrong offset!");

// Class Hero_1018.DoctorStrangeMoveLogicBaseComponent
// 0x0008 (0x03F8 - 0x03F0)
class UDoctorStrangeMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	TWeakObjectPtr<class AMovingCameraActor>      LandscapeCamera;                                   // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStrangeMoveLogicBaseComponent">();
	}
	static class UDoctorStrangeMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorStrangeMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UDoctorStrangeMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UDoctorStrangeMoveLogicBaseComponent");
static_assert(sizeof(UDoctorStrangeMoveLogicBaseComponent) == 0x0003F8, "Wrong size on UDoctorStrangeMoveLogicBaseComponent");
static_assert(offsetof(UDoctorStrangeMoveLogicBaseComponent, LandscapeCamera) == 0x0003F0, "Member 'UDoctorStrangeMoveLogicBaseComponent::LandscapeCamera' has a wrong offset!");

// Class Hero_1018.DoctorStrangeMovementComponent
// 0x0000 (0x1B60 - 0x1B60)
class UDoctorStrangeMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStrangeMovementComponent">();
	}
	static class UDoctorStrangeMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorStrangeMovementComponent>();
	}
};
static_assert(alignof(UDoctorStrangeMovementComponent) == 0x000010, "Wrong alignment on UDoctorStrangeMovementComponent");
static_assert(sizeof(UDoctorStrangeMovementComponent) == 0x001B60, "Wrong size on UDoctorStrangeMovementComponent");

// Class Hero_1018.EpicMomentAction_1018
// 0x0050 (0x0170 - 0x0120)
class UEpicMomentAction_1018 : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0x28];                                     // 0x0120(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    QConfig;                                           // 0x0148(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    ShieldBlockConfig;                                 // 0x0154(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         QBuffID;                                           // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QBuffCount;                                        // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldSummonerID;                                  // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldSummonerBlockDamageThreshold;                // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnActorTakeDamage(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1018">();
	}
	static class UEpicMomentAction_1018* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1018>();
	}
};
static_assert(alignof(UEpicMomentAction_1018) == 0x000008, "Wrong alignment on UEpicMomentAction_1018");
static_assert(sizeof(UEpicMomentAction_1018) == 0x000170, "Wrong size on UEpicMomentAction_1018");
static_assert(offsetof(UEpicMomentAction_1018, QConfig) == 0x000148, "Member 'UEpicMomentAction_1018::QConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1018, ShieldBlockConfig) == 0x000154, "Member 'UEpicMomentAction_1018::ShieldBlockConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1018, QBuffID) == 0x000160, "Member 'UEpicMomentAction_1018::QBuffID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1018, QBuffCount) == 0x000164, "Member 'UEpicMomentAction_1018::QBuffCount' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1018, ShieldSummonerID) == 0x000168, "Member 'UEpicMomentAction_1018::ShieldSummonerID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1018, ShieldSummonerBlockDamageThreshold) == 0x00016C, "Member 'UEpicMomentAction_1018::ShieldSummonerBlockDamageThreshold' has a wrong offset!");

// Class Hero_1018.LevelCheckPenetrationPortalInterface
// 0x0000 (0x0030 - 0x0030)
class ILevelCheckPenetrationPortalInterface final : public ILevelCheckPenetrationActorInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelCheckPenetrationPortalInterface">();
	}
	static class ILevelCheckPenetrationPortalInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILevelCheckPenetrationPortalInterface>();
	}
};
static_assert(alignof(ILevelCheckPenetrationPortalInterface) == 0x000008, "Wrong alignment on ILevelCheckPenetrationPortalInterface");
static_assert(sizeof(ILevelCheckPenetrationPortalInterface) == 0x000030, "Wrong size on ILevelCheckPenetrationPortalInterface");

// Class Hero_1018.TabData_1018
// 0x0000 (0x0050 - 0x0050)
class UTabData_1018 : public UHeroTabDataBase
{
public:
	void OnActorPreDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnActorTakeDamage(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1018">();
	}
	static class UTabData_1018* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1018>();
	}
};
static_assert(alignof(UTabData_1018) == 0x000008, "Wrong alignment on UTabData_1018");
static_assert(sizeof(UTabData_1018) == 0x000050, "Wrong size on UTabData_1018");

}

