#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1042

#include "Basic.hpp"

#include "DeclarativeUnreal_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Engine_classes.hpp"
#include "Hero_1042_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class Hero_1042.AbilityStatistics_104273
// 0x0000 (0x0088 - 0x0088)
class UAbilityStatistics_104273 final : public UTagAbilityStatistics
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityStatistics_104273">();
	}
	static class UAbilityStatistics_104273* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityStatistics_104273>();
	}
};
static_assert(alignof(UAbilityStatistics_104273) == 0x000008, "Wrong alignment on UAbilityStatistics_104273");
static_assert(sizeof(UAbilityStatistics_104273) == 0x000088, "Wrong size on UAbilityStatistics_104273");

// Class Hero_1042.Config_104202
// 0x0020 (0x00B8 - 0x0098)
class UConfig_104202 final : public UMarvelAbilityConfig
{
public:
	float                                         MeshOffset2Wall;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbSpeed;                                        // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxClimbSpeed;                                     // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbAcceleration;                                 // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationClimbing;                       // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbEndAirZSpeed;                                 // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControl;                                        // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104202">();
	}
	static class UConfig_104202* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104202>();
	}
};
static_assert(alignof(UConfig_104202) == 0x000008, "Wrong alignment on UConfig_104202");
static_assert(sizeof(UConfig_104202) == 0x0000B8, "Wrong size on UConfig_104202");
static_assert(offsetof(UConfig_104202, MeshOffset2Wall) == 0x000098, "Member 'UConfig_104202::MeshOffset2Wall' has a wrong offset!");
static_assert(offsetof(UConfig_104202, ClimbSpeed) == 0x00009C, "Member 'UConfig_104202::ClimbSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104202, MaxClimbSpeed) == 0x0000A0, "Member 'UConfig_104202::MaxClimbSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104202, ClimbAcceleration) == 0x0000A4, "Member 'UConfig_104202::ClimbAcceleration' has a wrong offset!");
static_assert(offsetof(UConfig_104202, BrakingDecelerationClimbing) == 0x0000A8, "Member 'UConfig_104202::BrakingDecelerationClimbing' has a wrong offset!");
static_assert(offsetof(UConfig_104202, ClimbEndAirZSpeed) == 0x0000AC, "Member 'UConfig_104202::ClimbEndAirZSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104202, AirControl) == 0x0000B0, "Member 'UConfig_104202::AirControl' has a wrong offset!");

// Class Hero_1042.Ability_104202
// 0x0038 (0x25B8 - 0x2580)
class UAbility_104202 final : public UMarvelGameplayAbility
{
public:
	class UConfig_104202*                         Config;                                            // 0x2580(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   AbilityOwner;                                      // 0x2588(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x2590(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputXYRate;                                       // 0x25A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CacheMaxAcceleration;                              // 0x25AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CacheMaxFlySpeed;                                  // 0x25B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CacheBrakingDecelerationFlying;                    // 0x25B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClimbEnd();
	void ClimbStart();
	void ClimbWall();
	void UpdateAbilityResources();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104202">();
	}
	static class UAbility_104202* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104202>();
	}
};
static_assert(alignof(UAbility_104202) == 0x000008, "Wrong alignment on UAbility_104202");
static_assert(sizeof(UAbility_104202) == 0x0025B8, "Wrong size on UAbility_104202");
static_assert(offsetof(UAbility_104202, Config) == 0x002580, "Member 'UAbility_104202::Config' has a wrong offset!");
static_assert(offsetof(UAbility_104202, AbilityOwner) == 0x002588, "Member 'UAbility_104202::AbilityOwner' has a wrong offset!");
static_assert(offsetof(UAbility_104202, HitNormal) == 0x002590, "Member 'UAbility_104202::HitNormal' has a wrong offset!");
static_assert(offsetof(UAbility_104202, InputXYRate) == 0x0025A8, "Member 'UAbility_104202::InputXYRate' has a wrong offset!");
static_assert(offsetof(UAbility_104202, CacheMaxAcceleration) == 0x0025AC, "Member 'UAbility_104202::CacheMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UAbility_104202, CacheMaxFlySpeed) == 0x0025B0, "Member 'UAbility_104202::CacheMaxFlySpeed' has a wrong offset!");
static_assert(offsetof(UAbility_104202, CacheBrakingDecelerationFlying) == 0x0025B4, "Member 'UAbility_104202::CacheBrakingDecelerationFlying' has a wrong offset!");

// Class Hero_1042.MarvelElectronicSpiderNestMovementComponent
// 0x1320 (0x3310 - 0x1FF0)
class UMarvelElectronicSpiderNestMovementComponent final : public UMarvelProjectileComponent
{
public:
	struct FMarvelTraceRule                       SummonedBounceRule;                                // 0x1FE8(0x0390)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_2378[0x8];                                     // 0x2378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             SummonerProjectileContext;                         // 0x2380(0x0F90)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelElectronicSpiderNestMovementComponent">();
	}
	static class UMarvelElectronicSpiderNestMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelElectronicSpiderNestMovementComponent>();
	}
};
static_assert(alignof(UMarvelElectronicSpiderNestMovementComponent) == 0x000010, "Wrong alignment on UMarvelElectronicSpiderNestMovementComponent");
static_assert(sizeof(UMarvelElectronicSpiderNestMovementComponent) == 0x003310, "Wrong size on UMarvelElectronicSpiderNestMovementComponent");
static_assert(offsetof(UMarvelElectronicSpiderNestMovementComponent, SummonedBounceRule) == 0x001FE8, "Member 'UMarvelElectronicSpiderNestMovementComponent::SummonedBounceRule' has a wrong offset!");
static_assert(offsetof(UMarvelElectronicSpiderNestMovementComponent, SummonerProjectileContext) == 0x002380, "Member 'UMarvelElectronicSpiderNestMovementComponent::SummonerProjectileContext' has a wrong offset!");

// Class Hero_1042.MarvelExplosiveSpiderMovementComponent
// 0x0390 (0x2380 - 0x1FF0)
class UMarvelExplosiveSpiderMovementComponent final : public UMarvelProjectileComponent
{
public:
	struct FMarvelTraceRule                       SummonedBounceRule;                                // 0x1FE8(0x0390)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_2378[0x8];                                     // 0x2378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelExplosiveSpiderMovementComponent">();
	}
	static class UMarvelExplosiveSpiderMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelExplosiveSpiderMovementComponent>();
	}
};
static_assert(alignof(UMarvelExplosiveSpiderMovementComponent) == 0x000010, "Wrong alignment on UMarvelExplosiveSpiderMovementComponent");
static_assert(sizeof(UMarvelExplosiveSpiderMovementComponent) == 0x002380, "Wrong size on UMarvelExplosiveSpiderMovementComponent");
static_assert(offsetof(UMarvelExplosiveSpiderMovementComponent, SummonedBounceRule) == 0x001FE8, "Member 'UMarvelExplosiveSpiderMovementComponent::SummonedBounceRule' has a wrong offset!");

// Class Hero_1042.SummonedMovementComponent_10424102
// 0x0000 (0x0A40 - 0x0A40)
class USummonedMovementComponent_10424102 final : public USummonedMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedMovementComponent_10424102">();
	}
	static class USummonedMovementComponent_10424102* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedMovementComponent_10424102>();
	}
};
static_assert(alignof(USummonedMovementComponent_10424102) == 0x000010, "Wrong alignment on USummonedMovementComponent_10424102");
static_assert(sizeof(USummonedMovementComponent_10424102) == 0x000A40, "Wrong size on USummonedMovementComponent_10424102");

// Class Hero_1042.Config_PeniParkerExlosiveSpider
// 0x0028 (0x00C0 - 0x0098)
class UConfig_PeniParkerExlosiveSpider : public UMarvelAbilityConfig
{
public:
	float                                         SpiderMoveSpeed;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRandomProjectile;                               // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpiderProjectileSpeed;                             // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSpiderProjectileSpeedMin;                    // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSpiderProjectileSpeedMax;                    // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSpiderSpeedPitchMin;                         // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSpiderSpeedPitchMax;                         // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpiderProjectileGravityScale;                      // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WebMaxOffsetDistance;                              // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_PeniParkerExlosiveSpider">();
	}
	static class UConfig_PeniParkerExlosiveSpider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_PeniParkerExlosiveSpider>();
	}
};
static_assert(alignof(UConfig_PeniParkerExlosiveSpider) == 0x000008, "Wrong alignment on UConfig_PeniParkerExlosiveSpider");
static_assert(sizeof(UConfig_PeniParkerExlosiveSpider) == 0x0000C0, "Wrong size on UConfig_PeniParkerExlosiveSpider");
static_assert(offsetof(UConfig_PeniParkerExlosiveSpider, SpiderMoveSpeed) == 0x000098, "Member 'UConfig_PeniParkerExlosiveSpider::SpiderMoveSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_PeniParkerExlosiveSpider, bIsRandomProjectile) == 0x00009C, "Member 'UConfig_PeniParkerExlosiveSpider::bIsRandomProjectile' has a wrong offset!");
static_assert(offsetof(UConfig_PeniParkerExlosiveSpider, SpiderProjectileSpeed) == 0x0000A0, "Member 'UConfig_PeniParkerExlosiveSpider::SpiderProjectileSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_PeniParkerExlosiveSpider, RandomSpiderProjectileSpeedMin) == 0x0000A4, "Member 'UConfig_PeniParkerExlosiveSpider::RandomSpiderProjectileSpeedMin' has a wrong offset!");
static_assert(offsetof(UConfig_PeniParkerExlosiveSpider, RandomSpiderProjectileSpeedMax) == 0x0000A8, "Member 'UConfig_PeniParkerExlosiveSpider::RandomSpiderProjectileSpeedMax' has a wrong offset!");
static_assert(offsetof(UConfig_PeniParkerExlosiveSpider, RandomSpiderSpeedPitchMin) == 0x0000AC, "Member 'UConfig_PeniParkerExlosiveSpider::RandomSpiderSpeedPitchMin' has a wrong offset!");
static_assert(offsetof(UConfig_PeniParkerExlosiveSpider, RandomSpiderSpeedPitchMax) == 0x0000B0, "Member 'UConfig_PeniParkerExlosiveSpider::RandomSpiderSpeedPitchMax' has a wrong offset!");
static_assert(offsetof(UConfig_PeniParkerExlosiveSpider, SpiderProjectileGravityScale) == 0x0000B4, "Member 'UConfig_PeniParkerExlosiveSpider::SpiderProjectileGravityScale' has a wrong offset!");
static_assert(offsetof(UConfig_PeniParkerExlosiveSpider, WebMaxOffsetDistance) == 0x0000B8, "Member 'UConfig_PeniParkerExlosiveSpider::WebMaxOffsetDistance' has a wrong offset!");

// Class Hero_1042.AbilityTargetActor_PawnPlacement_104241
// 0x0000 (0x1780 - 0x1780)
class AAbilityTargetActor_PawnPlacement_104241 final : public AMarvelAbilityTargetActor_PawnPlacement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTargetActor_PawnPlacement_104241">();
	}
	static class AAbilityTargetActor_PawnPlacement_104241* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityTargetActor_PawnPlacement_104241>();
	}
};
static_assert(alignof(AAbilityTargetActor_PawnPlacement_104241) == 0x000010, "Wrong alignment on AAbilityTargetActor_PawnPlacement_104241");
static_assert(sizeof(AAbilityTargetActor_PawnPlacement_104241) == 0x001780, "Wrong size on AAbilityTargetActor_PawnPlacement_104241");

// Class Hero_1042.Summoned_10424101
// 0x0000 (0x0890 - 0x0890)
class ASummoned_10424101 : public AMarvelSummonerBase
{
public:
	EState_10424101 GetCurrentState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10424101">();
	}
	static class ASummoned_10424101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10424101>();
	}
};
static_assert(alignof(ASummoned_10424101) == 0x000010, "Wrong alignment on ASummoned_10424101");
static_assert(sizeof(ASummoned_10424101) == 0x000890, "Wrong size on ASummoned_10424101");

// Class Hero_1042.SummonedComp_10424101
// 0x0000 (0x0CA0 - 0x0CA0)
class USummonedComp_10424101 : public UMarvelSummonedComponent
{
public:
	void OnMovementPlaced();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10424101">();
	}
	static class USummonedComp_10424101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10424101>();
	}
};
static_assert(alignof(USummonedComp_10424101) == 0x000010, "Wrong alignment on USummonedComp_10424101");
static_assert(sizeof(USummonedComp_10424101) == 0x000CA0, "Wrong size on USummonedComp_10424101");

// Class Hero_1042.SummonedMovementComponent_10424101
// 0x0000 (0x0A40 - 0x0A40)
class USummonedMovementComponent_10424101 final : public USummonedMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedMovementComponent_10424101">();
	}
	static class USummonedMovementComponent_10424101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedMovementComponent_10424101>();
	}
};
static_assert(alignof(USummonedMovementComponent_10424101) == 0x000010, "Wrong alignment on USummonedMovementComponent_10424101");
static_assert(sizeof(USummonedMovementComponent_10424101) == 0x000A40, "Wrong size on USummonedMovementComponent_10424101");

// Class Hero_1042.Summoned_10424102
// 0x0060 (0x08F0 - 0x0890)
class ASummoned_10424102 : public AMarvelSummonerBase
{
public:
	bool                                          bBindLifetToNest;                                  // 0x0890(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EState_10424102                               State;                                             // 0x0891(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_892[0x6];                                      // 0x0892(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSpiderStateChangeDispatcher;                     // 0x0898(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UConfig_PeniParkerExlosiveSpider*       Config;                                            // 0x08A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveMode_10424101                            MoveMode;                                          // 0x08B0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B1[0x7];                                      // 0x08B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationExpected;                                  // 0x08B8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectRadius;                                      // 0x08D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpiderMoveByEntityOrOnTheGround;                // 0x08D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D5[0x3];                                      // 0x08D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelSpiderEntity*                    SpiderEntity;                                      // 0x08D8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelExplosiveSpiderMovementComponent* MovementComponent;                                 // 0x08E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USummonedMovementComponent*             SummonedMovementComponent;                         // 0x08E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BeginAgentTask();
	void EndAgentTask();
	bool IsConfigValid();
	void MulticastLaunch(const struct FVector& StartLocation, const struct FVector& Velocity);
	void MulticastRegisterSpider(const struct FSpiderSpawnInfo& SpawnInfo);
	void OnRep_MoveMode();
	void OnRep_State();
	void OnSpiderMovingStateChange(bool bNewIsMoving);
	void OnSpiderProjectileStop(const struct FHitResult& ImpactResult);
	void ServerSetWeb(class ASummoned_10424103* InWeb, int32 InNodeIndex);

	class UMarvelSpiderEntity* GetSpiderEntity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10424102">();
	}
	static class ASummoned_10424102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10424102>();
	}
};
static_assert(alignof(ASummoned_10424102) == 0x000010, "Wrong alignment on ASummoned_10424102");
static_assert(sizeof(ASummoned_10424102) == 0x0008F0, "Wrong size on ASummoned_10424102");
static_assert(offsetof(ASummoned_10424102, bBindLifetToNest) == 0x000890, "Member 'ASummoned_10424102::bBindLifetToNest' has a wrong offset!");
static_assert(offsetof(ASummoned_10424102, State) == 0x000891, "Member 'ASummoned_10424102::State' has a wrong offset!");
static_assert(offsetof(ASummoned_10424102, OnSpiderStateChangeDispatcher) == 0x000898, "Member 'ASummoned_10424102::OnSpiderStateChangeDispatcher' has a wrong offset!");
static_assert(offsetof(ASummoned_10424102, Config) == 0x0008A8, "Member 'ASummoned_10424102::Config' has a wrong offset!");
static_assert(offsetof(ASummoned_10424102, MoveMode) == 0x0008B0, "Member 'ASummoned_10424102::MoveMode' has a wrong offset!");
static_assert(offsetof(ASummoned_10424102, LocationExpected) == 0x0008B8, "Member 'ASummoned_10424102::LocationExpected' has a wrong offset!");
static_assert(offsetof(ASummoned_10424102, DetectRadius) == 0x0008D0, "Member 'ASummoned_10424102::DetectRadius' has a wrong offset!");
static_assert(offsetof(ASummoned_10424102, bIsSpiderMoveByEntityOrOnTheGround) == 0x0008D4, "Member 'ASummoned_10424102::bIsSpiderMoveByEntityOrOnTheGround' has a wrong offset!");
static_assert(offsetof(ASummoned_10424102, SpiderEntity) == 0x0008D8, "Member 'ASummoned_10424102::SpiderEntity' has a wrong offset!");
static_assert(offsetof(ASummoned_10424102, MovementComponent) == 0x0008E0, "Member 'ASummoned_10424102::MovementComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10424102, SummonedMovementComponent) == 0x0008E8, "Member 'ASummoned_10424102::SummonedMovementComponent' has a wrong offset!");

// Class Hero_1042.SummonedComp_10424102
// 0x0000 (0x0CA0 - 0x0CA0)
class USummonedComp_10424102 : public UMarvelSummonedComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10424102">();
	}
	static class USummonedComp_10424102* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10424102>();
	}
};
static_assert(alignof(USummonedComp_10424102) == 0x000010, "Wrong alignment on USummonedComp_10424102");
static_assert(sizeof(USummonedComp_10424102) == 0x000CA0, "Wrong size on USummonedComp_10424102");

// Class Hero_1042.Summoned_10424103
// 0x0470 (0x0D00 - 0x0890)
class ASummoned_10424103 : public AMarvelSummonerBase
{
public:
	class USummonedMovementComponent*             SummonedMovement;                                  // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CentralDistToEnd;                                  // 0x0898(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckIsOverlappingWithDestruction;                // 0x089C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89D[0x3];                                      // 0x089D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 MoveNodeIndex;                                     // 0x08A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                MoveNodeOffset;                                    // 0x08B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SpiderWebMaterial;                                 // 0x08C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelGenMeshSpawnComponent*           SpiderWeb;                                         // 0x08D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelGenMeshActor*                    PyramidActor;                                      // 0x08D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelTraceRule                       TraceRule;                                         // 0x08E0(0x0390)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         CornerNum;                                         // 0x0C70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0C74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CornerPointsInterval;                              // 0x0C78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0C7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0C80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoubleLayerMesh;                                  // 0x0C84(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C85[0x3];                                      // 0x0C85(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClientRetrySpawnInterval;                          // 0x0C88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinkedGap;                                      // 0x0C8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LinkedScopeID;                                     // 0x0C90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C94[0x1C];                                     // 0x0C94(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             WebActivatedDispatcher;                            // 0x0CB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             WebReformedDispatcher;                             // 0x0CC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsLinkChar;                                       // 0x0CD0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD1[0x7];                                      // 0x0CD1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             LinkWebDispatcher;                                 // 0x0CD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RespawnMoveTime;                                   // 0x0CE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyMoveTransform;                                // 0x0CEC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevelMoveTrigger;                                 // 0x0CED(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWebSpawned;                                     // 0x0CEE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWebReleased;                                    // 0x0CEF(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WebAngleAroundNormal;                              // 0x0CF0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CF4[0xC];                                      // 0x0CF4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginSpawnWeb();
	void ClientTrySpawnWeb();
	class UMarvelGenMeshComponent* GetGenMeshComponent();
	void GetPyramidMeshVertices(TArray<struct FVector>* Vertices);
	bool GetWebCentralLocation(struct FVector* OutLocation);
	float GetWebMaxOffsetDistance();
	void GetWebValidNodesNum(int32* OutNum);
	void OnGenMeshBaseMoveFinish();
	void OnGenMeshDestroyed();
	void OnGenMeshReformed();
	void OnGenMeshRespawnMove(bool bIsReform);
	void OnGenMeshSpawnFinished(bool bSuccess);
	void OnRep_IsLinkChar();
	void OnRep_IsWebReleased();
	void OnRep_LevelMoveTrigger();
	void OnRep_WebAngle();
	void OnWebActivationChanged();
	void SetIsLinkChar(bool NewState);
	void SetIsWebReleased(bool bNewIsReleased);
	void SetIsWebSpawned(bool bNewIsSpawned);
	bool ShouldMoveWithBase();
	bool SpawnPyramidActor();
	void SwitchLevelMoveTrigger();

	class UMarvelWebEntity* GetWebEntity() const;
	bool IsWebActive() const;
	bool IsWebReleased() const;
	bool IsWebSpawned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10424103">();
	}
	static class ASummoned_10424103* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10424103>();
	}
};
static_assert(alignof(ASummoned_10424103) == 0x000010, "Wrong alignment on ASummoned_10424103");
static_assert(sizeof(ASummoned_10424103) == 0x000D00, "Wrong size on ASummoned_10424103");
static_assert(offsetof(ASummoned_10424103, SummonedMovement) == 0x000890, "Member 'ASummoned_10424103::SummonedMovement' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, CentralDistToEnd) == 0x000898, "Member 'ASummoned_10424103::CentralDistToEnd' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, bCheckIsOverlappingWithDestruction) == 0x00089C, "Member 'ASummoned_10424103::bCheckIsOverlappingWithDestruction' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, MoveNodeIndex) == 0x0008A0, "Member 'ASummoned_10424103::MoveNodeIndex' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, MoveNodeOffset) == 0x0008B0, "Member 'ASummoned_10424103::MoveNodeOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, SpiderWebMaterial) == 0x0008C8, "Member 'ASummoned_10424103::SpiderWebMaterial' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, SpiderWeb) == 0x0008D0, "Member 'ASummoned_10424103::SpiderWeb' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, PyramidActor) == 0x0008D8, "Member 'ASummoned_10424103::PyramidActor' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, TraceRule) == 0x0008E0, "Member 'ASummoned_10424103::TraceRule' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, CornerNum) == 0x000C70, "Member 'ASummoned_10424103::CornerNum' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, SphereRadius) == 0x000C74, "Member 'ASummoned_10424103::SphereRadius' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, CornerPointsInterval) == 0x000C78, "Member 'ASummoned_10424103::CornerPointsInterval' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, Height) == 0x000C7C, "Member 'ASummoned_10424103::Height' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, Length) == 0x000C80, "Member 'ASummoned_10424103::Length' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, bDoubleLayerMesh) == 0x000C84, "Member 'ASummoned_10424103::bDoubleLayerMesh' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, ClientRetrySpawnInterval) == 0x000C88, "Member 'ASummoned_10424103::ClientRetrySpawnInterval' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, MaxLinkedGap) == 0x000C8C, "Member 'ASummoned_10424103::MaxLinkedGap' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, LinkedScopeID) == 0x000C90, "Member 'ASummoned_10424103::LinkedScopeID' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, WebActivatedDispatcher) == 0x000CB0, "Member 'ASummoned_10424103::WebActivatedDispatcher' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, WebReformedDispatcher) == 0x000CC0, "Member 'ASummoned_10424103::WebReformedDispatcher' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, bIsLinkChar) == 0x000CD0, "Member 'ASummoned_10424103::bIsLinkChar' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, LinkWebDispatcher) == 0x000CD8, "Member 'ASummoned_10424103::LinkWebDispatcher' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, RespawnMoveTime) == 0x000CE8, "Member 'ASummoned_10424103::RespawnMoveTime' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, bOnlyMoveTransform) == 0x000CEC, "Member 'ASummoned_10424103::bOnlyMoveTransform' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, bLevelMoveTrigger) == 0x000CED, "Member 'ASummoned_10424103::bLevelMoveTrigger' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, bIsWebSpawned) == 0x000CEE, "Member 'ASummoned_10424103::bIsWebSpawned' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, bIsWebReleased) == 0x000CEF, "Member 'ASummoned_10424103::bIsWebReleased' has a wrong offset!");
static_assert(offsetof(ASummoned_10424103, WebAngleAroundNormal) == 0x000CF0, "Member 'ASummoned_10424103::WebAngleAroundNormal' has a wrong offset!");

// Class Hero_1042.SummonedComp_10424103
// 0x0000 (0x0CA0 - 0x0CA0)
class USummonedComp_10424103 : public UMarvelSummonedComponent
{
public:
	void K2_OnGenMeshDestroy();
	void K2_OnGenMeshReform();
	void K2_OnWebActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10424103">();
	}
	static class USummonedComp_10424103* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10424103>();
	}
};
static_assert(alignof(USummonedComp_10424103) == 0x000010, "Wrong alignment on USummonedComp_10424103");
static_assert(sizeof(USummonedComp_10424103) == 0x000CA0, "Wrong size on USummonedComp_10424103");

// Class Hero_1042.EffectiveComponent_10424101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10424101 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10424101">();
	}
	static class UEffectiveComponent_10424101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10424101>();
	}
};
static_assert(alignof(UEffectiveComponent_10424101) == 0x000010, "Wrong alignment on UEffectiveComponent_10424101");
static_assert(sizeof(UEffectiveComponent_10424101) == 0x001C00, "Wrong size on UEffectiveComponent_10424101");

// Class Hero_1042.TraceComponent_10424103
// 0x0FC0 (0x26D0 - 0x1710)
class UTraceComponent_10424103 : public UMarvelAgentTraceComponent
{
public:
	uint8                                         Pad_1708[0x8];                                     // 0x1708(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWebScopeDetectInfo                    DetectInfo;                                        // 0x1710(0x0FB0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C0[0x10];                                    // 0x26C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnPreOutTraceResults(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10424103">();
	}
	static class UTraceComponent_10424103* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10424103>();
	}
};
static_assert(alignof(UTraceComponent_10424103) == 0x000010, "Wrong alignment on UTraceComponent_10424103");
static_assert(sizeof(UTraceComponent_10424103) == 0x0026D0, "Wrong size on UTraceComponent_10424103");
static_assert(offsetof(UTraceComponent_10424103, DetectInfo) == 0x001710, "Member 'UTraceComponent_10424103::DetectInfo' has a wrong offset!");

// Class Hero_1042.TraceComponent_10420102
// 0x0000 (0x26D0 - 0x26D0)
class UTraceComponent_10420102 : public UTraceComponent_10424103
{
public:
	class UMarvelWebEntity* FindNearestLinkedWeb(class AMarvelBaseCharacter* TargetActor, uint32* OutNearestIndex);
	void InitCheckPoints();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10420102">();
	}
	static class UTraceComponent_10420102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10420102>();
	}
};
static_assert(alignof(UTraceComponent_10420102) == 0x000010, "Wrong alignment on UTraceComponent_10420102");
static_assert(sizeof(UTraceComponent_10420102) == 0x0026D0, "Wrong size on UTraceComponent_10420102");

// Class Hero_1042.EffectiveComponent_10424103
// 0x0010 (0x1C10 - 0x1C00)
class UEffectiveComponent_10424103 : public UMarvelAgentEffectiveComponent
{
public:
	TArray<class USummonedComp_10425101*>         AffectedMineComps;                                 // 0x1BF8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C08[0x8];                                     // 0x1C08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10424103">();
	}
	static class UEffectiveComponent_10424103* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10424103>();
	}
};
static_assert(alignof(UEffectiveComponent_10424103) == 0x000010, "Wrong alignment on UEffectiveComponent_10424103");
static_assert(sizeof(UEffectiveComponent_10424103) == 0x001C10, "Wrong size on UEffectiveComponent_10424103");
static_assert(offsetof(UEffectiveComponent_10424103, AffectedMineComps) == 0x001BF8, "Member 'UEffectiveComponent_10424103::AffectedMineComps' has a wrong offset!");

// Class Hero_1042.EffectiveComponent_10420101
// 0x0000 (0x1C10 - 0x1C10)
class UEffectiveComponent_10420101 final : public UEffectiveComponent_10424103
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10420101">();
	}
	static class UEffectiveComponent_10420101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10420101>();
	}
};
static_assert(alignof(UEffectiveComponent_10420101) == 0x000010, "Wrong alignment on UEffectiveComponent_10420101");
static_assert(sizeof(UEffectiveComponent_10420101) == 0x001C10, "Wrong size on UEffectiveComponent_10420101");

// Class Hero_1042.EffectiveComponent_10420102
// 0x0010 (0x1C20 - 0x1C10)
class UEffectiveComponent_10420102 : public UEffectiveComponent_10424103
{
public:
	float                                         DetectAngle;                                       // 0x1C10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C14[0xC];                                     // 0x1C14(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMarvelWebEntity* FindNearestLinkedWeb(const struct FVector& TargetActor, uint32* OutNearestIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10420102">();
	}
	static class UEffectiveComponent_10420102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10420102>();
	}
};
static_assert(alignof(UEffectiveComponent_10420102) == 0x000010, "Wrong alignment on UEffectiveComponent_10420102");
static_assert(sizeof(UEffectiveComponent_10420102) == 0x001C20, "Wrong size on UEffectiveComponent_10420102");
static_assert(offsetof(UEffectiveComponent_10420102, DetectAngle) == 0x001C10, "Member 'UEffectiveComponent_10420102::DetectAngle' has a wrong offset!");

// Class Hero_1042.GenProceduralMeshTask
// 0x0028 (0x0058 - 0x0030)
class UGenProceduralMeshTask final : public UObject
{
public:
	class AActor*                                 TaskOwner;                                         // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenProceduralMeshTask">();
	}
	static class UGenProceduralMeshTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenProceduralMeshTask>();
	}
};
static_assert(alignof(UGenProceduralMeshTask) == 0x000008, "Wrong alignment on UGenProceduralMeshTask");
static_assert(sizeof(UGenProceduralMeshTask) == 0x000058, "Wrong size on UGenProceduralMeshTask");
static_assert(offsetof(UGenProceduralMeshTask, TaskOwner) == 0x000030, "Member 'UGenProceduralMeshTask::TaskOwner' has a wrong offset!");

// Class Hero_1042.AsyncGenProceduralMeshManager
// 0x00B8 (0x00E8 - 0x0030)
class UAsyncGenProceduralMeshManager final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGenProceduralMeshTask*>         AllTasks;                                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0xA0];                                      // 0x0048(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncGenProceduralMeshManager">();
	}
	static class UAsyncGenProceduralMeshManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncGenProceduralMeshManager>();
	}
};
static_assert(alignof(UAsyncGenProceduralMeshManager) == 0x000008, "Wrong alignment on UAsyncGenProceduralMeshManager");
static_assert(sizeof(UAsyncGenProceduralMeshManager) == 0x0000E8, "Wrong size on UAsyncGenProceduralMeshManager");
static_assert(offsetof(UAsyncGenProceduralMeshManager, AllTasks) == 0x000038, "Member 'UAsyncGenProceduralMeshManager::AllTasks' has a wrong offset!");

// Class Hero_1042.Cue_Summoner_Loop_10424105
// 0x0118 (0x0FA8 - 0x0E90)
class ACue_Summoner_Loop_10424105 : public AMarvelCueNotify_Summoned
{
public:
	class ASummoned_10424103*                     OwnerSummoned;                                     // 0x0E90(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelTimelineComponent*               TimelineComp;                                      // 0x0E98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProceduralMeshComponent*               WebMeshComp;                                       // 0x0EA0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FProceduralMeshData>            WebMeshSectionData;                                // 0x0EA8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FProceduralMeshData>            WebMeshShadowSectionData;                          // 0x0EB8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UProceduralMeshComponent*               CobRootMeshComp;                                   // 0x0EC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FProceduralMeshData>            CobRootMeshSectionData;                            // 0x0ED0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   CobLinkMeshComp;                                   // 0x0EE0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASummoned_10424103>         OwnerSummonedClass;                                // 0x0EE8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WebMeshScale;                                      // 0x0EF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF4[0x4];                                      // 0x0EF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            StaticWebMesh;                                     // 0x0EF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticShadowMesh;                                  // 0x0F00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticCobRootMesh;                                 // 0x0F08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetLocationName;                                // 0x0F10(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CobBoneName;                                       // 0x0F1C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetProportion;                                  // 0x0F28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CobUnitLength;                                     // 0x0F2C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DissolveCurve;                                     // 0x0F30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DissolveMaterialName;                              // 0x0F38(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F44[0x4];                                      // 0x0F44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0F48(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F50[0x28];                                     // 0x0F50(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchingVerticesData>          NoumenonMatchingData;                              // 0x0F78(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMatchingVerticesData>          ShadowMatchingData;                                // 0x0F88(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMatchingVerticesData>          CobRootMatchingData;                               // 0x0F98(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Initialize();
	void K2_OnWebActivated();
	void OnDissolveFinish();
	void OnDissolveUpdate(class FName TrackName, class FName PropertyName, float OutValue);
	void OnWebActivated();
	void OnWebLinkedChanged(bool bIsLinked);
	void OnWebReformed();
	void StartWebTimelines();
	void UpdateLinkMesh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10424105">();
	}
	static class ACue_Summoner_Loop_10424105* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10424105>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10424105) == 0x000008, "Wrong alignment on ACue_Summoner_Loop_10424105");
static_assert(sizeof(ACue_Summoner_Loop_10424105) == 0x000FA8, "Wrong size on ACue_Summoner_Loop_10424105");
static_assert(offsetof(ACue_Summoner_Loop_10424105, OwnerSummoned) == 0x000E90, "Member 'ACue_Summoner_Loop_10424105::OwnerSummoned' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, TimelineComp) == 0x000E98, "Member 'ACue_Summoner_Loop_10424105::TimelineComp' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, WebMeshComp) == 0x000EA0, "Member 'ACue_Summoner_Loop_10424105::WebMeshComp' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, WebMeshSectionData) == 0x000EA8, "Member 'ACue_Summoner_Loop_10424105::WebMeshSectionData' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, WebMeshShadowSectionData) == 0x000EB8, "Member 'ACue_Summoner_Loop_10424105::WebMeshShadowSectionData' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, CobRootMeshComp) == 0x000EC8, "Member 'ACue_Summoner_Loop_10424105::CobRootMeshComp' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, CobRootMeshSectionData) == 0x000ED0, "Member 'ACue_Summoner_Loop_10424105::CobRootMeshSectionData' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, CobLinkMeshComp) == 0x000EE0, "Member 'ACue_Summoner_Loop_10424105::CobLinkMeshComp' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, OwnerSummonedClass) == 0x000EE8, "Member 'ACue_Summoner_Loop_10424105::OwnerSummonedClass' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, WebMeshScale) == 0x000EF0, "Member 'ACue_Summoner_Loop_10424105::WebMeshScale' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, StaticWebMesh) == 0x000EF8, "Member 'ACue_Summoner_Loop_10424105::StaticWebMesh' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, StaticShadowMesh) == 0x000F00, "Member 'ACue_Summoner_Loop_10424105::StaticShadowMesh' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, StaticCobRootMesh) == 0x000F08, "Member 'ACue_Summoner_Loop_10424105::StaticCobRootMesh' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, TargetLocationName) == 0x000F10, "Member 'ACue_Summoner_Loop_10424105::TargetLocationName' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, CobBoneName) == 0x000F1C, "Member 'ACue_Summoner_Loop_10424105::CobBoneName' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, TargetProportion) == 0x000F28, "Member 'ACue_Summoner_Loop_10424105::TargetProportion' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, CobUnitLength) == 0x000F2C, "Member 'ACue_Summoner_Loop_10424105::CobUnitLength' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, DissolveCurve) == 0x000F30, "Member 'ACue_Summoner_Loop_10424105::DissolveCurve' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, DissolveMaterialName) == 0x000F38, "Member 'ACue_Summoner_Loop_10424105::DissolveMaterialName' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, OwnerCharacter) == 0x000F48, "Member 'ACue_Summoner_Loop_10424105::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, NoumenonMatchingData) == 0x000F78, "Member 'ACue_Summoner_Loop_10424105::NoumenonMatchingData' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, ShadowMatchingData) == 0x000F88, "Member 'ACue_Summoner_Loop_10424105::ShadowMatchingData' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10424105, CobRootMatchingData) == 0x000F98, "Member 'ACue_Summoner_Loop_10424105::CobRootMatchingData' has a wrong offset!");

// Class Hero_1042.Summoned_10425101
// 0x0FE0 (0x1870 - 0x0890)
class ASummoned_10425101 : public AMarvelSummonerBase
{
public:
	class UMarvelProjectileComponent*             ProjectileMovement;                                // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelProjectileAgentTable            ProjectileData;                                    // 0x0898(0x0FD8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10425101">();
	}
	static class ASummoned_10425101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10425101>();
	}
};
static_assert(alignof(ASummoned_10425101) == 0x000010, "Wrong alignment on ASummoned_10425101");
static_assert(sizeof(ASummoned_10425101) == 0x001870, "Wrong size on ASummoned_10425101");
static_assert(offsetof(ASummoned_10425101, ProjectileMovement) == 0x000890, "Member 'ASummoned_10425101::ProjectileMovement' has a wrong offset!");
static_assert(offsetof(ASummoned_10425101, ProjectileData) == 0x000898, "Member 'ASummoned_10425101::ProjectileData' has a wrong offset!");

// Class Hero_1042.SummonedComp_10425101
// 0x0010 (0x0CB0 - 0x0CA0)
class USummonedComp_10425101 : public UMarvelSummonedComponent
{
public:
	class AActor*                                 TriggerActor;                                      // 0x0CA0(0x0008)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA8[0x8];                                      // 0x0CA8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeHiddenCount(bool bIsHidden, int32 UniqID);
	void K2_MineTrigger();
	void OnRep_TriggerActorChange();
	void OnScopeTraceResult(const TArray<struct FHitResult>& HitResults);
	void OnTriggerActorChange();
	void SetCollisionMaskFilter(bool bIsHidden);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10425101">();
	}
	static class USummonedComp_10425101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10425101>();
	}
};
static_assert(alignof(USummonedComp_10425101) == 0x000010, "Wrong alignment on USummonedComp_10425101");
static_assert(sizeof(USummonedComp_10425101) == 0x000CB0, "Wrong size on USummonedComp_10425101");
static_assert(offsetof(USummonedComp_10425101, TriggerActor) == 0x000CA0, "Member 'USummonedComp_10425101::TriggerActor' has a wrong offset!");

// Class Hero_1042.TraceComponent_10425101
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10425101 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10425101">();
	}
	static class UTraceComponent_10425101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10425101>();
	}
};
static_assert(alignof(UTraceComponent_10425101) == 0x000010, "Wrong alignment on UTraceComponent_10425101");
static_assert(sizeof(UTraceComponent_10425101) == 0x001710, "Wrong size on UTraceComponent_10425101");

// Class Hero_1042.Scope_10425101
// 0x0000 (0x1700 - 0x1700)
class AScope_10425101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10425101">();
	}
	static class AScope_10425101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10425101>();
	}
};
static_assert(alignof(AScope_10425101) == 0x000010, "Wrong alignment on AScope_10425101");
static_assert(sizeof(AScope_10425101) == 0x001700, "Wrong size on AScope_10425101");

// Class Hero_1042.Config_104261
// 0x2C58 (0x2CF0 - 0x0098)
class UConfig_104261 : public UMarvelAbilityConfig
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSelectTaskParam                       SelectTaskParam;                                   // 0x00A0(0x10A0)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         SpeedDownBuffID;                                   // 0x1140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SilkBrokenLength;                                  // 0x1144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SilkBalanceLength;                                 // 0x1148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeSilkLength;                                    // 0x114C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             BlockingTraceContext;                              // 0x1150(0x0F90)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedDownCurve;                                    // 0x20E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedDownAngle;                                 // 0x20E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAngleRatio;                                 // 0x20EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20ED[0x3];                                     // 0x20ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SilkBrakingDecelerationFalling;                    // 0x20F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SilkFallingLateralFriction;                        // 0x20F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSpeedDown;                                  // 0x20F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDash;                                       // 0x20F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableVerticalOffset;                             // 0x20FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20FB[0x1];                                     // 0x20FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalOffset;                                    // 0x20FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceleratedTime;                                   // 0x2100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDashTime;                                       // 0x2104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PullBackSpeedCurve;                                // 0x2108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDashAbilityInfo                       DashInfo;                                          // 0x2110(0x0BA8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DistanceLengthCurve;                               // 0x2CB8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraInterp*                          SilkCameraInterp;                                  // 0x2CC0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PullBackCameraTime;                                // 0x2CC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPullBackLength;                                 // 0x2CCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraInterp*                          PullBackCameraInterp;                              // 0x2CD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 BlockCameraInterpAbilityIDs;                       // 0x2CD8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CE8[0x8];                                     // 0x2CE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104261">();
	}
	static class UConfig_104261* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104261>();
	}
};
static_assert(alignof(UConfig_104261) == 0x000010, "Wrong alignment on UConfig_104261");
static_assert(sizeof(UConfig_104261) == 0x002CF0, "Wrong size on UConfig_104261");
static_assert(offsetof(UConfig_104261, SelectTaskParam) == 0x0000A0, "Member 'UConfig_104261::SelectTaskParam' has a wrong offset!");
static_assert(offsetof(UConfig_104261, SpeedDownBuffID) == 0x001140, "Member 'UConfig_104261::SpeedDownBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104261, SilkBrokenLength) == 0x001144, "Member 'UConfig_104261::SilkBrokenLength' has a wrong offset!");
static_assert(offsetof(UConfig_104261, SilkBalanceLength) == 0x001148, "Member 'UConfig_104261::SilkBalanceLength' has a wrong offset!");
static_assert(offsetof(UConfig_104261, FreeSilkLength) == 0x00114C, "Member 'UConfig_104261::FreeSilkLength' has a wrong offset!");
static_assert(offsetof(UConfig_104261, BlockingTraceContext) == 0x001150, "Member 'UConfig_104261::BlockingTraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_104261, SpeedDownCurve) == 0x0020E0, "Member 'UConfig_104261::SpeedDownCurve' has a wrong offset!");
static_assert(offsetof(UConfig_104261, MaxSpeedDownAngle) == 0x0020E8, "Member 'UConfig_104261::MaxSpeedDownAngle' has a wrong offset!");
static_assert(offsetof(UConfig_104261, bEnableAngleRatio) == 0x0020EC, "Member 'UConfig_104261::bEnableAngleRatio' has a wrong offset!");
static_assert(offsetof(UConfig_104261, SilkBrakingDecelerationFalling) == 0x0020F0, "Member 'UConfig_104261::SilkBrakingDecelerationFalling' has a wrong offset!");
static_assert(offsetof(UConfig_104261, SilkFallingLateralFriction) == 0x0020F4, "Member 'UConfig_104261::SilkFallingLateralFriction' has a wrong offset!");
static_assert(offsetof(UConfig_104261, bEnableSpeedDown) == 0x0020F8, "Member 'UConfig_104261::bEnableSpeedDown' has a wrong offset!");
static_assert(offsetof(UConfig_104261, bEnableDash) == 0x0020F9, "Member 'UConfig_104261::bEnableDash' has a wrong offset!");
static_assert(offsetof(UConfig_104261, bEnableVerticalOffset) == 0x0020FA, "Member 'UConfig_104261::bEnableVerticalOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104261, VerticalOffset) == 0x0020FC, "Member 'UConfig_104261::VerticalOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104261, AcceleratedTime) == 0x002100, "Member 'UConfig_104261::AcceleratedTime' has a wrong offset!");
static_assert(offsetof(UConfig_104261, MaxDashTime) == 0x002104, "Member 'UConfig_104261::MaxDashTime' has a wrong offset!");
static_assert(offsetof(UConfig_104261, PullBackSpeedCurve) == 0x002108, "Member 'UConfig_104261::PullBackSpeedCurve' has a wrong offset!");
static_assert(offsetof(UConfig_104261, DashInfo) == 0x002110, "Member 'UConfig_104261::DashInfo' has a wrong offset!");
static_assert(offsetof(UConfig_104261, DistanceLengthCurve) == 0x002CB8, "Member 'UConfig_104261::DistanceLengthCurve' has a wrong offset!");
static_assert(offsetof(UConfig_104261, SilkCameraInterp) == 0x002CC0, "Member 'UConfig_104261::SilkCameraInterp' has a wrong offset!");
static_assert(offsetof(UConfig_104261, PullBackCameraTime) == 0x002CC8, "Member 'UConfig_104261::PullBackCameraTime' has a wrong offset!");
static_assert(offsetof(UConfig_104261, MinPullBackLength) == 0x002CCC, "Member 'UConfig_104261::MinPullBackLength' has a wrong offset!");
static_assert(offsetof(UConfig_104261, PullBackCameraInterp) == 0x002CD0, "Member 'UConfig_104261::PullBackCameraInterp' has a wrong offset!");
static_assert(offsetof(UConfig_104261, BlockCameraInterpAbilityIDs) == 0x002CD8, "Member 'UConfig_104261::BlockCameraInterpAbilityIDs' has a wrong offset!");

// Class Hero_1042.Ability_104261
// 0x10D0 (0x3650 - 0x2580)
class UAbility_104261 : public UMarvelGameplayAbility
{
public:
	struct FMarvelAbilityTraceContext             VerifyTraceContext;                                // 0x2580(0x0F90)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 Cobweb;                                            // 0x3510(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPortalSegments                        Segments;                                          // 0x3518(0x0050)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	float                                         CurrentSilkLength;                                 // 0x3568(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLinked;                                         // 0x356C(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMoveInput;                                     // 0x356D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPressedEnd;                                    // 0x356E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_356F[0x1];                                     // 0x356F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumOfMoveInput;                                    // 0x3570(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFree;                                           // 0x3574(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDashing;                                        // 0x3575(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3576[0x2];                                     // 0x3576(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashDirection;                                     // 0x3578(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLinkStateChangeDispatcher;                       // 0x3590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCobwebDispatcher;                                // 0x35A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDashStartDispatcher;                             // 0x35B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDashStopDispatcher;                              // 0x35C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            SpeedDownEffectHandle;                             // 0x35D0(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     SpeedAttribute;                                    // 0x35D8(0x0040)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3618[0x8];                                     // 0x3618(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x3620(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConfig_104261*                         Config;                                            // 0x3628(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelAbilityTask_SelectTarget*        SelectTask;                                        // 0x3630(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelAbilityTask_Dash*                DashTask;                                          // 0x3638(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 PotentialCobweb;                                   // 0x3640(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3648[0x8];                                     // 0x3648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindPortalEndDelegate(class APortalViewActor* InPortal, bool bBind);
	void ClearPortalSegments();
	void DashToWeb();
	int32 GetCurrentTimelineIndex();
	float GetDashDeltaLength();
	void GetSilkLengthState(int32* OutStage, float* OutProgress);
	bool IsInLinkableRange();
	bool IsTargetBlocked(class AActor* Target);
	void OnDashFinished(EDashStopReason Reason);
	void OnGameplayActorRemoved(class AActor* GameplayActor);
	void OnLinkStateChanged(bool bNewState);
	void OnMovementPreUpdate(float DeltaSeconds);
	void OnPortalSegmentsEnd(class AActor* Value);
	void OnRep_Cobweb();
	void OnRep_DashDirection();
	void OnRep_IsDashing();
	void OnRep_IsLinked();
	void Server_StartDash(const struct FVector& TargetPosition, const float MaxSpeed, const float DashDuration, const struct FPortalSegments& InSegment);
	void SetCobweb(class AActor* InCobWeb);
	void SetLinkState(bool bNewState);
	void SetPortalSegments(const struct FPortalSegments& InSegments);
	void StartDash(const struct FVector& TargetPosition, const float MaxSpeed, const float DashDuration, const struct FPortalSegments& InSegment);
	bool TraceForCobweb();
	void UpdateCurrentSilkLength();
	void UpdateFallingFrictionAndDeceleration(bool bHasSpeedDown);
	void UpdateSpeedDownMagnitude();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104261">();
	}
	static class UAbility_104261* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104261>();
	}
};
static_assert(alignof(UAbility_104261) == 0x000010, "Wrong alignment on UAbility_104261");
static_assert(sizeof(UAbility_104261) == 0x003650, "Wrong size on UAbility_104261");
static_assert(offsetof(UAbility_104261, VerifyTraceContext) == 0x002580, "Member 'UAbility_104261::VerifyTraceContext' has a wrong offset!");
static_assert(offsetof(UAbility_104261, Cobweb) == 0x003510, "Member 'UAbility_104261::Cobweb' has a wrong offset!");
static_assert(offsetof(UAbility_104261, Segments) == 0x003518, "Member 'UAbility_104261::Segments' has a wrong offset!");
static_assert(offsetof(UAbility_104261, CurrentSilkLength) == 0x003568, "Member 'UAbility_104261::CurrentSilkLength' has a wrong offset!");
static_assert(offsetof(UAbility_104261, bIsLinked) == 0x00356C, "Member 'UAbility_104261::bIsLinked' has a wrong offset!");
static_assert(offsetof(UAbility_104261, bHasMoveInput) == 0x00356D, "Member 'UAbility_104261::bHasMoveInput' has a wrong offset!");
static_assert(offsetof(UAbility_104261, bHasPressedEnd) == 0x00356E, "Member 'UAbility_104261::bHasPressedEnd' has a wrong offset!");
static_assert(offsetof(UAbility_104261, NumOfMoveInput) == 0x003570, "Member 'UAbility_104261::NumOfMoveInput' has a wrong offset!");
static_assert(offsetof(UAbility_104261, bIsFree) == 0x003574, "Member 'UAbility_104261::bIsFree' has a wrong offset!");
static_assert(offsetof(UAbility_104261, bIsDashing) == 0x003575, "Member 'UAbility_104261::bIsDashing' has a wrong offset!");
static_assert(offsetof(UAbility_104261, DashDirection) == 0x003578, "Member 'UAbility_104261::DashDirection' has a wrong offset!");
static_assert(offsetof(UAbility_104261, OnLinkStateChangeDispatcher) == 0x003590, "Member 'UAbility_104261::OnLinkStateChangeDispatcher' has a wrong offset!");
static_assert(offsetof(UAbility_104261, OnCobwebDispatcher) == 0x0035A0, "Member 'UAbility_104261::OnCobwebDispatcher' has a wrong offset!");
static_assert(offsetof(UAbility_104261, OnDashStartDispatcher) == 0x0035B0, "Member 'UAbility_104261::OnDashStartDispatcher' has a wrong offset!");
static_assert(offsetof(UAbility_104261, OnDashStopDispatcher) == 0x0035C0, "Member 'UAbility_104261::OnDashStopDispatcher' has a wrong offset!");
static_assert(offsetof(UAbility_104261, SpeedDownEffectHandle) == 0x0035D0, "Member 'UAbility_104261::SpeedDownEffectHandle' has a wrong offset!");
static_assert(offsetof(UAbility_104261, SpeedAttribute) == 0x0035D8, "Member 'UAbility_104261::SpeedAttribute' has a wrong offset!");
static_assert(offsetof(UAbility_104261, OwnerCharacter) == 0x003620, "Member 'UAbility_104261::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_104261, Config) == 0x003628, "Member 'UAbility_104261::Config' has a wrong offset!");
static_assert(offsetof(UAbility_104261, SelectTask) == 0x003630, "Member 'UAbility_104261::SelectTask' has a wrong offset!");
static_assert(offsetof(UAbility_104261, DashTask) == 0x003638, "Member 'UAbility_104261::DashTask' has a wrong offset!");
static_assert(offsetof(UAbility_104261, PotentialCobweb) == 0x003640, "Member 'UAbility_104261::PotentialCobweb' has a wrong offset!");

// Class Hero_1042.Cue_Ability_Loop_10426101
// 0x0008 (0x1040 - 0x1038)
class ACue_Ability_Loop_10426101 : public AMarvelCueNotify_Buff
{
public:
	class UMarvelGameplayAbility*                 OwnerAbility;                                      // 0x1038(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UMarvelGameplayAbility* GetOwnerAbility();
	void UpdateWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10426101">();
	}
	static class ACue_Ability_Loop_10426101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10426101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10426101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10426101");
static_assert(sizeof(ACue_Ability_Loop_10426101) == 0x001040, "Wrong size on ACue_Ability_Loop_10426101");
static_assert(offsetof(ACue_Ability_Loop_10426101, OwnerAbility) == 0x001038, "Member 'ACue_Ability_Loop_10426101::OwnerAbility' has a wrong offset!");

// Class Hero_1042.Cue_Projectile_Loop_10426101
// 0x0030 (0x0DE0 - 0x0DB0)
class ACue_Projectile_Loop_10426101 final : public AMarvelCueNotify_Projectile
{
public:
	class UNiagaraComponent*                      NS_Loop;                                           // 0x0DB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FXTargetSocket;                                    // 0x0DB8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetPosParamName;                                // 0x0DC4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0DD0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbility_104261*                        OwningAbility;                                     // 0x0DD8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdateLoopFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10426101">();
	}
	static class ACue_Projectile_Loop_10426101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10426101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10426101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10426101");
static_assert(sizeof(ACue_Projectile_Loop_10426101) == 0x000DE0, "Wrong size on ACue_Projectile_Loop_10426101");
static_assert(offsetof(ACue_Projectile_Loop_10426101, NS_Loop) == 0x000DB0, "Member 'ACue_Projectile_Loop_10426101::NS_Loop' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10426101, FXTargetSocket) == 0x000DB8, "Member 'ACue_Projectile_Loop_10426101::FXTargetSocket' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10426101, TargetPosParamName) == 0x000DC4, "Member 'ACue_Projectile_Loop_10426101::TargetPosParamName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10426101, OwnerCharacter) == 0x000DD0, "Member 'ACue_Projectile_Loop_10426101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10426101, OwningAbility) == 0x000DD8, "Member 'ACue_Projectile_Loop_10426101::OwningAbility' has a wrong offset!");

// Class Hero_1042.Cue_AbilityLoop_10427101
// 0x0170 (0x0FC0 - 0x0E50)
class ACue_AbilityLoop_10427101 : public AMarvelCueNotify_Ability
{
public:
	class UCurveFloat*                            FXEndCurve;                                        // 0x0E50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FXParameterName;                                   // 0x0E58(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpeedLineFXParameterName;                          // 0x0E64(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpeedLineAttachSocketName;                         // 0x0E70(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRunSpeed;                                       // 0x0E7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedLineFloatCurve;                               // 0x0E80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRunMaterial_104271>            BodyRunMaterials;                                  // 0x0E88(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FRunMaterial_104271>            GunRunMaterials;                                   // 0x0E98(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_RunSpeedLine;                                   // 0x0EA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_VariantStart_01;                                // 0x0EB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_VariantStart_03;                                // 0x0EB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_VariantStart_04;                                // 0x0EC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_VariantStart_02_L_01;                           // 0x0EC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NS_VariantStart_02_L_01_SocketName;                // 0x0ED0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EDC[0x4];                                      // 0x0EDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_VariantStart_02_L_02;                           // 0x0EE0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NS_VariantStart_02_L_02_SocketName;                // 0x0EE8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF4[0x4];                                      // 0x0EF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_VariantStart_02_L_03;                           // 0x0EF8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NS_VariantStart_02_L_03_SocketName;                // 0x0F00(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0C[0x4];                                      // 0x0F0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_VariantStart_02_L_04;                           // 0x0F10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NS_VariantStart_02_L_04_SocketName;                // 0x0F18(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F24[0x4];                                      // 0x0F24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_VariantStart_02_R_01;                           // 0x0F28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NS_VariantStart_02_R_01_SocketName;                // 0x0F30(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F3C[0x4];                                      // 0x0F3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_VariantStart_02_R_02;                           // 0x0F40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NS_VariantStart_02_R_02_SocketName;                // 0x0F48(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F54[0x4];                                      // 0x0F54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_VariantStart_02_R_03;                           // 0x0F58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NS_VariantStart_02_R_03_SocketName;                // 0x0F60(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F6C[0x4];                                      // 0x0F6C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_VariantStart_02_R_04;                           // 0x0F70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NS_VariantStart_02_R_04_SocketName;                // 0x0F78(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F84[0x1C];                                     // 0x0F84(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsBeginState;                                     // 0x0FA0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFullyArmed;                                     // 0x0FA1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA2[0x6];                                      // 0x0FA2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0FA8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFormalPeniParkerChildActor*            OwnerChildActor;                                   // 0x0FB0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB8[0x8];                                      // 0x0FB8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDisappearFXState(bool NewStat);
	void SetIsFullyArmed(bool NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_AbilityLoop_10427101">();
	}
	static class ACue_AbilityLoop_10427101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_AbilityLoop_10427101>();
	}
};
static_assert(alignof(ACue_AbilityLoop_10427101) == 0x000008, "Wrong alignment on ACue_AbilityLoop_10427101");
static_assert(sizeof(ACue_AbilityLoop_10427101) == 0x000FC0, "Wrong size on ACue_AbilityLoop_10427101");
static_assert(offsetof(ACue_AbilityLoop_10427101, FXEndCurve) == 0x000E50, "Member 'ACue_AbilityLoop_10427101::FXEndCurve' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, FXParameterName) == 0x000E58, "Member 'ACue_AbilityLoop_10427101::FXParameterName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, SpeedLineFXParameterName) == 0x000E64, "Member 'ACue_AbilityLoop_10427101::SpeedLineFXParameterName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, SpeedLineAttachSocketName) == 0x000E70, "Member 'ACue_AbilityLoop_10427101::SpeedLineAttachSocketName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, MinRunSpeed) == 0x000E7C, "Member 'ACue_AbilityLoop_10427101::MinRunSpeed' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, SpeedLineFloatCurve) == 0x000E80, "Member 'ACue_AbilityLoop_10427101::SpeedLineFloatCurve' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, BodyRunMaterials) == 0x000E88, "Member 'ACue_AbilityLoop_10427101::BodyRunMaterials' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, GunRunMaterials) == 0x000E98, "Member 'ACue_AbilityLoop_10427101::GunRunMaterials' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_RunSpeedLine) == 0x000EA8, "Member 'ACue_AbilityLoop_10427101::NS_RunSpeedLine' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_01) == 0x000EB0, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_01' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_03) == 0x000EB8, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_03' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_04) == 0x000EC0, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_04' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_L_01) == 0x000EC8, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_L_01' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_L_01_SocketName) == 0x000ED0, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_L_01_SocketName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_L_02) == 0x000EE0, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_L_02' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_L_02_SocketName) == 0x000EE8, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_L_02_SocketName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_L_03) == 0x000EF8, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_L_03' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_L_03_SocketName) == 0x000F00, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_L_03_SocketName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_L_04) == 0x000F10, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_L_04' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_L_04_SocketName) == 0x000F18, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_L_04_SocketName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_R_01) == 0x000F28, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_R_01' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_R_01_SocketName) == 0x000F30, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_R_01_SocketName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_R_02) == 0x000F40, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_R_02' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_R_02_SocketName) == 0x000F48, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_R_02_SocketName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_R_03) == 0x000F58, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_R_03' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_R_03_SocketName) == 0x000F60, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_R_03_SocketName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_R_04) == 0x000F70, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_R_04' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, NS_VariantStart_02_R_04_SocketName) == 0x000F78, "Member 'ACue_AbilityLoop_10427101::NS_VariantStart_02_R_04_SocketName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, bIsBeginState) == 0x000FA0, "Member 'ACue_AbilityLoop_10427101::bIsBeginState' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, bIsFullyArmed) == 0x000FA1, "Member 'ACue_AbilityLoop_10427101::bIsFullyArmed' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, OwnerCharacter) == 0x000FA8, "Member 'ACue_AbilityLoop_10427101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10427101, OwnerChildActor) == 0x000FB0, "Member 'ACue_AbilityLoop_10427101::OwnerChildActor' has a wrong offset!");

// Class Hero_1042.Widget_10427101
// 0x0000 (0x05A8 - 0x05A8)
class UWidget_10427101 : public UMarvelUserWidget
{
public:
	void UpdateRunSpeedLine(bool bIsRunState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Widget_10427101">();
	}
	static class UWidget_10427101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidget_10427101>();
	}
};
static_assert(alignof(UWidget_10427101) == 0x000008, "Wrong alignment on UWidget_10427101");
static_assert(sizeof(UWidget_10427101) == 0x0005A8, "Wrong size on UWidget_10427101");

// Class Hero_1042.EffectiveComponent_10427501
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10427501 : public UMarvelAgentEffectiveComponent
{
public:
	TSubclassOf<class ULegacyCameraShake>         ActiveCameraShake;                                 // 0x1BF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10427501">();
	}
	static class UEffectiveComponent_10427501* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10427501>();
	}
};
static_assert(alignof(UEffectiveComponent_10427501) == 0x000010, "Wrong alignment on UEffectiveComponent_10427501");
static_assert(sizeof(UEffectiveComponent_10427501) == 0x001C00, "Wrong size on UEffectiveComponent_10427501");
static_assert(offsetof(UEffectiveComponent_10427501, ActiveCameraShake) == 0x001BF8, "Member 'UEffectiveComponent_10427501::ActiveCameraShake' has a wrong offset!");

// Class Hero_1042.EpicMomentAction_1042
// 0x0038 (0x0158 - 0x0120)
class UEpicMomentAction_1042 : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    RightConfig;                                       // 0x0128(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    SummonerHitConfig;                                 // 0x0134(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RightBuffID;                                       // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 RightInterruptAbilities;                           // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void OnActorAbilityCancel(class AActor* Source, int32 AbilityID, const class FString& SessionID, class UMarvelGameplayAbility* SourceAbility);
	void OnActorTakeDamage(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnProjectileBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Projectile, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnProjectileHit(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1042">();
	}
	static class UEpicMomentAction_1042* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1042>();
	}
};
static_assert(alignof(UEpicMomentAction_1042) == 0x000008, "Wrong alignment on UEpicMomentAction_1042");
static_assert(sizeof(UEpicMomentAction_1042) == 0x000158, "Wrong size on UEpicMomentAction_1042");
static_assert(offsetof(UEpicMomentAction_1042, RightConfig) == 0x000128, "Member 'UEpicMomentAction_1042::RightConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1042, SummonerHitConfig) == 0x000134, "Member 'UEpicMomentAction_1042::SummonerHitConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1042, RightBuffID) == 0x000140, "Member 'UEpicMomentAction_1042::RightBuffID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1042, RightInterruptAbilities) == 0x000148, "Member 'UEpicMomentAction_1042::RightInterruptAbilities' has a wrong offset!");

// Class Hero_1042.MarvelWebEntity
// 0x0190 (0x01C0 - 0x0030)
class alignas(0x10) UMarvelWebEntity final : public UObject
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UMarvelWebEntity*, class AMarvelAbilityTargetActor_Scope*> LinkedWebsAndScopes;                               // 0x00B0(0x0050)(NativeAccessSpecifierPublic)
	TMap<class AMarvelBaseCharacter*, uint32>     TargetNodeIndices;                                 // 0x0100(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x60];                                     // 0x0150(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelGenMeshActor*                    WebActor;                                          // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool FindNearestNodeLocation(class AMarvelBaseCharacter* OtherChar, struct FVector* NodeLoc);
	bool IsOverlapping(const struct FVector& Point, float Radius);
	bool IsReachingCharacter(class AMarvelBaseCharacter* OtherChar, float DetectDist, float DetectAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelWebEntity">();
	}
	static class UMarvelWebEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelWebEntity>();
	}
};
static_assert(alignof(UMarvelWebEntity) == 0x000010, "Wrong alignment on UMarvelWebEntity");
static_assert(sizeof(UMarvelWebEntity) == 0x0001C0, "Wrong size on UMarvelWebEntity");
static_assert(offsetof(UMarvelWebEntity, LinkedWebsAndScopes) == 0x0000B0, "Member 'UMarvelWebEntity::LinkedWebsAndScopes' has a wrong offset!");
static_assert(offsetof(UMarvelWebEntity, TargetNodeIndices) == 0x000100, "Member 'UMarvelWebEntity::TargetNodeIndices' has a wrong offset!");
static_assert(offsetof(UMarvelWebEntity, WebActor) == 0x0001B0, "Member 'UMarvelWebEntity::WebActor' has a wrong offset!");

// Class Hero_1042.MarvelSpiderEntity
// 0x0350 (0x0380 - 0x0030)
class UMarvelSpiderEntity final : public UObject
{
public:
	struct FVector                                Location;                                          // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OuterTransform;                                    // 0x0050(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Normal;                                            // 0x00B0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Forward;                                           // 0x00C8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingToNextWeb;                                // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             SpiderEndDelegate;                                 // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MovingStateChangedDelegate;                        // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIndicatorFlag;                                    // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x17];                                     // 0x0109(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelSpiderTarget                    Target;                                            // 0x0120(0x00B0)(NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0xB0];                                     // 0x01D0(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsMoving;                                         // 0x0280(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_281[0xFF];                                     // 0x0281(0x00FF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AMarvelBaseCharacter* GetTargetChar() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelSpiderEntity">();
	}
	static class UMarvelSpiderEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelSpiderEntity>();
	}
};
static_assert(alignof(UMarvelSpiderEntity) == 0x000010, "Wrong alignment on UMarvelSpiderEntity");
static_assert(sizeof(UMarvelSpiderEntity) == 0x000380, "Wrong size on UMarvelSpiderEntity");
static_assert(offsetof(UMarvelSpiderEntity, Location) == 0x000030, "Member 'UMarvelSpiderEntity::Location' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderEntity, OuterTransform) == 0x000050, "Member 'UMarvelSpiderEntity::OuterTransform' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderEntity, Normal) == 0x0000B0, "Member 'UMarvelSpiderEntity::Normal' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderEntity, Forward) == 0x0000C8, "Member 'UMarvelSpiderEntity::Forward' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderEntity, bIsMovingToNextWeb) == 0x0000E0, "Member 'UMarvelSpiderEntity::bIsMovingToNextWeb' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderEntity, SpiderEndDelegate) == 0x0000E8, "Member 'UMarvelSpiderEntity::SpiderEndDelegate' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderEntity, MovingStateChangedDelegate) == 0x0000F8, "Member 'UMarvelSpiderEntity::MovingStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderEntity, bIndicatorFlag) == 0x000108, "Member 'UMarvelSpiderEntity::bIndicatorFlag' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderEntity, Target) == 0x000120, "Member 'UMarvelSpiderEntity::Target' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderEntity, bIsMoving) == 0x000280, "Member 'UMarvelSpiderEntity::bIsMoving' has a wrong offset!");

// Class Hero_1042.MarvelSpiderAndWebManager
// 0x00D0 (0x01C0 - 0x00F0)
class UMarvelSpiderAndWebManager final : public UActorComponent
{
public:
	uint8                                         Pad_F0[0x4];                                       // 0x00F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxIndicatingRange;                                // 0x00F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpandedDetectDist;                                // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpandedDetectAngle;                               // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeclarationHolder                     ViewWatchHolder;                                   // 0x0108(0x0010)(NativeAccessSpecifierPrivate)
	TArray<class UMarvelWebEntity*>               AllWebs;                                           // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UMarvelSpiderEntity*>            AllSpiders;                                        // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x88];                                     // 0x0138(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMarvelWebEntity* GetWebEntity(class AMarvelGenMeshActor* InWebActor);
	void MulticastSetSpiderTarget(class AActor* SpiderOwner, class AActor* AttachedWebOwner, const struct FMarvelWebNode& InNode, class AMarvelBaseCharacter* InChar, class AActor* NextWebOwner, const struct FMarvelWebNode& InNextWebNode);
	void OnSpawnCharacter(class AMarvelBaseCharacter* InCharacter, ESpawnMethod SpawnMethod);
	void OnViewTargetChange(class AActor* ViewTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelSpiderAndWebManager">();
	}
	static class UMarvelSpiderAndWebManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelSpiderAndWebManager>();
	}
};
static_assert(alignof(UMarvelSpiderAndWebManager) == 0x000008, "Wrong alignment on UMarvelSpiderAndWebManager");
static_assert(sizeof(UMarvelSpiderAndWebManager) == 0x0001C0, "Wrong size on UMarvelSpiderAndWebManager");
static_assert(offsetof(UMarvelSpiderAndWebManager, MaxIndicatingRange) == 0x0000F4, "Member 'UMarvelSpiderAndWebManager::MaxIndicatingRange' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderAndWebManager, ExpandedDetectDist) == 0x0000F8, "Member 'UMarvelSpiderAndWebManager::ExpandedDetectDist' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderAndWebManager, ExpandedDetectAngle) == 0x0000FC, "Member 'UMarvelSpiderAndWebManager::ExpandedDetectAngle' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderAndWebManager, ViewWatchHolder) == 0x000108, "Member 'UMarvelSpiderAndWebManager::ViewWatchHolder' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderAndWebManager, AllWebs) == 0x000118, "Member 'UMarvelSpiderAndWebManager::AllWebs' has a wrong offset!");
static_assert(offsetof(UMarvelSpiderAndWebManager, AllSpiders) == 0x000128, "Member 'UMarvelSpiderAndWebManager::AllSpiders' has a wrong offset!");

// Class Hero_1042.PeniParkerAnimInstance
// 0x0070 (0x0980 - 0x0910)
class UPeniParkerAnimInstance final : public UMarvelAnimInstance
{
public:
	float                                         AimLength;                                         // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftShoulderBoneName;                              // 0x0914(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightShoulderBoneName;                             // 0x0920(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92C[0x4];                                      // 0x092C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAimOffsetBlendSpace*                   OnWallIdleAimOffset_2D;                            // 0x0930(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInDashState;                                      // 0x0938(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInAim;                                            // 0x0939(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInRun;                                            // 0x093A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInTurn;                                           // 0x093B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashAngle;                                         // 0x093C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AimOffsetAnimIndex;                                // 0x0940(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOnWall;                                         // 0x0944(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMovingOnWall;                                   // 0x0945(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOnWallIdle;                                     // 0x0946(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedJumpToTopOfWall;                              // 0x0947(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseAO;                                      // 0x0948(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInSpecialStateAndMove;                            // 0x0949(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94A[0x2];                                      // 0x094A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InSpecialStateAndMoveAplha;                        // 0x094C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_950[0x30];                                     // 0x0950(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RelevantUltimateArmedNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateShoulderGunRotation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PeniParkerAnimInstance">();
	}
	static class UPeniParkerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPeniParkerAnimInstance>();
	}
};
static_assert(alignof(UPeniParkerAnimInstance) == 0x000010, "Wrong alignment on UPeniParkerAnimInstance");
static_assert(sizeof(UPeniParkerAnimInstance) == 0x000980, "Wrong size on UPeniParkerAnimInstance");
static_assert(offsetof(UPeniParkerAnimInstance, AimLength) == 0x000910, "Member 'UPeniParkerAnimInstance::AimLength' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, LeftShoulderBoneName) == 0x000914, "Member 'UPeniParkerAnimInstance::LeftShoulderBoneName' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, RightShoulderBoneName) == 0x000920, "Member 'UPeniParkerAnimInstance::RightShoulderBoneName' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, OnWallIdleAimOffset_2D) == 0x000930, "Member 'UPeniParkerAnimInstance::OnWallIdleAimOffset_2D' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, bInDashState) == 0x000938, "Member 'UPeniParkerAnimInstance::bInDashState' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, bInAim) == 0x000939, "Member 'UPeniParkerAnimInstance::bInAim' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, bInRun) == 0x00093A, "Member 'UPeniParkerAnimInstance::bInRun' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, bInTurn) == 0x00093B, "Member 'UPeniParkerAnimInstance::bInTurn' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, DashAngle) == 0x00093C, "Member 'UPeniParkerAnimInstance::DashAngle' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, AimOffsetAnimIndex) == 0x000940, "Member 'UPeniParkerAnimInstance::AimOffsetAnimIndex' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, bIsOnWall) == 0x000944, "Member 'UPeniParkerAnimInstance::bIsOnWall' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, bIsMovingOnWall) == 0x000945, "Member 'UPeniParkerAnimInstance::bIsMovingOnWall' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, bIsOnWallIdle) == 0x000946, "Member 'UPeniParkerAnimInstance::bIsOnWallIdle' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, bNeedJumpToTopOfWall) == 0x000947, "Member 'UPeniParkerAnimInstance::bNeedJumpToTopOfWall' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, bShouldUseAO) == 0x000948, "Member 'UPeniParkerAnimInstance::bShouldUseAO' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, bInSpecialStateAndMove) == 0x000949, "Member 'UPeniParkerAnimInstance::bInSpecialStateAndMove' has a wrong offset!");
static_assert(offsetof(UPeniParkerAnimInstance, InSpecialStateAndMoveAplha) == 0x00094C, "Member 'UPeniParkerAnimInstance::InSpecialStateAndMoveAplha' has a wrong offset!");

// Class Hero_1042.PeniParkerCharacter
// 0x0040 (0x1850 - 0x1810)
class APeniParkerCharacter : public AMarvelBaseCharacter
{
public:
	int32                                         SilkAbilityID;                                     // 0x1810(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSpecialState;                                   // 0x1814(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAnimSpecialState;                               // 0x1815(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1816[0x2];                                     // 0x1816(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimSpecialStateAlpha;                             // 0x1818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181C[0x4];                                     // 0x181C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelSpiderAndWebManager*             SpiderManager;                                     // 0x1820(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAimState;                                       // 0x1828(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1829[0x3];                                     // 0x1829(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashAngle;                                         // 0x182C(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInDashState;                                      // 0x1830(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1831[0x7];                                     // 0x1831(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFormalPeniParkerChildActor*            ChildActor;                                        // 0x1838(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPeniParkerMoveLogicBaseComponent*      PeniParkerMoveLogic;                               // 0x1840(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1848[0x8];                                     // 0x1848(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginAimState(int32 AbilityID, int32 AbilityCombo);
	void ExitAimState();
	bool GetSilkDashing();
	bool IsSpawnWebBySeparateFrame();
	void OnAbilityActivate(int32 AbilityID);
	void OnAbilityInitialize(int32 AbilityID);
	void OnDashStart(const struct FVector& InDirection);
	void OnDashStop();
	void SetAimState(bool bInAimState_0);
	void SetAnimSpecialState(bool NewState);
	void SetSpecialState(bool NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PeniParkerCharacter">();
	}
	static class APeniParkerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APeniParkerCharacter>();
	}
};
static_assert(alignof(APeniParkerCharacter) == 0x000010, "Wrong alignment on APeniParkerCharacter");
static_assert(sizeof(APeniParkerCharacter) == 0x001850, "Wrong size on APeniParkerCharacter");
static_assert(offsetof(APeniParkerCharacter, SilkAbilityID) == 0x001810, "Member 'APeniParkerCharacter::SilkAbilityID' has a wrong offset!");
static_assert(offsetof(APeniParkerCharacter, bInSpecialState) == 0x001814, "Member 'APeniParkerCharacter::bInSpecialState' has a wrong offset!");
static_assert(offsetof(APeniParkerCharacter, bInAnimSpecialState) == 0x001815, "Member 'APeniParkerCharacter::bInAnimSpecialState' has a wrong offset!");
static_assert(offsetof(APeniParkerCharacter, AnimSpecialStateAlpha) == 0x001818, "Member 'APeniParkerCharacter::AnimSpecialStateAlpha' has a wrong offset!");
static_assert(offsetof(APeniParkerCharacter, SpiderManager) == 0x001820, "Member 'APeniParkerCharacter::SpiderManager' has a wrong offset!");
static_assert(offsetof(APeniParkerCharacter, bInAimState) == 0x001828, "Member 'APeniParkerCharacter::bInAimState' has a wrong offset!");
static_assert(offsetof(APeniParkerCharacter, DashAngle) == 0x00182C, "Member 'APeniParkerCharacter::DashAngle' has a wrong offset!");
static_assert(offsetof(APeniParkerCharacter, bInDashState) == 0x001830, "Member 'APeniParkerCharacter::bInDashState' has a wrong offset!");
static_assert(offsetof(APeniParkerCharacter, ChildActor) == 0x001838, "Member 'APeniParkerCharacter::ChildActor' has a wrong offset!");
static_assert(offsetof(APeniParkerCharacter, PeniParkerMoveLogic) == 0x001840, "Member 'APeniParkerCharacter::PeniParkerMoveLogic' has a wrong offset!");

// Class Hero_1042.PeniParkerChildActor
// 0x0018 (0x0A78 - 0x0A60)
class APeniParkerChildActor : public AMarvelCharacterChildActor
{
public:
	TArray<class FName>                           ForearmBoneNames;                                  // 0x0A60(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SpiderLegMesh;                                     // 0x0A70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HideForearmBone(bool NewState);
	void HideSpiderLegMesh(bool NewState);
	void PlaySpiderLegAnimation(class UAnimationAsset* Animation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PeniParkerChildActor">();
	}
	static class APeniParkerChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APeniParkerChildActor>();
	}
};
static_assert(alignof(APeniParkerChildActor) == 0x000008, "Wrong alignment on APeniParkerChildActor");
static_assert(sizeof(APeniParkerChildActor) == 0x000A78, "Wrong size on APeniParkerChildActor");
static_assert(offsetof(APeniParkerChildActor, ForearmBoneNames) == 0x000A60, "Member 'APeniParkerChildActor::ForearmBoneNames' has a wrong offset!");
static_assert(offsetof(APeniParkerChildActor, SpiderLegMesh) == 0x000A70, "Member 'APeniParkerChildActor::SpiderLegMesh' has a wrong offset!");

// Class Hero_1042.PeniMovementComponent
// 0x0010 (0x2FE0 - 0x2FD0)
class UPeniMovementComponent final : public UCharacterWallRunningComponent
{
public:
	class APeniParkerCharacter*                   PeniParkerCharacter;                               // 0x2FD0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OrientRotationLerpSpeed;                           // 0x2FD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOrientRotationInSpecial;                        // 0x2FDC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FDD[0x3];                                     // 0x2FDD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PeniMovementComponent">();
	}
	static class UPeniMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPeniMovementComponent>();
	}
};
static_assert(alignof(UPeniMovementComponent) == 0x000010, "Wrong alignment on UPeniMovementComponent");
static_assert(sizeof(UPeniMovementComponent) == 0x002FE0, "Wrong size on UPeniMovementComponent");
static_assert(offsetof(UPeniMovementComponent, PeniParkerCharacter) == 0x002FD0, "Member 'UPeniMovementComponent::PeniParkerCharacter' has a wrong offset!");
static_assert(offsetof(UPeniMovementComponent, OrientRotationLerpSpeed) == 0x002FD8, "Member 'UPeniMovementComponent::OrientRotationLerpSpeed' has a wrong offset!");
static_assert(offsetof(UPeniMovementComponent, bIsOrientRotationInSpecial) == 0x002FDC, "Member 'UPeniMovementComponent::bIsOrientRotationInSpecial' has a wrong offset!");

// Class Hero_1042.FormalPeniParkerChildActor
// 0x0180 (0x0BF8 - 0x0A78)
class AFormalPeniParkerChildActor final : public APeniParkerChildActor
{
public:
	class USkeletalMeshComponent*                 LeftShoulderGunMesh;                               // 0x0A78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 RightShoulderGunMesh;                              // 0x0A80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SpiderLegLDMesh;                                   // 0x0A88(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SpiderLegLUMesh;                                   // 0x0A90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SpiderLegRDMesh;                                   // 0x0A98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SpiderLegRUMesh;                                   // 0x0AA0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SpiderArmedChangeDispatcher;                       // 0x0AA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SweepAbilityActivateDispatcher;                    // 0x0AB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FShoulderGunAnimData                   LeftShoulderGunAnimData;                           // 0x0AC8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FShoulderGunAnimData                   RightShoulderGunAnimData;                          // 0x0AE8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BeginAimAbilityIDs;                                // 0x0B08(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 ExitAimAbilityIDs;                                 // 0x0B18(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         AimStateDuration;                                  // 0x0B28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShoulderMaterialName;                              // 0x0B2C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRightGunShoot;                                  // 0x0B38(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAimState;                                       // 0x0B39(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3A[0x6];                                      // 0x0B3A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class APeniParkerCharacter*                   OwnerCharacter;                                    // 0x0B40(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockAimTags;                                      // 0x0B48(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB0[0x48];                                     // 0x0BB0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginAimState(int32 ActivateAbilityID, int32 AbilityCombo);
	void ExitAimState();
	void FormalHideDownSpiderLegMesh(bool NewState);
	void FormalHideUpperSpiderLegMesh(bool NewState);
	void OnArmedStateChanged(bool NewState);
	void OnBlockAimTagsUpdate(const struct FGameplayTag& Tag, bool TagExists);
	void OnMeshVisibilityChanged(bool bNewHidden);
	void PlayBeginAimAnimation(int32 AnimationCombo);
	void PlayEndAimAnimation();
	void PlayLoopAimAnimation();
	void PlayShoulderGunMeshAnimation(class UAnimationAsset* Animation, bool bIsRight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FormalPeniParkerChildActor">();
	}
	static class AFormalPeniParkerChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFormalPeniParkerChildActor>();
	}
};
static_assert(alignof(AFormalPeniParkerChildActor) == 0x000008, "Wrong alignment on AFormalPeniParkerChildActor");
static_assert(sizeof(AFormalPeniParkerChildActor) == 0x000BF8, "Wrong size on AFormalPeniParkerChildActor");
static_assert(offsetof(AFormalPeniParkerChildActor, LeftShoulderGunMesh) == 0x000A78, "Member 'AFormalPeniParkerChildActor::LeftShoulderGunMesh' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, RightShoulderGunMesh) == 0x000A80, "Member 'AFormalPeniParkerChildActor::RightShoulderGunMesh' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, SpiderLegLDMesh) == 0x000A88, "Member 'AFormalPeniParkerChildActor::SpiderLegLDMesh' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, SpiderLegLUMesh) == 0x000A90, "Member 'AFormalPeniParkerChildActor::SpiderLegLUMesh' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, SpiderLegRDMesh) == 0x000A98, "Member 'AFormalPeniParkerChildActor::SpiderLegRDMesh' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, SpiderLegRUMesh) == 0x000AA0, "Member 'AFormalPeniParkerChildActor::SpiderLegRUMesh' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, SpiderArmedChangeDispatcher) == 0x000AA8, "Member 'AFormalPeniParkerChildActor::SpiderArmedChangeDispatcher' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, SweepAbilityActivateDispatcher) == 0x000AB8, "Member 'AFormalPeniParkerChildActor::SweepAbilityActivateDispatcher' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, LeftShoulderGunAnimData) == 0x000AC8, "Member 'AFormalPeniParkerChildActor::LeftShoulderGunAnimData' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, RightShoulderGunAnimData) == 0x000AE8, "Member 'AFormalPeniParkerChildActor::RightShoulderGunAnimData' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, BeginAimAbilityIDs) == 0x000B08, "Member 'AFormalPeniParkerChildActor::BeginAimAbilityIDs' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, ExitAimAbilityIDs) == 0x000B18, "Member 'AFormalPeniParkerChildActor::ExitAimAbilityIDs' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, AimStateDuration) == 0x000B28, "Member 'AFormalPeniParkerChildActor::AimStateDuration' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, ShoulderMaterialName) == 0x000B2C, "Member 'AFormalPeniParkerChildActor::ShoulderMaterialName' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, bIsRightGunShoot) == 0x000B38, "Member 'AFormalPeniParkerChildActor::bIsRightGunShoot' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, bInAimState) == 0x000B39, "Member 'AFormalPeniParkerChildActor::bInAimState' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, OwnerCharacter) == 0x000B40, "Member 'AFormalPeniParkerChildActor::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AFormalPeniParkerChildActor, BlockAimTags) == 0x000B48, "Member 'AFormalPeniParkerChildActor::BlockAimTags' has a wrong offset!");

// Class Hero_1042.SpiderLegAnimInstance_104271
// 0x0030 (0x0460 - 0x0430)
class USpiderLegAnimInstance_104271 final : public UAnimInstance
{
public:
	bool                                          bInArmedState;                                     // 0x0428(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumpStart;                                      // 0x0429(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumpLand;                                       // 0x042A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleToRun;                                        // 0x042B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunToStop;                                        // 0x042C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42D[0x3];                                      // 0x042D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LandHeight;                                        // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunToStopVelocity;                                 // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleToRunVelocity;                                 // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ArmedStateTag;                                     // 0x043C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESweepSpiderLeg_104275                        SpiderLegIndex;                                    // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USpiderLegAnimData_104271*              SpiderLegAnimData;                                 // 0x0450(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnArmedStateChange(bool bIsArmed);
	void OnOwnerActivateAbility(int32 AbilityID);
	void OnSweepAbilityActivate(ESweepSpiderLeg_104275 SweepSpiderLeg);
	void OnTurnInPlaceStarted(class UAnimMontage* Montage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpiderLegAnimInstance_104271">();
	}
	static class USpiderLegAnimInstance_104271* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpiderLegAnimInstance_104271>();
	}
};
static_assert(alignof(USpiderLegAnimInstance_104271) == 0x000010, "Wrong alignment on USpiderLegAnimInstance_104271");
static_assert(sizeof(USpiderLegAnimInstance_104271) == 0x000460, "Wrong size on USpiderLegAnimInstance_104271");
static_assert(offsetof(USpiderLegAnimInstance_104271, bInArmedState) == 0x000428, "Member 'USpiderLegAnimInstance_104271::bInArmedState' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimInstance_104271, bIsJumpStart) == 0x000429, "Member 'USpiderLegAnimInstance_104271::bIsJumpStart' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimInstance_104271, bIsJumpLand) == 0x00042A, "Member 'USpiderLegAnimInstance_104271::bIsJumpLand' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimInstance_104271, bIdleToRun) == 0x00042B, "Member 'USpiderLegAnimInstance_104271::bIdleToRun' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimInstance_104271, bRunToStop) == 0x00042C, "Member 'USpiderLegAnimInstance_104271::bRunToStop' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimInstance_104271, LandHeight) == 0x000430, "Member 'USpiderLegAnimInstance_104271::LandHeight' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimInstance_104271, RunToStopVelocity) == 0x000434, "Member 'USpiderLegAnimInstance_104271::RunToStopVelocity' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimInstance_104271, IdleToRunVelocity) == 0x000438, "Member 'USpiderLegAnimInstance_104271::IdleToRunVelocity' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimInstance_104271, ArmedStateTag) == 0x00043C, "Member 'USpiderLegAnimInstance_104271::ArmedStateTag' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimInstance_104271, SpiderLegIndex) == 0x000448, "Member 'USpiderLegAnimInstance_104271::SpiderLegIndex' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimInstance_104271, SpiderLegAnimData) == 0x000450, "Member 'USpiderLegAnimInstance_104271::SpiderLegAnimData' has a wrong offset!");

// Class Hero_1042.SpiderLegAnimData_104271
// 0x00A0 (0x00D8 - 0x0038)
class USpiderLegAnimData_104271 final : public UDataAsset
{
public:
	class UAnimSequence*                          JumpStart;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpLand;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpFalling;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Run;                                               // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RunStop;                                           // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Idle;                                              // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TurnMontage;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           OpenArmMontage;                                    // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CloseArmMontage;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SweepMontage;                                      // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UAnimMontage*>              AbilityMontageMaps;                                // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpiderLegAnimData_104271">();
	}
	static class USpiderLegAnimData_104271* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpiderLegAnimData_104271>();
	}
};
static_assert(alignof(USpiderLegAnimData_104271) == 0x000008, "Wrong alignment on USpiderLegAnimData_104271");
static_assert(sizeof(USpiderLegAnimData_104271) == 0x0000D8, "Wrong size on USpiderLegAnimData_104271");
static_assert(offsetof(USpiderLegAnimData_104271, JumpStart) == 0x000038, "Member 'USpiderLegAnimData_104271::JumpStart' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimData_104271, JumpLand) == 0x000040, "Member 'USpiderLegAnimData_104271::JumpLand' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimData_104271, JumpFalling) == 0x000048, "Member 'USpiderLegAnimData_104271::JumpFalling' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimData_104271, Run) == 0x000050, "Member 'USpiderLegAnimData_104271::Run' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimData_104271, RunStop) == 0x000058, "Member 'USpiderLegAnimData_104271::RunStop' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimData_104271, Idle) == 0x000060, "Member 'USpiderLegAnimData_104271::Idle' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimData_104271, TurnMontage) == 0x000068, "Member 'USpiderLegAnimData_104271::TurnMontage' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimData_104271, OpenArmMontage) == 0x000070, "Member 'USpiderLegAnimData_104271::OpenArmMontage' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimData_104271, CloseArmMontage) == 0x000078, "Member 'USpiderLegAnimData_104271::CloseArmMontage' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimData_104271, SweepMontage) == 0x000080, "Member 'USpiderLegAnimData_104271::SweepMontage' has a wrong offset!");
static_assert(offsetof(USpiderLegAnimData_104271, AbilityMontageMaps) == 0x000088, "Member 'USpiderLegAnimData_104271::AbilityMontageMaps' has a wrong offset!");

// Class Hero_1042.AnimNotify_PeniParkerAnimSpecialState
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_PeniParkerAnimSpecialState final : public UAnimNotify
{
public:
	bool                                          bInAnimSpecialState;                               // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PeniParkerAnimSpecialState">();
	}
	static class UAnimNotify_PeniParkerAnimSpecialState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PeniParkerAnimSpecialState>();
	}
};
static_assert(alignof(UAnimNotify_PeniParkerAnimSpecialState) == 0x000008, "Wrong alignment on UAnimNotify_PeniParkerAnimSpecialState");
static_assert(sizeof(UAnimNotify_PeniParkerAnimSpecialState) == 0x000048, "Wrong size on UAnimNotify_PeniParkerAnimSpecialState");
static_assert(offsetof(UAnimNotify_PeniParkerAnimSpecialState, bInAnimSpecialState) == 0x000040, "Member 'UAnimNotify_PeniParkerAnimSpecialState::bInAnimSpecialState' has a wrong offset!");

// Class Hero_1042.PeniParkerMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UPeniParkerMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PeniParkerMoveLogicBaseComponent">();
	}
	static class UPeniParkerMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPeniParkerMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UPeniParkerMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UPeniParkerMoveLogicBaseComponent");
static_assert(sizeof(UPeniParkerMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UPeniParkerMoveLogicBaseComponent");

}

