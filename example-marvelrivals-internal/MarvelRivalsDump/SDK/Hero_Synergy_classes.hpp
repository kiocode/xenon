#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_Synergy

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Hero_Synergy_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_Synergy.Cue_Scope_Loop_100005
// 0x0008 (0x0D78 - 0x0D70)
class ACue_Scope_Loop_100005 final : public AMarvelCueNotify_Scope
{
public:
	bool                                          bBeSeenThroughNiagara;                             // 0x0D70(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D71[0x7];                                      // 0x0D71(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_100005">();
	}
	static class ACue_Scope_Loop_100005* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_100005>();
	}
};
static_assert(alignof(ACue_Scope_Loop_100005) == 0x000008, "Wrong alignment on ACue_Scope_Loop_100005");
static_assert(sizeof(ACue_Scope_Loop_100005) == 0x000D78, "Wrong size on ACue_Scope_Loop_100005");
static_assert(offsetof(ACue_Scope_Loop_100005, bBeSeenThroughNiagara) == 0x000D70, "Member 'ACue_Scope_Loop_100005::bBeSeenThroughNiagara' has a wrong offset!");

// Class Hero_Synergy.MarvelBackTrackConfig
// 0x1FC8 (0x2060 - 0x0098)
class UMarvelBackTrackConfig final : public UMarvelAbilityConfig
{
public:
	bool                                          bHoldBackTrackSwitch;                              // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecordInterval;                                    // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRecordDistance;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTrackTime;                                     // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTrackTotalTime;                                // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTrackInterpSpeed;                              // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreFillDistance;                                   // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BackTrackTags;                                     // 0x00B8(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EMovementMode                                 BackTrackMoveMode;                                 // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BackTrackEndSectionName;                           // 0x0124(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             ReachTestTraceContext;                             // 0x0130(0x0F90)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             LandTestTraceContext;                              // 0x10C0(0x0F90)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bApplyShieldBuff;                                  // 0x2050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2051[0x3];                                     // 0x2051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NotTreatShieldBuff;                                // 0x2054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InjuryToShieldRatio;                               // 0x2058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugDrawTime;                                     // 0x205C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelBackTrackConfig">();
	}
	static class UMarvelBackTrackConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelBackTrackConfig>();
	}
};
static_assert(alignof(UMarvelBackTrackConfig) == 0x000010, "Wrong alignment on UMarvelBackTrackConfig");
static_assert(sizeof(UMarvelBackTrackConfig) == 0x002060, "Wrong size on UMarvelBackTrackConfig");
static_assert(offsetof(UMarvelBackTrackConfig, bHoldBackTrackSwitch) == 0x000098, "Member 'UMarvelBackTrackConfig::bHoldBackTrackSwitch' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, RecordInterval) == 0x00009C, "Member 'UMarvelBackTrackConfig::RecordInterval' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, MinRecordDistance) == 0x0000A0, "Member 'UMarvelBackTrackConfig::MinRecordDistance' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackTime) == 0x0000A4, "Member 'UMarvelBackTrackConfig::BackTrackTime' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackTotalTime) == 0x0000A8, "Member 'UMarvelBackTrackConfig::BackTrackTotalTime' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackInterpSpeed) == 0x0000AC, "Member 'UMarvelBackTrackConfig::BackTrackInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, PreFillDistance) == 0x0000B0, "Member 'UMarvelBackTrackConfig::PreFillDistance' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackTags) == 0x0000B8, "Member 'UMarvelBackTrackConfig::BackTrackTags' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackMoveMode) == 0x000120, "Member 'UMarvelBackTrackConfig::BackTrackMoveMode' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackEndSectionName) == 0x000124, "Member 'UMarvelBackTrackConfig::BackTrackEndSectionName' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, ReachTestTraceContext) == 0x000130, "Member 'UMarvelBackTrackConfig::ReachTestTraceContext' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, LandTestTraceContext) == 0x0010C0, "Member 'UMarvelBackTrackConfig::LandTestTraceContext' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, bApplyShieldBuff) == 0x002050, "Member 'UMarvelBackTrackConfig::bApplyShieldBuff' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, NotTreatShieldBuff) == 0x002054, "Member 'UMarvelBackTrackConfig::NotTreatShieldBuff' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, InjuryToShieldRatio) == 0x002058, "Member 'UMarvelBackTrackConfig::InjuryToShieldRatio' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, DebugDrawTime) == 0x00205C, "Member 'UMarvelBackTrackConfig::DebugDrawTime' has a wrong offset!");

// Class Hero_Synergy.MarvelBackTrackAbility
// 0x00C0 (0x2648 - 0x2588)
class UMarvelBackTrackAbility : public UAbility_108
{
public:
	TArray<struct FBackTrackContext>              PathDatas;                                         // 0x2588(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	double                                        BackTrackStartTime;                                // 0x2598(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelBackTrackConfig*                 BackTrackConfig;                                   // 0x25A0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   TargetCharacter;                                   // 0x25A8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           RecordStateTimer;                                  // 0x25B0(0x0018)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 CacheMovementMode;                                 // 0x25C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C9[0x7];                                     // 0x25C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_WaitLongPressRelease* WaitLongPressReleaseTask;                          // 0x25D0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBackTracking;                                   // 0x25D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D9[0x3];                                     // 0x25D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartPointIdx;                                     // 0x25DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StopPointIdx;                                      // 0x25E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PathPointNum;                                      // 0x25E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OutTime;                                           // 0x25E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateTimeCount;                                   // 0x25EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRecording;                                        // 0x25F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInterruptEnd;                                     // 0x25F1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F2[0x6];                                     // 0x25F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MinPos;                                            // 0x25F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MaxPos;                                            // 0x2610(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DelayStartRecordHandle;                            // 0x2628(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2640[0x8];                                     // 0x2640(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayStartRecord(bool bSetDelay);
	bool IsHoldMode();
	void MulticastInterrupt();
	void OnCharacterMovementPreUpdated(float DeltaTime);
	void OnCharTranslatedByPortal(class APortalViewActor* InPortalActor);
	void OnClientAckMoveWithStamp(const float Timestamp, const struct FVector& Location);
	void OnLivingStateChanged(EPlayerLivingState LivingState);
	void OnLongPressRelease(float TimeHeld);
	void OnLongPressTimeOverMaxHoldTime(float TimeHeld);
	void OnServerHandleClientMoveWithStamp(const float Timestamp, const struct FVector& Location);
	void RecordState(const float Timestamp, const struct FVector& Location);
	bool ServerCheckClientLocValid(const struct FVector& InTargetLoc, bool bStrictCheck);
	void ServerInterrupt(const struct FVector& InClientLocation);
	void StartBackTrack();
	void StartRecordState();
	void StopBackTrack();
	void StopRecordState(bool bClearData);

	bool SafeMoveTo(const struct FVector& TargetLoc, struct FHitResult* OutHit, bool bSweep) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelBackTrackAbility">();
	}
	static class UMarvelBackTrackAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelBackTrackAbility>();
	}
};
static_assert(alignof(UMarvelBackTrackAbility) == 0x000008, "Wrong alignment on UMarvelBackTrackAbility");
static_assert(sizeof(UMarvelBackTrackAbility) == 0x002648, "Wrong size on UMarvelBackTrackAbility");
static_assert(offsetof(UMarvelBackTrackAbility, PathDatas) == 0x002588, "Member 'UMarvelBackTrackAbility::PathDatas' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, BackTrackStartTime) == 0x002598, "Member 'UMarvelBackTrackAbility::BackTrackStartTime' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, BackTrackConfig) == 0x0025A0, "Member 'UMarvelBackTrackAbility::BackTrackConfig' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, TargetCharacter) == 0x0025A8, "Member 'UMarvelBackTrackAbility::TargetCharacter' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, RecordStateTimer) == 0x0025B0, "Member 'UMarvelBackTrackAbility::RecordStateTimer' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, CacheMovementMode) == 0x0025C8, "Member 'UMarvelBackTrackAbility::CacheMovementMode' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, WaitLongPressReleaseTask) == 0x0025D0, "Member 'UMarvelBackTrackAbility::WaitLongPressReleaseTask' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, bIsBackTracking) == 0x0025D8, "Member 'UMarvelBackTrackAbility::bIsBackTracking' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, StartPointIdx) == 0x0025DC, "Member 'UMarvelBackTrackAbility::StartPointIdx' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, StopPointIdx) == 0x0025E0, "Member 'UMarvelBackTrackAbility::StopPointIdx' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, PathPointNum) == 0x0025E4, "Member 'UMarvelBackTrackAbility::PathPointNum' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, OutTime) == 0x0025E8, "Member 'UMarvelBackTrackAbility::OutTime' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, UpdateTimeCount) == 0x0025EC, "Member 'UMarvelBackTrackAbility::UpdateTimeCount' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, bRecording) == 0x0025F0, "Member 'UMarvelBackTrackAbility::bRecording' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, bInterruptEnd) == 0x0025F1, "Member 'UMarvelBackTrackAbility::bInterruptEnd' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, MinPos) == 0x0025F8, "Member 'UMarvelBackTrackAbility::MinPos' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, MaxPos) == 0x002610, "Member 'UMarvelBackTrackAbility::MaxPos' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, DelayStartRecordHandle) == 0x002628, "Member 'UMarvelBackTrackAbility::DelayStartRecordHandle' has a wrong offset!");

// Class Hero_Synergy.TraceComponent_100009
// 0x0050 (0x1760 - 0x1710)
class UTraceComponent_100009 : public UMarvelAgentTraceComponent
{
public:
	TMap<int32, struct FGameplayTagContainer>     BondRequireTags;                                   // 0x1708(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_1758[0x8];                                     // 0x1758(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnPreOutTraceResults(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_100009">();
	}
	static class UTraceComponent_100009* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_100009>();
	}
};
static_assert(alignof(UTraceComponent_100009) == 0x000010, "Wrong alignment on UTraceComponent_100009");
static_assert(sizeof(UTraceComponent_100009) == 0x001760, "Wrong size on UTraceComponent_100009");
static_assert(offsetof(UTraceComponent_100009, BondRequireTags) == 0x001708, "Member 'UTraceComponent_100009::BondRequireTags' has a wrong offset!");

// Class Hero_Synergy.BuffManagerAbility_100009
// 0x01E8 (0x12E0 - 0x10F8)
class UBuffManagerAbility_100009 : public UMarvelEffectGameplayAbility
{
public:
	int32                                         ManagedBuffID;                                     // 0x10F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBindToDamage;                                     // 0x10FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBindToDebuff;                                     // 0x10FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10FE[0x2];                                     // 0x10FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               DebuffTagRequirements;                             // 0x1100(0x0118)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bBindToAbilities;                                  // 0x1218(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1219[0x7];                                     // 0x1219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BindToAbilitiseTags;                               // 0x1220(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bBindToCollide;                                    // 0x1288(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestoreBuff;                                      // 0x1289(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128A[0x2];                                     // 0x128A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RestoreBuffDelay;                                  // 0x128C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1290[0x50];                                    // 0x1290(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityActivate(int32 AbilityID);
	void OnAbilityEnded(int32 AbilityID);
	void OnBuffExecuted(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& EffectHandle);
	void OnBuffRemoved(const struct FGameplayEffectSpec& RemovedSpec, bool bPrematureRemoval);
	void OnOwnerCollide(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnOwnerTakeDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void RemoveBuffFromSelf();
	void RestoreBuffToSelfWithDelay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffManagerAbility_100009">();
	}
	static class UBuffManagerAbility_100009* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffManagerAbility_100009>();
	}
};
static_assert(alignof(UBuffManagerAbility_100009) == 0x000008, "Wrong alignment on UBuffManagerAbility_100009");
static_assert(sizeof(UBuffManagerAbility_100009) == 0x0012E0, "Wrong size on UBuffManagerAbility_100009");
static_assert(offsetof(UBuffManagerAbility_100009, ManagedBuffID) == 0x0010F8, "Member 'UBuffManagerAbility_100009::ManagedBuffID' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, bBindToDamage) == 0x0010FC, "Member 'UBuffManagerAbility_100009::bBindToDamage' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, bBindToDebuff) == 0x0010FD, "Member 'UBuffManagerAbility_100009::bBindToDebuff' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, DebuffTagRequirements) == 0x001100, "Member 'UBuffManagerAbility_100009::DebuffTagRequirements' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, bBindToAbilities) == 0x001218, "Member 'UBuffManagerAbility_100009::bBindToAbilities' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, BindToAbilitiseTags) == 0x001220, "Member 'UBuffManagerAbility_100009::BindToAbilitiseTags' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, bBindToCollide) == 0x001288, "Member 'UBuffManagerAbility_100009::bBindToCollide' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, bRestoreBuff) == 0x001289, "Member 'UBuffManagerAbility_100009::bRestoreBuff' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, RestoreBuffDelay) == 0x00128C, "Member 'UBuffManagerAbility_100009::RestoreBuffDelay' has a wrong offset!");

// Class Hero_Synergy.Config_100015
// 0x0160 (0x1390 - 0x1230)
#pragma pack(push, 0x1)
class alignas(0x10) UConfig_100015 : public UMarvelSelectTargetConfig
{
public:
	TMap<int32, int32>                            BondIDMap;                                         // 0x1228(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         WavingBuffID;                                      // 0x1278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WavingHoldTime;                                    // 0x127C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockAbilityTags;                                  // 0x1280(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CancelAbilityTags;                                 // 0x12E8(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bOptimizeGameStateFindTarget;                      // 0x1350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1351[0x3];                                     // 0x1351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetFilterDistance;                              // 0x1354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalEndCD;                                       // 0x1358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchEndCD;                                       // 0x135C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateChangedTaskParam                 ExitRideInputSetting;                              // 0x1360(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_100015">();
	}
	static class UConfig_100015* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_100015>();
	}
};
#pragma pack(pop)
static_assert(alignof(UConfig_100015) == 0x000010, "Wrong alignment on UConfig_100015");
static_assert(sizeof(UConfig_100015) == 0x001390, "Wrong size on UConfig_100015");
static_assert(offsetof(UConfig_100015, BondIDMap) == 0x001228, "Member 'UConfig_100015::BondIDMap' has a wrong offset!");
static_assert(offsetof(UConfig_100015, WavingBuffID) == 0x001278, "Member 'UConfig_100015::WavingBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_100015, WavingHoldTime) == 0x00127C, "Member 'UConfig_100015::WavingHoldTime' has a wrong offset!");
static_assert(offsetof(UConfig_100015, BlockAbilityTags) == 0x001280, "Member 'UConfig_100015::BlockAbilityTags' has a wrong offset!");
static_assert(offsetof(UConfig_100015, CancelAbilityTags) == 0x0012E8, "Member 'UConfig_100015::CancelAbilityTags' has a wrong offset!");
static_assert(offsetof(UConfig_100015, bOptimizeGameStateFindTarget) == 0x001350, "Member 'UConfig_100015::bOptimizeGameStateFindTarget' has a wrong offset!");
static_assert(offsetof(UConfig_100015, TargetFilterDistance) == 0x001354, "Member 'UConfig_100015::TargetFilterDistance' has a wrong offset!");
static_assert(offsetof(UConfig_100015, NormalEndCD) == 0x001358, "Member 'UConfig_100015::NormalEndCD' has a wrong offset!");
static_assert(offsetof(UConfig_100015, LaunchEndCD) == 0x00135C, "Member 'UConfig_100015::LaunchEndCD' has a wrong offset!");
static_assert(offsetof(UConfig_100015, ExitRideInputSetting) == 0x001360, "Member 'UConfig_100015::ExitRideInputSetting' has a wrong offset!");

// Class Hero_Synergy.Ability_100015
// 0x04F8 (0x2C48 - 0x2750)
class UAbility_100015 : public UMarvelSelectTargetAbility
{
public:
	class AMarvelGameState*                       CurrentGameState;                                  // 0x2750(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwningCharacter;                                   // 0x2758(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_100015*                         CoopConfig;                                        // 0x2760(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   WavingCharacter;                                   // 0x2768(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   ConfirmedCharacter;                                // 0x2770(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWavingStateChanged;                              // 0x2778(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FSynergyWavingData                     WavingData;                                        // 0x2788(0x02E8)(BlueprintVisible, Net, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	ESynergyWavingState                           CurrentWavingState;                                // 0x2A70(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A71[0x7];                                     // 0x2A71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   TraceHeroIDSet;                                    // 0x2A78(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           WavingHoldTimer;                                   // 0x2AC8(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConfirmed;                                        // 0x2AE0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AE1[0x7];                                     // 0x2AE1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_WaitInputStateChanged* RideCancelTask;                                    // 0x2AE8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         RideCancelKey;                                     // 0x2AF0(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B90[0x18];                                    // 0x2B90(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         WavingStateRPCKey;                                 // 0x2BA8(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddWavingData(const struct FHitResult& InHitResult);
	void BindCancelRideInput();
	void CancelRelevantSynergyAbility(bool bNormalEnd);
	void ClearWavingHoldTimer();
	void ClientCheckWavingState(ESynergyWavingState AuthorityRoleState);
	void CustomCommitSynergyCoolDown(bool bNormalEnd);
	struct FPortalSegments GetDashPortalSegments();
	class UAbility_100015* GetRelevantSynergyAbility(class AMarvelBaseCharacter* InCharacter);
	bool HasActiveBond();
	bool IsAbilityNormalEnd();
	void K2_OnStartWaving();
	void K2_OnWavingConfirmed();
	void K2_OnWavingTimeOut();
	void OnCoopAbilityTickStateChanged(bool bShouldAbilityTick);
	void OnOwnerGameplayTagUpdate(const struct FGameplayTag& InTag, bool bTagExists);
	void OnRep_ConfirmedCharacter();
	void OnRep_CurrentWavingState();
	void OnRep_WavingData();
	void OnRideCancel(float StateIntervalTime);
	void Python_OnRideCancel();
	void SetCurrentWavingCharacter(const class AActor* TargetActor);
	void SetWavingConfirmedByCharacter(class AMarvelBaseCharacter* InCharacter);
	void SetWavingState(ESynergyWavingState InNewState);

	ESynergyWavingState GetWavingState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_100015">();
	}
	static class UAbility_100015* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_100015>();
	}
};
static_assert(alignof(UAbility_100015) == 0x000008, "Wrong alignment on UAbility_100015");
static_assert(sizeof(UAbility_100015) == 0x002C48, "Wrong size on UAbility_100015");
static_assert(offsetof(UAbility_100015, CurrentGameState) == 0x002750, "Member 'UAbility_100015::CurrentGameState' has a wrong offset!");
static_assert(offsetof(UAbility_100015, OwningCharacter) == 0x002758, "Member 'UAbility_100015::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_100015, CoopConfig) == 0x002760, "Member 'UAbility_100015::CoopConfig' has a wrong offset!");
static_assert(offsetof(UAbility_100015, WavingCharacter) == 0x002768, "Member 'UAbility_100015::WavingCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_100015, ConfirmedCharacter) == 0x002770, "Member 'UAbility_100015::ConfirmedCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_100015, OnWavingStateChanged) == 0x002778, "Member 'UAbility_100015::OnWavingStateChanged' has a wrong offset!");
static_assert(offsetof(UAbility_100015, WavingData) == 0x002788, "Member 'UAbility_100015::WavingData' has a wrong offset!");
static_assert(offsetof(UAbility_100015, CurrentWavingState) == 0x002A70, "Member 'UAbility_100015::CurrentWavingState' has a wrong offset!");
static_assert(offsetof(UAbility_100015, TraceHeroIDSet) == 0x002A78, "Member 'UAbility_100015::TraceHeroIDSet' has a wrong offset!");
static_assert(offsetof(UAbility_100015, WavingHoldTimer) == 0x002AC8, "Member 'UAbility_100015::WavingHoldTimer' has a wrong offset!");
static_assert(offsetof(UAbility_100015, bConfirmed) == 0x002AE0, "Member 'UAbility_100015::bConfirmed' has a wrong offset!");
static_assert(offsetof(UAbility_100015, RideCancelTask) == 0x002AE8, "Member 'UAbility_100015::RideCancelTask' has a wrong offset!");
static_assert(offsetof(UAbility_100015, RideCancelKey) == 0x002AF0, "Member 'UAbility_100015::RideCancelKey' has a wrong offset!");
static_assert(offsetof(UAbility_100015, WavingStateRPCKey) == 0x002BA8, "Member 'UAbility_100015::WavingStateRPCKey' has a wrong offset!");

// Class Hero_Synergy.UIC_SelectTarget_100015
// 0x00B8 (0x0210 - 0x0158)
class UUIC_SelectTarget_100015 final : public UUIC_SelectTarget
{
public:
	struct FUIActionData                          WaveActionData;                                    // 0x0158(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUIActionData                          ConfirmActionData;                                 // 0x01B0(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAbility_100015*                        OwningAbility;                                     // 0x0208(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIC_SelectTarget_100015">();
	}
	static class UUIC_SelectTarget_100015* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIC_SelectTarget_100015>();
	}
};
static_assert(alignof(UUIC_SelectTarget_100015) == 0x000008, "Wrong alignment on UUIC_SelectTarget_100015");
static_assert(sizeof(UUIC_SelectTarget_100015) == 0x000210, "Wrong size on UUIC_SelectTarget_100015");
static_assert(offsetof(UUIC_SelectTarget_100015, WaveActionData) == 0x000158, "Member 'UUIC_SelectTarget_100015::WaveActionData' has a wrong offset!");
static_assert(offsetof(UUIC_SelectTarget_100015, ConfirmActionData) == 0x0001B0, "Member 'UUIC_SelectTarget_100015::ConfirmActionData' has a wrong offset!");
static_assert(offsetof(UUIC_SelectTarget_100015, OwningAbility) == 0x000208, "Member 'UUIC_SelectTarget_100015::OwningAbility' has a wrong offset!");

// Class Hero_Synergy.Config_100016
// 0x0030 (0x00C8 - 0x0098)
class UConfig_100016 : public UMarvelAbilityConfig
{
public:
	struct FVector                                ThrowSplineOffset;                                 // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowSplineInitSpeed;                              // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowSplineMaxSpeed;                               // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowSplineMaxAcceleration;                        // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowSplineUpGravityRatio;                         // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowSplineDownGravityRatio;                       // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_100016">();
	}
	static class UConfig_100016* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_100016>();
	}
};
static_assert(alignof(UConfig_100016) == 0x000008, "Wrong alignment on UConfig_100016");
static_assert(sizeof(UConfig_100016) == 0x0000C8, "Wrong size on UConfig_100016");
static_assert(offsetof(UConfig_100016, ThrowSplineOffset) == 0x000098, "Member 'UConfig_100016::ThrowSplineOffset' has a wrong offset!");
static_assert(offsetof(UConfig_100016, ThrowSplineInitSpeed) == 0x0000B0, "Member 'UConfig_100016::ThrowSplineInitSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_100016, ThrowSplineMaxSpeed) == 0x0000B4, "Member 'UConfig_100016::ThrowSplineMaxSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_100016, ThrowSplineMaxAcceleration) == 0x0000B8, "Member 'UConfig_100016::ThrowSplineMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UConfig_100016, ThrowSplineUpGravityRatio) == 0x0000BC, "Member 'UConfig_100016::ThrowSplineUpGravityRatio' has a wrong offset!");
static_assert(offsetof(UConfig_100016, ThrowSplineDownGravityRatio) == 0x0000C0, "Member 'UConfig_100016::ThrowSplineDownGravityRatio' has a wrong offset!");

// Class Hero_Synergy.Ability_100016
// 0x0048 (0x25E0 - 0x2598)
class UAbility_100016 : public UMarvelAbility_LongPressTrigger
{
public:
	FMulticastInlineDelegateProperty_             ThrowSplineHudEnabledDispatcher;                   // 0x2598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   ThrowCharacter;                                    // 0x25A8(0x0008)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowPrediction_UpHeight;                          // 0x25B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowPrediction_DownHeight;                        // 0x25B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowPrediction_UpSeconds;                         // 0x25B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowPrediction_DownSeconds;                       // 0x25BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceMoveSpeed;                                    // 0x25C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpGravityRatio;                                    // 0x25C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownGravityRatio;                                  // 0x25C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMoveSpeed;                                      // 0x25CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x25D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReleased;                                         // 0x25D4(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D5[0x3];                                     // 0x25D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_100016*                         CoopConfig;                                        // 0x25D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BroadcastThrowSplineHudEnabled(bool bEnabled);
	void OnRep_ThrowCharacter();
	void OnThrowCharacterCoopRideStateChanged(bool bIsRiding, class AMarvelBaseCharacter* RideCharacter);
	void PredictThrowDataWhenPressed(const struct FVector& PredictVelocity, TArray<struct FVector>* PredictionPath, float MaxFallSeconds, float MaxJumpHeightDown);
	struct FVector PredictThrowVelocity(float PredictSpeed, bool bRemoteRole, const struct FRotator& InRotator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_100016">();
	}
	static class UAbility_100016* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_100016>();
	}
};
static_assert(alignof(UAbility_100016) == 0x000008, "Wrong alignment on UAbility_100016");
static_assert(sizeof(UAbility_100016) == 0x0025E0, "Wrong size on UAbility_100016");
static_assert(offsetof(UAbility_100016, ThrowSplineHudEnabledDispatcher) == 0x002598, "Member 'UAbility_100016::ThrowSplineHudEnabledDispatcher' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ThrowCharacter) == 0x0025A8, "Member 'UAbility_100016::ThrowCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ThrowPrediction_UpHeight) == 0x0025B0, "Member 'UAbility_100016::ThrowPrediction_UpHeight' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ThrowPrediction_DownHeight) == 0x0025B4, "Member 'UAbility_100016::ThrowPrediction_DownHeight' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ThrowPrediction_UpSeconds) == 0x0025B8, "Member 'UAbility_100016::ThrowPrediction_UpSeconds' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ThrowPrediction_DownSeconds) == 0x0025BC, "Member 'UAbility_100016::ThrowPrediction_DownSeconds' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ForceMoveSpeed) == 0x0025C0, "Member 'UAbility_100016::ForceMoveSpeed' has a wrong offset!");
static_assert(offsetof(UAbility_100016, UpGravityRatio) == 0x0025C4, "Member 'UAbility_100016::UpGravityRatio' has a wrong offset!");
static_assert(offsetof(UAbility_100016, DownGravityRatio) == 0x0025C8, "Member 'UAbility_100016::DownGravityRatio' has a wrong offset!");
static_assert(offsetof(UAbility_100016, MaxMoveSpeed) == 0x0025CC, "Member 'UAbility_100016::MaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(UAbility_100016, MaxAcceleration) == 0x0025D0, "Member 'UAbility_100016::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UAbility_100016, bReleased) == 0x0025D4, "Member 'UAbility_100016::bReleased' has a wrong offset!");
static_assert(offsetof(UAbility_100016, CoopConfig) == 0x0025D8, "Member 'UAbility_100016::CoopConfig' has a wrong offset!");

// Class Hero_Synergy.Cue_Ability_Loop_100016
// 0x00B8 (0x0F08 - 0x0E50)
class ACue_Ability_Loop_100016 final : public AMarvelCueNotify_Ability
{
public:
	class UMarvelSplineComponent*                 SplineComponent;                                   // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            TailStaticMesh;                                    // 0x0E58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BodyStaticMesh;                                    // 0x0E60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            HeadStaticMesh;                                    // 0x0E68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           SplineMeshCollection;                              // 0x0E70(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         AbilityID;                                         // 0x0E80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E84[0x4];                                      // 0x0E84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_100016*                        OwnerAbility;                                      // 0x0E88(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0E90(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedCurve;                                        // 0x0E98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressedSecondsMin;                                 // 0x0EA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAuxiliaryLineOn;                                 // 0x0EA4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA5[0x3];                                      // 0x0EA5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTerminalHeight;                                 // 0x0EA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressedTimeAdjust;                                 // 0x0EAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressedTimeInterpAlpha;                            // 0x0EB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemoteVelocityInterpAlpha;                         // 0x0EB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EB8[0x4];                                      // 0x0EB8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumOfSplinePoints;                              // 0x0EBC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenPathReduction;                                // 0x0EC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC1[0x3];                                      // 0x0EC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastSegmentLength;                                 // 0x0EC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpSeconds;                                    // 0x0EC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpHeightDown;                                 // 0x0ECC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumOfSplineMeshUsed;                            // 0x0ED0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED4[0x20];                                     // 0x0ED4(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WolverineAlphaValue;                               // 0x0EF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF8[0x5];                                      // 0x0EF8(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAbilityEnableDrawSpline;                          // 0x0EFD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EFE[0xA];                                      // 0x0EFE(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerAbilityThrowSplineHudEnabledChanged(bool bEnabled);
	void OnPressRelease(float TimeWaited);
	void OnPressTimeMin(float TimeWaited);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_100016">();
	}
	static class ACue_Ability_Loop_100016* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_100016>();
	}
};
static_assert(alignof(ACue_Ability_Loop_100016) == 0x000008, "Wrong alignment on ACue_Ability_Loop_100016");
static_assert(sizeof(ACue_Ability_Loop_100016) == 0x000F08, "Wrong size on ACue_Ability_Loop_100016");
static_assert(offsetof(ACue_Ability_Loop_100016, SplineComponent) == 0x000E50, "Member 'ACue_Ability_Loop_100016::SplineComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, TailStaticMesh) == 0x000E58, "Member 'ACue_Ability_Loop_100016::TailStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, BodyStaticMesh) == 0x000E60, "Member 'ACue_Ability_Loop_100016::BodyStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, HeadStaticMesh) == 0x000E68, "Member 'ACue_Ability_Loop_100016::HeadStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, SplineMeshCollection) == 0x000E70, "Member 'ACue_Ability_Loop_100016::SplineMeshCollection' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, AbilityID) == 0x000E80, "Member 'ACue_Ability_Loop_100016::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, OwnerAbility) == 0x000E88, "Member 'ACue_Ability_Loop_100016::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, OwnerCharacter) == 0x000E90, "Member 'ACue_Ability_Loop_100016::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, SpeedCurve) == 0x000E98, "Member 'ACue_Ability_Loop_100016::SpeedCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, PressedSecondsMin) == 0x000EA0, "Member 'ACue_Ability_Loop_100016::PressedSecondsMin' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, IsAuxiliaryLineOn) == 0x000EA4, "Member 'ACue_Ability_Loop_100016::IsAuxiliaryLineOn' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, MinTerminalHeight) == 0x000EA8, "Member 'ACue_Ability_Loop_100016::MinTerminalHeight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, PressedTimeAdjust) == 0x000EAC, "Member 'ACue_Ability_Loop_100016::PressedTimeAdjust' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, PressedTimeInterpAlpha) == 0x000EB0, "Member 'ACue_Ability_Loop_100016::PressedTimeInterpAlpha' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, RemoteVelocityInterpAlpha) == 0x000EB4, "Member 'ACue_Ability_Loop_100016::RemoteVelocityInterpAlpha' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, MaxNumOfSplinePoints) == 0x000EBC, "Member 'ACue_Ability_Loop_100016::MaxNumOfSplinePoints' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, bOpenPathReduction) == 0x000EC0, "Member 'ACue_Ability_Loop_100016::bOpenPathReduction' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, LastSegmentLength) == 0x000EC4, "Member 'ACue_Ability_Loop_100016::LastSegmentLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, MaxJumpSeconds) == 0x000EC8, "Member 'ACue_Ability_Loop_100016::MaxJumpSeconds' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, MaxJumpHeightDown) == 0x000ECC, "Member 'ACue_Ability_Loop_100016::MaxJumpHeightDown' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, MaxNumOfSplineMeshUsed) == 0x000ED0, "Member 'ACue_Ability_Loop_100016::MaxNumOfSplineMeshUsed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, WolverineAlphaValue) == 0x000EF4, "Member 'ACue_Ability_Loop_100016::WolverineAlphaValue' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, bAbilityEnableDrawSpline) == 0x000EFD, "Member 'ACue_Ability_Loop_100016::bAbilityEnableDrawSpline' has a wrong offset!");

// Class Hero_Synergy.SynergyThrowSplineMeshComponent
// 0x0000 (0x0A30 - 0x0A30)
class USynergyThrowSplineMeshComponent final : public USplineMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SynergyThrowSplineMeshComponent">();
	}
	static class USynergyThrowSplineMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USynergyThrowSplineMeshComponent>();
	}
};
static_assert(alignof(USynergyThrowSplineMeshComponent) == 0x000010, "Wrong alignment on USynergyThrowSplineMeshComponent");
static_assert(sizeof(USynergyThrowSplineMeshComponent) == 0x000A30, "Wrong size on USynergyThrowSplineMeshComponent");

}

