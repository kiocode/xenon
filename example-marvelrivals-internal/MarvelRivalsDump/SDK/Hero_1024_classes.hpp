#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1024

#include "Basic.hpp"

#include "Hero_1024_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Hero_1024.ResurrectionAbility_10240201
// 0x0008 (0x1198 - 0x1190)
class UResurrectionAbility_10240201 : public UMarvelBaseResurrectionAbility
{
public:
	float                                         LokiResurrectionHPPercent;                         // 0x1190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThorResurrectionHPPercent;                         // 0x1194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResurrectionAbility_10240201">();
	}
	static class UResurrectionAbility_10240201* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResurrectionAbility_10240201>();
	}
};
static_assert(alignof(UResurrectionAbility_10240201) == 0x000008, "Wrong alignment on UResurrectionAbility_10240201");
static_assert(sizeof(UResurrectionAbility_10240201) == 0x001198, "Wrong size on UResurrectionAbility_10240201");
static_assert(offsetof(UResurrectionAbility_10240201, LokiResurrectionHPPercent) == 0x001190, "Member 'UResurrectionAbility_10240201::LokiResurrectionHPPercent' has a wrong offset!");
static_assert(offsetof(UResurrectionAbility_10240201, ThorResurrectionHPPercent) == 0x001194, "Member 'UResurrectionAbility_10240201::ThorResurrectionHPPercent' has a wrong offset!");

// Class Hero_1024.Cue_Buff_10240201
// 0x0170 (0x11C0 - 0x1050)
class ACue_Buff_10240201 final : public ACue_Buff_Resurrection
{
public:
	class UFXSystemAsset*                         GroundFX;                                          // 0x1050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         ResurrectLoopFX;                                   // 0x1058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         ResurrectExplodeFX;                                // 0x1060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1068[0x8];                                     // 0x1068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ExplodeFXOffset;                                   // 0x1070(0x0060)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             LoopFXOffset;                                      // 0x10D0(0x0060)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTraceDist;                                   // 0x1130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1134[0x4];                                     // 0x1134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWidgetStyle_BattleTransientTip        ResurrectionTip;                                   // 0x1138(0x0048)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MaterialCurve;                                     // 0x1180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName1;                                        // 0x1188(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName2;                                        // 0x1194(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A0[0x4];                                     // 0x11A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeshOverlayMaterialHandle             TargetMaterialHandle;                              // 0x11A4(0x001C)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10240201">();
	}
	static class ACue_Buff_10240201* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10240201>();
	}
};
static_assert(alignof(ACue_Buff_10240201) == 0x000010, "Wrong alignment on ACue_Buff_10240201");
static_assert(sizeof(ACue_Buff_10240201) == 0x0011C0, "Wrong size on ACue_Buff_10240201");
static_assert(offsetof(ACue_Buff_10240201, GroundFX) == 0x001050, "Member 'ACue_Buff_10240201::GroundFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ResurrectLoopFX) == 0x001058, "Member 'ACue_Buff_10240201::ResurrectLoopFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ResurrectExplodeFX) == 0x001060, "Member 'ACue_Buff_10240201::ResurrectExplodeFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ExplodeFXOffset) == 0x001070, "Member 'ACue_Buff_10240201::ExplodeFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, LoopFXOffset) == 0x0010D0, "Member 'ACue_Buff_10240201::LoopFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, GroundTraceDist) == 0x001130, "Member 'ACue_Buff_10240201::GroundTraceDist' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ResurrectionTip) == 0x001138, "Member 'ACue_Buff_10240201::ResurrectionTip' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, MaterialCurve) == 0x001180, "Member 'ACue_Buff_10240201::MaterialCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ParamName1) == 0x001188, "Member 'ACue_Buff_10240201::ParamName1' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, ParamName2) == 0x001194, "Member 'ACue_Buff_10240201::ParamName2' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10240201, TargetMaterialHandle) == 0x0011A4, "Member 'ACue_Buff_10240201::TargetMaterialHandle' has a wrong offset!");

// Class Hero_1024.Config_102411
// 0x0078 (0x0110 - 0x0098)
class UConfig_102411 final : public UMarvelAbilityConfig
{
public:
	int32                                         ScopeDamageID;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScopeDelay;                                  // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScopeWarningID;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreDeathTag;                                    // 0x00A8(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102411">();
	}
	static class UConfig_102411* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102411>();
	}
};
static_assert(alignof(UConfig_102411) == 0x000008, "Wrong alignment on UConfig_102411");
static_assert(sizeof(UConfig_102411) == 0x000110, "Wrong size on UConfig_102411");
static_assert(offsetof(UConfig_102411, ScopeDamageID) == 0x000098, "Member 'UConfig_102411::ScopeDamageID' has a wrong offset!");
static_assert(offsetof(UConfig_102411, DamageScopeDelay) == 0x00009C, "Member 'UConfig_102411::DamageScopeDelay' has a wrong offset!");
static_assert(offsetof(UConfig_102411, ScopeWarningID) == 0x0000A0, "Member 'UConfig_102411::ScopeWarningID' has a wrong offset!");
static_assert(offsetof(UConfig_102411, IgnoreDeathTag) == 0x0000A8, "Member 'UConfig_102411::IgnoreDeathTag' has a wrong offset!");

// Class Hero_1024.Ability_102411
// 0x0000 (0x2580 - 0x2580)
class UAbility_102411 : public UMarvelGameplayAbility
{
public:
	void OnActorDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnAssistKill(const struct FUIKillInfo& KillInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102411">();
	}
	static class UAbility_102411* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102411>();
	}
};
static_assert(alignof(UAbility_102411) == 0x000008, "Wrong alignment on UAbility_102411");
static_assert(sizeof(UAbility_102411) == 0x002580, "Wrong size on UAbility_102411");

// Class Hero_1024.Scope_10241102
// 0x0010 (0x1710 - 0x1700)
class AScope_10241102 final : public AMarvelAbilityTargetActor_Scope
{
public:
	struct FGameplayTag                           WarningCueTag;                                     // 0x1700(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_170C[0x4];                                     // 0x170C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10241102">();
	}
	static class AScope_10241102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10241102>();
	}
};
static_assert(alignof(AScope_10241102) == 0x000010, "Wrong alignment on AScope_10241102");
static_assert(sizeof(AScope_10241102) == 0x001710, "Wrong size on AScope_10241102");
static_assert(offsetof(AScope_10241102, WarningCueTag) == 0x001700, "Member 'AScope_10241102::WarningCueTag' has a wrong offset!");

// Class Hero_1024.Projectile_10244101
// 0x0000 (0x3050 - 0x3050)
class AProjectile_10244101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	void ListenHitComponentCollisionChanged(class UPrimitiveComponent* InComponent, bool bListen);
	void OnHitComponentCollisionChanged(class UPrimitiveComponent* InPrimitiveComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10244101">();
	}
	static class AProjectile_10244101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10244101>();
	}
};
static_assert(alignof(AProjectile_10244101) == 0x000010, "Wrong alignment on AProjectile_10244101");
static_assert(sizeof(AProjectile_10244101) == 0x003050, "Wrong size on AProjectile_10244101");

// Class Hero_1024.Cue_Ability_Loop_10244101
// 0x0038 (0x0E88 - 0x0E50)
class ACue_Ability_Loop_10244101 : public AMarvelCueNotify_Ability
{
public:
	TArray<struct FHelaFXInfo>                    HelaFXInfos;                                       // 0x0E50(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         InterpSpeedP;                                      // 0x0E60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeedY;                                      // 0x0E64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS1;                                               // 0x0E68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS2;                                               // 0x0E70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS3;                                               // 0x0E78(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS4;                                               // 0x0E80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FRotator GetFXRotation(class UNiagaraComponent* FXComponent, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10244101">();
	}
	static class ACue_Ability_Loop_10244101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10244101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10244101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10244101");
static_assert(sizeof(ACue_Ability_Loop_10244101) == 0x000E88, "Wrong size on ACue_Ability_Loop_10244101");
static_assert(offsetof(ACue_Ability_Loop_10244101, HelaFXInfos) == 0x000E50, "Member 'ACue_Ability_Loop_10244101::HelaFXInfos' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, InterpSpeedP) == 0x000E60, "Member 'ACue_Ability_Loop_10244101::InterpSpeedP' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, InterpSpeedY) == 0x000E64, "Member 'ACue_Ability_Loop_10244101::InterpSpeedY' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, NS1) == 0x000E68, "Member 'ACue_Ability_Loop_10244101::NS1' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, NS2) == 0x000E70, "Member 'ACue_Ability_Loop_10244101::NS2' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, NS3) == 0x000E78, "Member 'ACue_Ability_Loop_10244101::NS3' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10244101, NS4) == 0x000E80, "Member 'ACue_Ability_Loop_10244101::NS4' has a wrong offset!");

// Class Hero_1024.Config_102451
// 0x0010 (0x00A8 - 0x0098)
class UConfig_102451 : public UMarvelAbilityConfig
{
public:
	float                                         PhantomCapsuleHalfHeight;                          // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhantomCapsuleRadius;                              // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectActorCheckDistance;                          // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNewAbility;                                 // 0x00A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102451">();
	}
	static class UConfig_102451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102451>();
	}
};
static_assert(alignof(UConfig_102451) == 0x000008, "Wrong alignment on UConfig_102451");
static_assert(sizeof(UConfig_102451) == 0x0000A8, "Wrong size on UConfig_102451");
static_assert(offsetof(UConfig_102451, PhantomCapsuleHalfHeight) == 0x000098, "Member 'UConfig_102451::PhantomCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UConfig_102451, PhantomCapsuleRadius) == 0x00009C, "Member 'UConfig_102451::PhantomCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UConfig_102451, EffectActorCheckDistance) == 0x0000A0, "Member 'UConfig_102451::EffectActorCheckDistance' has a wrong offset!");
static_assert(offsetof(UConfig_102451, bEnableNewAbility) == 0x0000A4, "Member 'UConfig_102451::bEnableNewAbility' has a wrong offset!");

// Class Hero_1024.Ability_102451
// 0x0000 (0x2580 - 0x2580)
class UAbility_102451 : public UMarvelGameplayAbility
{
public:
	bool InBirthRoom();
	void PreTeleport();
	void Teleport();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102451">();
	}
	static class UAbility_102451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102451>();
	}
};
static_assert(alignof(UAbility_102451) == 0x000008, "Wrong alignment on UAbility_102451");
static_assert(sizeof(UAbility_102451) == 0x002580, "Wrong size on UAbility_102451");

// Class Hero_1024.ProjectileCollisionComponent_102451
// 0x0010 (0x08E0 - 0x08D0)
class UProjectileCollisionComponent_102451 final : public UProjectileCollisionComponent
{
public:
	bool                                          bOverridePawnSweep;                                // 0x08C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C9[0x7];                                      // 0x08C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      OwnerCapsule;                                      // 0x08D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D8[0x8];                                      // 0x08D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileCollisionComponent_102451">();
	}
	static class UProjectileCollisionComponent_102451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileCollisionComponent_102451>();
	}
};
static_assert(alignof(UProjectileCollisionComponent_102451) == 0x000010, "Wrong alignment on UProjectileCollisionComponent_102451");
static_assert(sizeof(UProjectileCollisionComponent_102451) == 0x0008E0, "Wrong size on UProjectileCollisionComponent_102451");
static_assert(offsetof(UProjectileCollisionComponent_102451, bOverridePawnSweep) == 0x0008C8, "Member 'UProjectileCollisionComponent_102451::bOverridePawnSweep' has a wrong offset!");
static_assert(offsetof(UProjectileCollisionComponent_102451, OwnerCapsule) == 0x0008D0, "Member 'UProjectileCollisionComponent_102451::OwnerCapsule' has a wrong offset!");

// Class Hero_1024.ProjectileMovementComponent_102451
// 0x0030 (0x2020 - 0x1FF0)
class UProjectileMovementComponent_102451 final : public UMarvelProjectileComponent
{
public:
	class UProjectileCollisionComponent_102451*   CollisionComponent;                                // 0x1FE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleControl;                                      // 0x1FF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepVelocityDirection;                            // 0x1FF4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FF5[0x1B];                                    // 0x1FF5(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastDiffLocationLength;                            // 0x2010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AMarvelAbilityTargetActor_Projectile> TargetActor;                                       // 0x2014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_201C[0x4];                                     // 0x201C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileMovementComponent_102451">();
	}
	static class UProjectileMovementComponent_102451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileMovementComponent_102451>();
	}
};
static_assert(alignof(UProjectileMovementComponent_102451) == 0x000010, "Wrong alignment on UProjectileMovementComponent_102451");
static_assert(sizeof(UProjectileMovementComponent_102451) == 0x002020, "Wrong size on UProjectileMovementComponent_102451");
static_assert(offsetof(UProjectileMovementComponent_102451, CollisionComponent) == 0x001FE8, "Member 'UProjectileMovementComponent_102451::CollisionComponent' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent_102451, AngleControl) == 0x001FF0, "Member 'UProjectileMovementComponent_102451::AngleControl' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent_102451, bKeepVelocityDirection) == 0x001FF4, "Member 'UProjectileMovementComponent_102451::bKeepVelocityDirection' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent_102451, LastDiffLocationLength) == 0x002010, "Member 'UProjectileMovementComponent_102451::LastDiffLocationLength' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent_102451, TargetActor) == 0x002014, "Member 'UProjectileMovementComponent_102451::TargetActor' has a wrong offset!");

// Class Hero_1024.Projectile_10245101
// 0x0040 (0x3090 - 0x3050)
class AProjectile_10245101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	class UCapsuleComponent*                      PhantomCapsuleComponent;                           // 0x3050(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelSpringArmComponent*              SpringArm;                                         // 0x3058(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       Camera;                                            // 0x3060(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x3068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_306C[0x24];                                    // 0x306C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10245101">();
	}
	static class AProjectile_10245101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10245101>();
	}
};
static_assert(alignof(AProjectile_10245101) == 0x000010, "Wrong alignment on AProjectile_10245101");
static_assert(sizeof(AProjectile_10245101) == 0x003090, "Wrong size on AProjectile_10245101");
static_assert(offsetof(AProjectile_10245101, PhantomCapsuleComponent) == 0x003050, "Member 'AProjectile_10245101::PhantomCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AProjectile_10245101, SpringArm) == 0x003058, "Member 'AProjectile_10245101::SpringArm' has a wrong offset!");
static_assert(offsetof(AProjectile_10245101, Camera) == 0x003060, "Member 'AProjectile_10245101::Camera' has a wrong offset!");
static_assert(offsetof(AProjectile_10245101, InterpSpeed) == 0x003068, "Member 'AProjectile_10245101::InterpSpeed' has a wrong offset!");

// Class Hero_1024.Cue_Projectile_Loop_10245101
// 0x0018 (0x0DC8 - 0x0DB0)
class ACue_Projectile_Loop_10245101 final : public AMarvelCueNotify_Projectile
{
public:
	float                                         CheckDistance;                                     // 0x0DB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB4[0x4];                                      // 0x0DB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectile_10245101*                   ProjectileTarget;                                  // 0x0DB8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_102451*                         OwnerAbilityConfig;                                // 0x0DC0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitializeSummonedSceneIndicator(float TotalTime);
	void OnViewingCharacterChanged(class AMarvelBaseCharacter* InCharacter);
	void UpdateStencilValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10245101">();
	}
	static class ACue_Projectile_Loop_10245101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10245101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10245101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10245101");
static_assert(sizeof(ACue_Projectile_Loop_10245101) == 0x000DC8, "Wrong size on ACue_Projectile_Loop_10245101");
static_assert(offsetof(ACue_Projectile_Loop_10245101, CheckDistance) == 0x000DB0, "Member 'ACue_Projectile_Loop_10245101::CheckDistance' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10245101, ProjectileTarget) == 0x000DB8, "Member 'ACue_Projectile_Loop_10245101::ProjectileTarget' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10245101, OwnerAbilityConfig) == 0x000DC0, "Member 'ACue_Projectile_Loop_10245101::OwnerAbilityConfig' has a wrong offset!");

// Class Hero_1024.Config_102461
// 0x0BA8 (0x0C40 - 0x0098)
class UConfig_102461 : public UMarvelAbilityConfig
{
public:
	struct FDashAbilityInfo                       DashInfo;                                          // 0x0098(0x0BA8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102461">();
	}
	static class UConfig_102461* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102461>();
	}
};
static_assert(alignof(UConfig_102461) == 0x000008, "Wrong alignment on UConfig_102461");
static_assert(sizeof(UConfig_102461) == 0x000C40, "Wrong size on UConfig_102461");
static_assert(offsetof(UConfig_102461, DashInfo) == 0x000098, "Member 'UConfig_102461::DashInfo' has a wrong offset!");

// Class Hero_1024.ForceMoveToAbility_102461
// 0x0008 (0x1100 - 0x10F8)
class UForceMoveToAbility_102461 : public UMarvelEffectGameplayAbility
{
public:
	class UMarvelAbilityTask_Dash*                MoveTask;                                          // 0x10F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDashFinish(EDashStopReason InReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceMoveToAbility_102461">();
	}
	static class UForceMoveToAbility_102461* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceMoveToAbility_102461>();
	}
};
static_assert(alignof(UForceMoveToAbility_102461) == 0x000008, "Wrong alignment on UForceMoveToAbility_102461");
static_assert(sizeof(UForceMoveToAbility_102461) == 0x001100, "Wrong size on UForceMoveToAbility_102461");
static_assert(offsetof(UForceMoveToAbility_102461, MoveTask) == 0x0010F8, "Member 'UForceMoveToAbility_102461::MoveTask' has a wrong offset!");

// Class Hero_1024.Summoned_10247101
// 0x0050 (0x08E0 - 0x0890)
class ASummoned_10247101 : public AMarvelSummonerBase
{
public:
	class UMarvelChildActorComponent*             ChildActorComponent;                               // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    SpringArm;                                         // 0x0898(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       Camera;                                            // 0x08A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      Capsule;                                           // 0x08A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonMaxPitchLimit;                          // 0x08B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x08B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFirstPerson;                                     // 0x08B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B9[0x7];                                      // 0x08B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LastRotation;                                      // 0x08C0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PenetrationExtraRadiusScale;                       // 0x08D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8DC[0x4];                                      // 0x08DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustCapsuleLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10247101">();
	}
	static class ASummoned_10247101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10247101>();
	}
};
static_assert(alignof(ASummoned_10247101) == 0x000010, "Wrong alignment on ASummoned_10247101");
static_assert(sizeof(ASummoned_10247101) == 0x0008E0, "Wrong size on ASummoned_10247101");
static_assert(offsetof(ASummoned_10247101, ChildActorComponent) == 0x000890, "Member 'ASummoned_10247101::ChildActorComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, SpringArm) == 0x000898, "Member 'ASummoned_10247101::SpringArm' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, Camera) == 0x0008A0, "Member 'ASummoned_10247101::Camera' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, Capsule) == 0x0008A8, "Member 'ASummoned_10247101::Capsule' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, ThirdPersonMaxPitchLimit) == 0x0008B0, "Member 'ASummoned_10247101::ThirdPersonMaxPitchLimit' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, InterpSpeed) == 0x0008B4, "Member 'ASummoned_10247101::InterpSpeed' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, IsFirstPerson) == 0x0008B8, "Member 'ASummoned_10247101::IsFirstPerson' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, LastRotation) == 0x0008C0, "Member 'ASummoned_10247101::LastRotation' has a wrong offset!");
static_assert(offsetof(ASummoned_10247101, PenetrationExtraRadiusScale) == 0x0008D8, "Member 'ASummoned_10247101::PenetrationExtraRadiusScale' has a wrong offset!");

// Class Hero_1024.SummonedComp_10247101
// 0x0010 (0x0CB0 - 0x0CA0)
class USummonedComp_10247101 : public UMarvelSummonedComponent
{
public:
	bool                                          IsFiring;                                          // 0x0CA0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEndPlay;                                         // 0x0CA1(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCameraFinish;                                    // 0x0CA2(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA3[0x1];                                      // 0x0CA3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityStatusNum;                                  // 0x0CA4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA8[0x8];                                      // 0x0CA8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10247101">();
	}
	static class USummonedComp_10247101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10247101>();
	}
};
static_assert(alignof(USummonedComp_10247101) == 0x000010, "Wrong alignment on USummonedComp_10247101");
static_assert(sizeof(USummonedComp_10247101) == 0x000CB0, "Wrong size on USummonedComp_10247101");
static_assert(offsetof(USummonedComp_10247101, IsFiring) == 0x000CA0, "Member 'USummonedComp_10247101::IsFiring' has a wrong offset!");
static_assert(offsetof(USummonedComp_10247101, IsEndPlay) == 0x000CA1, "Member 'USummonedComp_10247101::IsEndPlay' has a wrong offset!");
static_assert(offsetof(USummonedComp_10247101, IsCameraFinish) == 0x000CA2, "Member 'USummonedComp_10247101::IsCameraFinish' has a wrong offset!");
static_assert(offsetof(USummonedComp_10247101, AbilityStatusNum) == 0x000CA4, "Member 'USummonedComp_10247101::AbilityStatusNum' has a wrong offset!");

// Class Hero_1024.Ability_102471
// 0x0018 (0x2598 - 0x2580)
class UAbility_102471 : public UMarvelGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             ActiveFailedDueToHeight;                           // 0x2580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2590[0x8];                                     // 0x2590(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeGravityScale(float NewGravityScale);
	bool CheckHeightAboveGround();

	float GetOriginGravityScale() const;
	void OnAbilityActiveFailed(const class UGameplayAbility* InAbility, const struct FGameplayTagContainer& Tags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102471">();
	}
	static class UAbility_102471* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102471>();
	}
};
static_assert(alignof(UAbility_102471) == 0x000008, "Wrong alignment on UAbility_102471");
static_assert(sizeof(UAbility_102471) == 0x002598, "Wrong size on UAbility_102471");
static_assert(offsetof(UAbility_102471, ActiveFailedDueToHeight) == 0x002580, "Member 'UAbility_102471::ActiveFailedDueToHeight' has a wrong offset!");

// Class Hero_1024.Cue_Ability_Loop_102491
// 0x0010 (0x0E60 - 0x0E50)
class ACue_Ability_Loop_102491 final : public AMarvelCueNotify_Ability
{
public:
	class UNiagaraComponent*                      NS_Link;                                           // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHelaCharacter*                         OwnerCharacter;                                    // 0x0E58(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class APhysicsSummoner* GetWeaponSummoner();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_102491">();
	}
	static class ACue_Ability_Loop_102491* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_102491>();
	}
};
static_assert(alignof(ACue_Ability_Loop_102491) == 0x000008, "Wrong alignment on ACue_Ability_Loop_102491");
static_assert(sizeof(ACue_Ability_Loop_102491) == 0x000E60, "Wrong size on ACue_Ability_Loop_102491");
static_assert(offsetof(ACue_Ability_Loop_102491, NS_Link) == 0x000E50, "Member 'ACue_Ability_Loop_102491::NS_Link' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102491, OwnerCharacter) == 0x000E58, "Member 'ACue_Ability_Loop_102491::OwnerCharacter' has a wrong offset!");

// Class Hero_1024.CrownStormAnimInstance
// 0x0000 (0x0910 - 0x0910)
class UCrownStormAnimInstance final : public UMarvelAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrownStormAnimInstance">();
	}
	static class UCrownStormAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrownStormAnimInstance>();
	}
};
static_assert(alignof(UCrownStormAnimInstance) == 0x000010, "Wrong alignment on UCrownStormAnimInstance");
static_assert(sizeof(UCrownStormAnimInstance) == 0x000910, "Wrong size on UCrownStormAnimInstance");

// Class Hero_1024.CrownStormCharacter
// 0x0010 (0x1820 - 0x1810)
class ACrownStormCharacter final : public AMarvelBaseCharacter
{
public:
	int32                                         FromHeroID;                                        // 0x1810(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1814[0x4];                                     // 0x1814(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrownStormMoveLogicBaseComponent*      CrownStormMoveLogic;                               // 0x1818(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void MulticastTransitionToHela();
	void TransitionToHela();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrownStormCharacter">();
	}
	static class ACrownStormCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrownStormCharacter>();
	}
};
static_assert(alignof(ACrownStormCharacter) == 0x000010, "Wrong alignment on ACrownStormCharacter");
static_assert(sizeof(ACrownStormCharacter) == 0x001820, "Wrong size on ACrownStormCharacter");
static_assert(offsetof(ACrownStormCharacter, FromHeroID) == 0x001810, "Member 'ACrownStormCharacter::FromHeroID' has a wrong offset!");
static_assert(offsetof(ACrownStormCharacter, CrownStormMoveLogic) == 0x001818, "Member 'ACrownStormCharacter::CrownStormMoveLogic' has a wrong offset!");

// Class Hero_1024.CrownStormMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UCrownStormMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrownStormMoveLogicBaseComponent">();
	}
	static class UCrownStormMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrownStormMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UCrownStormMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UCrownStormMoveLogicBaseComponent");
static_assert(sizeof(UCrownStormMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UCrownStormMoveLogicBaseComponent");

// Class Hero_1024.HelaAnimInstance
// 0x0050 (0x0960 - 0x0910)
class UHelaAnimInstance : public UMarvelAnimInstance
{
public:
	float                                         HoverMaxSpeed;                                     // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FlyTag;                                            // 0x0914(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovingVelocityNormalInterpSpeed;                   // 0x0920(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDescending;                                     // 0x0924(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_925[0x3];                                      // 0x0925(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MovingVelocityNormal;                              // 0x0928(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHovering;                                       // 0x0940(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCrowState;                                      // 0x0941(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCrowFiring;                                     // 0x0942(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_943[0x1D];                                     // 0x0943(0x001D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFlyTagUpdated(const struct FGameplayTag& TagUpdated, bool TagExists);
	void SetAutoDescend(bool bInOpenAutoDescend);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaAnimInstance">();
	}
	static class UHelaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaAnimInstance>();
	}
};
static_assert(alignof(UHelaAnimInstance) == 0x000010, "Wrong alignment on UHelaAnimInstance");
static_assert(sizeof(UHelaAnimInstance) == 0x000960, "Wrong size on UHelaAnimInstance");
static_assert(offsetof(UHelaAnimInstance, HoverMaxSpeed) == 0x000910, "Member 'UHelaAnimInstance::HoverMaxSpeed' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, FlyTag) == 0x000914, "Member 'UHelaAnimInstance::FlyTag' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, MovingVelocityNormalInterpSpeed) == 0x000920, "Member 'UHelaAnimInstance::MovingVelocityNormalInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, bIsDescending) == 0x000924, "Member 'UHelaAnimInstance::bIsDescending' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, MovingVelocityNormal) == 0x000928, "Member 'UHelaAnimInstance::MovingVelocityNormal' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, bIsHovering) == 0x000940, "Member 'UHelaAnimInstance::bIsHovering' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, bIsCrowState) == 0x000941, "Member 'UHelaAnimInstance::bIsCrowState' has a wrong offset!");
static_assert(offsetof(UHelaAnimInstance, bIsCrowFiring) == 0x000942, "Member 'UHelaAnimInstance::bIsCrowFiring' has a wrong offset!");

// Class Hero_1024.HelaCrowCloakAnimInstance
// 0x0010 (0x0440 - 0x0430)
class UHelaCrowCloakAnimInstance final : public UAnimInstance
{
public:
	bool                                          bShouldTransIdle;                                  // 0x0428(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x3];                                      // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StateSeconds;                                      // 0x042C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaCrowCloakAnimInstance">();
	}
	static class UHelaCrowCloakAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaCrowCloakAnimInstance>();
	}
};
static_assert(alignof(UHelaCrowCloakAnimInstance) == 0x000010, "Wrong alignment on UHelaCrowCloakAnimInstance");
static_assert(sizeof(UHelaCrowCloakAnimInstance) == 0x000440, "Wrong size on UHelaCrowCloakAnimInstance");
static_assert(offsetof(UHelaCrowCloakAnimInstance, bShouldTransIdle) == 0x000428, "Member 'UHelaCrowCloakAnimInstance::bShouldTransIdle' has a wrong offset!");
static_assert(offsetof(UHelaCrowCloakAnimInstance, StateSeconds) == 0x00042C, "Member 'UHelaCrowCloakAnimInstance::StateSeconds' has a wrong offset!");

// Class Hero_1024.HelaCrowAnimInstance
// 0x0030 (0x0990 - 0x0960)
class UHelaCrowAnimInstance final : public UHelaAnimInstance
{
public:
	bool                                          bIsEnd;                                            // 0x0960(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransToLoop;                                   // 0x0961(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterStart;                                    // 0x0962(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_963[0x2D];                                     // 0x0963(0x002D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaCrowAnimInstance">();
	}
	static class UHelaCrowAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaCrowAnimInstance>();
	}
};
static_assert(alignof(UHelaCrowAnimInstance) == 0x000010, "Wrong alignment on UHelaCrowAnimInstance");
static_assert(sizeof(UHelaCrowAnimInstance) == 0x000990, "Wrong size on UHelaCrowAnimInstance");
static_assert(offsetof(UHelaCrowAnimInstance, bIsEnd) == 0x000960, "Member 'UHelaCrowAnimInstance::bIsEnd' has a wrong offset!");
static_assert(offsetof(UHelaCrowAnimInstance, bCanTransToLoop) == 0x000961, "Member 'UHelaCrowAnimInstance::bCanTransToLoop' has a wrong offset!");
static_assert(offsetof(UHelaCrowAnimInstance, bCanEnterStart) == 0x000962, "Member 'UHelaCrowAnimInstance::bCanEnterStart' has a wrong offset!");

// Class Hero_1024.HelaCrowFPAnimInstance
// 0x0010 (0x0970 - 0x0960)
class UHelaCrowFPAnimInstance final : public UHelaAnimInstance
{
public:
	float                                         PlayRate;                                          // 0x0960(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_964[0xC];                                      // 0x0964(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaCrowFPAnimInstance">();
	}
	static class UHelaCrowFPAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaCrowFPAnimInstance>();
	}
};
static_assert(alignof(UHelaCrowFPAnimInstance) == 0x000010, "Wrong alignment on UHelaCrowFPAnimInstance");
static_assert(sizeof(UHelaCrowFPAnimInstance) == 0x000970, "Wrong size on UHelaCrowFPAnimInstance");
static_assert(offsetof(UHelaCrowFPAnimInstance, PlayRate) == 0x000960, "Member 'UHelaCrowFPAnimInstance::PlayRate' has a wrong offset!");

// Class Hero_1024.HelaChildActor
// 0x0048 (0x0AA8 - 0x0A60)
class AHelaChildActor : public AMarvelCharacterChildActor
{
public:
	float                                         MinSpeed;                                          // 0x0A60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0A64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloakTimeOffset;                                   // 0x0A68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6C[0x4];                                      // 0x0A6C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CrowStormChildActor;                               // 0x0A70(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHelaCharacter*                         OwnerCharacter;                                    // 0x0AA0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaChildActor">();
	}
	static class AHelaChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHelaChildActor>();
	}
};
static_assert(alignof(AHelaChildActor) == 0x000008, "Wrong alignment on AHelaChildActor");
static_assert(sizeof(AHelaChildActor) == 0x000AA8, "Wrong size on AHelaChildActor");
static_assert(offsetof(AHelaChildActor, MinSpeed) == 0x000A60, "Member 'AHelaChildActor::MinSpeed' has a wrong offset!");
static_assert(offsetof(AHelaChildActor, MaxSpeed) == 0x000A64, "Member 'AHelaChildActor::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AHelaChildActor, CloakTimeOffset) == 0x000A68, "Member 'AHelaChildActor::CloakTimeOffset' has a wrong offset!");
static_assert(offsetof(AHelaChildActor, CrowStormChildActor) == 0x000A70, "Member 'AHelaChildActor::CrowStormChildActor' has a wrong offset!");
static_assert(offsetof(AHelaChildActor, OwnerCharacter) == 0x000AA0, "Member 'AHelaChildActor::OwnerCharacter' has a wrong offset!");

// Class Hero_1024.HelaCharacter
// 0x0040 (0x1850 - 0x1810)
class AHelaCharacter : public AMarvelBaseCharacter
{
public:
	class ASplineActor*                           StingActor;                                        // 0x1810(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSculptAssetLoaded;                               // 0x1818(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 CrowSummoner;                                      // 0x1828(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHelaMoveLogicBaseComponent*            HelaMoveLogic;                                     // 0x1830(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASplineActor>               StingActorClass;                                   // 0x1838(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TransitionDuration;                                // 0x1840(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1844[0xC];                                     // 0x1844(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelaySpawnPassiveAbilityDamageScope(class UGameplayAbility* InAbility, struct FMarvelAbilitySocketInfo* SocketInfo, float DelayTime, int32 ScopeId);
	void OnDeathDeal(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnRebornDeal(class AActor* InActor, const struct FCharacterRebornParam& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaCharacter">();
	}
	static class AHelaCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHelaCharacter>();
	}
};
static_assert(alignof(AHelaCharacter) == 0x000010, "Wrong alignment on AHelaCharacter");
static_assert(sizeof(AHelaCharacter) == 0x001850, "Wrong size on AHelaCharacter");
static_assert(offsetof(AHelaCharacter, StingActor) == 0x001810, "Member 'AHelaCharacter::StingActor' has a wrong offset!");
static_assert(offsetof(AHelaCharacter, OnSculptAssetLoaded) == 0x001818, "Member 'AHelaCharacter::OnSculptAssetLoaded' has a wrong offset!");
static_assert(offsetof(AHelaCharacter, CrowSummoner) == 0x001828, "Member 'AHelaCharacter::CrowSummoner' has a wrong offset!");
static_assert(offsetof(AHelaCharacter, HelaMoveLogic) == 0x001830, "Member 'AHelaCharacter::HelaMoveLogic' has a wrong offset!");
static_assert(offsetof(AHelaCharacter, StingActorClass) == 0x001838, "Member 'AHelaCharacter::StingActorClass' has a wrong offset!");
static_assert(offsetof(AHelaCharacter, TransitionDuration) == 0x001840, "Member 'AHelaCharacter::TransitionDuration' has a wrong offset!");

// Class Hero_1024.HelaMovementComponent
// 0x0000 (0x1B60 - 0x1B60)
class UHelaMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaMovementComponent">();
	}
	static class UHelaMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaMovementComponent>();
	}
};
static_assert(alignof(UHelaMovementComponent) == 0x000010, "Wrong alignment on UHelaMovementComponent");
static_assert(sizeof(UHelaMovementComponent) == 0x001B60, "Wrong size on UHelaMovementComponent");

// Class Hero_1024.HelaShowBPTickComponent
// 0x0008 (0x00F8 - 0x00F0)
class UHelaShowBPTickComponent final : public UActorComponent
{
public:
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaShowBPTickComponent">();
	}
	static class UHelaShowBPTickComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaShowBPTickComponent>();
	}
};
static_assert(alignof(UHelaShowBPTickComponent) == 0x000008, "Wrong alignment on UHelaShowBPTickComponent");
static_assert(sizeof(UHelaShowBPTickComponent) == 0x0000F8, "Wrong size on UHelaShowBPTickComponent");
static_assert(offsetof(UHelaShowBPTickComponent, SkeletalMesh) == 0x0000F0, "Member 'UHelaShowBPTickComponent::SkeletalMesh' has a wrong offset!");

// Class Hero_1024.HelaMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UHelaMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelaMoveLogicBaseComponent">();
	}
	static class UHelaMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelaMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UHelaMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UHelaMoveLogicBaseComponent");
static_assert(sizeof(UHelaMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UHelaMoveLogicBaseComponent");

// Class Hero_1024.TabData_1024
// 0x0000 (0x0050 - 0x0050)
class UTabData_1024 final : public UHeroTabDataBase
{
public:
	void OnPostApplyDamage(class AActor* InSource, class AActor* InTarget, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1024">();
	}
	static class UTabData_1024* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1024>();
	}
};
static_assert(alignof(UTabData_1024) == 0x000008, "Wrong alignment on UTabData_1024");
static_assert(sizeof(UTabData_1024) == 0x000050, "Wrong size on UTabData_1024");

}

