#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GraphAbility

#include "Basic.hpp"

#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "GraphAbility_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class GraphAbility.GATaskBase
// 0x0030 (0x0208 - 0x01D8)
class UGATaskBase : public UAbilityTask
{
public:
	TArray<class UGameplayTask*>                  SubTasks;                                          // 0x01D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnGATaskFailed;                                    // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UObject*                                TaskCaller;                                        // 0x01F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnding;                                         // 0x0200(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCancelAbilityWhenFailed;                          // 0x0201(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_202[0x6];                                      // 0x0202(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndTask_Aborted();
	void EndTask_Finished();
	void RegisterSubTask(class UGameplayTask* InTask, bool bSubTaskWithAbility);

	ENetRole GetOwnerNetRole() const;
	bool IsAbilityActivated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATaskBase">();
	}
	static class UGATaskBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATaskBase>();
	}
};
static_assert(alignof(UGATaskBase) == 0x000008, "Wrong alignment on UGATaskBase");
static_assert(sizeof(UGATaskBase) == 0x000208, "Wrong size on UGATaskBase");
static_assert(offsetof(UGATaskBase, SubTasks) == 0x0001D8, "Member 'UGATaskBase::SubTasks' has a wrong offset!");
static_assert(offsetof(UGATaskBase, OnGATaskFailed) == 0x0001E8, "Member 'UGATaskBase::OnGATaskFailed' has a wrong offset!");
static_assert(offsetof(UGATaskBase, TaskCaller) == 0x0001F8, "Member 'UGATaskBase::TaskCaller' has a wrong offset!");
static_assert(offsetof(UGATaskBase, bIsEnding) == 0x000200, "Member 'UGATaskBase::bIsEnding' has a wrong offset!");
static_assert(offsetof(UGATaskBase, bCancelAbilityWhenFailed) == 0x000201, "Member 'UGATaskBase::bCancelAbilityWhenFailed' has a wrong offset!");

// Class GraphAbility.GASpecTaskBase
// 0x0008 (0x0210 - 0x0208)
class UGASpecTaskBase : public UGATaskBase
{
public:
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpecBegin();
	void OnSpecEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GASpecTaskBase">();
	}
	static class UGASpecTaskBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGASpecTaskBase>();
	}
};
static_assert(alignof(UGASpecTaskBase) == 0x000008, "Wrong alignment on UGASpecTaskBase");
static_assert(sizeof(UGASpecTaskBase) == 0x000210, "Wrong size on UGASpecTaskBase");

// Class GraphAbility.GASpecTaskBase_Ability
// 0x0000 (0x0210 - 0x0210)
class UGASpecTaskBase_Ability : public UGASpecTaskBase
{
public:
	bool CanActivateAbility();
	void OnAbilityActivate();
	void OnAbilityEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GASpecTaskBase_Ability">();
	}
	static class UGASpecTaskBase_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGASpecTaskBase_Ability>();
	}
};
static_assert(alignof(UGASpecTaskBase_Ability) == 0x000008, "Wrong alignment on UGASpecTaskBase_Ability");
static_assert(sizeof(UGASpecTaskBase_Ability) == 0x000210, "Wrong size on UGASpecTaskBase_Ability");

// Class GraphAbility.GASpecTask_SelectTarget
// 0x10D0 (0x12E0 - 0x0210)
class alignas(0x10) UGASpecTask_SelectTarget final : public UGASpecTaskBase_Ability
{
public:
	uint8                                         Pad_210[0x10A8];                                   // 0x0210(0x10A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_SelectTarget*        SelectTargetTask;                                  // 0x12B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C0[0x20];                                    // 0x12C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGASpecTask_SelectTarget* AsSelectTargetAbility(class UGameplayAbility* OwningAbility, TDelegate<void(struct FHitResult& HitInfo, bool* bResult)> FilterDelegate, const struct FSelectTaskParam& SelectParam, bool bAutoBeginSelect, bool bShouldCheckActivate);

	void FilterDelegate__DelegateSignature(const struct FHitResult& HitInfo, bool* bResult);
	void BeginSelect();
	void EndSelect();
	void FilterTargets(const struct FVector& TraceStart, TArray<struct FHitResult>* InHitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GASpecTask_SelectTarget">();
	}
	static class UGASpecTask_SelectTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGASpecTask_SelectTarget>();
	}
};
static_assert(alignof(UGASpecTask_SelectTarget) == 0x000010, "Wrong alignment on UGASpecTask_SelectTarget");
static_assert(sizeof(UGASpecTask_SelectTarget) == 0x0012E0, "Wrong size on UGASpecTask_SelectTarget");
static_assert(offsetof(UGASpecTask_SelectTarget, SelectTargetTask) == 0x0012B8, "Member 'UGASpecTask_SelectTarget::SelectTargetTask' has a wrong offset!");

// Class GraphAbility.GATask_ApplyDash
// 0x0C58 (0x0E60 - 0x0208)
class UGATask_ApplyDash final : public UGATaskBase
{
public:
	class UMarvelAbilityTask_Dash*                SubDashTask;                                       // 0x0208(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHit;                                             // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnd;                                             // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDashAbilityInfo                       DashInfo;                                          // 0x0230(0x0BA8)(Transient, NativeAccessSpecifierPrivate)
	struct FVector                                DashToLocation;                                    // 0x0DD8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                DashToDirection;                                   // 0x0DF0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 DashToTarget;                                      // 0x0E08(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPortalSegments                        PortalSegments;                                    // 0x0E10(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UGATask_ApplyDash* ApplyDash(class UGameplayAbility* OwningAbility, const struct FDashAbilityInfo& DashInfo_0, const struct FVector& ToLocation, const struct FVector& ToDirection, class AActor* ToTargetActor, const struct FPortalSegments& PortalSegments_0);

	void EndDash();
	void OnDashEndEventDelegate__DelegateSignature(EDashStopReason Reason, const struct FHitResult& HitInfo);
	void OnDashFinished(EDashStopReason Reason);
	void OnDashHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnDashHitEventDelegate__DelegateSignature(class AActor* HitTarget, const struct FHitResult& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_ApplyDash">();
	}
	static class UGATask_ApplyDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_ApplyDash>();
	}
};
static_assert(alignof(UGATask_ApplyDash) == 0x000008, "Wrong alignment on UGATask_ApplyDash");
static_assert(sizeof(UGATask_ApplyDash) == 0x000E60, "Wrong size on UGATask_ApplyDash");
static_assert(offsetof(UGATask_ApplyDash, SubDashTask) == 0x000208, "Member 'UGATask_ApplyDash::SubDashTask' has a wrong offset!");
static_assert(offsetof(UGATask_ApplyDash, OnHit) == 0x000210, "Member 'UGATask_ApplyDash::OnHit' has a wrong offset!");
static_assert(offsetof(UGATask_ApplyDash, OnEnd) == 0x000220, "Member 'UGATask_ApplyDash::OnEnd' has a wrong offset!");
static_assert(offsetof(UGATask_ApplyDash, DashInfo) == 0x000230, "Member 'UGATask_ApplyDash::DashInfo' has a wrong offset!");
static_assert(offsetof(UGATask_ApplyDash, DashToLocation) == 0x000DD8, "Member 'UGATask_ApplyDash::DashToLocation' has a wrong offset!");
static_assert(offsetof(UGATask_ApplyDash, DashToDirection) == 0x000DF0, "Member 'UGATask_ApplyDash::DashToDirection' has a wrong offset!");
static_assert(offsetof(UGATask_ApplyDash, DashToTarget) == 0x000E08, "Member 'UGATask_ApplyDash::DashToTarget' has a wrong offset!");
static_assert(offsetof(UGATask_ApplyDash, PortalSegments) == 0x000E10, "Member 'UGATask_ApplyDash::PortalSegments' has a wrong offset!");

// Class GraphAbility.GATask_Gather
// 0x0030 (0x0238 - 0x0208)
class UGATask_Gather final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnStopDelegate;                                    // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGatherCallbackDelegate;                          // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGATask_Gather* GA_StartGather(class UGameplayAbility* OwningAbility, bool bStopAtMax, float CustomDuration);
	static class UGATask_Gather* StartGather(class UGameplayAbility* OwningAbility, bool bStopAtMax, float CustomDuration);

	void OnGatherIndexChanged(int32 TriggeredIndex);
	void OnGatherStateChanged(bool bState);
	void OnGatherStopDelegate__DelegateSignature(float TotalTime, int32 GatherIndex);
	void StopGather();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_Gather">();
	}
	static class UGATask_Gather* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_Gather>();
	}
};
static_assert(alignof(UGATask_Gather) == 0x000008, "Wrong alignment on UGATask_Gather");
static_assert(sizeof(UGATask_Gather) == 0x000238, "Wrong size on UGATask_Gather");
static_assert(offsetof(UGATask_Gather, OnStopDelegate) == 0x000208, "Member 'UGATask_Gather::OnStopDelegate' has a wrong offset!");
static_assert(offsetof(UGATask_Gather, OnGatherCallbackDelegate) == 0x000218, "Member 'UGATask_Gather::OnGatherCallbackDelegate' has a wrong offset!");

// Class GraphAbility.GATask_PlayTimeline
// 0x0088 (0x0290 - 0x0208)
class UGATask_PlayTimeline final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnCompletedDelegate;                               // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOutDelegate;                                // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterruptedDelegate;                             // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelledDelegate;                               // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerEvent;                                    // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UAnimTimeline*>                  Timelines;                                         // 0x0258(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 AnimIndexs;                                        // 0x0268(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 TimelineIndexs;                                    // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGATask_PlayTimeline* PlayTimeline(class UGameplayAbility* OwningAbility, const TArray<class UAnimTimeline*>& Timelines_0, const TArray<int32>& AnimIndexs_0, bool bStopTimeline);
	static class UGATask_PlayTimeline* PlayTimelineByIndex(class UGameplayAbility* OwningAbility, const TArray<int32>& TimelineIndexs_0, bool bStopTimeline);

	void EndPlayTimeline();
	void OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnReceiveEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void TriggerNotifyTagEventDelegate__DelegateSignature(const struct FGameplayTag& EventTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_PlayTimeline">();
	}
	static class UGATask_PlayTimeline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_PlayTimeline>();
	}
};
static_assert(alignof(UGATask_PlayTimeline) == 0x000008, "Wrong alignment on UGATask_PlayTimeline");
static_assert(sizeof(UGATask_PlayTimeline) == 0x000290, "Wrong size on UGATask_PlayTimeline");
static_assert(offsetof(UGATask_PlayTimeline, OnCompletedDelegate) == 0x000208, "Member 'UGATask_PlayTimeline::OnCompletedDelegate' has a wrong offset!");
static_assert(offsetof(UGATask_PlayTimeline, OnBlendOutDelegate) == 0x000218, "Member 'UGATask_PlayTimeline::OnBlendOutDelegate' has a wrong offset!");
static_assert(offsetof(UGATask_PlayTimeline, OnInterruptedDelegate) == 0x000228, "Member 'UGATask_PlayTimeline::OnInterruptedDelegate' has a wrong offset!");
static_assert(offsetof(UGATask_PlayTimeline, OnCancelledDelegate) == 0x000238, "Member 'UGATask_PlayTimeline::OnCancelledDelegate' has a wrong offset!");
static_assert(offsetof(UGATask_PlayTimeline, OnTriggerEvent) == 0x000248, "Member 'UGATask_PlayTimeline::OnTriggerEvent' has a wrong offset!");
static_assert(offsetof(UGATask_PlayTimeline, Timelines) == 0x000258, "Member 'UGATask_PlayTimeline::Timelines' has a wrong offset!");
static_assert(offsetof(UGATask_PlayTimeline, AnimIndexs) == 0x000268, "Member 'UGATask_PlayTimeline::AnimIndexs' has a wrong offset!");
static_assert(offsetof(UGATask_PlayTimeline, TimelineIndexs) == 0x000278, "Member 'UGATask_PlayTimeline::TimelineIndexs' has a wrong offset!");

// Class GraphAbility.GATask_ProjectileHoming
// 0x0050 (0x0258 - 0x0208)
class UGATask_ProjectileHoming final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnFinished;                                        // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOvertime;                                        // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTargetLose;                                      // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCanceled;                                        // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AMarvelAbilityTargetActor_Projectile*   Projectile;                                        // 0x0248(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 HomingTarget;                                      // 0x0250(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UGATask_ProjectileHoming* SetProjectileHoming(class UGameplayAbility* OwningAbility, class AMarvelAbilityTargetActor_Projectile* Projectile_0, class AActor* HomingToTarget);
	static class UGATask_ProjectileHoming* SetProjectileHomingWithProjectile(class AMarvelAbilityTargetActor_Projectile* Projectile_0, class AActor* HomingToTarget);

	void OnHomingEnd();
	void OnProjectileEventDelegate__DelegateSignature(class AMarvelAbilityTargetActor_Projectile* Projectile_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_ProjectileHoming">();
	}
	static class UGATask_ProjectileHoming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_ProjectileHoming>();
	}
};
static_assert(alignof(UGATask_ProjectileHoming) == 0x000008, "Wrong alignment on UGATask_ProjectileHoming");
static_assert(sizeof(UGATask_ProjectileHoming) == 0x000258, "Wrong size on UGATask_ProjectileHoming");
static_assert(offsetof(UGATask_ProjectileHoming, OnFinished) == 0x000208, "Member 'UGATask_ProjectileHoming::OnFinished' has a wrong offset!");
static_assert(offsetof(UGATask_ProjectileHoming, OnOvertime) == 0x000218, "Member 'UGATask_ProjectileHoming::OnOvertime' has a wrong offset!");
static_assert(offsetof(UGATask_ProjectileHoming, OnTargetLose) == 0x000228, "Member 'UGATask_ProjectileHoming::OnTargetLose' has a wrong offset!");
static_assert(offsetof(UGATask_ProjectileHoming, OnCanceled) == 0x000238, "Member 'UGATask_ProjectileHoming::OnCanceled' has a wrong offset!");
static_assert(offsetof(UGATask_ProjectileHoming, Projectile) == 0x000248, "Member 'UGATask_ProjectileHoming::Projectile' has a wrong offset!");
static_assert(offsetof(UGATask_ProjectileHoming, HomingTarget) == 0x000250, "Member 'UGATask_ProjectileHoming::HomingTarget' has a wrong offset!");

// Class GraphAbility.GATask_SpawnProjectile
// 0x0090 (0x0298 - 0x0208)
class UGATask_SpawnProjectile final : public UGATaskBase
{
public:
	class AMarvelAbilityTargetActor_Projectile*   Projectile;                                        // 0x0208(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBegin;                                           // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnd;                                             // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHit;                                             // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamage;                                          // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         ProjectileID;                                      // 0x0250(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SourceActor;                                       // 0x0258(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CustomLocation;                                    // 0x0260(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               CustomRotation;                                    // 0x0278(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGATask_SpawnProjectile* SpawnProjectile(class UGameplayAbility* OwningAbility, int32 InProjectileID, const struct FVector& CustomLocation_0, const struct FRotator& CustomRotation_0, bool bRelative);
	static class UGATask_SpawnProjectile* SpawnProjectileWithObject(class UObject* Source, int32 InProjectileID, const struct FVector& CustomLocation_0, const struct FRotator& CustomRotation_0);
	static class UGATask_SpawnProjectile* SpawnProjectileWithSource(class UGameplayAbility* OwningAbility, int32 InProjectileID, class AActor* Source, const struct FVector& CustomLocation_0, const struct FRotator& CustomRotation_0);

	void OnApplyDamage();
	void OnBeginAgentTask(class AActor* TargetActor);
	void OnEndAgentTask(class AActor* TargetActor);
	void OnHitOrTraceTarget(const struct FHitResult& HitTarget);
	void OnProjectileEventDelegate__DelegateSignature(class AMarvelAbilityTargetActor_Projectile* Projectile_0);
	void OnSpawnSuccess(class AActor* SpawnActor, const struct FGameplayAbilityTargetDataHandle& Data);
	void OnTargetEventDelegate__DelegateSignature(class AMarvelAbilityTargetActor_Projectile* Projectile_0, class AActor* HitTarget, const struct FVector& HitLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_SpawnProjectile">();
	}
	static class UGATask_SpawnProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_SpawnProjectile>();
	}
};
static_assert(alignof(UGATask_SpawnProjectile) == 0x000008, "Wrong alignment on UGATask_SpawnProjectile");
static_assert(sizeof(UGATask_SpawnProjectile) == 0x000298, "Wrong size on UGATask_SpawnProjectile");
static_assert(offsetof(UGATask_SpawnProjectile, Projectile) == 0x000208, "Member 'UGATask_SpawnProjectile::Projectile' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnProjectile, OnBegin) == 0x000210, "Member 'UGATask_SpawnProjectile::OnBegin' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnProjectile, OnEnd) == 0x000220, "Member 'UGATask_SpawnProjectile::OnEnd' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnProjectile, OnHit) == 0x000230, "Member 'UGATask_SpawnProjectile::OnHit' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnProjectile, OnDamage) == 0x000240, "Member 'UGATask_SpawnProjectile::OnDamage' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnProjectile, ProjectileID) == 0x000250, "Member 'UGATask_SpawnProjectile::ProjectileID' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnProjectile, SourceActor) == 0x000258, "Member 'UGATask_SpawnProjectile::SourceActor' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnProjectile, CustomLocation) == 0x000260, "Member 'UGATask_SpawnProjectile::CustomLocation' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnProjectile, CustomRotation) == 0x000278, "Member 'UGATask_SpawnProjectile::CustomRotation' has a wrong offset!");

// Class GraphAbility.GATask_SpawnScope
// 0x00A8 (0x02B0 - 0x0208)
class UGATask_SpawnScope final : public UGATaskBase
{
public:
	class AMarvelAbilityTargetActor_Scope*        ScopeActor;                                        // 0x0208(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAgentTraceComponent*             ScopeTraceComp;                                    // 0x0210(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAgentEffectiveComponent*         ScopeEffectComp;                                   // 0x0218(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBegin;                                           // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnd;                                             // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHit;                                             // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHitAll;                                          // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamage;                                          // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         ScopeId;                                           // 0x0270(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SourceActor;                                       // 0x0278(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CustomLocation;                                    // 0x0280(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               CustomRotation;                                    // 0x0298(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UGATask_SpawnScope* SpawnScope(class UGameplayAbility* OwningAbility, int32 InScopeID, const struct FVector& CustomLocation_0, const struct FRotator& CustomRotation_0);
	static class UGATask_SpawnScope* SpawnScopeWithObject(class UObject* Source, int32 InScopeID, const struct FVector& CustomLocation_0, const struct FRotator& CustomRotation_0);
	static class UGATask_SpawnScope* SpawnScopeWithSource(class UGameplayAbility* OwningAbility, int32 InScopeID, class AActor* Source, const struct FVector& CustomLocation_0, const struct FRotator& CustomRotation_0);

	void OnActorBeginAgentTask(class AActor* TargetActor);
	void OnActorEndAgentTask(class AActor* TargetActor);
	void OnAllHitDelegate__DelegateSignature(class AMarvelAbilityTargetActor_Scope* ScopeActor_0, const TArray<struct FHitResult>& HitInfos);
	void OnApplyDamage();
	void OnNoActorScopeInited(class UMarvelAgentTraceComponent* TraceComp, class UMarvelAgentEffectiveComponent* EffectComp);
	void OnScopeEventDelegate__DelegateSignature(class AMarvelAbilityTargetActor_Scope* ScopeActor_0);
	void OnSpawnActorSuccess(class AActor* SpawnActor, const struct FGameplayAbilityTargetDataHandle& Data);
	void OnTargetEventDelegate__DelegateSignature(class AMarvelAbilityTargetActor_Scope* ScopeActor_0, class AActor* Target, const struct FVector& Location);
	void OnTrace(class UObject* TraceSource, const TArray<struct FHitResult>& HitResults);
	void OnTraceEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_SpawnScope">();
	}
	static class UGATask_SpawnScope* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_SpawnScope>();
	}
};
static_assert(alignof(UGATask_SpawnScope) == 0x000008, "Wrong alignment on UGATask_SpawnScope");
static_assert(sizeof(UGATask_SpawnScope) == 0x0002B0, "Wrong size on UGATask_SpawnScope");
static_assert(offsetof(UGATask_SpawnScope, ScopeActor) == 0x000208, "Member 'UGATask_SpawnScope::ScopeActor' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnScope, ScopeTraceComp) == 0x000210, "Member 'UGATask_SpawnScope::ScopeTraceComp' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnScope, ScopeEffectComp) == 0x000218, "Member 'UGATask_SpawnScope::ScopeEffectComp' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnScope, OnBegin) == 0x000220, "Member 'UGATask_SpawnScope::OnBegin' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnScope, OnEnd) == 0x000230, "Member 'UGATask_SpawnScope::OnEnd' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnScope, OnHit) == 0x000240, "Member 'UGATask_SpawnScope::OnHit' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnScope, OnHitAll) == 0x000250, "Member 'UGATask_SpawnScope::OnHitAll' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnScope, OnDamage) == 0x000260, "Member 'UGATask_SpawnScope::OnDamage' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnScope, ScopeId) == 0x000270, "Member 'UGATask_SpawnScope::ScopeId' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnScope, SourceActor) == 0x000278, "Member 'UGATask_SpawnScope::SourceActor' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnScope, CustomLocation) == 0x000280, "Member 'UGATask_SpawnScope::CustomLocation' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnScope, CustomRotation) == 0x000298, "Member 'UGATask_SpawnScope::CustomRotation' has a wrong offset!");

// Class GraphAbility.GATask_SpawnSummoned
// 0x0080 (0x0288 - 0x0208)
class UGATask_SpawnSummoned final : public UGATaskBase
{
public:
	class AActor*                                 SummonedActor;                                     // 0x0208(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBegin;                                           // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnd;                                             // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeath;                                           // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         SummonedID;                                        // 0x0240(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SourceActor;                                       // 0x0248(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CustomLocation;                                    // 0x0250(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               CustomRotation;                                    // 0x0268(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class UMarvelSummonedComponent*               SpawnedSummonedComp;                               // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGATask_SpawnSummoned* SpawnProjectileWithObject(class UObject* Source, int32 InSummonedID, const struct FVector& CustomLocation_0, const struct FRotator& CustomRotation_0);
	static class UGATask_SpawnSummoned* SpawnSummoned(class UGameplayAbility* OwningAbility, int32 InSummonedID, const struct FVector& CustomLocation_0, const struct FRotator& CustomRotation_0);
	static class UGATask_SpawnSummoned* SpawnSummonedWithSource(class UGameplayAbility* OwningAbility, int32 InSummonedID, class AActor* Source, const struct FVector& CustomLocation_0, const struct FRotator& CustomRotation_0);

	void OnBeginAgentTask(class AActor* TargetActor);
	void OnEndAgentTask(class AActor* TargetActor);
	void OnSpawnSummonedSuccess(class AActor* SpawnActor);
	void OnSummonedDeath(class AActor* TargetActor);
	void OnSummonedDelegate__DelegateSignature(class AActor* Summoner);
	void OnTargetEventDelegate__DelegateSignature(class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_SpawnSummoned">();
	}
	static class UGATask_SpawnSummoned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_SpawnSummoned>();
	}
};
static_assert(alignof(UGATask_SpawnSummoned) == 0x000008, "Wrong alignment on UGATask_SpawnSummoned");
static_assert(sizeof(UGATask_SpawnSummoned) == 0x000288, "Wrong size on UGATask_SpawnSummoned");
static_assert(offsetof(UGATask_SpawnSummoned, SummonedActor) == 0x000208, "Member 'UGATask_SpawnSummoned::SummonedActor' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnSummoned, OnBegin) == 0x000210, "Member 'UGATask_SpawnSummoned::OnBegin' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnSummoned, OnEnd) == 0x000220, "Member 'UGATask_SpawnSummoned::OnEnd' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnSummoned, OnDeath) == 0x000230, "Member 'UGATask_SpawnSummoned::OnDeath' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnSummoned, SummonedID) == 0x000240, "Member 'UGATask_SpawnSummoned::SummonedID' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnSummoned, SourceActor) == 0x000248, "Member 'UGATask_SpawnSummoned::SourceActor' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnSummoned, CustomLocation) == 0x000250, "Member 'UGATask_SpawnSummoned::CustomLocation' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnSummoned, CustomRotation) == 0x000268, "Member 'UGATask_SpawnSummoned::CustomRotation' has a wrong offset!");
static_assert(offsetof(UGATask_SpawnSummoned, SpawnedSummonedComp) == 0x000280, "Member 'UGATask_SpawnSummoned::SpawnedSummonedComp' has a wrong offset!");

// Class GraphAbility.GATask_WaitAttributeChange
// 0x0080 (0x0288 - 0x0208)
class UGATask_WaitAttributeChange final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnInRange;                                         // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOutRange;                                        // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0228(0x0040)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinValue;                                          // 0x0268(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIncludeMin;                                       // 0x026C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxValue;                                          // 0x0270(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIncludeMax;                                       // 0x0274(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerOnce;                                      // 0x0275(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBeginCheck;                                       // 0x0276(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLastInRange;                                      // 0x0277(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                TargetASC;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGATask_WaitAttributeChange* WaitAttributeChange_Range(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& Attribute_0, float MinValue_0, bool bIncludeMin_0, float MaxValue_0, bool bIncludeMax_0, bool bTriggerOnce_0, bool bBeginCheck_0);
	static class UGATask_WaitAttributeChange* WaitAttributeChange_Single(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& Attribute_0, float CompareValue, EAttrCompareType Comparison, bool bTriggerOnce_0, bool bBeginCheck_0);

	void OnAttributeChangeDelegate__DelegateSignature(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WaitAttributeChange">();
	}
	static class UGATask_WaitAttributeChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WaitAttributeChange>();
	}
};
static_assert(alignof(UGATask_WaitAttributeChange) == 0x000008, "Wrong alignment on UGATask_WaitAttributeChange");
static_assert(sizeof(UGATask_WaitAttributeChange) == 0x000288, "Wrong size on UGATask_WaitAttributeChange");
static_assert(offsetof(UGATask_WaitAttributeChange, OnInRange) == 0x000208, "Member 'UGATask_WaitAttributeChange::OnInRange' has a wrong offset!");
static_assert(offsetof(UGATask_WaitAttributeChange, OnOutRange) == 0x000218, "Member 'UGATask_WaitAttributeChange::OnOutRange' has a wrong offset!");
static_assert(offsetof(UGATask_WaitAttributeChange, Attribute) == 0x000228, "Member 'UGATask_WaitAttributeChange::Attribute' has a wrong offset!");
static_assert(offsetof(UGATask_WaitAttributeChange, MinValue) == 0x000268, "Member 'UGATask_WaitAttributeChange::MinValue' has a wrong offset!");
static_assert(offsetof(UGATask_WaitAttributeChange, bIncludeMin) == 0x00026C, "Member 'UGATask_WaitAttributeChange::bIncludeMin' has a wrong offset!");
static_assert(offsetof(UGATask_WaitAttributeChange, MaxValue) == 0x000270, "Member 'UGATask_WaitAttributeChange::MaxValue' has a wrong offset!");
static_assert(offsetof(UGATask_WaitAttributeChange, bIncludeMax) == 0x000274, "Member 'UGATask_WaitAttributeChange::bIncludeMax' has a wrong offset!");
static_assert(offsetof(UGATask_WaitAttributeChange, bTriggerOnce) == 0x000275, "Member 'UGATask_WaitAttributeChange::bTriggerOnce' has a wrong offset!");
static_assert(offsetof(UGATask_WaitAttributeChange, bBeginCheck) == 0x000276, "Member 'UGATask_WaitAttributeChange::bBeginCheck' has a wrong offset!");
static_assert(offsetof(UGATask_WaitAttributeChange, bLastInRange) == 0x000277, "Member 'UGATask_WaitAttributeChange::bLastInRange' has a wrong offset!");
static_assert(offsetof(UGATask_WaitAttributeChange, TargetASC) == 0x000278, "Member 'UGATask_WaitAttributeChange::TargetASC' has a wrong offset!");

// Class GraphAbility.GATask_WaitBuffEvent
// 0x0198 (0x03A0 - 0x0208)
class UGATask_WaitBuffEvent final : public UGATaskBase
{
public:
	uint8                                         Pad_208[0x18];                                     // 0x0208(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnApplied;                                         // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoved;                                         // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x0240(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                TargetASC;                                         // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                SourceASC;                                         // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0258(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPredictionKey                         ApplyBuffKey;                                      // 0x0260(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPredictionKey                         RemoveBuffKey;                                     // 0x0300(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGATask_WaitBuffEvent* WaitBuffEvent(class UGameplayAbility* OwningAbility, int32 BuffID_0);

	void OnAppliedReplicatedCallback(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnBuffUpdateDelegate__DelegateSignature(int32 NewStackCount, int32 OldStackCount);
	void OnRemovedReplicatedCallback(const struct FGameplayAbilityTargetDataHandle& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WaitBuffEvent">();
	}
	static class UGATask_WaitBuffEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WaitBuffEvent>();
	}
};
static_assert(alignof(UGATask_WaitBuffEvent) == 0x000008, "Wrong alignment on UGATask_WaitBuffEvent");
static_assert(sizeof(UGATask_WaitBuffEvent) == 0x0003A0, "Wrong size on UGATask_WaitBuffEvent");
static_assert(offsetof(UGATask_WaitBuffEvent, OnApplied) == 0x000220, "Member 'UGATask_WaitBuffEvent::OnApplied' has a wrong offset!");
static_assert(offsetof(UGATask_WaitBuffEvent, OnRemoved) == 0x000230, "Member 'UGATask_WaitBuffEvent::OnRemoved' has a wrong offset!");
static_assert(offsetof(UGATask_WaitBuffEvent, BuffID) == 0x000240, "Member 'UGATask_WaitBuffEvent::BuffID' has a wrong offset!");
static_assert(offsetof(UGATask_WaitBuffEvent, TargetASC) == 0x000248, "Member 'UGATask_WaitBuffEvent::TargetASC' has a wrong offset!");
static_assert(offsetof(UGATask_WaitBuffEvent, SourceASC) == 0x000250, "Member 'UGATask_WaitBuffEvent::SourceASC' has a wrong offset!");
static_assert(offsetof(UGATask_WaitBuffEvent, EffectHandle) == 0x000258, "Member 'UGATask_WaitBuffEvent::EffectHandle' has a wrong offset!");
static_assert(offsetof(UGATask_WaitBuffEvent, ApplyBuffKey) == 0x000260, "Member 'UGATask_WaitBuffEvent::ApplyBuffKey' has a wrong offset!");
static_assert(offsetof(UGATask_WaitBuffEvent, RemoveBuffKey) == 0x000300, "Member 'UGATask_WaitBuffEvent::RemoveBuffKey' has a wrong offset!");

// Class GraphAbility.GATask_WaitConfirmCancel
// 0x0128 (0x0330 - 0x0208)
class UGATask_WaitConfirmCancel final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnConfirmPressed;                                  // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConfirmReleased;                                 // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelPressed;                                   // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelReleased;                                  // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimeout;                                         // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EAbilityInputBinds                            ConfirmInputBind;                                  // 0x0258(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAbilityInputBinds                            CancelInputBind;                                   // 0x0259(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSkipNowTrigger;                                   // 0x025A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25B[0x1];                                      // 0x025B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitTime;                                          // 0x025C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelAbilityTask_WaitBindInput*       ConfirmInputTask;                                  // 0x0260(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelAbilityTask_WaitBindInput*       CancelInputTask;                                   // 0x0268(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x18];                                     // 0x0270(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTimeout;                                        // 0x0288(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         TimerKey;                                          // 0x0290(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGATask_WaitConfirmCancel* WaitConfirmCancel(class UGameplayAbility* OwningAbility, EAbilityInputBinds ConfirmInput, EAbilityInputBinds CancelInput, bool bSkipNowTrigger_0, float MaxWaitTime);
	static class UGATask_WaitConfirmCancel* WaitConfirmCancelDefault(class UGameplayAbility* OwningAbility, bool bSkipNowTrigger_0, float MaxWaitTime);

	void EndWait();
	void OnCancelPressedCallback(float TimeWaited);
	void OnCancelReleasedCallback(float TimeWaited);
	void OnConfirmPressedCallback(float TimeWaited);
	void OnConfirmReleasedCallback(float TimeWaited);
	void OnTimeoutCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WaitConfirmCancel">();
	}
	static class UGATask_WaitConfirmCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WaitConfirmCancel>();
	}
};
static_assert(alignof(UGATask_WaitConfirmCancel) == 0x000008, "Wrong alignment on UGATask_WaitConfirmCancel");
static_assert(sizeof(UGATask_WaitConfirmCancel) == 0x000330, "Wrong size on UGATask_WaitConfirmCancel");
static_assert(offsetof(UGATask_WaitConfirmCancel, OnConfirmPressed) == 0x000208, "Member 'UGATask_WaitConfirmCancel::OnConfirmPressed' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, OnConfirmReleased) == 0x000218, "Member 'UGATask_WaitConfirmCancel::OnConfirmReleased' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, OnCancelPressed) == 0x000228, "Member 'UGATask_WaitConfirmCancel::OnCancelPressed' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, OnCancelReleased) == 0x000238, "Member 'UGATask_WaitConfirmCancel::OnCancelReleased' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, OnTimeout) == 0x000248, "Member 'UGATask_WaitConfirmCancel::OnTimeout' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, ConfirmInputBind) == 0x000258, "Member 'UGATask_WaitConfirmCancel::ConfirmInputBind' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, CancelInputBind) == 0x000259, "Member 'UGATask_WaitConfirmCancel::CancelInputBind' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, bSkipNowTrigger) == 0x00025A, "Member 'UGATask_WaitConfirmCancel::bSkipNowTrigger' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, WaitTime) == 0x00025C, "Member 'UGATask_WaitConfirmCancel::WaitTime' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, ConfirmInputTask) == 0x000260, "Member 'UGATask_WaitConfirmCancel::ConfirmInputTask' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, CancelInputTask) == 0x000268, "Member 'UGATask_WaitConfirmCancel::CancelInputTask' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, bIsTimeout) == 0x000288, "Member 'UGATask_WaitConfirmCancel::bIsTimeout' has a wrong offset!");
static_assert(offsetof(UGATask_WaitConfirmCancel, TimerKey) == 0x000290, "Member 'UGATask_WaitConfirmCancel::TimerKey' has a wrong offset!");

// Class GraphAbility.GATask_WaitDamageEvent
// 0x00C0 (0x02C8 - 0x0208)
class UGATask_WaitDamageEvent final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnDamageOrTreatEvent;                              // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMarvelBaseAbilitySystemComponent*      SourceASC;                                         // 0x0218(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0xA8];                                     // 0x0220(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGATask_WaitDamageEvent* WaitDamageEvent(class UGameplayAbility* OwningAbility, EDamageEventType EventType);

	void DamageDelegate__DelegateSignature(class AActor* OtherActor, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void EndWaiting();
	void OnDamageCallback(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WaitDamageEvent">();
	}
	static class UGATask_WaitDamageEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WaitDamageEvent>();
	}
};
static_assert(alignof(UGATask_WaitDamageEvent) == 0x000008, "Wrong alignment on UGATask_WaitDamageEvent");
static_assert(sizeof(UGATask_WaitDamageEvent) == 0x0002C8, "Wrong size on UGATask_WaitDamageEvent");
static_assert(offsetof(UGATask_WaitDamageEvent, OnDamageOrTreatEvent) == 0x000208, "Member 'UGATask_WaitDamageEvent::OnDamageOrTreatEvent' has a wrong offset!");
static_assert(offsetof(UGATask_WaitDamageEvent, SourceASC) == 0x000218, "Member 'UGATask_WaitDamageEvent::SourceASC' has a wrong offset!");

// Class GraphAbility.GATask_WaitKillEvent
// 0x00B8 (0x02C0 - 0x0208)
class UGATask_WaitKillEvent final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnKillEvent;                                       // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0xA8];                                     // 0x0218(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGATask_WaitKillEvent* WaitKillEvent(class UGameplayAbility* OwningAbility, class AActor* SourceCharacter, class AActor* TargetCharacter);

	void EndWaiting();
	void OnKillCallback(const struct FUIKillInfo& KillInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WaitKillEvent">();
	}
	static class UGATask_WaitKillEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WaitKillEvent>();
	}
};
static_assert(alignof(UGATask_WaitKillEvent) == 0x000008, "Wrong alignment on UGATask_WaitKillEvent");
static_assert(sizeof(UGATask_WaitKillEvent) == 0x0002C0, "Wrong size on UGATask_WaitKillEvent");
static_assert(offsetof(UGATask_WaitKillEvent, OnKillEvent) == 0x000208, "Member 'UGATask_WaitKillEvent::OnKillEvent' has a wrong offset!");

// Class GraphAbility.GATask_WaitInput
// 0x0170 (0x0378 - 0x0208)
class UGATask_WaitInput final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnPress;                                           // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRelease;                                         // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimeout;                                         // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EAbilityInputBinds                            InputBind;                                         // 0x0238(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSkipNowTrigger;                                   // 0x0239(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23A[0x2];                                      // 0x023A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitTime;                                          // 0x023C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerOnce;                                      // 0x0240(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActionTipsParam                       ActionTipsParam;                                   // 0x0248(0x0068)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x18];                                     // 0x02B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTimeout;                                        // 0x02C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPressElapsedTime;                              // 0x02CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastReleaseElapsedTime;                            // 0x02D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         TimerKey;                                          // 0x02D8(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGATask_WaitInput* WaitCancel(class UGameplayAbility* OwningAbility, bool bSkipNowTrigger_0, float MaxWaitTime);
	static class UGATask_WaitInput* WaitConfirm(class UGameplayAbility* OwningAbility, bool bSkipNowTrigger_0, float MaxWaitTime);
	static class UGATask_WaitInput* WaitInput(class UGameplayAbility* OwningAbility, EAbilityInputBinds Input, bool bSkipNowTrigger_0, float MaxWaitTime, bool bTriggerOnce_0, const struct FActionTipsParam& ActionTipsParam_0);

	void EndWait();
	void OnInputPressed(float TimeWaited);
	void OnInputReleased(float TimeWaited);
	void OnReleaseDelegate__DelegateSignature(float Duration);
	void OnTimeoutCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WaitInput">();
	}
	static class UGATask_WaitInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WaitInput>();
	}
};
static_assert(alignof(UGATask_WaitInput) == 0x000008, "Wrong alignment on UGATask_WaitInput");
static_assert(sizeof(UGATask_WaitInput) == 0x000378, "Wrong size on UGATask_WaitInput");
static_assert(offsetof(UGATask_WaitInput, OnPress) == 0x000208, "Member 'UGATask_WaitInput::OnPress' has a wrong offset!");
static_assert(offsetof(UGATask_WaitInput, OnRelease) == 0x000218, "Member 'UGATask_WaitInput::OnRelease' has a wrong offset!");
static_assert(offsetof(UGATask_WaitInput, OnTimeout) == 0x000228, "Member 'UGATask_WaitInput::OnTimeout' has a wrong offset!");
static_assert(offsetof(UGATask_WaitInput, InputBind) == 0x000238, "Member 'UGATask_WaitInput::InputBind' has a wrong offset!");
static_assert(offsetof(UGATask_WaitInput, bSkipNowTrigger) == 0x000239, "Member 'UGATask_WaitInput::bSkipNowTrigger' has a wrong offset!");
static_assert(offsetof(UGATask_WaitInput, WaitTime) == 0x00023C, "Member 'UGATask_WaitInput::WaitTime' has a wrong offset!");
static_assert(offsetof(UGATask_WaitInput, bTriggerOnce) == 0x000240, "Member 'UGATask_WaitInput::bTriggerOnce' has a wrong offset!");
static_assert(offsetof(UGATask_WaitInput, ActionTipsParam) == 0x000248, "Member 'UGATask_WaitInput::ActionTipsParam' has a wrong offset!");
static_assert(offsetof(UGATask_WaitInput, bIsTimeout) == 0x0002C8, "Member 'UGATask_WaitInput::bIsTimeout' has a wrong offset!");
static_assert(offsetof(UGATask_WaitInput, LastPressElapsedTime) == 0x0002CC, "Member 'UGATask_WaitInput::LastPressElapsedTime' has a wrong offset!");
static_assert(offsetof(UGATask_WaitInput, LastReleaseElapsedTime) == 0x0002D0, "Member 'UGATask_WaitInput::LastReleaseElapsedTime' has a wrong offset!");
static_assert(offsetof(UGATask_WaitInput, TimerKey) == 0x0002D8, "Member 'UGATask_WaitInput::TimerKey' has a wrong offset!");

// Class GraphAbility.GATask_WaitOwnerKillOther
// 0x00B8 (0x02C0 - 0x0208)
class UGATask_WaitOwnerKillOther final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnCharacterKillOther;                              // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPredictionKey                         OnKillOtherKey;                                    // 0x0218(0x00A0)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   TargetCharacter;                                   // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UGATask_WaitOwnerKillOther* WaitAbilityOwnerKillOther(class UGameplayAbility* OwningAbility);
	static class UGATask_WaitOwnerKillOther* WaitCharacterKillOther(class UGameplayAbility* OwningAbility, class AActor* InCharacter);

	void InternalOnCharacterKillOther(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnCharacterKillOther__DelegateSignature(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WaitOwnerKillOther">();
	}
	static class UGATask_WaitOwnerKillOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WaitOwnerKillOther>();
	}
};
static_assert(alignof(UGATask_WaitOwnerKillOther) == 0x000008, "Wrong alignment on UGATask_WaitOwnerKillOther");
static_assert(sizeof(UGATask_WaitOwnerKillOther) == 0x0002C0, "Wrong size on UGATask_WaitOwnerKillOther");
static_assert(offsetof(UGATask_WaitOwnerKillOther, OnCharacterKillOther) == 0x000208, "Member 'UGATask_WaitOwnerKillOther::OnCharacterKillOther' has a wrong offset!");
static_assert(offsetof(UGATask_WaitOwnerKillOther, OnKillOtherKey) == 0x000218, "Member 'UGATask_WaitOwnerKillOther::OnKillOtherKey' has a wrong offset!");
static_assert(offsetof(UGATask_WaitOwnerKillOther, TargetCharacter) == 0x0002B8, "Member 'UGATask_WaitOwnerKillOther::TargetCharacter' has a wrong offset!");

// Class GraphAbility.GATask_WaitSignal
// 0x00C0 (0x02C8 - 0x0208)
class UGATask_WaitSignal final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnReceiveSignal;                                   // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   SignalName;                                        // 0x0218(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESignalLevel                                  ReceiveLevel;                                      // 0x0224(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerOnce;                                      // 0x0225(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_226[0x2];                                      // 0x0226(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         TriggerKey;                                        // 0x0228(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGATask_WaitSignal* WaitSignalEvent(class UGameplayAbility* OwningAbility, class FName SignalName_0, ESignalLevel Level, bool bOnce);

	void EndWaitingSignal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WaitSignal">();
	}
	static class UGATask_WaitSignal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WaitSignal>();
	}
};
static_assert(alignof(UGATask_WaitSignal) == 0x000008, "Wrong alignment on UGATask_WaitSignal");
static_assert(sizeof(UGATask_WaitSignal) == 0x0002C8, "Wrong size on UGATask_WaitSignal");
static_assert(offsetof(UGATask_WaitSignal, OnReceiveSignal) == 0x000208, "Member 'UGATask_WaitSignal::OnReceiveSignal' has a wrong offset!");
static_assert(offsetof(UGATask_WaitSignal, SignalName) == 0x000218, "Member 'UGATask_WaitSignal::SignalName' has a wrong offset!");
static_assert(offsetof(UGATask_WaitSignal, ReceiveLevel) == 0x000224, "Member 'UGATask_WaitSignal::ReceiveLevel' has a wrong offset!");
static_assert(offsetof(UGATask_WaitSignal, bTriggerOnce) == 0x000225, "Member 'UGATask_WaitSignal::bTriggerOnce' has a wrong offset!");
static_assert(offsetof(UGATask_WaitSignal, TriggerKey) == 0x000228, "Member 'UGATask_WaitSignal::TriggerKey' has a wrong offset!");

// Class GraphAbility.GATask_WaitTargetData
// 0x1008 (0x1210 - 0x0208)
class UGATask_WaitTargetData final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnConfirm;                                         // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancel;                                          // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFindGroundParam                       TraceParams;                                       // 0x0230(0x0FD0)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PlacementCueTag;                                   // 0x1200(0x000C)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120C[0x4];                                     // 0x120C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGATask_WaitTargetData* WaitTargetData_PawnPlacement(class UGameplayAbility* OwningAbility, const struct FFindGroundParam& TraceParams_0, const struct FGameplayTag& PlacementCueTag_0);

	void OnCancelledCallback(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnValidDataCallback(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnValidLocationDelegate__DelegateSignature(const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WaitTargetData">();
	}
	static class UGATask_WaitTargetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WaitTargetData>();
	}
};
static_assert(alignof(UGATask_WaitTargetData) == 0x000010, "Wrong alignment on UGATask_WaitTargetData");
static_assert(sizeof(UGATask_WaitTargetData) == 0x001210, "Wrong size on UGATask_WaitTargetData");
static_assert(offsetof(UGATask_WaitTargetData, OnConfirm) == 0x000208, "Member 'UGATask_WaitTargetData::OnConfirm' has a wrong offset!");
static_assert(offsetof(UGATask_WaitTargetData, OnCancel) == 0x000218, "Member 'UGATask_WaitTargetData::OnCancel' has a wrong offset!");
static_assert(offsetof(UGATask_WaitTargetData, TraceParams) == 0x000230, "Member 'UGATask_WaitTargetData::TraceParams' has a wrong offset!");
static_assert(offsetof(UGATask_WaitTargetData, PlacementCueTag) == 0x001200, "Member 'UGATask_WaitTargetData::PlacementCueTag' has a wrong offset!");

// Class GraphAbility.GATask_WaitTime
// 0x0018 (0x0220 - 0x0208)
class UGATask_WaitTime final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnFinished;                                        // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0218(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGATask_WaitTime* WaitTimeSeconds(class UGameplayAbility* OwningAbility, float Seconds);

	void OnFinishedDelegate__DelegateSignature();
	void OnTimeFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WaitTime">();
	}
	static class UGATask_WaitTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WaitTime>();
	}
};
static_assert(alignof(UGATask_WaitTime) == 0x000008, "Wrong alignment on UGATask_WaitTime");
static_assert(sizeof(UGATask_WaitTime) == 0x000220, "Wrong size on UGATask_WaitTime");
static_assert(offsetof(UGATask_WaitTime, OnFinished) == 0x000208, "Member 'UGATask_WaitTime::OnFinished' has a wrong offset!");
static_assert(offsetof(UGATask_WaitTime, Time) == 0x000218, "Member 'UGATask_WaitTime::Time' has a wrong offset!");

// Class GraphAbility.GATask_WeaponFireOnce
// 0x0110 (0x0318 - 0x0208)
class UGATask_WeaponFireOnce final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnFired;                                           // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnd;                                             // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         WeaponID;                                          // 0x0228(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ShootModes;                                        // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         ShootCount;                                        // 0x0240(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShootDelay;                                        // 0x0244(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ReloadAbilityID;                                   // 0x0248(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AShootingWeapon*                        MyWeapon;                                          // 0x0250(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPredictionKey                         ShootPredictKey;                                   // 0x0258(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TriggeredShootCount;                               // 0x02F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FC[0x1C];                                     // 0x02FC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGATask_WeaponFireOnce* WeaponFireOnce_MultiMode(class UGameplayAbility* OwningAbility, int32 WeaponID_0, const TArray<int32>& ShootModes_0, int32 ShootCount_0, float ShootDelay_0, int32 ReloadAbilityID_0);
	static class UGATask_WeaponFireOnce* WeaponFireOnce_SingleMode(class UGameplayAbility* OwningAbility, int32 WeaponID_0, int32 ShootMode, int32 ShootCount_0, float ShootDelay_0, int32 ReloadAbilityID_0);

	void Shoot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WeaponFireOnce">();
	}
	static class UGATask_WeaponFireOnce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WeaponFireOnce>();
	}
};
static_assert(alignof(UGATask_WeaponFireOnce) == 0x000008, "Wrong alignment on UGATask_WeaponFireOnce");
static_assert(sizeof(UGATask_WeaponFireOnce) == 0x000318, "Wrong size on UGATask_WeaponFireOnce");
static_assert(offsetof(UGATask_WeaponFireOnce, OnFired) == 0x000208, "Member 'UGATask_WeaponFireOnce::OnFired' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFireOnce, OnEnd) == 0x000218, "Member 'UGATask_WeaponFireOnce::OnEnd' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFireOnce, WeaponID) == 0x000228, "Member 'UGATask_WeaponFireOnce::WeaponID' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFireOnce, ShootModes) == 0x000230, "Member 'UGATask_WeaponFireOnce::ShootModes' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFireOnce, ShootCount) == 0x000240, "Member 'UGATask_WeaponFireOnce::ShootCount' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFireOnce, ShootDelay) == 0x000244, "Member 'UGATask_WeaponFireOnce::ShootDelay' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFireOnce, ReloadAbilityID) == 0x000248, "Member 'UGATask_WeaponFireOnce::ReloadAbilityID' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFireOnce, MyWeapon) == 0x000250, "Member 'UGATask_WeaponFireOnce::MyWeapon' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFireOnce, ShootPredictKey) == 0x000258, "Member 'UGATask_WeaponFireOnce::ShootPredictKey' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFireOnce, TriggeredShootCount) == 0x0002F8, "Member 'UGATask_WeaponFireOnce::TriggeredShootCount' has a wrong offset!");

// Class GraphAbility.GATask_WeaponFiring
// 0x00F8 (0x0300 - 0x0208)
class UGATask_WeaponFiring final : public UGATaskBase
{
public:
	FMulticastInlineDelegateProperty_             OnFire;                                            // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnd;                                             // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         WeaponID;                                          // 0x0228(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ShootModes;                                        // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bIsRoundRobin;                                     // 0x0240(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReloadAbilityID;                                   // 0x0244(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayEndTask;                                      // 0x0248(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAbilityInputBinds                            InputBind;                                         // 0x024C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24D[0x3];                                      // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         FireKey;                                           // 0x0250(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FireIndex;                                         // 0x02F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelWeaponTask_Firing*               SubFireTask;                                       // 0x02F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGATask_WeaponFiring* WeaponFiring_MultiModes(class UGameplayAbility* OwningAbility, int32 WeaponID_0, const TArray<int32>& ShootModes_0, bool bIsRoundRobin_0, int32 ReloadAbilityID_0, float DelayEndTask_0, EAbilityInputBinds Input);
	static class UGATask_WeaponFiring* WeaponFiring_SingleMode(class UGameplayAbility* OwningAbility, int32 WeaponID_0, int32 ShootMode, int32 ReloadAbilityID_0, float DelayEndTask_0, EAbilityInputBinds Input);

	void OnFireReplicatedCallback(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnWeaponFire();
	void OnWeaponFireTaskEnd(bool AbilityEnded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GATask_WeaponFiring">();
	}
	static class UGATask_WeaponFiring* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGATask_WeaponFiring>();
	}
};
static_assert(alignof(UGATask_WeaponFiring) == 0x000008, "Wrong alignment on UGATask_WeaponFiring");
static_assert(sizeof(UGATask_WeaponFiring) == 0x000300, "Wrong size on UGATask_WeaponFiring");
static_assert(offsetof(UGATask_WeaponFiring, OnFire) == 0x000208, "Member 'UGATask_WeaponFiring::OnFire' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFiring, OnEnd) == 0x000218, "Member 'UGATask_WeaponFiring::OnEnd' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFiring, WeaponID) == 0x000228, "Member 'UGATask_WeaponFiring::WeaponID' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFiring, ShootModes) == 0x000230, "Member 'UGATask_WeaponFiring::ShootModes' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFiring, bIsRoundRobin) == 0x000240, "Member 'UGATask_WeaponFiring::bIsRoundRobin' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFiring, ReloadAbilityID) == 0x000244, "Member 'UGATask_WeaponFiring::ReloadAbilityID' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFiring, DelayEndTask) == 0x000248, "Member 'UGATask_WeaponFiring::DelayEndTask' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFiring, InputBind) == 0x00024C, "Member 'UGATask_WeaponFiring::InputBind' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFiring, FireKey) == 0x000250, "Member 'UGATask_WeaponFiring::FireKey' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFiring, FireIndex) == 0x0002F0, "Member 'UGATask_WeaponFiring::FireIndex' has a wrong offset!");
static_assert(offsetof(UGATask_WeaponFiring, SubFireTask) == 0x0002F8, "Member 'UGATask_WeaponFiring::SubFireTask' has a wrong offset!");

// Class GraphAbility.GraphAbilityFuncLibrary
// 0x0000 (0x0030 - 0x0030)
class UGraphAbilityFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class AActor* GetAbilityActorFromObj(class UObject* InObj);
	static class UMarvelAbilityConfig* GetAbilityConfigFromAbilityTarget(class UObject* InObj);
	static class AActor* GetAbilityTargetActorFromAbilityTarget(class UObject* InObj);
	static class UGameplayAbility* GetCurrentAbilityFromAbilityTarget(class UObject* InObj);
	static class APawn* GetCurrentInstigatorFromAbilityTarget(class UObject* InObj);
	static class UGameplayAbility* GetOriginAbilityFromAbilityTarget(class UObject* InObj);
	static class APawn* GetOriginInstigatorFromAbilityTarget(class UObject* InObj);
	static class UGameplayAbility* GetTaskAbilityFromAbilityTarget(class UObject* InObj);
	static void OnTargetActorCallAbilityTask(class UObject* TaskCaller, class UGameplayTask* InTask);
	static void SetAbilityTaskBeforeActivation(class UObject* InObj, class UAbilityTask* AbilityTask, int32 IsWithAbility, const class FString& GATaskName, bool bCancelAbilityWhenFailed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GraphAbilityFuncLibrary">();
	}
	static class UGraphAbilityFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGraphAbilityFuncLibrary>();
	}
};
static_assert(alignof(UGraphAbilityFuncLibrary) == 0x000008, "Wrong alignment on UGraphAbilityFuncLibrary");
static_assert(sizeof(UGraphAbilityFuncLibrary) == 0x000030, "Wrong size on UGraphAbilityFuncLibrary");

// Class GraphAbility.GraphAbilityFuncNodes
// 0x0000 (0x0030 - 0x0030)
class UGraphAbilityFuncNodes final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyBuffToTarget(class UObject* SelfObj, int32 BuffID, class AActor* Target, class AActor* Source);
	static float GetAttributeValue(const class AActor* Actor, const struct FGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute);
	static struct FVector GetDirectionByConfig(class UObject* InObj, ECommonPlayDir Direction);
	static class AActor* GetSelfActor(class UObject* InObj);
	static class APawn* GetSelfCurrentInstigator(class UObject* InObj);
	static bool HasOwnedBuff_Target(class UObject* SelfObj, int32 BuffID, class AActor* Target);
	static bool HasOwnedTag_Target(class UObject* SelfObj, const struct FGameplayTag& InTag, class AActor* Target);
	static bool IsActorValidAbilityTarget_Filter(class UObject* SelfObj, class AActor* Target, const struct FMarvelTraceRule& TraceRule);
	static bool IsHitResultValidAbilityTarget_Filter(class UObject* SelfObj, const struct FHitResult& HitResult, const struct FMarvelTraceRule& TraceRule);
	static void SetAttributeValue(const class AActor* Actor, const struct FGameplayAttribute& Attribute, float NewValue);
	static void TeleportTargetWithDir(class UObject* SelfObj, class AActor* Target, ECommonPlayDir Direction, float Distance);
	static void TeleportTargetWithLocation(class UObject* SelfObj, class AActor* Target, const struct FVector& Location);
	static void TriggerSignalEvent(class UObject* SelfObj, class FName SignalName, ESignalLevel Level);
	static void TriggerSignalEventToTarget(class UObject* SelfObj, class FName SignalName, class UObject* Target);
	static bool TryActivateAbilityByID(class AActor* Target, int32 AbilityID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GraphAbilityFuncNodes">();
	}
	static class UGraphAbilityFuncNodes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGraphAbilityFuncNodes>();
	}
};
static_assert(alignof(UGraphAbilityFuncNodes) == 0x000008, "Wrong alignment on UGraphAbilityFuncNodes");
static_assert(sizeof(UGraphAbilityFuncNodes) == 0x000030, "Wrong size on UGraphAbilityFuncNodes");

// Class GraphAbility.GraphAbilityFuncNodes_Ability
// 0x0000 (0x0030 - 0x0030)
class UGraphAbilityFuncNodes_Ability final : public UBlueprintFunctionLibrary
{
public:
	static void AE_CancelAbility(class UGameplayAbility* SelfAbility);
	static void ApplyBuffToSelf(class UGameplayAbility* SelfAbility, int32 BuffID);
	static void ApplyDamageToTarget(class UGameplayAbility* SelfAbility, class AActor* Target, float Damage);
	static void CustomBeginSelectTarget(class UGameplayAbility* SelfAbility);
	static void CustomEndSelectTarget(class UGameplayAbility* SelfAbility);
	static void DefaultProjectileStart(class UObject* SelfObj, struct FVector* OutLocation, struct FRotator* OutRotation, int32 ProjectileID, const struct FVector& OffsetLocation, const struct FRotator& OffsetRotation, EMarvelPawnBodyType LocationType);
	static void ExecuteAbilityCue(class UGameplayAbility* SelfAbility, const struct FGameplayTag& CueTag);
	static class AActor* GetSelectTarget(class UGameplayAbility* SelfAbility, struct FPortalSegments* OutPortalSegment, bool bGetPortalSegment);
	static bool HasOwnedBuff(class UGameplayAbility* SelfAbility, int32 BuffID);
	static bool HasOwnedTag(class UGameplayAbility* SelfAbility, const struct FGameplayTag& InTag);
	static bool IsAbilityActivated(class UObject* SelfObj);
	static void JumpTimelineSection(class UGameplayAbility* SelfAbility, class FName SectionName, class UAnimTimeline* Timeline);
	static void RecycleAbilityTargetByID(class UObject* SelfObj, int32 TargetId, ETargetActorTypes TargetType);
	static void RecycleAbilityTargetByObject(class UObject* SelfObj, class UObject* Target);
	static void RemoveAbilityCue(class UGameplayAbility* SelfAbility, const struct FGameplayTag& CueTag);
	static void RemoveBuffFromSelf(class UGameplayAbility* SelfAbility, int32 BuffID);
	static void RemoveBuffFromTarget(class UGameplayAbility* SelfAbility, int32 BuffID, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GraphAbilityFuncNodes_Ability">();
	}
	static class UGraphAbilityFuncNodes_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGraphAbilityFuncNodes_Ability>();
	}
};
static_assert(alignof(UGraphAbilityFuncNodes_Ability) == 0x000008, "Wrong alignment on UGraphAbilityFuncNodes_Ability");
static_assert(sizeof(UGraphAbilityFuncNodes_Ability) == 0x000030, "Wrong size on UGraphAbilityFuncNodes_Ability");

// Class GraphAbility.GraphAbilityFuncNodes_AbilityTarget
// 0x0000 (0x0030 - 0x0030)
class UGraphAbilityFuncNodes_AbilityTarget final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyDamageToTarget(class UObject* SelfObject, class AActor* Target, float Damage);
	static void K2_EndAgentTask(class AActor* SelfActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GraphAbilityFuncNodes_AbilityTarget">();
	}
	static class UGraphAbilityFuncNodes_AbilityTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGraphAbilityFuncNodes_AbilityTarget>();
	}
};
static_assert(alignof(UGraphAbilityFuncNodes_AbilityTarget) == 0x000008, "Wrong alignment on UGraphAbilityFuncNodes_AbilityTarget");
static_assert(sizeof(UGraphAbilityFuncNodes_AbilityTarget) == 0x000030, "Wrong size on UGraphAbilityFuncNodes_AbilityTarget");

// Class GraphAbility.GraphAbilityTaskMgr
// 0x0198 (0x01D0 - 0x0038)
class UGraphAbilityTaskMgr final : public UWorldSubsystem
{
public:
	class UAbilityTargetMgmtSys*                  AbilityTargetMgmt;                                 // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x190];                                     // 0x0040(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckCanActivateAbilityForGASpec(class UGameplayAbility* InAbility);
	void OnActorEndPlay(class AActor* Target, EEndPlayReason EndPlayReason);
	void OnCharacterDeath(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnProjectileUnregister(class AMarvelAbilityTargetActor_Projectile* InProjectile);
	void OnScopeActorUnregister(class AMarvelAbilityTargetActor_Scope* InScope);
	void OnSummonedUnregister(class UMarvelSummonedComponent* InSummonedComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GraphAbilityTaskMgr">();
	}
	static class UGraphAbilityTaskMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGraphAbilityTaskMgr>();
	}
};
static_assert(alignof(UGraphAbilityTaskMgr) == 0x000008, "Wrong alignment on UGraphAbilityTaskMgr");
static_assert(sizeof(UGraphAbilityTaskMgr) == 0x0001D0, "Wrong size on UGraphAbilityTaskMgr");
static_assert(offsetof(UGraphAbilityTaskMgr, AbilityTargetMgmt) == 0x000038, "Member 'UGraphAbilityTaskMgr::AbilityTargetMgmt' has a wrong offset!");

}

