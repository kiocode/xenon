#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1034

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "DeclarativeUnreal_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Hero_1034_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Hero_1034.Config_103401
// 0x00D0 (0x11D0 - 0x1100)
class UConfig_103401 final : public UConfig_AeroBase
{
public:
	struct FGameplayTagContainer                  AscendingCancleAbilityTags;                        // 0x10F8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<int32>                                 AeroStateControlBydAbilityIds;                     // 0x1160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AscendConfigID;                                    // 0x1170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DescendConfigID;                                   // 0x1174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   AchieveRecordFlyDistanceAbilityIDs;                // 0x1178(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C8[0x8];                                     // 0x11C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103401">();
	}
	static class UConfig_103401* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103401>();
	}
};
static_assert(alignof(UConfig_103401) == 0x000010, "Wrong alignment on UConfig_103401");
static_assert(sizeof(UConfig_103401) == 0x0011D0, "Wrong size on UConfig_103401");
static_assert(offsetof(UConfig_103401, AscendingCancleAbilityTags) == 0x0010F8, "Member 'UConfig_103401::AscendingCancleAbilityTags' has a wrong offset!");
static_assert(offsetof(UConfig_103401, AeroStateControlBydAbilityIds) == 0x001160, "Member 'UConfig_103401::AeroStateControlBydAbilityIds' has a wrong offset!");
static_assert(offsetof(UConfig_103401, AscendConfigID) == 0x001170, "Member 'UConfig_103401::AscendConfigID' has a wrong offset!");
static_assert(offsetof(UConfig_103401, DescendConfigID) == 0x001174, "Member 'UConfig_103401::DescendConfigID' has a wrong offset!");
static_assert(offsetof(UConfig_103401, AchieveRecordFlyDistanceAbilityIDs) == 0x001178, "Member 'UConfig_103401::AchieveRecordFlyDistanceAbilityIDs' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Loop_10340101
// 0x0210 (0x1060 - 0x0E50)
class ACue_Ability_Loop_10340101 : public AMarvelCueNotify_Ability
{
public:
	class UNiagaraComponent*                      LoopNS_FootFxL;                                    // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FootFxR;                                    // 0x0E58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandFxL;                                    // 0x0E60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandFxR;                                    // 0x0E68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FootFxL;                          // 0x0E70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FootFxR;                          // 0x0E78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_HandFxL;                          // 0x0E80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_HandFxR;                          // 0x0E88(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsBlockHandFX;                                   // 0x0E90(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsBlockFloatingGunFX;                            // 0x0EF8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsNanoWeapons;                                   // 0x0F60(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsLaserAbilities;                                // 0x0FC8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Stationary_SpeedThreshold;                         // 0x1030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlyLateralInLaserState_StartAudioID;               // 0x1034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlyLateralInLaserState_LoopAudioID;                // 0x1038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlyLateralInLaserState_EndAudioID;                 // 0x103C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1040[0x20];                                    // 0x1040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerTagUpdated(const struct FGameplayTag& TagUpdated, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10340101">();
	}
	static class ACue_Ability_Loop_10340101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10340101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10340101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10340101");
static_assert(sizeof(ACue_Ability_Loop_10340101) == 0x001060, "Wrong size on ACue_Ability_Loop_10340101");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_FootFxL) == 0x000E50, "Member 'ACue_Ability_Loop_10340101::LoopNS_FootFxL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_FootFxR) == 0x000E58, "Member 'ACue_Ability_Loop_10340101::LoopNS_FootFxR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_HandFxL) == 0x000E60, "Member 'ACue_Ability_Loop_10340101::LoopNS_HandFxL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_HandFxR) == 0x000E68, "Member 'ACue_Ability_Loop_10340101::LoopNS_HandFxR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_Ascending_FootFxL) == 0x000E70, "Member 'ACue_Ability_Loop_10340101::LoopNS_Ascending_FootFxL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_Ascending_FootFxR) == 0x000E78, "Member 'ACue_Ability_Loop_10340101::LoopNS_Ascending_FootFxR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_Ascending_HandFxL) == 0x000E80, "Member 'ACue_Ability_Loop_10340101::LoopNS_Ascending_HandFxL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, LoopNS_Ascending_HandFxR) == 0x000E88, "Member 'ACue_Ability_Loop_10340101::LoopNS_Ascending_HandFxR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, TagsBlockHandFX) == 0x000E90, "Member 'ACue_Ability_Loop_10340101::TagsBlockHandFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, TagsBlockFloatingGunFX) == 0x000EF8, "Member 'ACue_Ability_Loop_10340101::TagsBlockFloatingGunFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, TagsNanoWeapons) == 0x000F60, "Member 'ACue_Ability_Loop_10340101::TagsNanoWeapons' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, TagsLaserAbilities) == 0x000FC8, "Member 'ACue_Ability_Loop_10340101::TagsLaserAbilities' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, Stationary_SpeedThreshold) == 0x001030, "Member 'ACue_Ability_Loop_10340101::Stationary_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, FlyLateralInLaserState_StartAudioID) == 0x001034, "Member 'ACue_Ability_Loop_10340101::FlyLateralInLaserState_StartAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, FlyLateralInLaserState_LoopAudioID) == 0x001038, "Member 'ACue_Ability_Loop_10340101::FlyLateralInLaserState_LoopAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10340101, FlyLateralInLaserState_EndAudioID) == 0x00103C, "Member 'ACue_Ability_Loop_10340101::FlyLateralInLaserState_EndAudioID' has a wrong offset!");

// Class Hero_1034.Ability_103401_V2
// 0x0010 (0x5C10 - 0x5C00)
class UAbility_103401_V2 : public UMarvelAeroBaseAbility
{
public:
	float                                         AchieveFlyDistance;                                // 0x5C00(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C04[0x4];                                     // 0x5C04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AIronManCharacter*                      OwnerIronManCharacter;                             // 0x5C08(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCharacterMovementFlyDistance(float InDistance);
	void OnHoveringAbilityActivate(class UGameplayAbility* ActivatedAbility);
	void OnHoveringAbilityBreak(class UGameplayAbility* Ability);
	void OnHoveringAbilityEnd(class UGameplayAbility* Ability);
	void OnOwnerCharBorn103401(class AActor* TargetActor, const struct FCharacterRebornParam& Param);
	void OnOwnerCharDeath103401(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void UpdateAeroStateByOtherAbility(class UGameplayAbility* Ability, const bool bAbilityActivate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103401_V2">();
	}
	static class UAbility_103401_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103401_V2>();
	}
};
static_assert(alignof(UAbility_103401_V2) == 0x000010, "Wrong alignment on UAbility_103401_V2");
static_assert(sizeof(UAbility_103401_V2) == 0x005C10, "Wrong size on UAbility_103401_V2");
static_assert(offsetof(UAbility_103401_V2, AchieveFlyDistance) == 0x005C00, "Member 'UAbility_103401_V2::AchieveFlyDistance' has a wrong offset!");
static_assert(offsetof(UAbility_103401_V2, OwnerIronManCharacter) == 0x005C08, "Member 'UAbility_103401_V2::OwnerIronManCharacter' has a wrong offset!");

// Class Hero_1034.Cue_Projectile_Loop_10341101
// 0x0028 (0x0DD8 - 0x0DB0)
class ACue_Projectile_Loop_10341101 : public AMarvelCueNotify_Projectile
{
public:
	class UNiagaraComponent*                      LoopNS;                                            // 0x0DB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         StartMuzzleFX;                                     // 0x0DB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StartMuzzleScale3D;                                // 0x0DC0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10341101">();
	}
	static class ACue_Projectile_Loop_10341101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10341101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10341101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10341101");
static_assert(sizeof(ACue_Projectile_Loop_10341101) == 0x000DD8, "Wrong size on ACue_Projectile_Loop_10341101");
static_assert(offsetof(ACue_Projectile_Loop_10341101, LoopNS) == 0x000DB0, "Member 'ACue_Projectile_Loop_10341101::LoopNS' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10341101, StartMuzzleFX) == 0x000DB8, "Member 'ACue_Projectile_Loop_10341101::StartMuzzleFX' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10341101, StartMuzzleScale3D) == 0x000DC0, "Member 'ACue_Projectile_Loop_10341101::StartMuzzleScale3D' has a wrong offset!");

// Class Hero_1034.Cue_Projectile_Loop_10341901
// 0x0010 (0x0DE8 - 0x0DD8)
class ACue_Projectile_Loop_10341901 : public ACue_Projectile_Loop_10341101
{
public:
	class UNiagaraComponent*                      LoopNS_Enhanced;                                   // 0x0DD8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EnhancedAbilityID;                                 // 0x0DE0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DE4[0x4];                                      // 0x0DE4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10341901">();
	}
	static class ACue_Projectile_Loop_10341901* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10341901>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10341901) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10341901");
static_assert(sizeof(ACue_Projectile_Loop_10341901) == 0x000DE8, "Wrong size on ACue_Projectile_Loop_10341901");
static_assert(offsetof(ACue_Projectile_Loop_10341901, LoopNS_Enhanced) == 0x000DD8, "Member 'ACue_Projectile_Loop_10341901::LoopNS_Enhanced' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10341901, EnhancedAbilityID) == 0x000DE0, "Member 'ACue_Projectile_Loop_10341901::EnhancedAbilityID' has a wrong offset!");

// Class Hero_1034.Config_103421
// 0x0100 (0x0198 - 0x0098)
class UConfig_103421 : public UMarvelAbilityConfig
{
public:
	int32                                         ScopeId;                                           // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAmmoClipType                                 AmmoType;                                          // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CustomCancelByTags;                                // 0x00A0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CustomBlockByTags;                                 // 0x0108(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FShootModeSensitivityParam             AbilitySensitivityParam;                           // 0x0170(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103421">();
	}
	static class UConfig_103421* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103421>();
	}
};
static_assert(alignof(UConfig_103421) == 0x000008, "Wrong alignment on UConfig_103421");
static_assert(sizeof(UConfig_103421) == 0x000198, "Wrong size on UConfig_103421");
static_assert(offsetof(UConfig_103421, ScopeId) == 0x000098, "Member 'UConfig_103421::ScopeId' has a wrong offset!");
static_assert(offsetof(UConfig_103421, AmmoType) == 0x00009C, "Member 'UConfig_103421::AmmoType' has a wrong offset!");
static_assert(offsetof(UConfig_103421, CustomCancelByTags) == 0x0000A0, "Member 'UConfig_103421::CustomCancelByTags' has a wrong offset!");
static_assert(offsetof(UConfig_103421, CustomBlockByTags) == 0x000108, "Member 'UConfig_103421::CustomBlockByTags' has a wrong offset!");
static_assert(offsetof(UConfig_103421, AbilitySensitivityParam) == 0x000170, "Member 'UConfig_103421::AbilitySensitivityParam' has a wrong offset!");

// Class Hero_1034.Ability_103421
// 0x00F0 (0x2678 - 0x2588)
class UAbility_103421 : public UAbility_108
{
public:
	class UAbilityTask_WaitInputRelease*          InputRightTask;                                    // 0x2588(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_WaitBindInput*       InputSpaceTask;                                    // 0x2590(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLaserFinished;                                  // 0x2598(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2599[0x7];                                     // 0x2599(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelAbilityTargetActor_Scope*        OwnedScope;                                        // 0x25A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A8[0xD0];                                    // 0x25A8(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CommitIronManAmmo();
	void OnPressSpace(float TimeWaited);
	void OnReleaseRight(float TimeWaited);
	void TryCancelOnGameplayEffectAppliedToSelf(class UAbilitySystemComponent* Source, class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& EffectHandle);
	void UpdateAbilitySensitivity();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103421">();
	}
	static class UAbility_103421* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103421>();
	}
};
static_assert(alignof(UAbility_103421) == 0x000008, "Wrong alignment on UAbility_103421");
static_assert(sizeof(UAbility_103421) == 0x002678, "Wrong size on UAbility_103421");
static_assert(offsetof(UAbility_103421, InputRightTask) == 0x002588, "Member 'UAbility_103421::InputRightTask' has a wrong offset!");
static_assert(offsetof(UAbility_103421, InputSpaceTask) == 0x002590, "Member 'UAbility_103421::InputSpaceTask' has a wrong offset!");
static_assert(offsetof(UAbility_103421, bIsLaserFinished) == 0x002598, "Member 'UAbility_103421::bIsLaserFinished' has a wrong offset!");
static_assert(offsetof(UAbility_103421, OwnedScope) == 0x0025A0, "Member 'UAbility_103421::OwnedScope' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Loop_10342101
// 0x1168 (0x2150 - 0x0FE8)
#pragma pack(push, 0x1)
class alignas(0x10) ACue_Ability_Loop_10342101 : public AMarvelCueNotify_Laser
{
public:
	class UNiagaraComponent*                      LoopNS_Main;                                       // 0x0FE8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOneShotAudioActor*                     LaserLoopAudioActor;                               // 0x0FF0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScopeId;                                           // 0x0FF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityID;                                         // 0x0FFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamNameLength;                                   // 0x1000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamNameDir;                                      // 0x100C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalTranslucencySortPriority;                     // 0x1018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101C[0x4];                                     // 0x101C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AttachPos;                                         // 0x1020(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimLocation;                                       // 0x1038(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         AirHitFx;                                          // 0x1050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         MultiCharacterHitFx;                               // 0x1058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ScratchCueTag;                                     // 0x1060(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScratchFXOffset;                                   // 0x106C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     InstanceAirHitFXComponent;                         // 0x1070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1078[0x8];                                     // 0x1078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             ScopeTraceContext;                                 // 0x1080(0x0F90)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class AMarvelBaseCharacter*, class UFXSystemComponent*> CharacterHitsActor2FXMap;                          // 0x2010(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x2060(0x0010)(Transient, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_GenericMain;                                // 0x2070(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2078[0x8];                                     // 0x2078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRemoteRotationSInterp                 CameraRotationInterp;                              // 0x2080(0x00A0)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2120[0x8];                                     // 0x2120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Loop1PAudioID;                                     // 0x2128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Loop2PAudioID;                                     // 0x212C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmmoRTPCThreshold;                                 // 0x2130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2134[0x4];                                     // 0x2134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CurveAmmoRTPC;                                     // 0x2138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x2140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShorCut;                                       // 0x2144(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2145[0x3];                                     // 0x2145(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClientPlayerViewSideChange(EClientPlayerViewSide InViewSide);
	void UpdateLaser(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10342101">();
	}
	static class ACue_Ability_Loop_10342101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10342101>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACue_Ability_Loop_10342101) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10342101");
static_assert(sizeof(ACue_Ability_Loop_10342101) == 0x002150, "Wrong size on ACue_Ability_Loop_10342101");
static_assert(offsetof(ACue_Ability_Loop_10342101, LoopNS_Main) == 0x000FE8, "Member 'ACue_Ability_Loop_10342101::LoopNS_Main' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, LaserLoopAudioActor) == 0x000FF0, "Member 'ACue_Ability_Loop_10342101::LaserLoopAudioActor' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ScopeId) == 0x000FF8, "Member 'ACue_Ability_Loop_10342101::ScopeId' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, AbilityID) == 0x000FFC, "Member 'ACue_Ability_Loop_10342101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ParamNameLength) == 0x001000, "Member 'ACue_Ability_Loop_10342101::ParamNameLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ParamNameDir) == 0x00100C, "Member 'ACue_Ability_Loop_10342101::ParamNameDir' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, DecalTranslucencySortPriority) == 0x001018, "Member 'ACue_Ability_Loop_10342101::DecalTranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, AttachPos) == 0x001020, "Member 'ACue_Ability_Loop_10342101::AttachPos' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, AimLocation) == 0x001038, "Member 'ACue_Ability_Loop_10342101::AimLocation' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, AirHitFx) == 0x001050, "Member 'ACue_Ability_Loop_10342101::AirHitFx' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, MultiCharacterHitFx) == 0x001058, "Member 'ACue_Ability_Loop_10342101::MultiCharacterHitFx' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ScratchCueTag) == 0x001060, "Member 'ACue_Ability_Loop_10342101::ScratchCueTag' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ScratchFXOffset) == 0x00106C, "Member 'ACue_Ability_Loop_10342101::ScratchFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, InstanceAirHitFXComponent) == 0x001070, "Member 'ACue_Ability_Loop_10342101::InstanceAirHitFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, ScopeTraceContext) == 0x001080, "Member 'ACue_Ability_Loop_10342101::ScopeTraceContext' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, CharacterHitsActor2FXMap) == 0x002010, "Member 'ACue_Ability_Loop_10342101::CharacterHitsActor2FXMap' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, DeclarePlayerViewSideHolder) == 0x002060, "Member 'ACue_Ability_Loop_10342101::DeclarePlayerViewSideHolder' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, LoopNS_GenericMain) == 0x002070, "Member 'ACue_Ability_Loop_10342101::LoopNS_GenericMain' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, CameraRotationInterp) == 0x002080, "Member 'ACue_Ability_Loop_10342101::CameraRotationInterp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, Loop1PAudioID) == 0x002128, "Member 'ACue_Ability_Loop_10342101::Loop1PAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, Loop2PAudioID) == 0x00212C, "Member 'ACue_Ability_Loop_10342101::Loop2PAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, AmmoRTPCThreshold) == 0x002130, "Member 'ACue_Ability_Loop_10342101::AmmoRTPCThreshold' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, CurveAmmoRTPC) == 0x002138, "Member 'ACue_Ability_Loop_10342101::CurveAmmoRTPC' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, DrawTime) == 0x002140, "Member 'ACue_Ability_Loop_10342101::DrawTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342101, bUseShorCut) == 0x002144, "Member 'ACue_Ability_Loop_10342101::bUseShorCut' has a wrong offset!");

// Class Hero_1034.Cue_Scope_Start_10342103
// 0x0010 (0x0378 - 0x0368)
class UCue_Scope_Start_10342103 : public UMarvelCueNotify_Base
{
public:
	class FName                                   ScaleName;                                         // 0x0368(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleValue;                                        // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Start_10342103">();
	}
	static class UCue_Scope_Start_10342103* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Scope_Start_10342103>();
	}
};
static_assert(alignof(UCue_Scope_Start_10342103) == 0x000008, "Wrong alignment on UCue_Scope_Start_10342103");
static_assert(sizeof(UCue_Scope_Start_10342103) == 0x000378, "Wrong size on UCue_Scope_Start_10342103");
static_assert(offsetof(UCue_Scope_Start_10342103, ScaleName) == 0x000368, "Member 'UCue_Scope_Start_10342103::ScaleName' has a wrong offset!");
static_assert(offsetof(UCue_Scope_Start_10342103, ScaleValue) == 0x000374, "Member 'UCue_Scope_Start_10342103::ScaleValue' has a wrong offset!");

// Class Hero_1034.Config_103429
// 0x0000 (0x0198 - 0x0198)
class UConfig_103429 final : public UConfig_103421
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103429">();
	}
	static class UConfig_103429* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103429>();
	}
};
static_assert(alignof(UConfig_103429) == 0x000008, "Wrong alignment on UConfig_103429");
static_assert(sizeof(UConfig_103429) == 0x000198, "Wrong size on UConfig_103429");

// Class Hero_1034.Ability_103429
// 0x0000 (0x2678 - 0x2678)
class UAbility_103429 : public UAbility_103421
{
public:
	void OnNanoStateTimeout();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103429">();
	}
	static class UAbility_103429* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103429>();
	}
};
static_assert(alignof(UAbility_103429) == 0x000008, "Wrong alignment on UAbility_103429");
static_assert(sizeof(UAbility_103429) == 0x002678, "Wrong size on UAbility_103429");

// Class Hero_1034.Cue_Ability_Loop_10342901
// 0x0070 (0x21C0 - 0x2150)
class ACue_Ability_Loop_10342901 : public ACue_Ability_Loop_10342101
{
public:
	class USkeletalMeshComponent*                 FloatingMeshComp;                                  // 0x2148(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Junction;                                   // 0x2150(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_SmallLasers;                                // 0x2158(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_EnhancedMain;                               // 0x2160(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_EnhancedJunction;                           // 0x2168(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamNameEndPos;                                   // 0x2170(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamNameTargetSkelMesh;                           // 0x217C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnhancedAbilityID;                                 // 0x2188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JunctionDistance;                                  // 0x218C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JunctionLocation;                                  // 0x2190(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPortableMaterialSlotName>      WeaponMeshDissolveSlots;                           // 0x21A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasShowWeaponMesh;                                // 0x21B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B9[0x7];                                     // 0x21B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateNanoLaser(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10342901">();
	}
	static class ACue_Ability_Loop_10342901* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10342901>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10342901) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10342901");
static_assert(sizeof(ACue_Ability_Loop_10342901) == 0x0021C0, "Wrong size on ACue_Ability_Loop_10342901");
static_assert(offsetof(ACue_Ability_Loop_10342901, FloatingMeshComp) == 0x002148, "Member 'ACue_Ability_Loop_10342901::FloatingMeshComp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, LoopNS_Junction) == 0x002150, "Member 'ACue_Ability_Loop_10342901::LoopNS_Junction' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, LoopNS_SmallLasers) == 0x002158, "Member 'ACue_Ability_Loop_10342901::LoopNS_SmallLasers' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, LoopNS_EnhancedMain) == 0x002160, "Member 'ACue_Ability_Loop_10342901::LoopNS_EnhancedMain' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, LoopNS_EnhancedJunction) == 0x002168, "Member 'ACue_Ability_Loop_10342901::LoopNS_EnhancedJunction' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, ParamNameEndPos) == 0x002170, "Member 'ACue_Ability_Loop_10342901::ParamNameEndPos' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, ParamNameTargetSkelMesh) == 0x00217C, "Member 'ACue_Ability_Loop_10342901::ParamNameTargetSkelMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, EnhancedAbilityID) == 0x002188, "Member 'ACue_Ability_Loop_10342901::EnhancedAbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, JunctionDistance) == 0x00218C, "Member 'ACue_Ability_Loop_10342901::JunctionDistance' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, JunctionLocation) == 0x002190, "Member 'ACue_Ability_Loop_10342901::JunctionLocation' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, WeaponMeshDissolveSlots) == 0x0021A8, "Member 'ACue_Ability_Loop_10342901::WeaponMeshDissolveSlots' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10342901, bHasShowWeaponMesh) == 0x0021B8, "Member 'ACue_Ability_Loop_10342901::bHasShowWeaponMesh' has a wrong offset!");

// Class Hero_1034.Config_103431
// 0x0068 (0x0100 - 0x0098)
class UConfig_103431 : public UMarvelAbilityConfig
{
public:
	struct FVector2D                              CapsuleSize;                                       // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADControlFactor;                                   // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SocketOffsetTargetY;                               // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMin;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMax;                                      // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyArrivedMaxHeightInterpSpeed;                    // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxEnterength;                                     // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxExitLength;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlySpeedBuffId;                                    // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EndFlyCueTag;                                      // 0x00C8(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateChangedTaskParam                 ActiveUserSetting;                                 // 0x00D4(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103431">();
	}
	static class UConfig_103431* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103431>();
	}
};
static_assert(alignof(UConfig_103431) == 0x000008, "Wrong alignment on UConfig_103431");
static_assert(sizeof(UConfig_103431) == 0x000100, "Wrong size on UConfig_103431");
static_assert(offsetof(UConfig_103431, CapsuleSize) == 0x000098, "Member 'UConfig_103431::CapsuleSize' has a wrong offset!");
static_assert(offsetof(UConfig_103431, ADControlFactor) == 0x0000A8, "Member 'UConfig_103431::ADControlFactor' has a wrong offset!");
static_assert(offsetof(UConfig_103431, SocketOffsetTargetY) == 0x0000AC, "Member 'UConfig_103431::SocketOffsetTargetY' has a wrong offset!");
static_assert(offsetof(UConfig_103431, ViewPitchMin) == 0x0000B0, "Member 'UConfig_103431::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(UConfig_103431, ViewPitchMax) == 0x0000B4, "Member 'UConfig_103431::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(UConfig_103431, FlyArrivedMaxHeightInterpSpeed) == 0x0000B8, "Member 'UConfig_103431::FlyArrivedMaxHeightInterpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_103431, BoxEnterength) == 0x0000BC, "Member 'UConfig_103431::BoxEnterength' has a wrong offset!");
static_assert(offsetof(UConfig_103431, BoxExitLength) == 0x0000C0, "Member 'UConfig_103431::BoxExitLength' has a wrong offset!");
static_assert(offsetof(UConfig_103431, FlySpeedBuffId) == 0x0000C4, "Member 'UConfig_103431::FlySpeedBuffId' has a wrong offset!");
static_assert(offsetof(UConfig_103431, EndFlyCueTag) == 0x0000C8, "Member 'UConfig_103431::EndFlyCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103431, ActiveUserSetting) == 0x0000D4, "Member 'UConfig_103431::ActiveUserSetting' has a wrong offset!");

// Class Hero_1034.Ability_103431
// 0x0240 (0x27C8 - 0x2588)
class UAbility_103431 : public UAbility_108
{
public:
	class UCapsuleComponent*                      AvatarCapsule;                                     // 0x2588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitCancel*                CancelInputTask;                                   // 0x2590(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputLeftTask;                                     // 0x2598(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputRightTask;                                    // 0x25A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitInputStateChanged* InputStateChangedTask;                             // 0x25A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103431*                         Config103431;                                      // 0x25B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      PlayerController;                                  // 0x25B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C0[0x208];                                   // 0x25C0(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelInput(float Time);
	bool GetLastTestResult();
	void OnMoveRightReceive(float RightInput);
	void OnPressA(float TimeWaited);
	void OnPressD(float TimeWaited);
	void OnReleaseA(float TimeWaited);
	void OnReleaseD(float TimeWaited);
	void RefreshADControllTag();
	void ServerSetADState(int32 PredictionSerial, int8 ADState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103431">();
	}
	static class UAbility_103431* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103431>();
	}
};
static_assert(alignof(UAbility_103431) == 0x000008, "Wrong alignment on UAbility_103431");
static_assert(sizeof(UAbility_103431) == 0x0027C8, "Wrong size on UAbility_103431");
static_assert(offsetof(UAbility_103431, AvatarCapsule) == 0x002588, "Member 'UAbility_103431::AvatarCapsule' has a wrong offset!");
static_assert(offsetof(UAbility_103431, CancelInputTask) == 0x002590, "Member 'UAbility_103431::CancelInputTask' has a wrong offset!");
static_assert(offsetof(UAbility_103431, InputLeftTask) == 0x002598, "Member 'UAbility_103431::InputLeftTask' has a wrong offset!");
static_assert(offsetof(UAbility_103431, InputRightTask) == 0x0025A0, "Member 'UAbility_103431::InputRightTask' has a wrong offset!");
static_assert(offsetof(UAbility_103431, InputStateChangedTask) == 0x0025A8, "Member 'UAbility_103431::InputStateChangedTask' has a wrong offset!");
static_assert(offsetof(UAbility_103431, Config103431) == 0x0025B0, "Member 'UAbility_103431::Config103431' has a wrong offset!");
static_assert(offsetof(UAbility_103431, PlayerController) == 0x0025B8, "Member 'UAbility_103431::PlayerController' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Loop_10343101
// 0x00B8 (0x0F08 - 0x0E50)
class ACue_Ability_Loop_10343101 : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E50[0x18];                                     // 0x0E50(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      LoopBody;                                          // 0x0E68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandL;                                      // 0x0E70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandR;                                      // 0x0E78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FootL;                                      // 0x0E80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FootR;                                      // 0x0E88(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_GunL;                                       // 0x0E90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_GunR;                                       // 0x0E98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTagUpdateDispatcher;                             // 0x0EA0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FloatingGunSizeScaleCurve;                         // 0x0EB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FlameSizeScaleCurve;                               // 0x0EB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SoundCurveHeight;                                  // 0x0EC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SoundThresholdUpDown;                              // 0x0EC8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundThresholdLeftRight;                           // 0x0ED8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EDC[0x4];                                      // 0x0EDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SoundCurveRight;                                   // 0x0EE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SoundCurveRightWhenUpDown;                         // 0x0EE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SoundCurveUp;                                      // 0x0EF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SoundCurveUpWhenLeftRight;                         // 0x0EF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkComponent*                           AudioComp;                                         // 0x0F00(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnOwnedTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10343101">();
	}
	static class ACue_Ability_Loop_10343101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10343101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10343101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10343101");
static_assert(sizeof(ACue_Ability_Loop_10343101) == 0x000F08, "Wrong size on ACue_Ability_Loop_10343101");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopBody) == 0x000E68, "Member 'ACue_Ability_Loop_10343101::LoopBody' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_HandL) == 0x000E70, "Member 'ACue_Ability_Loop_10343101::LoopNS_HandL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_HandR) == 0x000E78, "Member 'ACue_Ability_Loop_10343101::LoopNS_HandR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_FootL) == 0x000E80, "Member 'ACue_Ability_Loop_10343101::LoopNS_FootL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_FootR) == 0x000E88, "Member 'ACue_Ability_Loop_10343101::LoopNS_FootR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_GunL) == 0x000E90, "Member 'ACue_Ability_Loop_10343101::LoopNS_GunL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, LoopNS_GunR) == 0x000E98, "Member 'ACue_Ability_Loop_10343101::LoopNS_GunR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, OnTagUpdateDispatcher) == 0x000EA0, "Member 'ACue_Ability_Loop_10343101::OnTagUpdateDispatcher' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, FloatingGunSizeScaleCurve) == 0x000EB0, "Member 'ACue_Ability_Loop_10343101::FloatingGunSizeScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, FlameSizeScaleCurve) == 0x000EB8, "Member 'ACue_Ability_Loop_10343101::FlameSizeScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundCurveHeight) == 0x000EC0, "Member 'ACue_Ability_Loop_10343101::SoundCurveHeight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundThresholdUpDown) == 0x000EC8, "Member 'ACue_Ability_Loop_10343101::SoundThresholdUpDown' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundThresholdLeftRight) == 0x000ED8, "Member 'ACue_Ability_Loop_10343101::SoundThresholdLeftRight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundCurveRight) == 0x000EE0, "Member 'ACue_Ability_Loop_10343101::SoundCurveRight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundCurveRightWhenUpDown) == 0x000EE8, "Member 'ACue_Ability_Loop_10343101::SoundCurveRightWhenUpDown' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundCurveUp) == 0x000EF0, "Member 'ACue_Ability_Loop_10343101::SoundCurveUp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, SoundCurveUpWhenLeftRight) == 0x000EF8, "Member 'ACue_Ability_Loop_10343101::SoundCurveUpWhenLeftRight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10343101, AudioComp) == 0x000F00, "Member 'ACue_Ability_Loop_10343101::AudioComp' has a wrong offset!");

// Class Hero_1034.Config_103439
// 0x0000 (0x0100 - 0x0100)
class UConfig_103439 final : public UConfig_103431
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103439">();
	}
	static class UConfig_103439* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103439>();
	}
};
static_assert(alignof(UConfig_103439) == 0x000008, "Wrong alignment on UConfig_103439");
static_assert(sizeof(UConfig_103439) == 0x000100, "Wrong size on UConfig_103439");

// Class Hero_1034.Ability_103439
// 0x0000 (0x27C8 - 0x27C8)
class UAbility_103439 : public UAbility_103431
{
public:
	void OnNanoStateTimeout();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103439">();
	}
	static class UAbility_103439* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103439>();
	}
};
static_assert(alignof(UAbility_103439) == 0x000008, "Wrong alignment on UAbility_103439");
static_assert(sizeof(UAbility_103439) == 0x0027C8, "Wrong size on UAbility_103439");

// Class Hero_1034.SplineConfigActor_103441
// 0x0010 (0x04A0 - 0x0490)
class ASplineConfigActor_103441 final : public AActor
{
public:
	TArray<class USplineComponent*>               SplineCompArray;                                   // 0x0490(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineConfigActor_103441">();
	}
	static class ASplineConfigActor_103441* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineConfigActor_103441>();
	}
};
static_assert(alignof(ASplineConfigActor_103441) == 0x000008, "Wrong alignment on ASplineConfigActor_103441");
static_assert(sizeof(ASplineConfigActor_103441) == 0x0004A0, "Wrong size on ASplineConfigActor_103441");
static_assert(offsetof(ASplineConfigActor_103441, SplineCompArray) == 0x000490, "Member 'ASplineConfigActor_103441::SplineCompArray' has a wrong offset!");

// Class Hero_1034.Config_103441
// 0x0090 (0x0128 - 0x0098)
class UConfig_103441 final : public UMarvelAbilityConfig
{
public:
	float                                         MaxCurvesTime;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SplineLocationScale;                               // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FIronManSpline>                 SplineDatas;                                       // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SplineConfigActor;                                 // 0x00C8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TestIndex;                                         // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineFixedVelocityX;                              // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGroundDist;                                     // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepDistByEachIndex;                               // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepDistByEvenIndex;                               // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFireCount;                                      // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireInterval;                                      // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FIronManMissileSpec>            MissileSpecs;                                      // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103441">();
	}
	static class UConfig_103441* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103441>();
	}
};
static_assert(alignof(UConfig_103441) == 0x000008, "Wrong alignment on UConfig_103441");
static_assert(sizeof(UConfig_103441) == 0x000128, "Wrong size on UConfig_103441");
static_assert(offsetof(UConfig_103441, MaxCurvesTime) == 0x000098, "Member 'UConfig_103441::MaxCurvesTime' has a wrong offset!");
static_assert(offsetof(UConfig_103441, SplineLocationScale) == 0x0000A0, "Member 'UConfig_103441::SplineLocationScale' has a wrong offset!");
static_assert(offsetof(UConfig_103441, SplineDatas) == 0x0000B8, "Member 'UConfig_103441::SplineDatas' has a wrong offset!");
static_assert(offsetof(UConfig_103441, SplineConfigActor) == 0x0000C8, "Member 'UConfig_103441::SplineConfigActor' has a wrong offset!");
static_assert(offsetof(UConfig_103441, TestIndex) == 0x0000F8, "Member 'UConfig_103441::TestIndex' has a wrong offset!");
static_assert(offsetof(UConfig_103441, SplineFixedVelocityX) == 0x0000FC, "Member 'UConfig_103441::SplineFixedVelocityX' has a wrong offset!");
static_assert(offsetof(UConfig_103441, MaxGroundDist) == 0x000100, "Member 'UConfig_103441::MaxGroundDist' has a wrong offset!");
static_assert(offsetof(UConfig_103441, StepDistByEachIndex) == 0x000104, "Member 'UConfig_103441::StepDistByEachIndex' has a wrong offset!");
static_assert(offsetof(UConfig_103441, StepDistByEvenIndex) == 0x000108, "Member 'UConfig_103441::StepDistByEvenIndex' has a wrong offset!");
static_assert(offsetof(UConfig_103441, MaxFireCount) == 0x00010C, "Member 'UConfig_103441::MaxFireCount' has a wrong offset!");
static_assert(offsetof(UConfig_103441, FireInterval) == 0x000110, "Member 'UConfig_103441::FireInterval' has a wrong offset!");
static_assert(offsetof(UConfig_103441, MissileSpecs) == 0x000118, "Member 'UConfig_103441::MissileSpecs' has a wrong offset!");

// Class Hero_1034.Ability_103441
// 0x0008 (0x2590 - 0x2588)
class UAbility_103441 : public UAbility_108
{
public:
	int32                                         ProjectileIndex;                                   // 0x2588(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258C[0x4];                                     // 0x258C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103441">();
	}
	static class UAbility_103441* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103441>();
	}
};
static_assert(alignof(UAbility_103441) == 0x000008, "Wrong alignment on UAbility_103441");
static_assert(sizeof(UAbility_103441) == 0x002590, "Wrong size on UAbility_103441");
static_assert(offsetof(UAbility_103441, ProjectileIndex) == 0x002588, "Member 'UAbility_103441::ProjectileIndex' has a wrong offset!");

// Class Hero_1034.MarvelProjectileSplineComponent
// 0x0020 (0x2010 - 0x1FF0)
class UMarvelProjectileSplineComponent final : public UMarvelProjectileComponent
{
public:
	class USplineComponent*                       RelativeSplineComponent;                           // 0x1FE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF0[0x20];                                    // 0x1FF0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelProjectileSplineComponent">();
	}
	static class UMarvelProjectileSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelProjectileSplineComponent>();
	}
};
static_assert(alignof(UMarvelProjectileSplineComponent) == 0x000010, "Wrong alignment on UMarvelProjectileSplineComponent");
static_assert(sizeof(UMarvelProjectileSplineComponent) == 0x002010, "Wrong size on UMarvelProjectileSplineComponent");
static_assert(offsetof(UMarvelProjectileSplineComponent, RelativeSplineComponent) == 0x001FE8, "Member 'UMarvelProjectileSplineComponent::RelativeSplineComponent' has a wrong offset!");

// Class Hero_1034.Projectile_10344101
// 0x0030 (0x3080 - 0x3050)
class AProjectile_10344101 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x3050(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileIndex;                                   // 0x3058(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_305C[0x4];                                     // 0x305C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialTargetLocation;                             // 0x3060(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3078[0x8];                                     // 0x3078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ProjectileIndex();
	void SetDataByProjectileIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10344101">();
	}
	static class AProjectile_10344101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10344101>();
	}
};
static_assert(alignof(AProjectile_10344101) == 0x000010, "Wrong alignment on AProjectile_10344101");
static_assert(sizeof(AProjectile_10344101) == 0x003080, "Wrong size on AProjectile_10344101");
static_assert(offsetof(AProjectile_10344101, SplineComponent) == 0x003050, "Member 'AProjectile_10344101::SplineComponent' has a wrong offset!");
static_assert(offsetof(AProjectile_10344101, ProjectileIndex) == 0x003058, "Member 'AProjectile_10344101::ProjectileIndex' has a wrong offset!");
static_assert(offsetof(AProjectile_10344101, InitialTargetLocation) == 0x003060, "Member 'AProjectile_10344101::InitialTargetLocation' has a wrong offset!");

// Class Hero_1034.Config_103449
// 0x0FF8 (0x1090 - 0x0098)
class UConfig_103449 final : public UMarvelAbilityConfig
{
public:
	int32                                         MissileNumber;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnInterval;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFXSocketName;                                  // 0x00A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFXSocketName;                                 // 0x00AC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeMax;                                         // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngelDegreeRandom;                                 // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDistance;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRadius;                                      // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceParam;                                        // 0x00D0(0x0F90)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector2D                              ArcTime;                                           // 0x1060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ArcRadius;                                         // 0x1070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetPosRandomRange;                              // 0x1080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1084[0xC];                                     // 0x1084(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103449">();
	}
	static class UConfig_103449* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103449>();
	}
};
static_assert(alignof(UConfig_103449) == 0x000010, "Wrong alignment on UConfig_103449");
static_assert(sizeof(UConfig_103449) == 0x001090, "Wrong size on UConfig_103449");
static_assert(offsetof(UConfig_103449, MissileNumber) == 0x000098, "Member 'UConfig_103449::MissileNumber' has a wrong offset!");
static_assert(offsetof(UConfig_103449, SpawnInterval) == 0x00009C, "Member 'UConfig_103449::SpawnInterval' has a wrong offset!");
static_assert(offsetof(UConfig_103449, LeftFXSocketName) == 0x0000A0, "Member 'UConfig_103449::LeftFXSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_103449, RightFXSocketName) == 0x0000AC, "Member 'UConfig_103449::RightFXSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_103449, DegreeMax) == 0x0000B8, "Member 'UConfig_103449::DegreeMax' has a wrong offset!");
static_assert(offsetof(UConfig_103449, AngelDegreeRandom) == 0x0000BC, "Member 'UConfig_103449::AngelDegreeRandom' has a wrong offset!");
static_assert(offsetof(UConfig_103449, TargetDistance) == 0x0000C0, "Member 'UConfig_103449::TargetDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103449, TargetRadius) == 0x0000C4, "Member 'UConfig_103449::TargetRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103449, TraceParam) == 0x0000D0, "Member 'UConfig_103449::TraceParam' has a wrong offset!");
static_assert(offsetof(UConfig_103449, ArcTime) == 0x001060, "Member 'UConfig_103449::ArcTime' has a wrong offset!");
static_assert(offsetof(UConfig_103449, ArcRadius) == 0x001070, "Member 'UConfig_103449::ArcRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103449, TargetPosRandomRange) == 0x001080, "Member 'UConfig_103449::TargetPosRandomRange' has a wrong offset!");

// Class Hero_1034.ProjectileMovementComponent_103449
// 0x0040 (0x2030 - 0x1FF0)
class UProjectileMovementComponent_103449 final : public UMarvelProjectileComponent
{
public:
	class AProjectile_10344901*                   OwnerProjectile;                                   // 0x1FE8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF0[0x40];                                    // 0x1FF0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileMovementComponent_103449">();
	}
	static class UProjectileMovementComponent_103449* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileMovementComponent_103449>();
	}
};
static_assert(alignof(UProjectileMovementComponent_103449) == 0x000010, "Wrong alignment on UProjectileMovementComponent_103449");
static_assert(sizeof(UProjectileMovementComponent_103449) == 0x002030, "Wrong size on UProjectileMovementComponent_103449");
static_assert(offsetof(UProjectileMovementComponent_103449, OwnerProjectile) == 0x001FE8, "Member 'UProjectileMovementComponent_103449::OwnerProjectile' has a wrong offset!");

// Class Hero_1034.Projectile_10344901
// 0x00C0 (0x3110 - 0x3050)
class AProjectile_10344901 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	bool                                          bStraight;                                         // 0x3050(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3051[0x7];                                     // 0x3051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Target;                                            // 0x3058(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneNormal;                                       // 0x3070(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArcEnd;                                            // 0x3088(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArcCenter;                                         // 0x30A0(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArcBeginDir;                                       // 0x30B8(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArcEndDir;                                         // 0x30D0(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArcMiddleDir;                                      // 0x30E8(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcRadius;                                         // 0x3100(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcTime;                                           // 0x3104(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3108[0x8];                                     // 0x3108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Straight();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10344901">();
	}
	static class AProjectile_10344901* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10344901>();
	}
};
static_assert(alignof(AProjectile_10344901) == 0x000010, "Wrong alignment on AProjectile_10344901");
static_assert(sizeof(AProjectile_10344901) == 0x003110, "Wrong size on AProjectile_10344901");
static_assert(offsetof(AProjectile_10344901, bStraight) == 0x003050, "Member 'AProjectile_10344901::bStraight' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, Target) == 0x003058, "Member 'AProjectile_10344901::Target' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, PlaneNormal) == 0x003070, "Member 'AProjectile_10344901::PlaneNormal' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcEnd) == 0x003088, "Member 'AProjectile_10344901::ArcEnd' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcCenter) == 0x0030A0, "Member 'AProjectile_10344901::ArcCenter' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcBeginDir) == 0x0030B8, "Member 'AProjectile_10344901::ArcBeginDir' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcEndDir) == 0x0030D0, "Member 'AProjectile_10344901::ArcEndDir' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcMiddleDir) == 0x0030E8, "Member 'AProjectile_10344901::ArcMiddleDir' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcRadius) == 0x003100, "Member 'AProjectile_10344901::ArcRadius' has a wrong offset!");
static_assert(offsetof(AProjectile_10344901, ArcTime) == 0x003104, "Member 'AProjectile_10344901::ArcTime' has a wrong offset!");

// Class Hero_1034.Ability_103449
// 0x0130 (0x26B8 - 0x2588)
class UAbility_103449 : public UAbility_108
{
public:
	TArray<struct FVector>                        TargetDirctions;                                   // 0x2588(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UConfig_103449*                         Config103449;                                      // 0x2598(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDistance;                                    // 0x25A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A4[0x4];                                     // 0x25A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MainTargetPos;                                     // 0x25A8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MainTargetDir;                                     // 0x25C0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D8[0xE0];                                    // 0x25D8(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFireSucceed(class AActor* SpawnActor, const struct FGameplayAbilityTargetDataHandle& Data);
	void OnNeedSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103449">();
	}
	static class UAbility_103449* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103449>();
	}
};
static_assert(alignof(UAbility_103449) == 0x000008, "Wrong alignment on UAbility_103449");
static_assert(sizeof(UAbility_103449) == 0x0026B8, "Wrong size on UAbility_103449");
static_assert(offsetof(UAbility_103449, TargetDirctions) == 0x002588, "Member 'UAbility_103449::TargetDirctions' has a wrong offset!");
static_assert(offsetof(UAbility_103449, Config103449) == 0x002598, "Member 'UAbility_103449::Config103449' has a wrong offset!");
static_assert(offsetof(UAbility_103449, TargetDistance) == 0x0025A0, "Member 'UAbility_103449::TargetDistance' has a wrong offset!");
static_assert(offsetof(UAbility_103449, MainTargetPos) == 0x0025A8, "Member 'UAbility_103449::MainTargetPos' has a wrong offset!");
static_assert(offsetof(UAbility_103449, MainTargetDir) == 0x0025C0, "Member 'UAbility_103449::MainTargetDir' has a wrong offset!");

// Class Hero_1034.Config_103451
// 0x0070 (0x1200 - 0x1190)
class UConfig_103451 : public UConfig_113
{
public:
	struct FGameplayTagContainer                  MissileToAddTags;                                  // 0x1190(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         EnhancedAbilityDuration;                           // 0x11F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11FC[0x4];                                     // 0x11FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103451">();
	}
	static class UConfig_103451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103451>();
	}
};
static_assert(alignof(UConfig_103451) == 0x000010, "Wrong alignment on UConfig_103451");
static_assert(sizeof(UConfig_103451) == 0x001200, "Wrong size on UConfig_103451");
static_assert(offsetof(UConfig_103451, MissileToAddTags) == 0x001190, "Member 'UConfig_103451::MissileToAddTags' has a wrong offset!");
static_assert(offsetof(UConfig_103451, EnhancedAbilityDuration) == 0x0011F8, "Member 'UConfig_103451::EnhancedAbilityDuration' has a wrong offset!");

// Class Hero_1034.Ability_103451
// 0x0010 (0x27F0 - 0x27E0)
class UAbility_103451 : public UAbility_113
{
public:
	uint8                                         Pad_27E0[0x8];                                     // 0x27E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_WaitAbilityActivate*       WaitUltimateActivateTask;                          // 0x27E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnExitNanoState(const struct FGameplayEventData& Payload);
	void OnUltimateAbilityActivate(class UGameplayAbility* Ability);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103451">();
	}
	static class UAbility_103451* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103451>();
	}
};
static_assert(alignof(UAbility_103451) == 0x000008, "Wrong alignment on UAbility_103451");
static_assert(sizeof(UAbility_103451) == 0x0027F0, "Wrong size on UAbility_103451");
static_assert(offsetof(UAbility_103451, WaitUltimateActivateTask) == 0x0027E8, "Member 'UAbility_103451::WaitUltimateActivateTask' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Loop_10345101
// 0x00A0 (0x0EF0 - 0x0E50)
class ACue_Ability_Loop_10345101 : public AMarvelCueNotify_Ability
{
public:
	int32                                         AbilityID;                                         // 0x0E50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E54[0x4];                                      // 0x0E54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCueHintData                           HintData;                                          // 0x0E58(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10345101">();
	}
	static class ACue_Ability_Loop_10345101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10345101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10345101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10345101");
static_assert(sizeof(ACue_Ability_Loop_10345101) == 0x000EF0, "Wrong size on ACue_Ability_Loop_10345101");
static_assert(offsetof(ACue_Ability_Loop_10345101, AbilityID) == 0x000E50, "Member 'ACue_Ability_Loop_10345101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345101, HintData) == 0x000E58, "Member 'ACue_Ability_Loop_10345101::HintData' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Loop_10345103
// 0x0060 (0x10C0 - 0x1060)
class ACue_Ability_Loop_10345103 : public ACue_Ability_Loop_10340101
{
public:
	class UNiagaraComponent*                      LoopNS_FootFxNanoL;                                // 0x1060(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FootFxNanoR;                                // 0x1068(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandFxNanoL;                                // 0x1070(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_HandFxNanoR;                                // 0x1078(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FloatFxNanoL;                               // 0x1080(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_FloatFxNanoR;                               // 0x1088(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FootFxNanoL;                      // 0x1090(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FootFxNanoR;                      // 0x1098(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_HandFxNanoL;                      // 0x10A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_HandFxNanoR;                      // 0x10A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FloatFxNanoL;                     // 0x10B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNS_Ascending_FloatFxNanoR;                     // 0x10B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10345103">();
	}
	static class ACue_Ability_Loop_10345103* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10345103>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10345103) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10345103");
static_assert(sizeof(ACue_Ability_Loop_10345103) == 0x0010C0, "Wrong size on ACue_Ability_Loop_10345103");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_FootFxNanoL) == 0x001060, "Member 'ACue_Ability_Loop_10345103::LoopNS_FootFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_FootFxNanoR) == 0x001068, "Member 'ACue_Ability_Loop_10345103::LoopNS_FootFxNanoR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_HandFxNanoL) == 0x001070, "Member 'ACue_Ability_Loop_10345103::LoopNS_HandFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_HandFxNanoR) == 0x001078, "Member 'ACue_Ability_Loop_10345103::LoopNS_HandFxNanoR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_FloatFxNanoL) == 0x001080, "Member 'ACue_Ability_Loop_10345103::LoopNS_FloatFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_FloatFxNanoR) == 0x001088, "Member 'ACue_Ability_Loop_10345103::LoopNS_FloatFxNanoR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_FootFxNanoL) == 0x001090, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_FootFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_FootFxNanoR) == 0x001098, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_FootFxNanoR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_HandFxNanoL) == 0x0010A0, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_HandFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_HandFxNanoR) == 0x0010A8, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_HandFxNanoR' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_FloatFxNanoL) == 0x0010B0, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_FloatFxNanoL' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10345103, LoopNS_Ascending_FloatFxNanoR) == 0x0010B8, "Member 'ACue_Ability_Loop_10345103::LoopNS_Ascending_FloatFxNanoR' has a wrong offset!");

// Class Hero_1034.Config_103452
// 0x0010 (0x00A8 - 0x0098)
class UConfig_103452 final : public UMarvelAbilityConfig
{
public:
	TArray<struct FStateBasedTimelineSpec>        StateBasedTimelineSpecs;                           // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103452">();
	}
	static class UConfig_103452* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103452>();
	}
};
static_assert(alignof(UConfig_103452) == 0x000008, "Wrong alignment on UConfig_103452");
static_assert(sizeof(UConfig_103452) == 0x0000A8, "Wrong size on UConfig_103452");
static_assert(offsetof(UConfig_103452, StateBasedTimelineSpecs) == 0x000098, "Member 'UConfig_103452::StateBasedTimelineSpecs' has a wrong offset!");

// Class Hero_1034.Ability_103452
// 0x0000 (0x2588 - 0x2588)
class UAbility_103452 : public UAbility_108
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103452">();
	}
	static class UAbility_103452* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103452>();
	}
};
static_assert(alignof(UAbility_103452) == 0x000008, "Wrong alignment on UAbility_103452");
static_assert(sizeof(UAbility_103452) == 0x002588, "Wrong size on UAbility_103452");

// Class Hero_1034.Config_103454
// 0x0010 (0x1210 - 0x1200)
class UConfig_103454 final : public UConfig_103451
{
public:
	int32                                         ConsumeBuffWhenEndAbility;                         // 0x1200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1204[0xC];                                     // 0x1204(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103454">();
	}
	static class UConfig_103454* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103454>();
	}
};
static_assert(alignof(UConfig_103454) == 0x000010, "Wrong alignment on UConfig_103454");
static_assert(sizeof(UConfig_103454) == 0x001210, "Wrong size on UConfig_103454");
static_assert(offsetof(UConfig_103454, ConsumeBuffWhenEndAbility) == 0x001200, "Member 'UConfig_103454::ConsumeBuffWhenEndAbility' has a wrong offset!");

// Class Hero_1034.Ability_103454
// 0x0000 (0x27F0 - 0x27F0)
class UAbility_103454 : public UAbility_103451
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103454">();
	}
	static class UAbility_103454* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103454>();
	}
};
static_assert(alignof(UAbility_103454) == 0x000008, "Wrong alignment on UAbility_103454");
static_assert(sizeof(UAbility_103454) == 0x0027F0, "Wrong size on UAbility_103454");

// Class Hero_1034.Config_103461
// 0x0000 (0x0098 - 0x0098)
class UConfig_103461 final : public UMarvelAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103461">();
	}
	static class UConfig_103461* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103461>();
	}
};
static_assert(alignof(UConfig_103461) == 0x000008, "Wrong alignment on UConfig_103461");
static_assert(sizeof(UConfig_103461) == 0x000098, "Wrong size on UConfig_103461");

// Class Hero_1034.Ability_103461
// 0x0000 (0x2588 - 0x2588)
class UAbility_103461 : public UAbility_108
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103461">();
	}
	static class UAbility_103461* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103461>();
	}
};
static_assert(alignof(UAbility_103461) == 0x000008, "Wrong alignment on UAbility_103461");
static_assert(sizeof(UAbility_103461) == 0x002588, "Wrong size on UAbility_103461");

// Class Hero_1034.TraceComponent_10346101
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10346101 final : public UMarvelAgentTraceComponent
{
public:
	void OnApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10346101">();
	}
	static class UTraceComponent_10346101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10346101>();
	}
};
static_assert(alignof(UTraceComponent_10346101) == 0x000010, "Wrong alignment on UTraceComponent_10346101");
static_assert(sizeof(UTraceComponent_10346101) == 0x001710, "Wrong size on UTraceComponent_10346101");

// Class Hero_1034.Projectile_10346101
// 0x0000 (0x3050 - 0x3050)
class AProjectile_10346101 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10346101">();
	}
	static class AProjectile_10346101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10346101>();
	}
};
static_assert(alignof(AProjectile_10346101) == 0x000010, "Wrong alignment on AProjectile_10346101");
static_assert(sizeof(AProjectile_10346101) == 0x003050, "Wrong size on AProjectile_10346101");

// Class Hero_1034.Cue_Ability_Loop_10346101
// 0x0008 (0x0E58 - 0x0E50)
class ACue_Ability_Loop_10346101 : public AMarvelCueNotify_Ability
{
public:
	class USkeletalMeshComponent*                 WeaponMesh;                                        // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10346101">();
	}
	static class ACue_Ability_Loop_10346101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10346101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10346101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10346101");
static_assert(sizeof(ACue_Ability_Loop_10346101) == 0x000E58, "Wrong size on ACue_Ability_Loop_10346101");
static_assert(offsetof(ACue_Ability_Loop_10346101, WeaponMesh) == 0x000E50, "Member 'ACue_Ability_Loop_10346101::WeaponMesh' has a wrong offset!");

// Class Hero_1034.Cue_Instant_HitImpact_10346101
// 0x0050 (0x0520 - 0x04D0)
class UCue_Instant_HitImpact_10346101 : public UMarvelCueNotify_HitImpact
{
public:
	struct FCueNiagaraInfo_Custom                 CustomHitNiagaraInfo;                              // 0x04D0(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         GroundHiddenZThreshold;                            // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomHitNiagaraSpawned(class UNiagaraComponent* InNiagaraComponent, class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Instant_HitImpact_10346101">();
	}
	static class UCue_Instant_HitImpact_10346101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Instant_HitImpact_10346101>();
	}
};
static_assert(alignof(UCue_Instant_HitImpact_10346101) == 0x000008, "Wrong alignment on UCue_Instant_HitImpact_10346101");
static_assert(sizeof(UCue_Instant_HitImpact_10346101) == 0x000520, "Wrong size on UCue_Instant_HitImpact_10346101");
static_assert(offsetof(UCue_Instant_HitImpact_10346101, CustomHitNiagaraInfo) == 0x0004D0, "Member 'UCue_Instant_HitImpact_10346101::CustomHitNiagaraInfo' has a wrong offset!");
static_assert(offsetof(UCue_Instant_HitImpact_10346101, GroundHiddenZThreshold) == 0x000518, "Member 'UCue_Instant_HitImpact_10346101::GroundHiddenZThreshold' has a wrong offset!");

// Class Hero_1034.Cue_Ability_Instant_10346101
// 0x0008 (0x0370 - 0x0368)
class UCue_Ability_Instant_10346101 : public UMarvelCueNotify_Base
{
public:
	int32                                         NanoAudioID;                                       // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalAudioID;                                     // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Instant_10346101">();
	}
	static class UCue_Ability_Instant_10346101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Ability_Instant_10346101>();
	}
};
static_assert(alignof(UCue_Ability_Instant_10346101) == 0x000008, "Wrong alignment on UCue_Ability_Instant_10346101");
static_assert(sizeof(UCue_Ability_Instant_10346101) == 0x000370, "Wrong size on UCue_Ability_Instant_10346101");
static_assert(offsetof(UCue_Ability_Instant_10346101, NanoAudioID) == 0x000368, "Member 'UCue_Ability_Instant_10346101::NanoAudioID' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10346101, NormalAudioID) == 0x00036C, "Member 'UCue_Ability_Instant_10346101::NormalAudioID' has a wrong offset!");

// Class Hero_1034.IronManAnimInstance
// 0x00C0 (0x09D0 - 0x0910)
class UIronManAnimInstance : public UMarvelAnimInstance
{
public:
	float                                         FlyTransitionTime;                                 // 0x0910(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ADControlAnimFactor;                               // 0x0914(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DirAnimCurveX;                                     // 0x0918(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DirAnimCurveY;                                     // 0x0920(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AccCurveY;                                         // 0x0928(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AccCurveZ;                                         // 0x0930(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AbilityTag103431;                                  // 0x0938(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AbilityTag103439;                                  // 0x0944(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CustomLandAbilityTag;                              // 0x0950(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_95C[0x4];                                      // 0x095C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LandSequence;                                      // 0x0960(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          LandSequenceAbility;                               // 0x0968(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            LandLean2D;                                        // 0x0970(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomLand;                                    // 0x0978(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFly;                                              // 0x0979(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndFlyComplete;                                   // 0x097A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_97B[0x1];                                      // 0x097B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraForwardPitch;                                // 0x097C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFlyStartTransition;                               // 0x0980(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsNanoWeapon;                                     // 0x0981(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_982[0x6];                                      // 0x0982(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpringArmSocketOffset;                             // 0x0988(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A0[0x30];                                     // 0x09A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManAnimInstance">();
	}
	static class UIronManAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIronManAnimInstance>();
	}
};
static_assert(alignof(UIronManAnimInstance) == 0x000010, "Wrong alignment on UIronManAnimInstance");
static_assert(sizeof(UIronManAnimInstance) == 0x0009D0, "Wrong size on UIronManAnimInstance");
static_assert(offsetof(UIronManAnimInstance, FlyTransitionTime) == 0x000910, "Member 'UIronManAnimInstance::FlyTransitionTime' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, ADControlAnimFactor) == 0x000914, "Member 'UIronManAnimInstance::ADControlAnimFactor' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, DirAnimCurveX) == 0x000918, "Member 'UIronManAnimInstance::DirAnimCurveX' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, DirAnimCurveY) == 0x000920, "Member 'UIronManAnimInstance::DirAnimCurveY' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, AccCurveY) == 0x000928, "Member 'UIronManAnimInstance::AccCurveY' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, AccCurveZ) == 0x000930, "Member 'UIronManAnimInstance::AccCurveZ' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, AbilityTag103431) == 0x000938, "Member 'UIronManAnimInstance::AbilityTag103431' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, AbilityTag103439) == 0x000944, "Member 'UIronManAnimInstance::AbilityTag103439' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, CustomLandAbilityTag) == 0x000950, "Member 'UIronManAnimInstance::CustomLandAbilityTag' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, LandSequence) == 0x000960, "Member 'UIronManAnimInstance::LandSequence' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, LandSequenceAbility) == 0x000968, "Member 'UIronManAnimInstance::LandSequenceAbility' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, LandLean2D) == 0x000970, "Member 'UIronManAnimInstance::LandLean2D' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, bUseCustomLand) == 0x000978, "Member 'UIronManAnimInstance::bUseCustomLand' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, bFly) == 0x000979, "Member 'UIronManAnimInstance::bFly' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, bEndFlyComplete) == 0x00097A, "Member 'UIronManAnimInstance::bEndFlyComplete' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, CameraForwardPitch) == 0x00097C, "Member 'UIronManAnimInstance::CameraForwardPitch' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, bFlyStartTransition) == 0x000980, "Member 'UIronManAnimInstance::bFlyStartTransition' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, bIsNanoWeapon) == 0x000981, "Member 'UIronManAnimInstance::bIsNanoWeapon' has a wrong offset!");
static_assert(offsetof(UIronManAnimInstance, SpringArmSocketOffset) == 0x000988, "Member 'UIronManAnimInstance::SpringArmSocketOffset' has a wrong offset!");

// Class Hero_1034.IronManFlyMotionAnimInstance
// 0x0030 (0x0460 - 0x0430)
class UIronManFlyMotionAnimInstance final : public UAnimInstance
{
public:
	bool                                          bFly;                                              // 0x0428(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartFly;                                         // 0x0429(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42A[0x6];                                      // 0x042A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InterpAirVeloctiy;                                 // 0x0430(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraForwardRot;                                  // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyTransitionStartAlpha;                           // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            FlyBS2D;                                           // 0x0450(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FlyStopAnimSequence;                               // 0x0458(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManFlyMotionAnimInstance">();
	}
	static class UIronManFlyMotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIronManFlyMotionAnimInstance>();
	}
};
static_assert(alignof(UIronManFlyMotionAnimInstance) == 0x000010, "Wrong alignment on UIronManFlyMotionAnimInstance");
static_assert(sizeof(UIronManFlyMotionAnimInstance) == 0x000460, "Wrong size on UIronManFlyMotionAnimInstance");
static_assert(offsetof(UIronManFlyMotionAnimInstance, bFly) == 0x000428, "Member 'UIronManFlyMotionAnimInstance::bFly' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, bStartFly) == 0x000429, "Member 'UIronManFlyMotionAnimInstance::bStartFly' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, InterpAirVeloctiy) == 0x000430, "Member 'UIronManFlyMotionAnimInstance::InterpAirVeloctiy' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, CameraForwardRot) == 0x000448, "Member 'UIronManFlyMotionAnimInstance::CameraForwardRot' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, FlyTransitionStartAlpha) == 0x00044C, "Member 'UIronManFlyMotionAnimInstance::FlyTransitionStartAlpha' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, FlyBS2D) == 0x000450, "Member 'UIronManFlyMotionAnimInstance::FlyBS2D' has a wrong offset!");
static_assert(offsetof(UIronManFlyMotionAnimInstance, FlyStopAnimSequence) == 0x000458, "Member 'UIronManFlyMotionAnimInstance::FlyStopAnimSequence' has a wrong offset!");

// Class Hero_1034.IronManCharacter
// 0x0040 (0x1850 - 0x1810)
class AIronManCharacter : public AMarvelBaseCharacter
{
public:
	class USceneCaptureComponent2D*               SceneCapComponent2D;                               // 0x1810(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelMultiCapsuleComponent*           BodyLeanCollision;                                 // 0x1818(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             NanoStateTimeoutDispatcher;                        // 0x1820(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIronManShiftFlyDistanceDispatcher;               // 0x1830(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UIronManMoveLogicBaseComponent*         IronManMoveLogic;                                  // 0x1840(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1848[0x8];                                     // 0x1848(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManCharacter">();
	}
	static class AIronManCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIronManCharacter>();
	}
};
static_assert(alignof(AIronManCharacter) == 0x000010, "Wrong alignment on AIronManCharacter");
static_assert(sizeof(AIronManCharacter) == 0x001850, "Wrong size on AIronManCharacter");
static_assert(offsetof(AIronManCharacter, SceneCapComponent2D) == 0x001810, "Member 'AIronManCharacter::SceneCapComponent2D' has a wrong offset!");
static_assert(offsetof(AIronManCharacter, BodyLeanCollision) == 0x001818, "Member 'AIronManCharacter::BodyLeanCollision' has a wrong offset!");
static_assert(offsetof(AIronManCharacter, NanoStateTimeoutDispatcher) == 0x001820, "Member 'AIronManCharacter::NanoStateTimeoutDispatcher' has a wrong offset!");
static_assert(offsetof(AIronManCharacter, OnIronManShiftFlyDistanceDispatcher) == 0x001830, "Member 'AIronManCharacter::OnIronManShiftFlyDistanceDispatcher' has a wrong offset!");
static_assert(offsetof(AIronManCharacter, IronManMoveLogic) == 0x001840, "Member 'AIronManCharacter::IronManMoveLogic' has a wrong offset!");

// Class Hero_1034.IronManChildActor
// 0x0040 (0x0AA0 - 0x0A60)
class AIronManChildActor : public AMarvelCharacterChildActor
{
public:
	bool                                          bFly;                                              // 0x0A60(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A61[0x7];                                      // 0x0A61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpringArmSocketOffsetForShift;                     // 0x0A68(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshSlotGroupAssetUserData*            MeshSlotGroup;                                     // 0x0A80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A88[0x18];                                     // 0x0A88(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManChildActor">();
	}
	static class AIronManChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIronManChildActor>();
	}
};
static_assert(alignof(AIronManChildActor) == 0x000008, "Wrong alignment on AIronManChildActor");
static_assert(sizeof(AIronManChildActor) == 0x000AA0, "Wrong size on AIronManChildActor");
static_assert(offsetof(AIronManChildActor, bFly) == 0x000A60, "Member 'AIronManChildActor::bFly' has a wrong offset!");
static_assert(offsetof(AIronManChildActor, SpringArmSocketOffsetForShift) == 0x000A68, "Member 'AIronManChildActor::SpringArmSocketOffsetForShift' has a wrong offset!");
static_assert(offsetof(AIronManChildActor, MeshSlotGroup) == 0x000A80, "Member 'AIronManChildActor::MeshSlotGroup' has a wrong offset!");

// Class Hero_1034.IronManSpringArmComponent
// 0x00A0 (0x1230 - 0x1190)
class UIronManSpringArmComponent final : public UMarvelComposerSpringArmComponent
{
public:
	struct FVector2D                              RotFactor;                                         // 0x1188(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SocketOffsetTargetY;                               // 0x1198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119C[0x4];                                     // 0x119C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MouseRecoverSpeed;                                 // 0x11A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseOffsetFactor;                                 // 0x11B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputToOffsetScale;                                // 0x11C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOffset;                                           // 0x11C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DOffset;                                           // 0x11C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseInterpSpeed;                                  // 0x11CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShiftFlySocketOffsetInterpSpeed;                   // 0x11D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringBackDelay;                                   // 0x11D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InputCameraThreshold;                              // 0x11D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E8[0x20];                                    // 0x11E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TargetMouseInput;                                  // 0x1208(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1218[0x18];                                    // 0x1218(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManSpringArmComponent">();
	}
	static class UIronManSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIronManSpringArmComponent>();
	}
};
static_assert(alignof(UIronManSpringArmComponent) == 0x000010, "Wrong alignment on UIronManSpringArmComponent");
static_assert(sizeof(UIronManSpringArmComponent) == 0x001230, "Wrong size on UIronManSpringArmComponent");
static_assert(offsetof(UIronManSpringArmComponent, RotFactor) == 0x001188, "Member 'UIronManSpringArmComponent::RotFactor' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, SocketOffsetTargetY) == 0x001198, "Member 'UIronManSpringArmComponent::SocketOffsetTargetY' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, MouseRecoverSpeed) == 0x0011A0, "Member 'UIronManSpringArmComponent::MouseRecoverSpeed' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, MouseOffsetFactor) == 0x0011B0, "Member 'UIronManSpringArmComponent::MouseOffsetFactor' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, InputToOffsetScale) == 0x0011C0, "Member 'UIronManSpringArmComponent::InputToOffsetScale' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, AOffset) == 0x0011C4, "Member 'UIronManSpringArmComponent::AOffset' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, DOffset) == 0x0011C8, "Member 'UIronManSpringArmComponent::DOffset' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, MouseInterpSpeed) == 0x0011CC, "Member 'UIronManSpringArmComponent::MouseInterpSpeed' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, ShiftFlySocketOffsetInterpSpeed) == 0x0011D0, "Member 'UIronManSpringArmComponent::ShiftFlySocketOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, SpringBackDelay) == 0x0011D4, "Member 'UIronManSpringArmComponent::SpringBackDelay' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, InputCameraThreshold) == 0x0011D8, "Member 'UIronManSpringArmComponent::InputCameraThreshold' has a wrong offset!");
static_assert(offsetof(UIronManSpringArmComponent, TargetMouseInput) == 0x001208, "Member 'UIronManSpringArmComponent::TargetMouseInput' has a wrong offset!");

// Class Hero_1034.IronManMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UIronManMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManMoveLogicBaseComponent">();
	}
	static class UIronManMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIronManMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UIronManMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UIronManMoveLogicBaseComponent");
static_assert(sizeof(UIronManMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UIronManMoveLogicBaseComponent");

// Class Hero_1034.IronManMovementComponent
// 0x0010 (0x1B70 - 0x1B60)
class UIronManMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	uint8                                         Pad_1B60[0x10];                                    // 0x1B60(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IronManMovementComponent">();
	}
	static class UIronManMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIronManMovementComponent>();
	}
};
static_assert(alignof(UIronManMovementComponent) == 0x000010, "Wrong alignment on UIronManMovementComponent");
static_assert(sizeof(UIronManMovementComponent) == 0x001B70, "Wrong size on UIronManMovementComponent");

// Class Hero_1034.NanoAbilityStatics
// 0x0000 (0x0030 - 0x0030)
class UNanoAbilityStatics final : public UBlueprintFunctionLibrary
{
public:
	static struct FGameplayTagContainer GetNanoCanActivateTags();
	static struct FGameplayTagContainer GetNanoWeaponTags();
	static bool HasAnyNanoCanActivateTags(const class UAbilitySystemComponent* ASC);
	static bool HasAnyNanoWeaponTags(const class UAbilitySystemComponent* ASC);
	static bool IsNanoWeaponTags(const struct FGameplayTag& InTag);
	static bool RemoveAllNanoCanActivateTags(class UAbilitySystemComponent* ASC);
	static bool RemoveAllNanoWeaponTags(class UAbilitySystemComponent* ASC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NanoAbilityStatics">();
	}
	static class UNanoAbilityStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNanoAbilityStatics>();
	}
};
static_assert(alignof(UNanoAbilityStatics) == 0x000008, "Wrong alignment on UNanoAbilityStatics");
static_assert(sizeof(UNanoAbilityStatics) == 0x000030, "Wrong size on UNanoAbilityStatics");

}

