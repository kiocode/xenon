#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1033

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Hero_1033_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Hero_1033.Cue_Projectile_10335202
// 0x0000 (0x0DB0 - 0x0DB0)
class ACue_Projectile_10335202 final : public AMarvelCueNotify_Projectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_10335202">();
	}
	static class ACue_Projectile_10335202* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_10335202>();
	}
};
static_assert(alignof(ACue_Projectile_10335202) == 0x000008, "Wrong alignment on ACue_Projectile_10335202");
static_assert(sizeof(ACue_Projectile_10335202) == 0x000DB0, "Wrong size on ACue_Projectile_10335202");

// Class Hero_1033.Cue_Summoned_Loop_10335201
// 0x0000 (0x0E90 - 0x0E90)
class ACue_Summoned_Loop_10335201 final : public AMarvelCueNotify_Summoned
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoned_Loop_10335201">();
	}
	static class ACue_Summoned_Loop_10335201* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoned_Loop_10335201>();
	}
};
static_assert(alignof(ACue_Summoned_Loop_10335201) == 0x000008, "Wrong alignment on ACue_Summoned_Loop_10335201");
static_assert(sizeof(ACue_Summoned_Loop_10335201) == 0x000E90, "Wrong size on ACue_Summoned_Loop_10335201");

// Class Hero_1033.Ability_103302
// 0x0008 (0x2690 - 0x2688)
class UAbility_103302 : public UAbility_103
{
public:
	uint8                                         Pad_2688[0x8];                                     // 0x2688(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103302">();
	}
	static class UAbility_103302* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103302>();
	}
};
static_assert(alignof(UAbility_103302) == 0x000008, "Wrong alignment on UAbility_103302");
static_assert(sizeof(UAbility_103302) == 0x002690, "Wrong size on UAbility_103302");

// Class Hero_1033.Ability_103303
// 0x00D8 (0x2658 - 0x2580)
class UAbility_103303 : public UMarvelGameplayAbility
{
public:
	bool                                          bDebugAbility;                                     // 0x2580(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2581[0x3];                                     // 0x2581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PendingWeaponEquipID;                              // 0x2584(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NextAbilityID;                                     // 0x2588(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AbilityWaitForActivate;                            // 0x258C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* AnimTask;                                          // 0x2590(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UEquipComponent>         EquipComp;                                         // 0x2598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitDelay*                 DelayTask;                                         // 0x25A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_NetworkSyncPoint*          NetSyncTask;                                       // 0x25A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25B0[0xA8];                                    // 0x25B0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayEndAbility();
	void OnEndSync();
	void OnWeaponSwitchedReplicated(class AShootingWeapon* Weapon, const struct FMarvelEquipmentTable& WeaponInfo, bool bState);
	void SetNextAbilityID(int32 AbilityID);
	void SwitchWeapon(int32 NewWeaponIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103303">();
	}
	static class UAbility_103303* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103303>();
	}
};
static_assert(alignof(UAbility_103303) == 0x000008, "Wrong alignment on UAbility_103303");
static_assert(sizeof(UAbility_103303) == 0x002658, "Wrong size on UAbility_103303");
static_assert(offsetof(UAbility_103303, bDebugAbility) == 0x002580, "Member 'UAbility_103303::bDebugAbility' has a wrong offset!");
static_assert(offsetof(UAbility_103303, PendingWeaponEquipID) == 0x002584, "Member 'UAbility_103303::PendingWeaponEquipID' has a wrong offset!");
static_assert(offsetof(UAbility_103303, NextAbilityID) == 0x002588, "Member 'UAbility_103303::NextAbilityID' has a wrong offset!");
static_assert(offsetof(UAbility_103303, AbilityWaitForActivate) == 0x00258C, "Member 'UAbility_103303::AbilityWaitForActivate' has a wrong offset!");
static_assert(offsetof(UAbility_103303, AnimTask) == 0x002590, "Member 'UAbility_103303::AnimTask' has a wrong offset!");
static_assert(offsetof(UAbility_103303, EquipComp) == 0x002598, "Member 'UAbility_103303::EquipComp' has a wrong offset!");
static_assert(offsetof(UAbility_103303, DelayTask) == 0x0025A0, "Member 'UAbility_103303::DelayTask' has a wrong offset!");
static_assert(offsetof(UAbility_103303, NetSyncTask) == 0x0025A8, "Member 'UAbility_103303::NetSyncTask' has a wrong offset!");

// Class Hero_1033.MarvelAbilityConfig_AimDownSights
// 0x0408 (0x04A0 - 0x0098)
class UMarvelAbilityConfig_AimDownSights : public UMarvelAbilityConfig
{
public:
	int32                                         DecelerateBuffID;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraCorrParam                       CamCorrParam;                                      // 0x00A0(0x03B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FShootModeSensitivityParam             SensitivityParam;                                  // 0x0450(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsWaitStateChanged;                               // 0x0474(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_475[0x3];                                      // 0x0475(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStateChangedTaskParam                 TaskParam;                                         // 0x0478(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAbilityConfig_AimDownSights">();
	}
	static class UMarvelAbilityConfig_AimDownSights* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAbilityConfig_AimDownSights>();
	}
};
static_assert(alignof(UMarvelAbilityConfig_AimDownSights) == 0x000008, "Wrong alignment on UMarvelAbilityConfig_AimDownSights");
static_assert(sizeof(UMarvelAbilityConfig_AimDownSights) == 0x0004A0, "Wrong size on UMarvelAbilityConfig_AimDownSights");
static_assert(offsetof(UMarvelAbilityConfig_AimDownSights, DecelerateBuffID) == 0x000098, "Member 'UMarvelAbilityConfig_AimDownSights::DecelerateBuffID' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityConfig_AimDownSights, CamCorrParam) == 0x0000A0, "Member 'UMarvelAbilityConfig_AimDownSights::CamCorrParam' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityConfig_AimDownSights, SensitivityParam) == 0x000450, "Member 'UMarvelAbilityConfig_AimDownSights::SensitivityParam' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityConfig_AimDownSights, bIsWaitStateChanged) == 0x000474, "Member 'UMarvelAbilityConfig_AimDownSights::bIsWaitStateChanged' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityConfig_AimDownSights, TaskParam) == 0x000478, "Member 'UMarvelAbilityConfig_AimDownSights::TaskParam' has a wrong offset!");

// Class Hero_1033.MarvelAbility_AimDownSights
// 0x0068 (0x25E8 - 0x2580)
class UMarvelAbility_AimDownSights : public UMarvelGameplayAbility
{
public:
	bool                                          bIsAiming;                                         // 0x2580(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2581[0x7];                                     // 0x2581(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAimingStateChangeDispatcher;                     // 0x2588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCameraInterp*                          CameraInterpAsset;                                 // 0x2598(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityConfig_AimDownSights*     Config;                                            // 0x25A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x25A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25B0[0x38];                                    // 0x25B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAimingStateChange();
	void OnInputStateEnd(float StateIntervalTime);
	void OnRep_IsAiming();
	void SetAimingFOV(bool bInAiming);
	void SetAimingSensitivity();
	void SetAimingState(bool bNewState);
	void SetArmOffsetWithCorrection(bool bInAiming);
	void SetDecelerateBuffActive(bool bInAiming);
	void SetFppMode(bool bInAiming);
	void UpdateAimDownSightsSensitivity();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAbility_AimDownSights">();
	}
	static class UMarvelAbility_AimDownSights* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAbility_AimDownSights>();
	}
};
static_assert(alignof(UMarvelAbility_AimDownSights) == 0x000008, "Wrong alignment on UMarvelAbility_AimDownSights");
static_assert(sizeof(UMarvelAbility_AimDownSights) == 0x0025E8, "Wrong size on UMarvelAbility_AimDownSights");
static_assert(offsetof(UMarvelAbility_AimDownSights, bIsAiming) == 0x002580, "Member 'UMarvelAbility_AimDownSights::bIsAiming' has a wrong offset!");
static_assert(offsetof(UMarvelAbility_AimDownSights, OnAimingStateChangeDispatcher) == 0x002588, "Member 'UMarvelAbility_AimDownSights::OnAimingStateChangeDispatcher' has a wrong offset!");
static_assert(offsetof(UMarvelAbility_AimDownSights, CameraInterpAsset) == 0x002598, "Member 'UMarvelAbility_AimDownSights::CameraInterpAsset' has a wrong offset!");
static_assert(offsetof(UMarvelAbility_AimDownSights, Config) == 0x0025A0, "Member 'UMarvelAbility_AimDownSights::Config' has a wrong offset!");
static_assert(offsetof(UMarvelAbility_AimDownSights, OwnerChar) == 0x0025A8, "Member 'UMarvelAbility_AimDownSights::OwnerChar' has a wrong offset!");

// Class Hero_1033.BlackWidowAnimInstance
// 0x00E0 (0x09F0 - 0x0910)
class UBlackWidowAnimInstance final : public UMarvelAnimInstance
{
public:
	float                                         JumpDirectionInterpSpeed;                          // 0x0910(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_914[0xC];                                      // 0x0914(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  LeftHandAdditiveRotation;                          // 0x0920(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AimingStateTags;                                   // 0x0940(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         AimOffsetDataIndex;                                // 0x09A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HitAnimIndex;                                      // 0x09AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingEnhancedJump;                                // 0x09B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B1[0x3];                                      // 0x09B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElectronicStrength;                                // 0x09B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpDirection;                                     // 0x09B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintDirection;                                   // 0x09BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintWithRifle;                                  // 0x09C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinalLeftHandIKEnabled;                           // 0x09C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bElectronicState_None;                             // 0x09C2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bElectronicState_Storage;                          // 0x09C3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bElectronicState_Fire;                             // 0x09C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWeaponModeWithRifle;                              // 0x09C5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRunState_SprintToNormal;                          // 0x09C6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRunState_SprintStartConduit;                      // 0x09C7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C8[0x4];                                      // 0x09C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAnimInstance>           AbilityAnimInstance;                               // 0x09CC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9D4[0xC];                                      // 0x09D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class ABlackWidowCharacter*                   BlackWidowCharacter;                               // 0x09E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9E8[0x8];                                      // 0x09E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowAnimInstance">();
	}
	static class UBlackWidowAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowAnimInstance>();
	}
};
static_assert(alignof(UBlackWidowAnimInstance) == 0x000010, "Wrong alignment on UBlackWidowAnimInstance");
static_assert(sizeof(UBlackWidowAnimInstance) == 0x0009F0, "Wrong size on UBlackWidowAnimInstance");
static_assert(offsetof(UBlackWidowAnimInstance, JumpDirectionInterpSpeed) == 0x000910, "Member 'UBlackWidowAnimInstance::JumpDirectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, LeftHandAdditiveRotation) == 0x000920, "Member 'UBlackWidowAnimInstance::LeftHandAdditiveRotation' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, AimingStateTags) == 0x000940, "Member 'UBlackWidowAnimInstance::AimingStateTags' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, AimOffsetDataIndex) == 0x0009A8, "Member 'UBlackWidowAnimInstance::AimOffsetDataIndex' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, HitAnimIndex) == 0x0009AC, "Member 'UBlackWidowAnimInstance::HitAnimIndex' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bUsingEnhancedJump) == 0x0009B0, "Member 'UBlackWidowAnimInstance::bUsingEnhancedJump' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, ElectronicStrength) == 0x0009B4, "Member 'UBlackWidowAnimInstance::ElectronicStrength' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, JumpDirection) == 0x0009B8, "Member 'UBlackWidowAnimInstance::JumpDirection' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, SprintDirection) == 0x0009BC, "Member 'UBlackWidowAnimInstance::SprintDirection' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bSprintWithRifle) == 0x0009C0, "Member 'UBlackWidowAnimInstance::bSprintWithRifle' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bFinalLeftHandIKEnabled) == 0x0009C1, "Member 'UBlackWidowAnimInstance::bFinalLeftHandIKEnabled' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bElectronicState_None) == 0x0009C2, "Member 'UBlackWidowAnimInstance::bElectronicState_None' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bElectronicState_Storage) == 0x0009C3, "Member 'UBlackWidowAnimInstance::bElectronicState_Storage' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bElectronicState_Fire) == 0x0009C4, "Member 'UBlackWidowAnimInstance::bElectronicState_Fire' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bWeaponModeWithRifle) == 0x0009C5, "Member 'UBlackWidowAnimInstance::bWeaponModeWithRifle' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bRunState_SprintToNormal) == 0x0009C6, "Member 'UBlackWidowAnimInstance::bRunState_SprintToNormal' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, bRunState_SprintStartConduit) == 0x0009C7, "Member 'UBlackWidowAnimInstance::bRunState_SprintStartConduit' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, AbilityAnimInstance) == 0x0009CC, "Member 'UBlackWidowAnimInstance::AbilityAnimInstance' has a wrong offset!");
static_assert(offsetof(UBlackWidowAnimInstance, BlackWidowCharacter) == 0x0009E0, "Member 'UBlackWidowAnimInstance::BlackWidowCharacter' has a wrong offset!");

// Class Hero_1033.Cue_Instant_HitImpact_10332201
// 0x0018 (0x0518 - 0x0500)
class UCue_Instant_HitImpact_10332201 final : public UMarvelCueNotify_InstantHitImpact
{
public:
	struct FVector                                RelativeBeamPosition;                              // 0x0500(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Instant_HitImpact_10332201">();
	}
	static class UCue_Instant_HitImpact_10332201* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Instant_HitImpact_10332201>();
	}
};
static_assert(alignof(UCue_Instant_HitImpact_10332201) == 0x000008, "Wrong alignment on UCue_Instant_HitImpact_10332201");
static_assert(sizeof(UCue_Instant_HitImpact_10332201) == 0x000518, "Wrong size on UCue_Instant_HitImpact_10332201");
static_assert(offsetof(UCue_Instant_HitImpact_10332201, RelativeBeamPosition) == 0x000500, "Member 'UCue_Instant_HitImpact_10332201::RelativeBeamPosition' has a wrong offset!");

// Class Hero_1033.MarvelCueNotify_TraceActor_10333101
// 0x0FC0 (0x1CC0 - 0x0D00)
class AMarvelCueNotify_TraceActor_10333101 final : public AMarvelCueNotify_TraceActor
{
public:
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x0D00(0x0F90)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComp;                                         // 0x1C90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalSize;                                         // 0x1C98(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DecalMaterialInstance;                             // 0x1CB0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CB8[0x8];                                     // 0x1CB8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelCueNotify_TraceActor_10333101">();
	}
	static class AMarvelCueNotify_TraceActor_10333101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelCueNotify_TraceActor_10333101>();
	}
};
static_assert(alignof(AMarvelCueNotify_TraceActor_10333101) == 0x000010, "Wrong alignment on AMarvelCueNotify_TraceActor_10333101");
static_assert(sizeof(AMarvelCueNotify_TraceActor_10333101) == 0x001CC0, "Wrong size on AMarvelCueNotify_TraceActor_10333101");
static_assert(offsetof(AMarvelCueNotify_TraceActor_10333101, TraceContext) == 0x000D00, "Member 'AMarvelCueNotify_TraceActor_10333101::TraceContext' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_TraceActor_10333101, DecalComp) == 0x001C90, "Member 'AMarvelCueNotify_TraceActor_10333101::DecalComp' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_TraceActor_10333101, DecalSize) == 0x001C98, "Member 'AMarvelCueNotify_TraceActor_10333101::DecalSize' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_TraceActor_10333101, DecalMaterialInstance) == 0x001CB0, "Member 'AMarvelCueNotify_TraceActor_10333101::DecalMaterialInstance' has a wrong offset!");

// Class Hero_1033.BlackWidowSniperGun
// 0x0020 (0x0CB0 - 0x0C90)
class ABlackWidowSniperGun : public AShootingWeapon
{
public:
	uint8                                         Pad_C90[0x8];                                      // 0x0C90(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   CachedBindedRebornCharacter;                       // 0x0C98(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBulletLoadedInfo_1033                 BulletLoadedInfo;                                  // 0x0CA0(0x0010)(BlueprintVisible, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnOwnerCharacterRespawned(class AActor* TargetActor, const struct FCharacterRebornParam& RebornParam);
	void OnRep_BulletLoaded();
	void SetBulletLoaded(bool bLoaded);

	float GetPullBulletDuration() const;
	bool IsBulletLoaded() const;
	bool ShouldPassPullBulletSafeCheck(float Tolerance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowSniperGun">();
	}
	static class ABlackWidowSniperGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlackWidowSniperGun>();
	}
};
static_assert(alignof(ABlackWidowSniperGun) == 0x000008, "Wrong alignment on ABlackWidowSniperGun");
static_assert(sizeof(ABlackWidowSniperGun) == 0x000CB0, "Wrong size on ABlackWidowSniperGun");
static_assert(offsetof(ABlackWidowSniperGun, CachedBindedRebornCharacter) == 0x000C98, "Member 'ABlackWidowSniperGun::CachedBindedRebornCharacter' has a wrong offset!");
static_assert(offsetof(ABlackWidowSniperGun, BulletLoadedInfo) == 0x000CA0, "Member 'ABlackWidowSniperGun::BulletLoadedInfo' has a wrong offset!");

// Class Hero_1033.Ability_103331
// 0x0010 (0x2590 - 0x2580)
class UAbility_103331 : public UMarvelGameplayAbility
{
public:
	TArray<class AActor*>                         HitActors;                                         // 0x2580(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void SaveHitActors(const TArray<struct FHitResult>& InHitResults);

	bool HasValidHitActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103331">();
	}
	static class UAbility_103331* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103331>();
	}
};
static_assert(alignof(UAbility_103331) == 0x000008, "Wrong alignment on UAbility_103331");
static_assert(sizeof(UAbility_103331) == 0x002590, "Wrong size on UAbility_103331");
static_assert(offsetof(UAbility_103331, HitActors) == 0x002580, "Member 'UAbility_103331::HitActors' has a wrong offset!");

// Class Hero_1033.Config_103331
// 0x0040 (0x00D8 - 0x0098)
class UConfig_103331 final : public UMarvelAbilityConfig
{
public:
	float                                         MaxTargetPitchAngle;                               // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValidPitchAngle;                                // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetDistance;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTargetHeight;                                   // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveAngel;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnlyPlatform;                                   // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DecalRotator;                                      // 0x00B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlacementCueTag;                                   // 0x00C8(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103331">();
	}
	static class UConfig_103331* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103331>();
	}
};
static_assert(alignof(UConfig_103331) == 0x000008, "Wrong alignment on UConfig_103331");
static_assert(sizeof(UConfig_103331) == 0x0000D8, "Wrong size on UConfig_103331");
static_assert(offsetof(UConfig_103331, MaxTargetPitchAngle) == 0x000098, "Member 'UConfig_103331::MaxTargetPitchAngle' has a wrong offset!");
static_assert(offsetof(UConfig_103331, MaxValidPitchAngle) == 0x00009C, "Member 'UConfig_103331::MaxValidPitchAngle' has a wrong offset!");
static_assert(offsetof(UConfig_103331, MaxTargetDistance) == 0x0000A0, "Member 'UConfig_103331::MaxTargetDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103331, MinTargetHeight) == 0x0000A4, "Member 'UConfig_103331::MinTargetHeight' has a wrong offset!");
static_assert(offsetof(UConfig_103331, AdditiveAngel) == 0x0000A8, "Member 'UConfig_103331::AdditiveAngel' has a wrong offset!");
static_assert(offsetof(UConfig_103331, bIsOnlyPlatform) == 0x0000AC, "Member 'UConfig_103331::bIsOnlyPlatform' has a wrong offset!");
static_assert(offsetof(UConfig_103331, DecalRotator) == 0x0000B0, "Member 'UConfig_103331::DecalRotator' has a wrong offset!");
static_assert(offsetof(UConfig_103331, PlacementCueTag) == 0x0000C8, "Member 'UConfig_103331::PlacementCueTag' has a wrong offset!");

// Class Hero_1033.AbilityTargetActor_PawnPlacement_103331
// 0x0030 (0x17B0 - 0x1780)
class AAbilityTargetActor_PawnPlacement_103331 final : public AMarvelAbilityTargetActor_PawnPlacement
{
public:
	FMulticastInlineDelegateProperty_             OnPlacementTargetPositionUpdated;                  // 0x1780(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1790[0x20];                                    // 0x1790(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTargetActor_PawnPlacement_103331">();
	}
	static class AAbilityTargetActor_PawnPlacement_103331* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityTargetActor_PawnPlacement_103331>();
	}
};
static_assert(alignof(AAbilityTargetActor_PawnPlacement_103331) == 0x000010, "Wrong alignment on AAbilityTargetActor_PawnPlacement_103331");
static_assert(sizeof(AAbilityTargetActor_PawnPlacement_103331) == 0x0017B0, "Wrong size on AAbilityTargetActor_PawnPlacement_103331");
static_assert(offsetof(AAbilityTargetActor_PawnPlacement_103331, OnPlacementTargetPositionUpdated) == 0x001780, "Member 'AAbilityTargetActor_PawnPlacement_103331::OnPlacementTargetPositionUpdated' has a wrong offset!");

// Class Hero_1033.CueWeaponLoop_103301
// 0x0000 (0x10A8 - 0x10A8)
class ACueWeaponLoop_103301 final : public AMarvelCueNotify_Weapon_Loop
{
public:
	class USkeletalMeshComponent* GetWeaponMesh1P();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueWeaponLoop_103301">();
	}
	static class ACueWeaponLoop_103301* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueWeaponLoop_103301>();
	}
};
static_assert(alignof(ACueWeaponLoop_103301) == 0x000008, "Wrong alignment on ACueWeaponLoop_103301");
static_assert(sizeof(ACueWeaponLoop_103301) == 0x0010A8, "Wrong size on ACueWeaponLoop_103301");

// Class Hero_1033.Ability_103332
// 0x0068 (0x25E8 - 0x2580)
class UAbility_103332 : public UMarvelGameplayAbility
{
public:
	TArray<class AActor*>                         ValidActors;                                       // 0x2580(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 SelectedActor;                                     // 0x2590(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPortalSegments                        PortalSegments;                                    // 0x2598(0x0050)(Net, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void FilterValidHitResult(TArray<struct FHitResult>& InOutHitResults);
	void SetSelectedActor(class AActor* InSelectedActor, const struct FPortalSegments& InPortalSegments);

	class AActor* GetSelectedActor() const;
	TArray<class AActor*> GetValidActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103332">();
	}
	static class UAbility_103332* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103332>();
	}
};
static_assert(alignof(UAbility_103332) == 0x000008, "Wrong alignment on UAbility_103332");
static_assert(sizeof(UAbility_103332) == 0x0025E8, "Wrong size on UAbility_103332");
static_assert(offsetof(UAbility_103332, ValidActors) == 0x002580, "Member 'UAbility_103332::ValidActors' has a wrong offset!");
static_assert(offsetof(UAbility_103332, SelectedActor) == 0x002590, "Member 'UAbility_103332::SelectedActor' has a wrong offset!");
static_assert(offsetof(UAbility_103332, PortalSegments) == 0x002598, "Member 'UAbility_103332::PortalSegments' has a wrong offset!");

// Class Hero_1033.Config_103332
// 0x0008 (0x00A0 - 0x0098)
class UConfig_103332 final : public UMarvelAbilityConfig
{
public:
	float                                         ThreholdLandDistance;                              // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103332">();
	}
	static class UConfig_103332* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103332>();
	}
};
static_assert(alignof(UConfig_103332) == 0x000008, "Wrong alignment on UConfig_103332");
static_assert(sizeof(UConfig_103332) == 0x0000A0, "Wrong size on UConfig_103332");
static_assert(offsetof(UConfig_103332, ThreholdLandDistance) == 0x000098, "Member 'UConfig_103332::ThreholdLandDistance' has a wrong offset!");

// Class Hero_1033.Ability_103333
// 0x0C68 (0x31E8 - 0x2580)
class UAbility_103333 : public UMarvelGameplayAbility
{
public:
	class AActor*                                 SelectedActor;                                     // 0x2580(0x0008)(BlueprintVisible, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SelectedActorChangedDelegate;                      // 0x2588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDashAbilityInfo                       DashInfo;                                          // 0x2598(0x0BA8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPredictionKey                         ClosedToCharacterKey;                              // 0x3140(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31E0[0x4];                                     // 0x31E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToKickBeforeDashEnd;                           // 0x31E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClosedToTarget();
	void OnRep_SelectedActor(class AActor* OldActor);
	void PlayKickTimeline();
	void SelectedActorChangedDelegate__DelegateSignature(class AActor* OldActor, class AActor* NewActor);
	void StartCheckDashLeftTime();
	void StopCheckDashLeftTime();

	int32 GetDashTimelineIndex() const;
	int32 GetKickTimelineIndex() const;
	struct FPortalSegments GetPortalSegments() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103333">();
	}
	static class UAbility_103333* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103333>();
	}
};
static_assert(alignof(UAbility_103333) == 0x000008, "Wrong alignment on UAbility_103333");
static_assert(sizeof(UAbility_103333) == 0x0031E8, "Wrong size on UAbility_103333");
static_assert(offsetof(UAbility_103333, SelectedActor) == 0x002580, "Member 'UAbility_103333::SelectedActor' has a wrong offset!");
static_assert(offsetof(UAbility_103333, SelectedActorChangedDelegate) == 0x002588, "Member 'UAbility_103333::SelectedActorChangedDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_103333, DashInfo) == 0x002598, "Member 'UAbility_103333::DashInfo' has a wrong offset!");
static_assert(offsetof(UAbility_103333, ClosedToCharacterKey) == 0x003140, "Member 'UAbility_103333::ClosedToCharacterKey' has a wrong offset!");
static_assert(offsetof(UAbility_103333, TimeToKickBeforeDashEnd) == 0x0031E4, "Member 'UAbility_103333::TimeToKickBeforeDashEnd' has a wrong offset!");

// Class Hero_1033.EpicMomentAction_1033
// 0x0018 (0x0138 - 0x0120)
class UEpicMomentAction_1033 final : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnProjectileBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Projectile, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnSummonerBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Summoned, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnSummonerEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1033">();
	}
	static class UEpicMomentAction_1033* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1033>();
	}
};
static_assert(alignof(UEpicMomentAction_1033) == 0x000008, "Wrong alignment on UEpicMomentAction_1033");
static_assert(sizeof(UEpicMomentAction_1033) == 0x000138, "Wrong size on UEpicMomentAction_1033");

// Class Hero_1033.Cue_Ability_Loop_10333301
// 0x00A8 (0x0EF8 - 0x0E50)
class ACue_Ability_Loop_10333301 final : public AMarvelCueNotify_Ability
{
public:
	float                                         HookFlyDuration;                                   // 0x0E50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E54[0x24];                                     // 0x0E54(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   HookComponent;                                     // 0x0E78(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      NS_Cable;                                          // 0x0E80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         NS_CableHit;                                       // 0x0E88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbility_103333*                        OwnerAbility;                                      // 0x0E90(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ACharacter>              TargetCharacter;                                   // 0x0E98(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA0[0x58];                                     // 0x0EA0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleReceiveTargetCharacter(class AActor* OldActor, class AActor* NewActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10333301">();
	}
	static class ACue_Ability_Loop_10333301* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10333301>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10333301) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10333301");
static_assert(sizeof(ACue_Ability_Loop_10333301) == 0x000EF8, "Wrong size on ACue_Ability_Loop_10333301");
static_assert(offsetof(ACue_Ability_Loop_10333301, HookFlyDuration) == 0x000E50, "Member 'ACue_Ability_Loop_10333301::HookFlyDuration' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10333301, HookComponent) == 0x000E78, "Member 'ACue_Ability_Loop_10333301::HookComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10333301, NS_Cable) == 0x000E80, "Member 'ACue_Ability_Loop_10333301::NS_Cable' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10333301, NS_CableHit) == 0x000E88, "Member 'ACue_Ability_Loop_10333301::NS_CableHit' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10333301, OwnerAbility) == 0x000E90, "Member 'ACue_Ability_Loop_10333301::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10333301, TargetCharacter) == 0x000E98, "Member 'ACue_Ability_Loop_10333301::TargetCharacter' has a wrong offset!");

// Class Hero_1033.CueDataProcessor_AttachBlackWidow_103333
// 0x0010 (0x00D0 - 0x00C0)
class UCueDataProcessor_AttachBlackWidow_103333 final : public UCueDataProcessor_AttachCharacter
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueDataProcessor_AttachBlackWidow_103333">();
	}
	static class UCueDataProcessor_AttachBlackWidow_103333* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCueDataProcessor_AttachBlackWidow_103333>();
	}
};
static_assert(alignof(UCueDataProcessor_AttachBlackWidow_103333) == 0x000008, "Wrong alignment on UCueDataProcessor_AttachBlackWidow_103333");
static_assert(sizeof(UCueDataProcessor_AttachBlackWidow_103333) == 0x0000D0, "Wrong size on UCueDataProcessor_AttachBlackWidow_103333");

// Class Hero_1033.Cue_Ability_Instant_10333301
// 0x0048 (0x02D0 - 0x0288)
class UCue_Ability_Instant_10333301 final : public UMarvelCueNotify_Static
{
public:
	struct FCueNiagaraInfo_Custom                 HitNiagaraInfo;                                    // 0x0288(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Instant_10333301">();
	}
	static class UCue_Ability_Instant_10333301* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Ability_Instant_10333301>();
	}
};
static_assert(alignof(UCue_Ability_Instant_10333301) == 0x000008, "Wrong alignment on UCue_Ability_Instant_10333301");
static_assert(sizeof(UCue_Ability_Instant_10333301) == 0x0002D0, "Wrong size on UCue_Ability_Instant_10333301");
static_assert(offsetof(UCue_Ability_Instant_10333301, HitNiagaraInfo) == 0x000288, "Member 'UCue_Ability_Instant_10333301::HitNiagaraInfo' has a wrong offset!");

// Class Hero_1033.Config_103341
// 0x0FD8 (0x1070 - 0x0098)
class UConfig_103341 final : public UMarvelAbilityConfig
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFindGroundParam                       TargetPointTracingParam;                           // 0x00A0(0x0FD0)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103341">();
	}
	static class UConfig_103341* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103341>();
	}
};
static_assert(alignof(UConfig_103341) == 0x000010, "Wrong alignment on UConfig_103341");
static_assert(sizeof(UConfig_103341) == 0x001070, "Wrong size on UConfig_103341");
static_assert(offsetof(UConfig_103341, TargetPointTracingParam) == 0x0000A0, "Member 'UConfig_103341::TargetPointTracingParam' has a wrong offset!");

// Class Hero_1033.BlackWidowMoveLogicBaseComponent
// 0x0010 (0x0400 - 0x03F0)
class UBlackWidowMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	struct FGameplayTag                           FallingTag;                                        // 0x03F0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowMoveLogicBaseComponent">();
	}
	static class UBlackWidowMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UBlackWidowMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UBlackWidowMoveLogicBaseComponent");
static_assert(sizeof(UBlackWidowMoveLogicBaseComponent) == 0x000400, "Wrong size on UBlackWidowMoveLogicBaseComponent");
static_assert(offsetof(UBlackWidowMoveLogicBaseComponent, FallingTag) == 0x0003F0, "Member 'UBlackWidowMoveLogicBaseComponent::FallingTag' has a wrong offset!");

// Class Hero_1033.Ability_103341
// 0x0000 (0x2580 - 0x2580)
class UAbility_103341 : public UMarvelGameplayAbility
{
public:
	bool GetAbilityInputKeyPressed();
	bool IsMovingForward();
	bool OnStopMovingForward();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103341">();
	}
	static class UAbility_103341* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103341>();
	}
};
static_assert(alignof(UAbility_103341) == 0x000008, "Wrong alignment on UAbility_103341");
static_assert(sizeof(UAbility_103341) == 0x002580, "Wrong size on UAbility_103341");

// Class Hero_1033.CueProjectileLoop_1033_RopeHook
// 0x0020 (0x0DD0 - 0x0DB0)
class ACueProjectileLoop_1033_RopeHook : public AMarvelCueNotify_Projectile
{
public:
	float                                         CableLengthFactor;                                 // 0x0DB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RopeAttachedSocketName;                            // 0x0DB4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelCableComponent*                  Cable;                                             // 0x0DC0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x0DC8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueProjectileLoop_1033_RopeHook">();
	}
	static class ACueProjectileLoop_1033_RopeHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueProjectileLoop_1033_RopeHook>();
	}
};
static_assert(alignof(ACueProjectileLoop_1033_RopeHook) == 0x000008, "Wrong alignment on ACueProjectileLoop_1033_RopeHook");
static_assert(sizeof(ACueProjectileLoop_1033_RopeHook) == 0x000DD0, "Wrong size on ACueProjectileLoop_1033_RopeHook");
static_assert(offsetof(ACueProjectileLoop_1033_RopeHook, CableLengthFactor) == 0x000DB0, "Member 'ACueProjectileLoop_1033_RopeHook::CableLengthFactor' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_1033_RopeHook, RopeAttachedSocketName) == 0x000DB4, "Member 'ACueProjectileLoop_1033_RopeHook::RopeAttachedSocketName' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_1033_RopeHook, Cable) == 0x000DC0, "Member 'ACueProjectileLoop_1033_RopeHook::Cable' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_1033_RopeHook, TargetMesh) == 0x000DC8, "Member 'ACueProjectileLoop_1033_RopeHook::TargetMesh' has a wrong offset!");

// Class Hero_1033.Ability_103352
// 0x0010 (0x2590 - 0x2580)
class UAbility_103352 : public UMarvelGameplayAbility
{
public:
	bool                                          bIsAccumulating;                                   // 0x2580(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2581[0x3];                                     // 0x2581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargeDuration;                                    // 0x2584(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2588[0x8];                                     // 0x2588(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetChargeStrength() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103352">();
	}
	static class UAbility_103352* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103352>();
	}
};
static_assert(alignof(UAbility_103352) == 0x000008, "Wrong alignment on UAbility_103352");
static_assert(sizeof(UAbility_103352) == 0x002590, "Wrong size on UAbility_103352");
static_assert(offsetof(UAbility_103352, bIsAccumulating) == 0x002580, "Member 'UAbility_103352::bIsAccumulating' has a wrong offset!");
static_assert(offsetof(UAbility_103352, ChargeDuration) == 0x002584, "Member 'UAbility_103352::ChargeDuration' has a wrong offset!");

// Class Hero_1033.Config_103352
// 0x0028 (0x00C0 - 0x0098)
class UConfig_103352 : public UMarvelAbilityConfig
{
public:
	float                                         MinChargeDuration;                                 // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxChargeDuration;                                 // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RTPCName;                                          // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedClampMin;                                     // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedClampMax;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedClampMax;                                  // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103352">();
	}
	static class UConfig_103352* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103352>();
	}
};
static_assert(alignof(UConfig_103352) == 0x000008, "Wrong alignment on UConfig_103352");
static_assert(sizeof(UConfig_103352) == 0x0000C0, "Wrong size on UConfig_103352");
static_assert(offsetof(UConfig_103352, MinChargeDuration) == 0x000098, "Member 'UConfig_103352::MinChargeDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103352, MaxChargeDuration) == 0x00009C, "Member 'UConfig_103352::MaxChargeDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103352, RTPCName) == 0x0000A0, "Member 'UConfig_103352::RTPCName' has a wrong offset!");
static_assert(offsetof(UConfig_103352, SpeedClampMin) == 0x0000B0, "Member 'UConfig_103352::SpeedClampMin' has a wrong offset!");
static_assert(offsetof(UConfig_103352, MinSpeedClampMax) == 0x0000B4, "Member 'UConfig_103352::MinSpeedClampMax' has a wrong offset!");
static_assert(offsetof(UConfig_103352, MaxSpeedClampMax) == 0x0000B8, "Member 'UConfig_103352::MaxSpeedClampMax' has a wrong offset!");

// Class Hero_1033.Projectile_10335202
// 0x0010 (0x3060 - 0x3050)
class AProjectile_10335202 : public AMarvelAbilityTargetActor_Projectile
{
public:
	float                                         ChargeDuration;                                    // 0x3050(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3054[0xC];                                     // 0x3054(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10335202">();
	}
	static class AProjectile_10335202* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10335202>();
	}
};
static_assert(alignof(AProjectile_10335202) == 0x000010, "Wrong alignment on AProjectile_10335202");
static_assert(sizeof(AProjectile_10335202) == 0x003060, "Wrong size on AProjectile_10335202");
static_assert(offsetof(AProjectile_10335202, ChargeDuration) == 0x003050, "Member 'AProjectile_10335202::ChargeDuration' has a wrong offset!");

// Class Hero_1033.BlackWidowWeaponAnimInstance
// 0x0010 (0x0920 - 0x0910)
class UBlackWidowWeaponAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsAiming;                                         // 0x0910(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReloading;                                      // 0x0911(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_912[0x2];                                      // 0x0912(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StoragePercent;                                    // 0x0914(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateShoot;                                  // 0x0918(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateAim;                                    // 0x0919(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateAimLoop;                                // 0x091A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateStorage;                                // 0x091B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x091C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsViewingSelf;                                    // 0x091D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlackWidowElectronicState                    ElectronicState;                                   // 0x091E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlackWidow_103333_WeaponState                State_103333;                                      // 0x091F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetState_103333(EBlackWidow_103333_WeaponState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowWeaponAnimInstance">();
	}
	static class UBlackWidowWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowWeaponAnimInstance>();
	}
};
static_assert(alignof(UBlackWidowWeaponAnimInstance) == 0x000010, "Wrong alignment on UBlackWidowWeaponAnimInstance");
static_assert(sizeof(UBlackWidowWeaponAnimInstance) == 0x000920, "Wrong size on UBlackWidowWeaponAnimInstance");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsAiming) == 0x000910, "Member 'UBlackWidowWeaponAnimInstance::bIsAiming' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsReloading) == 0x000911, "Member 'UBlackWidowWeaponAnimInstance::bIsReloading' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, StoragePercent) == 0x000914, "Member 'UBlackWidowWeaponAnimInstance::StoragePercent' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsUltimateShoot) == 0x000918, "Member 'UBlackWidowWeaponAnimInstance::bIsUltimateShoot' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsUltimateAim) == 0x000919, "Member 'UBlackWidowWeaponAnimInstance::bIsUltimateAim' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsUltimateAimLoop) == 0x00091A, "Member 'UBlackWidowWeaponAnimInstance::bIsUltimateAimLoop' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsUltimateStorage) == 0x00091B, "Member 'UBlackWidowWeaponAnimInstance::bIsUltimateStorage' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsRunning) == 0x00091C, "Member 'UBlackWidowWeaponAnimInstance::bIsRunning' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, bIsViewingSelf) == 0x00091D, "Member 'UBlackWidowWeaponAnimInstance::bIsViewingSelf' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, ElectronicState) == 0x00091E, "Member 'UBlackWidowWeaponAnimInstance::ElectronicState' has a wrong offset!");
static_assert(offsetof(UBlackWidowWeaponAnimInstance, State_103333) == 0x00091F, "Member 'UBlackWidowWeaponAnimInstance::State_103333' has a wrong offset!");

// Class Hero_1033.BlackWidowFPAnimInstance
// 0x0090 (0x09A0 - 0x0910)
class UBlackWidowFPAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsScopeAiming;                                    // 0x0910(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAinFiring;                                      // 0x0911(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReloading;                                      // 0x0912(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x0913(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StoragePercent;                                    // 0x0914(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateShoot;                                  // 0x0918(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateAim;                                    // 0x0919(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateAimLoop;                                // 0x091A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateStorage;                                // 0x091B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlackWidowElectronicState                    ElectronicState;                                   // 0x091C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91D[0x3];                                      // 0x091D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               WeaponRotator;                                     // 0x0920(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_938[0x8];                                      // 0x0938(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LeftHandleTransform;                               // 0x0940(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowFPAnimInstance">();
	}
	static class UBlackWidowFPAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowFPAnimInstance>();
	}
};
static_assert(alignof(UBlackWidowFPAnimInstance) == 0x000010, "Wrong alignment on UBlackWidowFPAnimInstance");
static_assert(sizeof(UBlackWidowFPAnimInstance) == 0x0009A0, "Wrong size on UBlackWidowFPAnimInstance");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsScopeAiming) == 0x000910, "Member 'UBlackWidowFPAnimInstance::bIsScopeAiming' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsAinFiring) == 0x000911, "Member 'UBlackWidowFPAnimInstance::bIsAinFiring' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsReloading) == 0x000912, "Member 'UBlackWidowFPAnimInstance::bIsReloading' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsRunning) == 0x000913, "Member 'UBlackWidowFPAnimInstance::bIsRunning' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, StoragePercent) == 0x000914, "Member 'UBlackWidowFPAnimInstance::StoragePercent' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsUltimateShoot) == 0x000918, "Member 'UBlackWidowFPAnimInstance::bIsUltimateShoot' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsUltimateAim) == 0x000919, "Member 'UBlackWidowFPAnimInstance::bIsUltimateAim' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsUltimateAimLoop) == 0x00091A, "Member 'UBlackWidowFPAnimInstance::bIsUltimateAimLoop' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, bIsUltimateStorage) == 0x00091B, "Member 'UBlackWidowFPAnimInstance::bIsUltimateStorage' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, ElectronicState) == 0x00091C, "Member 'UBlackWidowFPAnimInstance::ElectronicState' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, WeaponRotator) == 0x000920, "Member 'UBlackWidowFPAnimInstance::WeaponRotator' has a wrong offset!");
static_assert(offsetof(UBlackWidowFPAnimInstance, LeftHandleTransform) == 0x000940, "Member 'UBlackWidowFPAnimInstance::LeftHandleTransform' has a wrong offset!");

// Class Hero_1033.BlackWidowCharacter
// 0x0060 (0x1870 - 0x1810)
class ABlackWidowCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bIsFiring;                                         // 0x1810(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReloading;                                      // 0x1811(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateAiming;                                 // 0x1812(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1813[0x5];                                     // 0x1813(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               WeaponRotator;                                     // 0x1818(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WeaponRotationRate;                                // 0x1830(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponRotationInterpSpeed;                         // 0x1834(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponMoveRotationMaxVec;                          // 0x1838(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponMoveRotationMinVec;                          // 0x183C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlackWidowElectronicStateChanged;                // 0x1840(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBlackWidowMoveLogicBaseComponent*      BlackWidowMoveLogic;                               // 0x1850(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElectronicStrength;                                // 0x1858(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBlackWidowElectronicState                    ElectronicState;                                   // 0x185C(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOpenMirrorShootReady;                             // 0x185D(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsScopeAiming;                                    // 0x185E(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAimFiring;                                      // 0x185F(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEnhancedJump;                                  // 0x1860(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBlackWidow_RunState                          RunState;                                          // 0x1861(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1862[0x2];                                     // 0x1862(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargeDuration;                                    // 0x1864(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1868[0x8];                                     // 0x1868(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsViewingSelfInFirstPerspective();
	void OnRep_ElectronicState(EBlackWidowElectronicState OldState);
	void SetAimFiringState(bool bSetState);
	void SetAimingState(bool bSetState);
	void SetAimReloadingState(bool bSetState);
	void SetBlackWidowRunState(EBlackWidow_RunState InRunState);
	void SetElectronicState(EBlackWidowElectronicState ElecState);
	void SetElectronicStrength(float InStrength);
	void SetFiringingState(bool bSetState);
	void SetOpenMirrorShootReady(bool bSetState);
	void SetUltimateAimingState(bool bSetState);
	void SetUseEnhancedJump(bool bUse);

	EBlackWidowWeaponMode GetCurrentWeaponMode() const;
	EBlackWidowElectronicState GetElectronicState() const;
	float GetElectronicStrength() const;
	bool GetOpenMirrorShootReady() const;
	bool IsSwitchingToSniperRifle() const;
	bool IsSwitchingToStick() const;
	bool IsUsingSniperRifle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowCharacter">();
	}
	static class ABlackWidowCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlackWidowCharacter>();
	}
};
static_assert(alignof(ABlackWidowCharacter) == 0x000010, "Wrong alignment on ABlackWidowCharacter");
static_assert(sizeof(ABlackWidowCharacter) == 0x001870, "Wrong size on ABlackWidowCharacter");
static_assert(offsetof(ABlackWidowCharacter, bIsFiring) == 0x001810, "Member 'ABlackWidowCharacter::bIsFiring' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bIsReloading) == 0x001811, "Member 'ABlackWidowCharacter::bIsReloading' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bIsUltimateAiming) == 0x001812, "Member 'ABlackWidowCharacter::bIsUltimateAiming' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, WeaponRotator) == 0x001818, "Member 'ABlackWidowCharacter::WeaponRotator' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, WeaponRotationRate) == 0x001830, "Member 'ABlackWidowCharacter::WeaponRotationRate' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, WeaponRotationInterpSpeed) == 0x001834, "Member 'ABlackWidowCharacter::WeaponRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, WeaponMoveRotationMaxVec) == 0x001838, "Member 'ABlackWidowCharacter::WeaponMoveRotationMaxVec' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, WeaponMoveRotationMinVec) == 0x00183C, "Member 'ABlackWidowCharacter::WeaponMoveRotationMinVec' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, OnBlackWidowElectronicStateChanged) == 0x001840, "Member 'ABlackWidowCharacter::OnBlackWidowElectronicStateChanged' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, BlackWidowMoveLogic) == 0x001850, "Member 'ABlackWidowCharacter::BlackWidowMoveLogic' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, ElectronicStrength) == 0x001858, "Member 'ABlackWidowCharacter::ElectronicStrength' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, ElectronicState) == 0x00185C, "Member 'ABlackWidowCharacter::ElectronicState' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bOpenMirrorShootReady) == 0x00185D, "Member 'ABlackWidowCharacter::bOpenMirrorShootReady' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bIsScopeAiming) == 0x00185E, "Member 'ABlackWidowCharacter::bIsScopeAiming' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bIsAimFiring) == 0x00185F, "Member 'ABlackWidowCharacter::bIsAimFiring' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, bUseEnhancedJump) == 0x001860, "Member 'ABlackWidowCharacter::bUseEnhancedJump' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, RunState) == 0x001861, "Member 'ABlackWidowCharacter::RunState' has a wrong offset!");
static_assert(offsetof(ABlackWidowCharacter, ChargeDuration) == 0x001864, "Member 'ABlackWidowCharacter::ChargeDuration' has a wrong offset!");

// Class Hero_1033.ShootingLogic_103321
// 0x0000 (0x0DB8 - 0x0DB8)
class UShootingLogic_103321 final : public UShootingLogic_Instant
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShootingLogic_103321">();
	}
	static class UShootingLogic_103321* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShootingLogic_103321>();
	}
};
static_assert(alignof(UShootingLogic_103321) == 0x000008, "Wrong alignment on UShootingLogic_103321");
static_assert(sizeof(UShootingLogic_103321) == 0x000DB8, "Wrong size on UShootingLogic_103321");

// Class Hero_1033.BlackWidowMovementComponent
// 0x0010 (0x1B70 - 0x1B60)
class UBlackWidowMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	float                                         CustomGravityScale;                                // 0x1B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomGravity;                                 // 0x1B64(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B65[0xB];                                     // 0x1B65(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowMovementComponent">();
	}
	static class UBlackWidowMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowMovementComponent>();
	}
};
static_assert(alignof(UBlackWidowMovementComponent) == 0x000010, "Wrong alignment on UBlackWidowMovementComponent");
static_assert(sizeof(UBlackWidowMovementComponent) == 0x001B70, "Wrong size on UBlackWidowMovementComponent");
static_assert(offsetof(UBlackWidowMovementComponent, CustomGravityScale) == 0x001B60, "Member 'UBlackWidowMovementComponent::CustomGravityScale' has a wrong offset!");
static_assert(offsetof(UBlackWidowMovementComponent, bUseCustomGravity) == 0x001B64, "Member 'UBlackWidowMovementComponent::bUseCustomGravity' has a wrong offset!");

// Class Hero_1033.BlackWidowStickMeshComponent
// 0x0010 (0x16E0 - 0x16D0)
class UBlackWidowStickMeshComponent final : public USkeletalMeshComponent
{
public:
	bool                                          bHiddenWhile_103333;                               // 0x16D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16D1[0xF];                                     // 0x16D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHiddenWhile_103333(bool bInHiddenWhile_103333);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackWidowStickMeshComponent">();
	}
	static class UBlackWidowStickMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackWidowStickMeshComponent>();
	}
};
static_assert(alignof(UBlackWidowStickMeshComponent) == 0x000010, "Wrong alignment on UBlackWidowStickMeshComponent");
static_assert(sizeof(UBlackWidowStickMeshComponent) == 0x0016E0, "Wrong size on UBlackWidowStickMeshComponent");
static_assert(offsetof(UBlackWidowStickMeshComponent, bHiddenWhile_103333) == 0x0016D0, "Member 'UBlackWidowStickMeshComponent::bHiddenWhile_103333' has a wrong offset!");

// Class Hero_1033.KnockUp_10333301
// 0x0000 (0x1D98 - 0x1D98)
class UKnockUp_10333301 : public UMarvelKnockUpAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnockUp_10333301">();
	}
	static class UKnockUp_10333301* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnockUp_10333301>();
	}
};
static_assert(alignof(UKnockUp_10333301) == 0x000008, "Wrong alignment on UKnockUp_10333301");
static_assert(sizeof(UKnockUp_10333301) == 0x001D98, "Wrong size on UKnockUp_10333301");

}

