#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1025

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Engine_structs.hpp"
#include "Hero_1025_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK::Params
{

// Function Hero_1025.AbilityStatistics_102581.OnAdsorbStateUpdated
// 0x0001 (0x0001 - 0x0000)
struct AbilityStatistics_102581_OnAdsorbStateUpdated final
{
public:
	EAdsorbState                                  AdsorbState;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityStatistics_102581_OnAdsorbStateUpdated) == 0x000001, "Wrong alignment on AbilityStatistics_102581_OnAdsorbStateUpdated");
static_assert(sizeof(AbilityStatistics_102581_OnAdsorbStateUpdated) == 0x000001, "Wrong size on AbilityStatistics_102581_OnAdsorbStateUpdated");
static_assert(offsetof(AbilityStatistics_102581_OnAdsorbStateUpdated, AdsorbState) == 0x000000, "Member 'AbilityStatistics_102581_OnAdsorbStateUpdated::AdsorbState' has a wrong offset!");

// Function Hero_1025.Projectile_10251101.IsValidTargetToSpawnTreatScope
// 0x0178 (0x0178 - 0x0000)
struct Projectile_10251101_IsValidTargetToSpawnTreatScope final
{
public:
	struct FHitResult                             InHitResult;                                       // 0x0000(0x0170)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0170(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Projectile_10251101_IsValidTargetToSpawnTreatScope) == 0x000008, "Wrong alignment on Projectile_10251101_IsValidTargetToSpawnTreatScope");
static_assert(sizeof(Projectile_10251101_IsValidTargetToSpawnTreatScope) == 0x000178, "Wrong size on Projectile_10251101_IsValidTargetToSpawnTreatScope");
static_assert(offsetof(Projectile_10251101_IsValidTargetToSpawnTreatScope, InHitResult) == 0x000000, "Member 'Projectile_10251101_IsValidTargetToSpawnTreatScope::InHitResult' has a wrong offset!");
static_assert(offsetof(Projectile_10251101_IsValidTargetToSpawnTreatScope, ReturnValue) == 0x000170, "Member 'Projectile_10251101_IsValidTargetToSpawnTreatScope::ReturnValue' has a wrong offset!");

// Function Hero_1025.Cue_Scope_Loop_10251101.UpdateAlpha
// 0x001C (0x001C - 0x0000)
struct Cue_Scope_Loop_10251101_UpdateAlpha final
{
public:
	class FName                                   TrackName;                                         // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Scope_Loop_10251101_UpdateAlpha) == 0x000004, "Wrong alignment on Cue_Scope_Loop_10251101_UpdateAlpha");
static_assert(sizeof(Cue_Scope_Loop_10251101_UpdateAlpha) == 0x00001C, "Wrong size on Cue_Scope_Loop_10251101_UpdateAlpha");
static_assert(offsetof(Cue_Scope_Loop_10251101_UpdateAlpha, TrackName) == 0x000000, "Member 'Cue_Scope_Loop_10251101_UpdateAlpha::TrackName' has a wrong offset!");
static_assert(offsetof(Cue_Scope_Loop_10251101_UpdateAlpha, PropertyName) == 0x00000C, "Member 'Cue_Scope_Loop_10251101_UpdateAlpha::PropertyName' has a wrong offset!");
static_assert(offsetof(Cue_Scope_Loop_10251101_UpdateAlpha, Value) == 0x000018, "Member 'Cue_Scope_Loop_10251101_UpdateAlpha::Value' has a wrong offset!");

// DelegateFunction Hero_1025.Ability_102581.AdsorbStateDelegate__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct Ability_102581_AdsorbStateDelegate__DelegateSignature final
{
public:
	EAdsorbState                                  AdsorbState;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_102581_AdsorbStateDelegate__DelegateSignature) == 0x000001, "Wrong alignment on Ability_102581_AdsorbStateDelegate__DelegateSignature");
static_assert(sizeof(Ability_102581_AdsorbStateDelegate__DelegateSignature) == 0x000001, "Wrong size on Ability_102581_AdsorbStateDelegate__DelegateSignature");
static_assert(offsetof(Ability_102581_AdsorbStateDelegate__DelegateSignature, AdsorbState) == 0x000000, "Member 'Ability_102581_AdsorbStateDelegate__DelegateSignature::AdsorbState' has a wrong offset!");

// Function Hero_1025.Cue_Ability_Loop_10258101.GetReleaseAimRotation
// 0x0018 (0x0018 - 0x0000)
struct Cue_Ability_Loop_10258101_GetReleaseAimRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10258101_GetReleaseAimRotation) == 0x000008, "Wrong alignment on Cue_Ability_Loop_10258101_GetReleaseAimRotation");
static_assert(sizeof(Cue_Ability_Loop_10258101_GetReleaseAimRotation) == 0x000018, "Wrong size on Cue_Ability_Loop_10258101_GetReleaseAimRotation");
static_assert(offsetof(Cue_Ability_Loop_10258101_GetReleaseAimRotation, ReturnValue) == 0x000000, "Member 'Cue_Ability_Loop_10258101_GetReleaseAimRotation::ReturnValue' has a wrong offset!");

// Function Hero_1025.Cue_Ability_Loop_10258101.GetVisualHitLocation
// 0x0020 (0x0020 - 0x0000)
struct Cue_Ability_Loop_10258101_GetVisualHitLocation final
{
public:
	struct FVector                                OutLocation;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Cue_Ability_Loop_10258101_GetVisualHitLocation) == 0x000008, "Wrong alignment on Cue_Ability_Loop_10258101_GetVisualHitLocation");
static_assert(sizeof(Cue_Ability_Loop_10258101_GetVisualHitLocation) == 0x000020, "Wrong size on Cue_Ability_Loop_10258101_GetVisualHitLocation");
static_assert(offsetof(Cue_Ability_Loop_10258101_GetVisualHitLocation, OutLocation) == 0x000000, "Member 'Cue_Ability_Loop_10258101_GetVisualHitLocation::OutLocation' has a wrong offset!");
static_assert(offsetof(Cue_Ability_Loop_10258101_GetVisualHitLocation, ReturnValue) == 0x000018, "Member 'Cue_Ability_Loop_10258101_GetVisualHitLocation::ReturnValue' has a wrong offset!");

// Function Hero_1025.Cue_Ability_Loop_10258101.OnAdsorbStateUpdated
// 0x0001 (0x0001 - 0x0000)
struct Cue_Ability_Loop_10258101_OnAdsorbStateUpdated final
{
public:
	EAdsorbState                                  InAdsorbState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10258101_OnAdsorbStateUpdated) == 0x000001, "Wrong alignment on Cue_Ability_Loop_10258101_OnAdsorbStateUpdated");
static_assert(sizeof(Cue_Ability_Loop_10258101_OnAdsorbStateUpdated) == 0x000001, "Wrong size on Cue_Ability_Loop_10258101_OnAdsorbStateUpdated");
static_assert(offsetof(Cue_Ability_Loop_10258101_OnAdsorbStateUpdated, InAdsorbState) == 0x000000, "Member 'Cue_Ability_Loop_10258101_OnAdsorbStateUpdated::InAdsorbState' has a wrong offset!");

// Function Hero_1025.Cue_Ability_Loop_10258101.PlayAdsorbAudio
// 0x0008 (0x0008 - 0x0000)
struct Cue_Ability_Loop_10258101_PlayAdsorbAudio final
{
public:
	int32                                         AudioID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoop;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Cue_Ability_Loop_10258101_PlayAdsorbAudio) == 0x000004, "Wrong alignment on Cue_Ability_Loop_10258101_PlayAdsorbAudio");
static_assert(sizeof(Cue_Ability_Loop_10258101_PlayAdsorbAudio) == 0x000008, "Wrong size on Cue_Ability_Loop_10258101_PlayAdsorbAudio");
static_assert(offsetof(Cue_Ability_Loop_10258101_PlayAdsorbAudio, AudioID) == 0x000000, "Member 'Cue_Ability_Loop_10258101_PlayAdsorbAudio::AudioID' has a wrong offset!");
static_assert(offsetof(Cue_Ability_Loop_10258101_PlayAdsorbAudio, bIsLoop) == 0x000004, "Member 'Cue_Ability_Loop_10258101_PlayAdsorbAudio::bIsLoop' has a wrong offset!");

// Function Hero_1025.Cue_Ability_Loop_10258101.SetAllFXsVisible
// 0x0002 (0x0002 - 0x0000)
struct Cue_Ability_Loop_10258101_SetAllFXsVisible final
{
public:
	bool                                          bIsShow;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReset;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10258101_SetAllFXsVisible) == 0x000001, "Wrong alignment on Cue_Ability_Loop_10258101_SetAllFXsVisible");
static_assert(sizeof(Cue_Ability_Loop_10258101_SetAllFXsVisible) == 0x000002, "Wrong size on Cue_Ability_Loop_10258101_SetAllFXsVisible");
static_assert(offsetof(Cue_Ability_Loop_10258101_SetAllFXsVisible, bIsShow) == 0x000000, "Member 'Cue_Ability_Loop_10258101_SetAllFXsVisible::bIsShow' has a wrong offset!");
static_assert(offsetof(Cue_Ability_Loop_10258101_SetAllFXsVisible, bIsReset) == 0x000001, "Member 'Cue_Ability_Loop_10258101_SetAllFXsVisible::bIsReset' has a wrong offset!");

// Function Hero_1025.Cue_Ability_Loop_10258101.SetFXVisible
// 0x0010 (0x0010 - 0x0000)
struct Cue_Ability_Loop_10258101_SetFXVisible final
{
public:
	class UNiagaraComponent*                      OutNSComp;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShow;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReset;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Cue_Ability_Loop_10258101_SetFXVisible) == 0x000008, "Wrong alignment on Cue_Ability_Loop_10258101_SetFXVisible");
static_assert(sizeof(Cue_Ability_Loop_10258101_SetFXVisible) == 0x000010, "Wrong size on Cue_Ability_Loop_10258101_SetFXVisible");
static_assert(offsetof(Cue_Ability_Loop_10258101_SetFXVisible, OutNSComp) == 0x000000, "Member 'Cue_Ability_Loop_10258101_SetFXVisible::OutNSComp' has a wrong offset!");
static_assert(offsetof(Cue_Ability_Loop_10258101_SetFXVisible, bIsShow) == 0x000008, "Member 'Cue_Ability_Loop_10258101_SetFXVisible::bIsShow' has a wrong offset!");
static_assert(offsetof(Cue_Ability_Loop_10258101_SetFXVisible, bIsReset) == 0x000009, "Member 'Cue_Ability_Loop_10258101_SetFXVisible::bIsReset' has a wrong offset!");

// Function Hero_1025.Cue_Ability_Loop_10258101.StopAdsorbAudio
// 0x0004 (0x0004 - 0x0000)
struct Cue_Ability_Loop_10258101_StopAdsorbAudio final
{
public:
	int32                                         AudioID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10258101_StopAdsorbAudio) == 0x000004, "Wrong alignment on Cue_Ability_Loop_10258101_StopAdsorbAudio");
static_assert(sizeof(Cue_Ability_Loop_10258101_StopAdsorbAudio) == 0x000004, "Wrong size on Cue_Ability_Loop_10258101_StopAdsorbAudio");
static_assert(offsetof(Cue_Ability_Loop_10258101_StopAdsorbAudio, AudioID) == 0x000000, "Member 'Cue_Ability_Loop_10258101_StopAdsorbAudio::AudioID' has a wrong offset!");

// Function Hero_1025.Cue_Ability_Loop_10258101.UpdateAudios
// 0x0001 (0x0001 - 0x0000)
struct Cue_Ability_Loop_10258101_UpdateAudios final
{
public:
	EAdsorbState                                  LastAdsorbState;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10258101_UpdateAudios) == 0x000001, "Wrong alignment on Cue_Ability_Loop_10258101_UpdateAudios");
static_assert(sizeof(Cue_Ability_Loop_10258101_UpdateAudios) == 0x000001, "Wrong size on Cue_Ability_Loop_10258101_UpdateAudios");
static_assert(offsetof(Cue_Ability_Loop_10258101_UpdateAudios, LastAdsorbState) == 0x000000, "Member 'Cue_Ability_Loop_10258101_UpdateAudios::LastAdsorbState' has a wrong offset!");

// Function Hero_1025.Cue_Ability_Loop_10258101.UpdateHitFXLocation
// 0x0018 (0x0018 - 0x0000)
struct Cue_Ability_Loop_10258101_UpdateHitFXLocation final
{
public:
	struct FVector                                InLocation;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10258101_UpdateHitFXLocation) == 0x000008, "Wrong alignment on Cue_Ability_Loop_10258101_UpdateHitFXLocation");
static_assert(sizeof(Cue_Ability_Loop_10258101_UpdateHitFXLocation) == 0x000018, "Wrong size on Cue_Ability_Loop_10258101_UpdateHitFXLocation");
static_assert(offsetof(Cue_Ability_Loop_10258101_UpdateHitFXLocation, InLocation) == 0x000000, "Member 'Cue_Ability_Loop_10258101_UpdateHitFXLocation::InLocation' has a wrong offset!");

// Function Hero_1025.Cue_Ability_Loop_10258101.UpdateLinkFXParam
// 0x0018 (0x0018 - 0x0000)
struct Cue_Ability_Loop_10258101_UpdateLinkFXParam final
{
public:
	struct FVector                                InHitLocation;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10258101_UpdateLinkFXParam) == 0x000008, "Wrong alignment on Cue_Ability_Loop_10258101_UpdateLinkFXParam");
static_assert(sizeof(Cue_Ability_Loop_10258101_UpdateLinkFXParam) == 0x000018, "Wrong size on Cue_Ability_Loop_10258101_UpdateLinkFXParam");
static_assert(offsetof(Cue_Ability_Loop_10258101_UpdateLinkFXParam, InHitLocation) == 0x000000, "Member 'Cue_Ability_Loop_10258101_UpdateLinkFXParam::InHitLocation' has a wrong offset!");

// Function Hero_1025.Cue_Scope_Loop_10259101.OnScopeEnd
// 0x0008 (0x0008 - 0x0000)
struct Cue_Scope_Loop_10259101_OnScopeEnd final
{
public:
	class AActor*                                 OutScope;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Scope_Loop_10259101_OnScopeEnd) == 0x000008, "Wrong alignment on Cue_Scope_Loop_10259101_OnScopeEnd");
static_assert(sizeof(Cue_Scope_Loop_10259101_OnScopeEnd) == 0x000008, "Wrong size on Cue_Scope_Loop_10259101_OnScopeEnd");
static_assert(offsetof(Cue_Scope_Loop_10259101_OnScopeEnd, OutScope) == 0x000000, "Member 'Cue_Scope_Loop_10259101_OnScopeEnd::OutScope' has a wrong offset!");

// Function Hero_1025.CloakAndDaggerCharacter.GetCurrentCharacterType
// 0x0001 (0x0001 - 0x0000)
struct CloakAndDaggerCharacter_GetCurrentCharacterType final
{
public:
	EDaggerCharacterType                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CloakAndDaggerCharacter_GetCurrentCharacterType) == 0x000001, "Wrong alignment on CloakAndDaggerCharacter_GetCurrentCharacterType");
static_assert(sizeof(CloakAndDaggerCharacter_GetCurrentCharacterType) == 0x000001, "Wrong size on CloakAndDaggerCharacter_GetCurrentCharacterType");
static_assert(offsetof(CloakAndDaggerCharacter_GetCurrentCharacterType, ReturnValue) == 0x000000, "Member 'CloakAndDaggerCharacter_GetCurrentCharacterType::ReturnValue' has a wrong offset!");

// Function Hero_1025.CloakAndDaggerCharacter.SetCurrentCharacterType
// 0x0001 (0x0001 - 0x0000)
struct CloakAndDaggerCharacter_SetCurrentCharacterType final
{
public:
	EDaggerCharacterType                          CharacterType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CloakAndDaggerCharacter_SetCurrentCharacterType) == 0x000001, "Wrong alignment on CloakAndDaggerCharacter_SetCurrentCharacterType");
static_assert(sizeof(CloakAndDaggerCharacter_SetCurrentCharacterType) == 0x000001, "Wrong size on CloakAndDaggerCharacter_SetCurrentCharacterType");
static_assert(offsetof(CloakAndDaggerCharacter_SetCurrentCharacterType, CharacterType) == 0x000000, "Member 'CloakAndDaggerCharacter_SetCurrentCharacterType::CharacterType' has a wrong offset!");

// Function Hero_1025.NiagaraComponent_Cloak.IsOwnerMoving
// 0x0001 (0x0001 - 0x0000)
struct NiagaraComponent_Cloak_IsOwnerMoving final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraComponent_Cloak_IsOwnerMoving) == 0x000001, "Wrong alignment on NiagaraComponent_Cloak_IsOwnerMoving");
static_assert(sizeof(NiagaraComponent_Cloak_IsOwnerMoving) == 0x000001, "Wrong size on NiagaraComponent_Cloak_IsOwnerMoving");
static_assert(offsetof(NiagaraComponent_Cloak_IsOwnerMoving, ReturnValue) == 0x000000, "Member 'NiagaraComponent_Cloak_IsOwnerMoving::ReturnValue' has a wrong offset!");

// Function Hero_1025.NiagaraComponent_Cloak.SetEffectOpacity
// 0x0004 (0x0004 - 0x0000)
struct NiagaraComponent_Cloak_SetEffectOpacity final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraComponent_Cloak_SetEffectOpacity) == 0x000004, "Wrong alignment on NiagaraComponent_Cloak_SetEffectOpacity");
static_assert(sizeof(NiagaraComponent_Cloak_SetEffectOpacity) == 0x000004, "Wrong size on NiagaraComponent_Cloak_SetEffectOpacity");
static_assert(offsetof(NiagaraComponent_Cloak_SetEffectOpacity, InValue) == 0x000000, "Member 'NiagaraComponent_Cloak_SetEffectOpacity::InValue' has a wrong offset!");

// Function Hero_1025.NiagaraComponent_Cloak.UpdateAlpha
// 0x001C (0x001C - 0x0000)
struct NiagaraComponent_Cloak_UpdateAlpha final
{
public:
	class FName                                   TrackName;                                         // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraComponent_Cloak_UpdateAlpha) == 0x000004, "Wrong alignment on NiagaraComponent_Cloak_UpdateAlpha");
static_assert(sizeof(NiagaraComponent_Cloak_UpdateAlpha) == 0x00001C, "Wrong size on NiagaraComponent_Cloak_UpdateAlpha");
static_assert(offsetof(NiagaraComponent_Cloak_UpdateAlpha, TrackName) == 0x000000, "Member 'NiagaraComponent_Cloak_UpdateAlpha::TrackName' has a wrong offset!");
static_assert(offsetof(NiagaraComponent_Cloak_UpdateAlpha, PropertyName) == 0x00000C, "Member 'NiagaraComponent_Cloak_UpdateAlpha::PropertyName' has a wrong offset!");
static_assert(offsetof(NiagaraComponent_Cloak_UpdateAlpha, Value) == 0x000018, "Member 'NiagaraComponent_Cloak_UpdateAlpha::Value' has a wrong offset!");

// Function Hero_1025.CloakChildActor.OnCharacterDeath
// 0x0028 (0x0028 - 0x0000)
struct CloakChildActor_OnCharacterDeath final
{
public:
	class AActor*                                 OutSourceAvatar;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OutTargetAvatar;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeModifierHandle               ModifierParameterHandle;                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CloakChildActor_OnCharacterDeath) == 0x000008, "Wrong alignment on CloakChildActor_OnCharacterDeath");
static_assert(sizeof(CloakChildActor_OnCharacterDeath) == 0x000028, "Wrong size on CloakChildActor_OnCharacterDeath");
static_assert(offsetof(CloakChildActor_OnCharacterDeath, OutSourceAvatar) == 0x000000, "Member 'CloakChildActor_OnCharacterDeath::OutSourceAvatar' has a wrong offset!");
static_assert(offsetof(CloakChildActor_OnCharacterDeath, OutTargetAvatar) == 0x000008, "Member 'CloakChildActor_OnCharacterDeath::OutTargetAvatar' has a wrong offset!");
static_assert(offsetof(CloakChildActor_OnCharacterDeath, ModifierParameterHandle) == 0x000010, "Member 'CloakChildActor_OnCharacterDeath::ModifierParameterHandle' has a wrong offset!");

// Function Hero_1025.CloakChildActor.OnCharacterReborn
// 0x0740 (0x0740 - 0x0000)
struct CloakChildActor_OnCharacterReborn final
{
public:
	class AActor*                                 OutTargetActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterRebornParam                  Param;                                             // 0x0010(0x0730)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CloakChildActor_OnCharacterReborn) == 0x000010, "Wrong alignment on CloakChildActor_OnCharacterReborn");
static_assert(sizeof(CloakChildActor_OnCharacterReborn) == 0x000740, "Wrong size on CloakChildActor_OnCharacterReborn");
static_assert(offsetof(CloakChildActor_OnCharacterReborn, OutTargetActor) == 0x000000, "Member 'CloakChildActor_OnCharacterReborn::OutTargetActor' has a wrong offset!");
static_assert(offsetof(CloakChildActor_OnCharacterReborn, Param) == 0x000010, "Member 'CloakChildActor_OnCharacterReborn::Param' has a wrong offset!");

// Function Hero_1025.CloakChildActor.OnTagUpdate
// 0x0010 (0x0010 - 0x0000)
struct CloakChildActor_OnTagUpdate final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTagExists;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CloakChildActor_OnTagUpdate) == 0x000004, "Wrong alignment on CloakChildActor_OnTagUpdate");
static_assert(sizeof(CloakChildActor_OnTagUpdate) == 0x000010, "Wrong size on CloakChildActor_OnTagUpdate");
static_assert(offsetof(CloakChildActor_OnTagUpdate, Tag) == 0x000000, "Member 'CloakChildActor_OnTagUpdate::Tag' has a wrong offset!");
static_assert(offsetof(CloakChildActor_OnTagUpdate, bTagExists) == 0x00000C, "Member 'CloakChildActor_OnTagUpdate::bTagExists' has a wrong offset!");

// Function Hero_1025.EpicMomentAction_1025.OnGameplayEffectAppliedToTarget
// 0x0018 (0x0018 - 0x0000)
struct EpicMomentAction_1025_OnGameplayEffectAppliedToTarget final
{
public:
	class UAbilitySystemComponent*                ASC;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecStackHandle         GameplayEffectSpecHandle;                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveGameplayEffectHandle;                        // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EpicMomentAction_1025_OnGameplayEffectAppliedToTarget) == 0x000008, "Wrong alignment on EpicMomentAction_1025_OnGameplayEffectAppliedToTarget");
static_assert(sizeof(EpicMomentAction_1025_OnGameplayEffectAppliedToTarget) == 0x000018, "Wrong size on EpicMomentAction_1025_OnGameplayEffectAppliedToTarget");
static_assert(offsetof(EpicMomentAction_1025_OnGameplayEffectAppliedToTarget, ASC) == 0x000000, "Member 'EpicMomentAction_1025_OnGameplayEffectAppliedToTarget::ASC' has a wrong offset!");
static_assert(offsetof(EpicMomentAction_1025_OnGameplayEffectAppliedToTarget, GameplayEffectSpecHandle) == 0x000008, "Member 'EpicMomentAction_1025_OnGameplayEffectAppliedToTarget::GameplayEffectSpecHandle' has a wrong offset!");
static_assert(offsetof(EpicMomentAction_1025_OnGameplayEffectAppliedToTarget, ActiveGameplayEffectHandle) == 0x000010, "Member 'EpicMomentAction_1025_OnGameplayEffectAppliedToTarget::ActiveGameplayEffectHandle' has a wrong offset!");

// Function Hero_1025.EpicMomentAction_1025.OnScopeBegin
// 0x0060 (0x0060 - 0x0000)
struct EpicMomentAction_1025_OnScopeBegin final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelGameplayAbility*                 SourceAbility;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Scope;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelTargetActorGenerateInfo         GenerateInfo;                                      // 0x0018(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EpicMomentAction_1025_OnScopeBegin) == 0x000008, "Wrong alignment on EpicMomentAction_1025_OnScopeBegin");
static_assert(sizeof(EpicMomentAction_1025_OnScopeBegin) == 0x000060, "Wrong size on EpicMomentAction_1025_OnScopeBegin");
static_assert(offsetof(EpicMomentAction_1025_OnScopeBegin, SourceActor) == 0x000000, "Member 'EpicMomentAction_1025_OnScopeBegin::SourceActor' has a wrong offset!");
static_assert(offsetof(EpicMomentAction_1025_OnScopeBegin, SourceAbility) == 0x000008, "Member 'EpicMomentAction_1025_OnScopeBegin::SourceAbility' has a wrong offset!");
static_assert(offsetof(EpicMomentAction_1025_OnScopeBegin, Scope) == 0x000010, "Member 'EpicMomentAction_1025_OnScopeBegin::Scope' has a wrong offset!");
static_assert(offsetof(EpicMomentAction_1025_OnScopeBegin, GenerateInfo) == 0x000018, "Member 'EpicMomentAction_1025_OnScopeBegin::GenerateInfo' has a wrong offset!");

// Function Hero_1025.EpicMomentAction_1025.OnScopeEnd
// 0x0008 (0x0008 - 0x0000)
struct EpicMomentAction_1025_OnScopeEnd final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EpicMomentAction_1025_OnScopeEnd) == 0x000008, "Wrong alignment on EpicMomentAction_1025_OnScopeEnd");
static_assert(sizeof(EpicMomentAction_1025_OnScopeEnd) == 0x000008, "Wrong size on EpicMomentAction_1025_OnScopeEnd");
static_assert(offsetof(EpicMomentAction_1025_OnScopeEnd, InActor) == 0x000000, "Member 'EpicMomentAction_1025_OnScopeEnd::InActor' has a wrong offset!");

}

