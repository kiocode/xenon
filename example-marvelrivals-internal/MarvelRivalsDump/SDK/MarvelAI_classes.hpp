#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MarvelAI

#include "Basic.hpp"

#include "UESVON_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "MarvelAI_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "InputRecord_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "NavigationSystem_classes.hpp"


namespace SDK
{

// Class MarvelAI.ActionRequirementBase
// 0x0008 (0x0038 - 0x0030)
class UActionRequirementBase : public UObject
{
public:
	bool                                          Invert;                                            // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Requirement(class AAIController* OwnerController, class AActor* ControlledPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionRequirementBase">();
	}
	static class UActionRequirementBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionRequirementBase>();
	}
};
static_assert(alignof(UActionRequirementBase) == 0x000008, "Wrong alignment on UActionRequirementBase");
static_assert(sizeof(UActionRequirementBase) == 0x000038, "Wrong size on UActionRequirementBase");
static_assert(offsetof(UActionRequirementBase, Invert) == 0x000030, "Member 'UActionRequirementBase::Invert' has a wrong offset!");

// Class MarvelAI.Requirement_BattleCalculate
// 0x0020 (0x0058 - 0x0038)
class URequirement_BattleCalculate final : public UActionRequirementBase
{
public:
	ECalculateType                                CalculateType;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIFilterSide                                 LeftFilterSide;                                    // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPropertyValueType                            LeftValueType;                                     // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeftAlive;                                         // 0x003B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftCoefficient;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMarvelArithmeticOperation                    ArithmeticOperation;                               // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIFilterSide                                 RightFilterSide;                                   // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPropertyValueType                            RightValueType;                                    // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RightAlive;                                        // 0x0043(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightCoefficient;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Description;                                       // 0x0048(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Requirement_BattleCalculate">();
	}
	static class URequirement_BattleCalculate* GetDefaultObj()
	{
		return GetDefaultObjImpl<URequirement_BattleCalculate>();
	}
};
static_assert(alignof(URequirement_BattleCalculate) == 0x000008, "Wrong alignment on URequirement_BattleCalculate");
static_assert(sizeof(URequirement_BattleCalculate) == 0x000058, "Wrong size on URequirement_BattleCalculate");
static_assert(offsetof(URequirement_BattleCalculate, CalculateType) == 0x000038, "Member 'URequirement_BattleCalculate::CalculateType' has a wrong offset!");
static_assert(offsetof(URequirement_BattleCalculate, LeftFilterSide) == 0x000039, "Member 'URequirement_BattleCalculate::LeftFilterSide' has a wrong offset!");
static_assert(offsetof(URequirement_BattleCalculate, LeftValueType) == 0x00003A, "Member 'URequirement_BattleCalculate::LeftValueType' has a wrong offset!");
static_assert(offsetof(URequirement_BattleCalculate, LeftAlive) == 0x00003B, "Member 'URequirement_BattleCalculate::LeftAlive' has a wrong offset!");
static_assert(offsetof(URequirement_BattleCalculate, LeftCoefficient) == 0x00003C, "Member 'URequirement_BattleCalculate::LeftCoefficient' has a wrong offset!");
static_assert(offsetof(URequirement_BattleCalculate, ArithmeticOperation) == 0x000040, "Member 'URequirement_BattleCalculate::ArithmeticOperation' has a wrong offset!");
static_assert(offsetof(URequirement_BattleCalculate, RightFilterSide) == 0x000041, "Member 'URequirement_BattleCalculate::RightFilterSide' has a wrong offset!");
static_assert(offsetof(URequirement_BattleCalculate, RightValueType) == 0x000042, "Member 'URequirement_BattleCalculate::RightValueType' has a wrong offset!");
static_assert(offsetof(URequirement_BattleCalculate, RightAlive) == 0x000043, "Member 'URequirement_BattleCalculate::RightAlive' has a wrong offset!");
static_assert(offsetof(URequirement_BattleCalculate, RightCoefficient) == 0x000044, "Member 'URequirement_BattleCalculate::RightCoefficient' has a wrong offset!");
static_assert(offsetof(URequirement_BattleCalculate, Description) == 0x000048, "Member 'URequirement_BattleCalculate::Description' has a wrong offset!");

// Class MarvelAI.MarvelAISubsystem
// 0x0000 (0x0040 - 0x0040)
class UMarvelAISubsystem : public UAISubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAISubsystem">();
	}
	static class UMarvelAISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAISubsystem>();
	}
};
static_assert(alignof(UMarvelAISubsystem) == 0x000008, "Wrong alignment on UMarvelAISubsystem");
static_assert(sizeof(UMarvelAISubsystem) == 0x000040, "Wrong size on UMarvelAISubsystem");

// Class MarvelAI.AbilityTacticsManager
// 0x00C0 (0x0100 - 0x0040)
class UAbilityTacticsManager final : public UMarvelAISubsystem
{
public:
	TArray<struct FAbilityTacticsRequest>         TacticsRequests;                                   // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class UClass*, class UAbilityTacticsTask*> TaskObjectPool;                                    // 0x0050(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int32, TSubclassOf<class UAbilityTacticsTask>> TacticsTaskClasses;                                // 0x00A0(0x0050)(Edit, EditFixedSize, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTacticsManager">();
	}
	static class UAbilityTacticsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTacticsManager>();
	}
};
static_assert(alignof(UAbilityTacticsManager) == 0x000008, "Wrong alignment on UAbilityTacticsManager");
static_assert(sizeof(UAbilityTacticsManager) == 0x000100, "Wrong size on UAbilityTacticsManager");
static_assert(offsetof(UAbilityTacticsManager, TacticsRequests) == 0x000040, "Member 'UAbilityTacticsManager::TacticsRequests' has a wrong offset!");
static_assert(offsetof(UAbilityTacticsManager, TaskObjectPool) == 0x000050, "Member 'UAbilityTacticsManager::TaskObjectPool' has a wrong offset!");
static_assert(offsetof(UAbilityTacticsManager, TacticsTaskClasses) == 0x0000A0, "Member 'UAbilityTacticsManager::TacticsTaskClasses' has a wrong offset!");

// Class MarvelAI.BTService_MarvelInstancedBase
// 0x0008 (0x00A8 - 0x00A0)
class UBTService_MarvelInstancedBase : public UBTService_BlueprintBase
{
public:
	class AMarvelAIController*                    MarvelAIOwner;                                     // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDestroyed(class UBehaviorTreeComponent* OwnerComp);

	class AMarvelBaseCharacter* K2_GetControlledHero() const;
	class APawn* K2_GetControlledPawn() const;
	class AMarvelAIController* K2_GetMarvelAIOwner() const;
	class UBehaviorTreeComponent* K2_GetOwnerBTComp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_MarvelInstancedBase">();
	}
	static class UBTService_MarvelInstancedBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_MarvelInstancedBase>();
	}
};
static_assert(alignof(UBTService_MarvelInstancedBase) == 0x000008, "Wrong alignment on UBTService_MarvelInstancedBase");
static_assert(sizeof(UBTService_MarvelInstancedBase) == 0x0000A8, "Wrong size on UBTService_MarvelInstancedBase");
static_assert(offsetof(UBTService_MarvelInstancedBase, MarvelAIOwner) == 0x0000A0, "Member 'UBTService_MarvelInstancedBase::MarvelAIOwner' has a wrong offset!");

// Class MarvelAI.AbilityTacticsTask
// 0x0118 (0x0148 - 0x0030)
class UAbilityTacticsTask : public UObject
{
public:
	uint8                                         Pad_30[0xB8];                                      // 0x0030(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAIAbilitySelectCheckBase>  SelectCheckClass;                                  // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UseIndex;                                          // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UAIAbilitySelectCheckBase>, class UAIAbilitySelectCheckBase*> CheckObjectMap;                                    // 0x00F8(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	class UAIAbilitySelectCheckBase* GetSelectCheck() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTacticsTask">();
	}
	static class UAbilityTacticsTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTacticsTask>();
	}
};
static_assert(alignof(UAbilityTacticsTask) == 0x000008, "Wrong alignment on UAbilityTacticsTask");
static_assert(sizeof(UAbilityTacticsTask) == 0x000148, "Wrong size on UAbilityTacticsTask");
static_assert(offsetof(UAbilityTacticsTask, SelectCheckClass) == 0x0000E8, "Member 'UAbilityTacticsTask::SelectCheckClass' has a wrong offset!");
static_assert(offsetof(UAbilityTacticsTask, UseIndex) == 0x0000F0, "Member 'UAbilityTacticsTask::UseIndex' has a wrong offset!");
static_assert(offsetof(UAbilityTacticsTask, CheckObjectMap) == 0x0000F8, "Member 'UAbilityTacticsTask::CheckObjectMap' has a wrong offset!");

// Class MarvelAI.AbilityTacticsTask_AILab
// 0x0030 (0x0178 - 0x0148)
class UAbilityTacticsTask_AILab final : public UAbilityTacticsTask
{
public:
	uint8                                         Pad_148[0x4];                                      // 0x0148(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAITag                         AITag;                                             // 0x014C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x10];                                     // 0x0158(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIServerRequestServices*               AIServerRequestServices;                           // 0x0168(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeOut;                                        // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAIAbilityServerResponse(bool bSuccess, int64 RequestID, int32 UID, const struct FAIServerResponseProtocol& AIServerResponseProtocol, const struct FAIServerResponseCode& AIServerResponseCode, class AMarvelAIController* AIController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTacticsTask_AILab">();
	}
	static class UAbilityTacticsTask_AILab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTacticsTask_AILab>();
	}
};
static_assert(alignof(UAbilityTacticsTask_AILab) == 0x000008, "Wrong alignment on UAbilityTacticsTask_AILab");
static_assert(sizeof(UAbilityTacticsTask_AILab) == 0x000178, "Wrong size on UAbilityTacticsTask_AILab");
static_assert(offsetof(UAbilityTacticsTask_AILab, AITag) == 0x00014C, "Member 'UAbilityTacticsTask_AILab::AITag' has a wrong offset!");
static_assert(offsetof(UAbilityTacticsTask_AILab, AIServerRequestServices) == 0x000168, "Member 'UAbilityTacticsTask_AILab::AIServerRequestServices' has a wrong offset!");
static_assert(offsetof(UAbilityTacticsTask_AILab, MaxTimeOut) == 0x000170, "Member 'UAbilityTacticsTask_AILab::MaxTimeOut' has a wrong offset!");

// Class MarvelAI.BTDecorator_MarvelInstancedBase
// 0x0010 (0x00B8 - 0x00A8)
class UBTDecorator_MarvelInstancedBase : public UBTDecorator_BlueprintBase
{
public:
	class AMarvelAIController*                    MarvelAIOwner;                                     // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Interval;                                          // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomDeviation;                                   // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AMarvelBaseCharacter* K2_GetControlledHero() const;
	class APawn* K2_GetControlledPawn() const;
	class AMarvelAIController* K2_GetMarvelAIOwner() const;
	class UBehaviorTreeComponent* K2_GetOwnerBTComp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_MarvelInstancedBase">();
	}
	static class UBTDecorator_MarvelInstancedBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_MarvelInstancedBase>();
	}
};
static_assert(alignof(UBTDecorator_MarvelInstancedBase) == 0x000008, "Wrong alignment on UBTDecorator_MarvelInstancedBase");
static_assert(sizeof(UBTDecorator_MarvelInstancedBase) == 0x0000B8, "Wrong size on UBTDecorator_MarvelInstancedBase");
static_assert(offsetof(UBTDecorator_MarvelInstancedBase, MarvelAIOwner) == 0x0000A8, "Member 'UBTDecorator_MarvelInstancedBase::MarvelAIOwner' has a wrong offset!");
static_assert(offsetof(UBTDecorator_MarvelInstancedBase, Interval) == 0x0000B0, "Member 'UBTDecorator_MarvelInstancedBase::Interval' has a wrong offset!");
static_assert(offsetof(UBTDecorator_MarvelInstancedBase, RandomDeviation) == 0x0000B4, "Member 'UBTDecorator_MarvelInstancedBase::RandomDeviation' has a wrong offset!");

// Class MarvelAI.BTD_CheckGameplayTag
// 0x0070 (0x0128 - 0x00B8)
class UBTD_CheckGameplayTag : public UBTDecorator_MarvelInstancedBase
{
public:
	struct FGameplayTagContainer                  TagsToCheck;                                       // 0x00B8(0x0068)(Edit, NativeAccessSpecifierPrivate)
	EGameplayContainerMatchType                   MatchType;                                         // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_CheckGameplayTag">();
	}
	static class UBTD_CheckGameplayTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_CheckGameplayTag>();
	}
};
static_assert(alignof(UBTD_CheckGameplayTag) == 0x000008, "Wrong alignment on UBTD_CheckGameplayTag");
static_assert(sizeof(UBTD_CheckGameplayTag) == 0x000128, "Wrong size on UBTD_CheckGameplayTag");
static_assert(offsetof(UBTD_CheckGameplayTag, TagsToCheck) == 0x0000B8, "Member 'UBTD_CheckGameplayTag::TagsToCheck' has a wrong offset!");
static_assert(offsetof(UBTD_CheckGameplayTag, MatchType) == 0x000120, "Member 'UBTD_CheckGameplayTag::MatchType' has a wrong offset!");

// Class MarvelAI.AbilityTacticsTask_AutoAbility
// 0x0000 (0x0148 - 0x0148)
class UAbilityTacticsTask_AutoAbility final : public UAbilityTacticsTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTacticsTask_AutoAbility">();
	}
	static class UAbilityTacticsTask_AutoAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTacticsTask_AutoAbility>();
	}
};
static_assert(alignof(UAbilityTacticsTask_AutoAbility) == 0x000008, "Wrong alignment on UAbilityTacticsTask_AutoAbility");
static_assert(sizeof(UAbilityTacticsTask_AutoAbility) == 0x000148, "Wrong size on UAbilityTacticsTask_AutoAbility");

// Class MarvelAI.AbilityTacticsTask_SingleAbility
// 0x0000 (0x0148 - 0x0148)
class UAbilityTacticsTask_SingleAbility final : public UAbilityTacticsTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTacticsTask_SingleAbility">();
	}
	static class UAbilityTacticsTask_SingleAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTacticsTask_SingleAbility>();
	}
};
static_assert(alignof(UAbilityTacticsTask_SingleAbility) == 0x000008, "Wrong alignment on UAbilityTacticsTask_SingleAbility");
static_assert(sizeof(UAbilityTacticsTask_SingleAbility) == 0x000148, "Wrong size on UAbilityTacticsTask_SingleAbility");

// Class MarvelAI.EnvQueryTest_EvadeTarget
// 0x1140 (0x13C0 - 0x0280)
class UEnvQueryTest_EvadeTarget final : public UEnvQueryTest
{
public:
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x0280(0x0F90)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAITagMatchParameter>           TagMatchParameters;                                // 0x1210(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAbilityCheckConfig                    Asset;                                             // 0x1220(0x0198)(Edit, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B8[0x8];                                     // 0x13B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_EvadeTarget">();
	}
	static class UEnvQueryTest_EvadeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_EvadeTarget>();
	}
};
static_assert(alignof(UEnvQueryTest_EvadeTarget) == 0x000010, "Wrong alignment on UEnvQueryTest_EvadeTarget");
static_assert(sizeof(UEnvQueryTest_EvadeTarget) == 0x0013C0, "Wrong size on UEnvQueryTest_EvadeTarget");
static_assert(offsetof(UEnvQueryTest_EvadeTarget, TraceContext) == 0x000280, "Member 'UEnvQueryTest_EvadeTarget::TraceContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_EvadeTarget, TagMatchParameters) == 0x001210, "Member 'UEnvQueryTest_EvadeTarget::TagMatchParameters' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_EvadeTarget, Asset) == 0x001220, "Member 'UEnvQueryTest_EvadeTarget::Asset' has a wrong offset!");

// Class MarvelAI.AbilityTacticsTaskInterface
// 0x0000 (0x0030 - 0x0030)
class IAbilityTacticsTaskInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTacticsTaskInterface">();
	}
	static class IAbilityTacticsTaskInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAbilityTacticsTaskInterface>();
	}
};
static_assert(alignof(IAbilityTacticsTaskInterface) == 0x000008, "Wrong alignment on IAbilityTacticsTaskInterface");
static_assert(sizeof(IAbilityTacticsTaskInterface) == 0x000030, "Wrong size on IAbilityTacticsTaskInterface");

// Class MarvelAI.StandPointBase
// 0x00A8 (0x0560 - 0x04B8)
class AStandPointBase : public ANavigationObjectBase
{
public:
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBattleSide, int32>                      OwnedStateMap;                                     // 0x04C0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelAIController*>            OwnedControllerList;                               // 0x0510(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_520[0x4];                                      // 0x0520(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PointName;                                         // 0x0524(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0530(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EStandPointType                               StandPointType;                                    // 0x0548(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIStandPointTeamType                         TeamType;                                          // 0x0549(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54A[0x2];                                      // 0x054A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x054C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomRadius;                                      // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitFlyHeight;                                   // 0x0554(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_555[0x3];                                      // 0x0555(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinFlyHeight;                                      // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFlyHeight;                                      // 0x055C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BindController(const class AMarvelAIController* InController);
	struct FVector GetFlyGoalLocation(class AActor* MovingActor);
	struct FVector GetFocusPosition();
	struct FVector GetLandGoalLocation(class AActor* MovingActor);
	void UnbindController(const class AMarvelAIController* InController);

	bool CheckIsValid(class AMarvelAIController* AIController, bool bAllowedMulti) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StandPointBase">();
	}
	static class AStandPointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStandPointBase>();
	}
};
static_assert(alignof(AStandPointBase) == 0x000008, "Wrong alignment on AStandPointBase");
static_assert(sizeof(AStandPointBase) == 0x000560, "Wrong size on AStandPointBase");
static_assert(offsetof(AStandPointBase, OwnedStateMap) == 0x0004C0, "Member 'AStandPointBase::OwnedStateMap' has a wrong offset!");
static_assert(offsetof(AStandPointBase, OwnedControllerList) == 0x000510, "Member 'AStandPointBase::OwnedControllerList' has a wrong offset!");
static_assert(offsetof(AStandPointBase, PointName) == 0x000524, "Member 'AStandPointBase::PointName' has a wrong offset!");
static_assert(offsetof(AStandPointBase, Description) == 0x000530, "Member 'AStandPointBase::Description' has a wrong offset!");
static_assert(offsetof(AStandPointBase, StandPointType) == 0x000548, "Member 'AStandPointBase::StandPointType' has a wrong offset!");
static_assert(offsetof(AStandPointBase, TeamType) == 0x000549, "Member 'AStandPointBase::TeamType' has a wrong offset!");
static_assert(offsetof(AStandPointBase, Weight) == 0x00054C, "Member 'AStandPointBase::Weight' has a wrong offset!");
static_assert(offsetof(AStandPointBase, RandomRadius) == 0x000550, "Member 'AStandPointBase::RandomRadius' has a wrong offset!");
static_assert(offsetof(AStandPointBase, bLimitFlyHeight) == 0x000554, "Member 'AStandPointBase::bLimitFlyHeight' has a wrong offset!");
static_assert(offsetof(AStandPointBase, MinFlyHeight) == 0x000558, "Member 'AStandPointBase::MinFlyHeight' has a wrong offset!");
static_assert(offsetof(AStandPointBase, MaxFlyHeight) == 0x00055C, "Member 'AStandPointBase::MaxFlyHeight' has a wrong offset!");

// Class MarvelAI.AICommunicateAsset
// 0x0050 (0x0088 - 0x0038)
class UAICommunicateAsset final : public UPrimaryDataAsset
{
public:
	struct FAICommunicateData                     Communicate;                                       // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICommunicateAsset">();
	}
	static class UAICommunicateAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICommunicateAsset>();
	}
};
static_assert(alignof(UAICommunicateAsset) == 0x000008, "Wrong alignment on UAICommunicateAsset");
static_assert(sizeof(UAICommunicateAsset) == 0x000088, "Wrong size on UAICommunicateAsset");
static_assert(offsetof(UAICommunicateAsset, Communicate) == 0x000038, "Member 'UAICommunicateAsset::Communicate' has a wrong offset!");

// Class MarvelAI.AbilityUsageStandPoint
// 0x0068 (0x05C8 - 0x0560)
class AAbilityUsageStandPoint : public AStandPointBase
{
public:
	TArray<struct FAbilityUsagePointData>         AbilityDataList;                                   // 0x0560(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EBattleSide                                   RequiredBattleSide;                                // 0x0570(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldCheckGameplayProgress;                      // 0x0571(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_572[0x2];                                      // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayProgress                      RequiredGameplayProgress;                          // 0x0574(0x000C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAbilityUsagePointData>         ProcessedAbilityDataList;                          // 0x0580(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         AbilityDataIndex;                                  // 0x0590(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointIndex;                                        // 0x0594(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  TargetPositionActor;                               // 0x0598(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CheckIsValidPointToUse(class AMarvelBaseCharacter* ToCheckHero, class UAIAbilityUsageObject* AbilityUsage);
	bool PyCheckGameplayProgressIsMatch();
	void SetUsagePositionToActor();

	bool CheckIsValidByAbilityUsageId(int32 AbilityUsageID) const;
	void DrawUsagePositions() const;
	bool GetDataForUsage(const class UAIAbilityUsageObject* InAbilityUsage, struct FAbilityUsagePointData* OutData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityUsageStandPoint">();
	}
	static class AAbilityUsageStandPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilityUsageStandPoint>();
	}
};
static_assert(alignof(AAbilityUsageStandPoint) == 0x000008, "Wrong alignment on AAbilityUsageStandPoint");
static_assert(sizeof(AAbilityUsageStandPoint) == 0x0005C8, "Wrong size on AAbilityUsageStandPoint");
static_assert(offsetof(AAbilityUsageStandPoint, AbilityDataList) == 0x000560, "Member 'AAbilityUsageStandPoint::AbilityDataList' has a wrong offset!");
static_assert(offsetof(AAbilityUsageStandPoint, RequiredBattleSide) == 0x000570, "Member 'AAbilityUsageStandPoint::RequiredBattleSide' has a wrong offset!");
static_assert(offsetof(AAbilityUsageStandPoint, bShouldCheckGameplayProgress) == 0x000571, "Member 'AAbilityUsageStandPoint::bShouldCheckGameplayProgress' has a wrong offset!");
static_assert(offsetof(AAbilityUsageStandPoint, RequiredGameplayProgress) == 0x000574, "Member 'AAbilityUsageStandPoint::RequiredGameplayProgress' has a wrong offset!");
static_assert(offsetof(AAbilityUsageStandPoint, ProcessedAbilityDataList) == 0x000580, "Member 'AAbilityUsageStandPoint::ProcessedAbilityDataList' has a wrong offset!");
static_assert(offsetof(AAbilityUsageStandPoint, AbilityDataIndex) == 0x000590, "Member 'AAbilityUsageStandPoint::AbilityDataIndex' has a wrong offset!");
static_assert(offsetof(AAbilityUsageStandPoint, PointIndex) == 0x000594, "Member 'AAbilityUsageStandPoint::PointIndex' has a wrong offset!");
static_assert(offsetof(AAbilityUsageStandPoint, TargetPositionActor) == 0x000598, "Member 'AAbilityUsageStandPoint::TargetPositionActor' has a wrong offset!");

// Class MarvelAI.LinkedAbilityUsageStandPoint
// 0x0018 (0x05E0 - 0x05C8)
class ALinkedAbilityUsageStandPoint final : public AAbilityUsageStandPoint
{
public:
	TArray<struct FNavigationLink>                Links;                                             // 0x05C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDoubleLink;                                       // 0x05D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x7];                                      // 0x05D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetEndLocation(int32 Index_0);
	struct FVector GetStartLocation(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LinkedAbilityUsageStandPoint">();
	}
	static class ALinkedAbilityUsageStandPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALinkedAbilityUsageStandPoint>();
	}
};
static_assert(alignof(ALinkedAbilityUsageStandPoint) == 0x000008, "Wrong alignment on ALinkedAbilityUsageStandPoint");
static_assert(sizeof(ALinkedAbilityUsageStandPoint) == 0x0005E0, "Wrong size on ALinkedAbilityUsageStandPoint");
static_assert(offsetof(ALinkedAbilityUsageStandPoint, Links) == 0x0005C8, "Member 'ALinkedAbilityUsageStandPoint::Links' has a wrong offset!");
static_assert(offsetof(ALinkedAbilityUsageStandPoint, bDoubleLink) == 0x0005D8, "Member 'ALinkedAbilityUsageStandPoint::bDoubleLink' has a wrong offset!");

// Class MarvelAI.MarvelEnvQueryTest
// 0x0000 (0x0280 - 0x0280)
class UMarvelEnvQueryTest : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelEnvQueryTest">();
	}
	static class UMarvelEnvQueryTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelEnvQueryTest>();
	}
};
static_assert(alignof(UMarvelEnvQueryTest) == 0x000008, "Wrong alignment on UMarvelEnvQueryTest");
static_assert(sizeof(UMarvelEnvQueryTest) == 0x000280, "Wrong size on UMarvelEnvQueryTest");

// Class MarvelAI.EnvQueryTest_MarginTarget
// 0x0008 (0x0288 - 0x0280)
class UEnvQueryTest_MarginTarget final : public UMarvelEnvQueryTest
{
public:
	float                                         ScoreMax;                                          // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_MarginTarget">();
	}
	static class UEnvQueryTest_MarginTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_MarginTarget>();
	}
};
static_assert(alignof(UEnvQueryTest_MarginTarget) == 0x000008, "Wrong alignment on UEnvQueryTest_MarginTarget");
static_assert(sizeof(UEnvQueryTest_MarginTarget) == 0x000288, "Wrong size on UEnvQueryTest_MarginTarget");
static_assert(offsetof(UEnvQueryTest_MarginTarget, ScoreMax) == 0x000280, "Member 'UEnvQueryTest_MarginTarget::ScoreMax' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_MarginTarget, Radius) == 0x000284, "Member 'UEnvQueryTest_MarginTarget::Radius' has a wrong offset!");

// Class MarvelAI.AIAbilityCondition
// 0x0008 (0x0038 - 0x0030)
class UAIAbilityCondition : public UObject
{
public:
	bool                                          bInverseResult;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CouldPass(const struct FRequiredAIDataForAutoAbility& AIAutoAbilityContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityCondition">();
	}
	static class UAIAbilityCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityCondition>();
	}
};
static_assert(alignof(UAIAbilityCondition) == 0x000008, "Wrong alignment on UAIAbilityCondition");
static_assert(sizeof(UAIAbilityCondition) == 0x000038, "Wrong size on UAIAbilityCondition");
static_assert(offsetof(UAIAbilityCondition, bInverseResult) == 0x000030, "Member 'UAIAbilityCondition::bInverseResult' has a wrong offset!");

// Class MarvelAI.AIAbilityCondition_CheckAbilityCounter
// 0x0010 (0x0048 - 0x0038)
class UAIAbilityCondition_CheckAbilityCounter final : public UAIAbilityCondition
{
public:
	TArray<class FName>                           TableRawNameList;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityCondition_CheckAbilityCounter">();
	}
	static class UAIAbilityCondition_CheckAbilityCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityCondition_CheckAbilityCounter>();
	}
};
static_assert(alignof(UAIAbilityCondition_CheckAbilityCounter) == 0x000008, "Wrong alignment on UAIAbilityCondition_CheckAbilityCounter");
static_assert(sizeof(UAIAbilityCondition_CheckAbilityCounter) == 0x000048, "Wrong size on UAIAbilityCondition_CheckAbilityCounter");
static_assert(offsetof(UAIAbilityCondition_CheckAbilityCounter, TableRawNameList) == 0x000038, "Member 'UAIAbilityCondition_CheckAbilityCounter::TableRawNameList' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_DamageAbilityScope
// 0x0000 (0x0280 - 0x0280)
class UEnvQueryTest_DamageAbilityScope final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_DamageAbilityScope">();
	}
	static class UEnvQueryTest_DamageAbilityScope* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_DamageAbilityScope>();
	}
};
static_assert(alignof(UEnvQueryTest_DamageAbilityScope) == 0x000008, "Wrong alignment on UEnvQueryTest_DamageAbilityScope");
static_assert(sizeof(UEnvQueryTest_DamageAbilityScope) == 0x000280, "Wrong size on UEnvQueryTest_DamageAbilityScope");

// Class MarvelAI.AIAbilityCondition_CheckHeight
// 0x0010 (0x0048 - 0x0038)
class UAIAbilityCondition_CheckHeight final : public UAIAbilityCondition
{
public:
	float                                         MinHeight;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIAbilityCheckTarget                         CheckTarget;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityCondition_CheckHeight">();
	}
	static class UAIAbilityCondition_CheckHeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityCondition_CheckHeight>();
	}
};
static_assert(alignof(UAIAbilityCondition_CheckHeight) == 0x000008, "Wrong alignment on UAIAbilityCondition_CheckHeight");
static_assert(sizeof(UAIAbilityCondition_CheckHeight) == 0x000048, "Wrong size on UAIAbilityCondition_CheckHeight");
static_assert(offsetof(UAIAbilityCondition_CheckHeight, MinHeight) == 0x000038, "Member 'UAIAbilityCondition_CheckHeight::MinHeight' has a wrong offset!");
static_assert(offsetof(UAIAbilityCondition_CheckHeight, MaxHeight) == 0x00003C, "Member 'UAIAbilityCondition_CheckHeight::MaxHeight' has a wrong offset!");
static_assert(offsetof(UAIAbilityCondition_CheckHeight, CheckTarget) == 0x000040, "Member 'UAIAbilityCondition_CheckHeight::CheckTarget' has a wrong offset!");

// Class MarvelAI.AIAbilityCondition_SummonerCheck
// 0x0028 (0x0060 - 0x0038)
class UAIAbilityCondition_SummonerCheck : public UAIAbilityCondition
{
public:
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SummonerId;                                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInt32Range                            RequiredSummonerNumRange;                          // 0x0040(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAllowedDistanceToSelf;                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAllowedDistanceToEnemy;                         // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireIsVisible;                                 // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetSummonerListOfOwner(class AActor* AbilityOwner, int32 SummonerId_0, TArray<class AActor*>* OutSummonerList);

	bool ReceiveCheckIsValidSummoner(const struct FRequiredAIDataForAutoAbility& AIAutoAbilityContext, const class AActor* SummonerActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityCondition_SummonerCheck">();
	}
	static class UAIAbilityCondition_SummonerCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityCondition_SummonerCheck>();
	}
};
static_assert(alignof(UAIAbilityCondition_SummonerCheck) == 0x000008, "Wrong alignment on UAIAbilityCondition_SummonerCheck");
static_assert(sizeof(UAIAbilityCondition_SummonerCheck) == 0x000060, "Wrong size on UAIAbilityCondition_SummonerCheck");
static_assert(offsetof(UAIAbilityCondition_SummonerCheck, SummonerId) == 0x00003C, "Member 'UAIAbilityCondition_SummonerCheck::SummonerId' has a wrong offset!");
static_assert(offsetof(UAIAbilityCondition_SummonerCheck, RequiredSummonerNumRange) == 0x000040, "Member 'UAIAbilityCondition_SummonerCheck::RequiredSummonerNumRange' has a wrong offset!");
static_assert(offsetof(UAIAbilityCondition_SummonerCheck, MaxAllowedDistanceToSelf) == 0x000050, "Member 'UAIAbilityCondition_SummonerCheck::MaxAllowedDistanceToSelf' has a wrong offset!");
static_assert(offsetof(UAIAbilityCondition_SummonerCheck, MaxAllowedDistanceToEnemy) == 0x000054, "Member 'UAIAbilityCondition_SummonerCheck::MaxAllowedDistanceToEnemy' has a wrong offset!");
static_assert(offsetof(UAIAbilityCondition_SummonerCheck, bRequireIsVisible) == 0x000058, "Member 'UAIAbilityCondition_SummonerCheck::bRequireIsVisible' has a wrong offset!");

// Class MarvelAI.BTS_IsInBattle
// 0x00F8 (0x0170 - 0x0078)
class UBTS_IsInBattle : public UBTService
{
public:
	struct FBlackboardKeySelector                 IsInBattle;                                        // 0x0078(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 AttackTarget;                                      // 0x00A8(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 TeammateTarget;                                    // 0x00D8(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FAIHeroTag                             MatchTag;                                          // 0x0108(0x0068)(Edit, DisableEditOnInstance, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_IsInBattle">();
	}
	static class UBTS_IsInBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_IsInBattle>();
	}
};
static_assert(alignof(UBTS_IsInBattle) == 0x000008, "Wrong alignment on UBTS_IsInBattle");
static_assert(sizeof(UBTS_IsInBattle) == 0x000170, "Wrong size on UBTS_IsInBattle");
static_assert(offsetof(UBTS_IsInBattle, IsInBattle) == 0x000078, "Member 'UBTS_IsInBattle::IsInBattle' has a wrong offset!");
static_assert(offsetof(UBTS_IsInBattle, AttackTarget) == 0x0000A8, "Member 'UBTS_IsInBattle::AttackTarget' has a wrong offset!");
static_assert(offsetof(UBTS_IsInBattle, TeammateTarget) == 0x0000D8, "Member 'UBTS_IsInBattle::TeammateTarget' has a wrong offset!");
static_assert(offsetof(UBTS_IsInBattle, MatchTag) == 0x000108, "Member 'UBTS_IsInBattle::MatchTag' has a wrong offset!");

// Class MarvelAI.AIAbilityCondition_SummonerDistance
// 0x0090 (0x00C8 - 0x0038)
class UAIAbilityCondition_SummonerDistance final : public UAIAbilityCondition
{
public:
	int32                                         SummonerId;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHeroFilter                            HeroFilter;                                        // 0x0040(0x0080)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bIgnoreSelf;                                       // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityCondition_SummonerDistance">();
	}
	static class UAIAbilityCondition_SummonerDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityCondition_SummonerDistance>();
	}
};
static_assert(alignof(UAIAbilityCondition_SummonerDistance) == 0x000008, "Wrong alignment on UAIAbilityCondition_SummonerDistance");
static_assert(sizeof(UAIAbilityCondition_SummonerDistance) == 0x0000C8, "Wrong size on UAIAbilityCondition_SummonerDistance");
static_assert(offsetof(UAIAbilityCondition_SummonerDistance, SummonerId) == 0x000038, "Member 'UAIAbilityCondition_SummonerDistance::SummonerId' has a wrong offset!");
static_assert(offsetof(UAIAbilityCondition_SummonerDistance, Radius) == 0x00003C, "Member 'UAIAbilityCondition_SummonerDistance::Radius' has a wrong offset!");
static_assert(offsetof(UAIAbilityCondition_SummonerDistance, HeroFilter) == 0x000040, "Member 'UAIAbilityCondition_SummonerDistance::HeroFilter' has a wrong offset!");
static_assert(offsetof(UAIAbilityCondition_SummonerDistance, bIgnoreSelf) == 0x0000C0, "Member 'UAIAbilityCondition_SummonerDistance::bIgnoreSelf' has a wrong offset!");

// Class MarvelAI.AIAbilityExecutorManagerComponent
// 0x0100 (0x01F0 - 0x00F0)
class UAIAbilityExecutorManagerComponent final : public UMarvelActorComponentBase
{
public:
	class AMarvelAIController*                    MarvelAIController;                                // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UAIAbilityExecutor*>        AbilityExecutorDict;                               // 0x00F8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<int32>                                   ActivatedAbilitySet;                               // 0x0148(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x48];                                     // 0x0198(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIAbilityResourceQueue>        ResourceQueueList;                                 // 0x01E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	bool ActivateAbility(const struct FAIAbilityUsage& InAbilityUsage, int32 UsageID);
	void AddResource(int32 ResourceList, int32 UsageID, int32 Priority);
	bool CancelAbility(int32 UsageID);
	bool CheckAbilityIsActivated(int32 UsageID);
	bool CheckResource(int32 ResourceList, int32 UsageID, int32 Priority);
	void DeleteResource(int32 ResourceList, int32 UsageID);
	class UAIAbilityExecutor* GetAbilityExecutor(int32 UsageID);
	void OnAbilityActivate(int32 UsageID, class UAIAbilityExecutor* Executor);
	void OnAbilityPause(int32 UsageID, class UAIAbilityExecutor* Executor);
	void OnAbilityResume(int32 UsageID, class UAIAbilityExecutor* Executor);
	void OnAbilityStop(int32 UsageID, class UAIAbilityExecutor* Executor);
	bool PauseAbility(int32 UsageID);
	void RemoveAllAbility(bool bForceStop);
	bool ResumeAbility(int32 UsageID);
	bool StopAbility(int32 UsageID);
	void UpdateAbilityState(class UAIAbilityExecutor* Executor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityExecutorManagerComponent">();
	}
	static class UAIAbilityExecutorManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityExecutorManagerComponent>();
	}
};
static_assert(alignof(UAIAbilityExecutorManagerComponent) == 0x000008, "Wrong alignment on UAIAbilityExecutorManagerComponent");
static_assert(sizeof(UAIAbilityExecutorManagerComponent) == 0x0001F0, "Wrong size on UAIAbilityExecutorManagerComponent");
static_assert(offsetof(UAIAbilityExecutorManagerComponent, MarvelAIController) == 0x0000F0, "Member 'UAIAbilityExecutorManagerComponent::MarvelAIController' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutorManagerComponent, AbilityExecutorDict) == 0x0000F8, "Member 'UAIAbilityExecutorManagerComponent::AbilityExecutorDict' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutorManagerComponent, ActivatedAbilitySet) == 0x000148, "Member 'UAIAbilityExecutorManagerComponent::ActivatedAbilitySet' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutorManagerComponent, ResourceQueueList) == 0x0001E0, "Member 'UAIAbilityExecutorManagerComponent::ResourceQueueList' has a wrong offset!");

// Class MarvelAI.BTS_UpdateDangerous
// 0x0010 (0x0088 - 0x0078)
class UBTS_UpdateDangerous : public UBTService
{
public:
	bool                                          bEnableDebugLog;                                   // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDangerousTargetAsset*                  DangerousTarget;                                   // 0x0080(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateDangerous">();
	}
	static class UBTS_UpdateDangerous* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateDangerous>();
	}
};
static_assert(alignof(UBTS_UpdateDangerous) == 0x000008, "Wrong alignment on UBTS_UpdateDangerous");
static_assert(sizeof(UBTS_UpdateDangerous) == 0x000088, "Wrong size on UBTS_UpdateDangerous");
static_assert(offsetof(UBTS_UpdateDangerous, bEnableDebugLog) == 0x000078, "Member 'UBTS_UpdateDangerous::bEnableDebugLog' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateDangerous, DangerousTarget) == 0x000080, "Member 'UBTS_UpdateDangerous::DangerousTarget' has a wrong offset!");

// Class MarvelAI.AIAbilityExecutorManager
// 0x0018 (0x0050 - 0x0038)
class UAIAbilityExecutorManager final : public UWorldSubsystem
{
public:
	TArray<class UAIAbilityExecutor*>             AbilityExecutorPool;                               // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsInitialized;                                    // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityExecutorManager">();
	}
	static class UAIAbilityExecutorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityExecutorManager>();
	}
};
static_assert(alignof(UAIAbilityExecutorManager) == 0x000008, "Wrong alignment on UAIAbilityExecutorManager");
static_assert(sizeof(UAIAbilityExecutorManager) == 0x000050, "Wrong size on UAIAbilityExecutorManager");
static_assert(offsetof(UAIAbilityExecutorManager, AbilityExecutorPool) == 0x000038, "Member 'UAIAbilityExecutorManager::AbilityExecutorPool' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutorManager, bIsInitialized) == 0x000048, "Member 'UAIAbilityExecutorManager::bIsInitialized' has a wrong offset!");

// Class MarvelAI.AIAbilityExitStageLogic
// 0x0008 (0x0038 - 0x0030)
class UAIAbilityExitStageLogic : public UObject
{
public:
	bool                                          bCouldUseDefaultObject;                            // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAIAbilityExitStageLogic* GetAbilityExitStageLogic(class AMarvelAIController* MarvelAIOwner, TSubclassOf<class UAIAbilityExitStageLogic> ExitStageLogicClass);

	bool CheckLogic(const struct FAIAbilityUsage& AbilityUsage, class AMarvelAIController* OwnerController);
	void InitLogic();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityExitStageLogic">();
	}
	static class UAIAbilityExitStageLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityExitStageLogic>();
	}
};
static_assert(alignof(UAIAbilityExitStageLogic) == 0x000008, "Wrong alignment on UAIAbilityExitStageLogic");
static_assert(sizeof(UAIAbilityExitStageLogic) == 0x000038, "Wrong size on UAIAbilityExitStageLogic");
static_assert(offsetof(UAIAbilityExitStageLogic, bCouldUseDefaultObject) == 0x000030, "Member 'UAIAbilityExitStageLogic::bCouldUseDefaultObject' has a wrong offset!");

// Class MarvelAI.HotPoint_DataAsset
// 0x00A0 (0x00D8 - 0x0038)
class UHotPoint_DataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FMapPoint>           MapPoints;                                         // 0x0038(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FMapPoint                              DefaultConfig;                                     // 0x0088(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotPoint_DataAsset">();
	}
	static class UHotPoint_DataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotPoint_DataAsset>();
	}
};
static_assert(alignof(UHotPoint_DataAsset) == 0x000008, "Wrong alignment on UHotPoint_DataAsset");
static_assert(sizeof(UHotPoint_DataAsset) == 0x0000D8, "Wrong size on UHotPoint_DataAsset");
static_assert(offsetof(UHotPoint_DataAsset, MapPoints) == 0x000038, "Member 'UHotPoint_DataAsset::MapPoints' has a wrong offset!");
static_assert(offsetof(UHotPoint_DataAsset, DefaultConfig) == 0x000088, "Member 'UHotPoint_DataAsset::DefaultConfig' has a wrong offset!");

// Class MarvelAI.AIAbilityExitStageLogic_BindLogic
// 0x0018 (0x0050 - 0x0038)
class UAIAbilityExitStageLogic_BindLogic : public UAIAbilityExitStageLogic
{
public:
	TArray<class UAIAbilityExitStageLogic*>       ExitStageLogicList;                                // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bEndOnlyIfAllLogicEnd;                             // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityExitStageLogic_BindLogic">();
	}
	static class UAIAbilityExitStageLogic_BindLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityExitStageLogic_BindLogic>();
	}
};
static_assert(alignof(UAIAbilityExitStageLogic_BindLogic) == 0x000008, "Wrong alignment on UAIAbilityExitStageLogic_BindLogic");
static_assert(sizeof(UAIAbilityExitStageLogic_BindLogic) == 0x000050, "Wrong size on UAIAbilityExitStageLogic_BindLogic");
static_assert(offsetof(UAIAbilityExitStageLogic_BindLogic, ExitStageLogicList) == 0x000038, "Member 'UAIAbilityExitStageLogic_BindLogic::ExitStageLogicList' has a wrong offset!");
static_assert(offsetof(UAIAbilityExitStageLogic_BindLogic, bEndOnlyIfAllLogicEnd) == 0x000048, "Member 'UAIAbilityExitStageLogic_BindLogic::bEndOnlyIfAllLogicEnd' has a wrong offset!");

// Class MarvelAI.AIAbilityExitStageLogic_CheckBuffedCharacter
// 0x0098 (0x00D0 - 0x0038)
class UAIAbilityExitStageLogic_CheckBuffedCharacter : public UAIAbilityExitStageLogic
{
public:
	int32                                         BuffID;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHeroFilter                            HeroFilter;                                        // 0x0040(0x0080)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bCheckDistance;                                    // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InverseResult;                                     // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckInView;                                      // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityExitStageLogic_CheckBuffedCharacter">();
	}
	static class UAIAbilityExitStageLogic_CheckBuffedCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityExitStageLogic_CheckBuffedCharacter>();
	}
};
static_assert(alignof(UAIAbilityExitStageLogic_CheckBuffedCharacter) == 0x000008, "Wrong alignment on UAIAbilityExitStageLogic_CheckBuffedCharacter");
static_assert(sizeof(UAIAbilityExitStageLogic_CheckBuffedCharacter) == 0x0000D0, "Wrong size on UAIAbilityExitStageLogic_CheckBuffedCharacter");
static_assert(offsetof(UAIAbilityExitStageLogic_CheckBuffedCharacter, BuffID) == 0x000038, "Member 'UAIAbilityExitStageLogic_CheckBuffedCharacter::BuffID' has a wrong offset!");
static_assert(offsetof(UAIAbilityExitStageLogic_CheckBuffedCharacter, HeroFilter) == 0x000040, "Member 'UAIAbilityExitStageLogic_CheckBuffedCharacter::HeroFilter' has a wrong offset!");
static_assert(offsetof(UAIAbilityExitStageLogic_CheckBuffedCharacter, bCheckDistance) == 0x0000C0, "Member 'UAIAbilityExitStageLogic_CheckBuffedCharacter::bCheckDistance' has a wrong offset!");
static_assert(offsetof(UAIAbilityExitStageLogic_CheckBuffedCharacter, Distance) == 0x0000C4, "Member 'UAIAbilityExitStageLogic_CheckBuffedCharacter::Distance' has a wrong offset!");
static_assert(offsetof(UAIAbilityExitStageLogic_CheckBuffedCharacter, InverseResult) == 0x0000C8, "Member 'UAIAbilityExitStageLogic_CheckBuffedCharacter::InverseResult' has a wrong offset!");
static_assert(offsetof(UAIAbilityExitStageLogic_CheckBuffedCharacter, bCheckInView) == 0x0000C9, "Member 'UAIAbilityExitStageLogic_CheckBuffedCharacter::bCheckInView' has a wrong offset!");

// Class MarvelAI.BTS_CheckDefense
// 0x00E0 (0x0158 - 0x0078)
class UBTS_CheckDefense final : public UBTService
{
public:
	struct FBlackboardKeySelector                 OutIsNeedDefenseKey;                               // 0x0078(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 InFrontierKey;                                     // 0x00A8(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 InSelfActorKey;                                    // 0x00D8(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FFloatRange                            FrontierCheckDistance;                             // 0x0108(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FInt32Range                            FrontierEnemyProportion;                           // 0x0118(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FInt32Range                            FrontierAllyProportion;                            // 0x0128(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            SelfCheckDistance;                                 // 0x0138(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FInt32Range                            EnemyAroundProportion;                             // 0x0148(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_CheckDefense">();
	}
	static class UBTS_CheckDefense* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_CheckDefense>();
	}
};
static_assert(alignof(UBTS_CheckDefense) == 0x000008, "Wrong alignment on UBTS_CheckDefense");
static_assert(sizeof(UBTS_CheckDefense) == 0x000158, "Wrong size on UBTS_CheckDefense");
static_assert(offsetof(UBTS_CheckDefense, OutIsNeedDefenseKey) == 0x000078, "Member 'UBTS_CheckDefense::OutIsNeedDefenseKey' has a wrong offset!");
static_assert(offsetof(UBTS_CheckDefense, InFrontierKey) == 0x0000A8, "Member 'UBTS_CheckDefense::InFrontierKey' has a wrong offset!");
static_assert(offsetof(UBTS_CheckDefense, InSelfActorKey) == 0x0000D8, "Member 'UBTS_CheckDefense::InSelfActorKey' has a wrong offset!");
static_assert(offsetof(UBTS_CheckDefense, FrontierCheckDistance) == 0x000108, "Member 'UBTS_CheckDefense::FrontierCheckDistance' has a wrong offset!");
static_assert(offsetof(UBTS_CheckDefense, FrontierEnemyProportion) == 0x000118, "Member 'UBTS_CheckDefense::FrontierEnemyProportion' has a wrong offset!");
static_assert(offsetof(UBTS_CheckDefense, FrontierAllyProportion) == 0x000128, "Member 'UBTS_CheckDefense::FrontierAllyProportion' has a wrong offset!");
static_assert(offsetof(UBTS_CheckDefense, SelfCheckDistance) == 0x000138, "Member 'UBTS_CheckDefense::SelfCheckDistance' has a wrong offset!");
static_assert(offsetof(UBTS_CheckDefense, EnemyAroundProportion) == 0x000148, "Member 'UBTS_CheckDefense::EnemyAroundProportion' has a wrong offset!");

// Class MarvelAI.AIAbilityExitStageLogic_EQSComplete
// 0x0000 (0x0038 - 0x0038)
class UAIAbilityExitStageLogic_EQSComplete final : public UAIAbilityExitStageLogic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityExitStageLogic_EQSComplete">();
	}
	static class UAIAbilityExitStageLogic_EQSComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityExitStageLogic_EQSComplete>();
	}
};
static_assert(alignof(UAIAbilityExitStageLogic_EQSComplete) == 0x000008, "Wrong alignment on UAIAbilityExitStageLogic_EQSComplete");
static_assert(sizeof(UAIAbilityExitStageLogic_EQSComplete) == 0x000038, "Wrong size on UAIAbilityExitStageLogic_EQSComplete");

// Class MarvelAI.AIAbilityExitStageLogic_TargetHasTag
// 0x0010 (0x0048 - 0x0038)
class UAIAbilityExitStageLogic_TargetHasTag : public UAIAbilityExitStageLogic
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0038(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityExitStageLogic_TargetHasTag">();
	}
	static class UAIAbilityExitStageLogic_TargetHasTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityExitStageLogic_TargetHasTag>();
	}
};
static_assert(alignof(UAIAbilityExitStageLogic_TargetHasTag) == 0x000008, "Wrong alignment on UAIAbilityExitStageLogic_TargetHasTag");
static_assert(sizeof(UAIAbilityExitStageLogic_TargetHasTag) == 0x000048, "Wrong size on UAIAbilityExitStageLogic_TargetHasTag");
static_assert(offsetof(UAIAbilityExitStageLogic_TargetHasTag, Tag) == 0x000038, "Member 'UAIAbilityExitStageLogic_TargetHasTag::Tag' has a wrong offset!");

// Class MarvelAI.BTS_UpdateMatchState_New
// 0x00A0 (0x0118 - 0x0078)
class UBTS_UpdateMatchState_New : public UBTService
{
public:
	struct FBlackboardKeySelector                 GameModeTagKey;                                    // 0x0078(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 MatchStateKey;                                     // 0x00A8(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 RemainTimeKey;                                     // 0x00D8(0x0030)(Edit, NativeAccessSpecifierPrivate)
	class AAIController*                          AIOwner;                                           // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSubsystem*                        LevelSubsystem;                                    // 0x0110(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnMatchStateChange(EMatchState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateMatchState_New">();
	}
	static class UBTS_UpdateMatchState_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateMatchState_New>();
	}
};
static_assert(alignof(UBTS_UpdateMatchState_New) == 0x000008, "Wrong alignment on UBTS_UpdateMatchState_New");
static_assert(sizeof(UBTS_UpdateMatchState_New) == 0x000118, "Wrong size on UBTS_UpdateMatchState_New");
static_assert(offsetof(UBTS_UpdateMatchState_New, GameModeTagKey) == 0x000078, "Member 'UBTS_UpdateMatchState_New::GameModeTagKey' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateMatchState_New, MatchStateKey) == 0x0000A8, "Member 'UBTS_UpdateMatchState_New::MatchStateKey' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateMatchState_New, RemainTimeKey) == 0x0000D8, "Member 'UBTS_UpdateMatchState_New::RemainTimeKey' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateMatchState_New, AIOwner) == 0x000108, "Member 'UBTS_UpdateMatchState_New::AIOwner' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateMatchState_New, LevelSubsystem) == 0x000110, "Member 'UBTS_UpdateMatchState_New::LevelSubsystem' has a wrong offset!");

// Class MarvelAI.AIAbilityExitStageLogic_WaitFocusMatched
// 0x0008 (0x0040 - 0x0038)
class UAIAbilityExitStageLogic_WaitFocusMatched : public UAIAbilityExitStageLogic
{
public:
	float                                         AllowedAngleDeviation;                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityExitStageLogic_WaitFocusMatched">();
	}
	static class UAIAbilityExitStageLogic_WaitFocusMatched* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityExitStageLogic_WaitFocusMatched>();
	}
};
static_assert(alignof(UAIAbilityExitStageLogic_WaitFocusMatched) == 0x000008, "Wrong alignment on UAIAbilityExitStageLogic_WaitFocusMatched");
static_assert(sizeof(UAIAbilityExitStageLogic_WaitFocusMatched) == 0x000040, "Wrong size on UAIAbilityExitStageLogic_WaitFocusMatched");
static_assert(offsetof(UAIAbilityExitStageLogic_WaitFocusMatched, AllowedAngleDeviation) == 0x000038, "Member 'UAIAbilityExitStageLogic_WaitFocusMatched::AllowedAngleDeviation' has a wrong offset!");

// Class MarvelAI.AIAbilityFlowCheckLogicBase
// 0x0008 (0x0038 - 0x0030)
class UAIAbilityFlowCheckLogicBase : public UObject
{
public:
	bool                                          bCouldUseDefaultObject;                            // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAIAbilityFlowCheckLogicBase* GetAbilityFlowCheckLogic(class AMarvelAIController* MarvelAIOwner, TSubclassOf<class UAIAbilityFlowCheckLogicBase> CheckLogicClass);

	bool CheckLogic(const struct FAIAbilityUsage& AbilityUsage, class AMarvelAIController* OwnerController);
	void InitLogic();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityFlowCheckLogicBase">();
	}
	static class UAIAbilityFlowCheckLogicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityFlowCheckLogicBase>();
	}
};
static_assert(alignof(UAIAbilityFlowCheckLogicBase) == 0x000008, "Wrong alignment on UAIAbilityFlowCheckLogicBase");
static_assert(sizeof(UAIAbilityFlowCheckLogicBase) == 0x000038, "Wrong size on UAIAbilityFlowCheckLogicBase");
static_assert(offsetof(UAIAbilityFlowCheckLogicBase, bCouldUseDefaultObject) == 0x000030, "Member 'UAIAbilityFlowCheckLogicBase::bCouldUseDefaultObject' has a wrong offset!");

// Class MarvelAI.BTS_UpdateUsageGroup
// 0x0068 (0x00E0 - 0x0078)
class UBTS_UpdateUsageGroup : public UBTService
{
public:
	struct FGameplayTagContainer                  UsageGroupTags;                                    // 0x0078(0x0068)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateUsageGroup">();
	}
	static class UBTS_UpdateUsageGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateUsageGroup>();
	}
};
static_assert(alignof(UBTS_UpdateUsageGroup) == 0x000008, "Wrong alignment on UBTS_UpdateUsageGroup");
static_assert(sizeof(UBTS_UpdateUsageGroup) == 0x0000E0, "Wrong size on UBTS_UpdateUsageGroup");
static_assert(offsetof(UBTS_UpdateUsageGroup, UsageGroupTags) == 0x000078, "Member 'UBTS_UpdateUsageGroup::UsageGroupTags' has a wrong offset!");

// Class MarvelAI.AIAbilityFlowCheck_Condition
// 0x0010 (0x0048 - 0x0038)
class UAIAbilityFlowCheck_Condition final : public UAIAbilityFlowCheckLogicBase
{
public:
	TArray<class UAIAbilityCondition*>            ConditionList;                                     // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityFlowCheck_Condition">();
	}
	static class UAIAbilityFlowCheck_Condition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityFlowCheck_Condition>();
	}
};
static_assert(alignof(UAIAbilityFlowCheck_Condition) == 0x000008, "Wrong alignment on UAIAbilityFlowCheck_Condition");
static_assert(sizeof(UAIAbilityFlowCheck_Condition) == 0x000048, "Wrong size on UAIAbilityFlowCheck_Condition");
static_assert(offsetof(UAIAbilityFlowCheck_Condition, ConditionList) == 0x000038, "Member 'UAIAbilityFlowCheck_Condition::ConditionList' has a wrong offset!");

// Class MarvelAI.AIMoveControlLogic
// 0x0018 (0x0048 - 0x0030)
class UAIMoveControlLogic : public UObject
{
public:
	bool                                          bUseCustomSelectDir;                               // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIBattleMoveType                             MoveType;                                          // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              EQSTemplate;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCouldUseDefaultObject;                            // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAIMoveControlLogic* GetMoveControlLogic(class AMarvelAIController* MarvelAIOwner, TSubclassOf<class UAIMoveControlLogic> MoveLogicClass);

	struct FVector CustomSelectMoveDir(class AMarvelAIController* OwnerController, class APawn* ControlledPawn);
	bool ShouldUseCustomSelectDir(class AMarvelAIController* OwnerController, class APawn* ControlledPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveControlLogic">();
	}
	static class UAIMoveControlLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveControlLogic>();
	}
};
static_assert(alignof(UAIMoveControlLogic) == 0x000008, "Wrong alignment on UAIMoveControlLogic");
static_assert(sizeof(UAIMoveControlLogic) == 0x000048, "Wrong size on UAIMoveControlLogic");
static_assert(offsetof(UAIMoveControlLogic, bUseCustomSelectDir) == 0x000030, "Member 'UAIMoveControlLogic::bUseCustomSelectDir' has a wrong offset!");
static_assert(offsetof(UAIMoveControlLogic, MoveType) == 0x000031, "Member 'UAIMoveControlLogic::MoveType' has a wrong offset!");
static_assert(offsetof(UAIMoveControlLogic, EQSTemplate) == 0x000038, "Member 'UAIMoveControlLogic::EQSTemplate' has a wrong offset!");
static_assert(offsetof(UAIMoveControlLogic, bCouldUseDefaultObject) == 0x000040, "Member 'UAIMoveControlLogic::bCouldUseDefaultObject' has a wrong offset!");

// Class MarvelAI.BTS_UpdateFireLine
// 0x0070 (0x00E8 - 0x0078)
class UBTS_UpdateFireLine final : public UBTService
{
public:
	float                                         TeammateDistance;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 DifficultyMode;                                    // 0x0080(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 DifficultyLevel;                                   // 0x00B0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         TempPriority;                                      // 0x00E0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsActorInFireLineState(const class AMarvelBaseCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateFireLine">();
	}
	static class UBTS_UpdateFireLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateFireLine>();
	}
};
static_assert(alignof(UBTS_UpdateFireLine) == 0x000008, "Wrong alignment on UBTS_UpdateFireLine");
static_assert(sizeof(UBTS_UpdateFireLine) == 0x0000E8, "Wrong size on UBTS_UpdateFireLine");
static_assert(offsetof(UBTS_UpdateFireLine, TeammateDistance) == 0x000078, "Member 'UBTS_UpdateFireLine::TeammateDistance' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateFireLine, DifficultyMode) == 0x000080, "Member 'UBTS_UpdateFireLine::DifficultyMode' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateFireLine, DifficultyLevel) == 0x0000B0, "Member 'UBTS_UpdateFireLine::DifficultyLevel' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateFireLine, TempPriority) == 0x0000E0, "Member 'UBTS_UpdateFireLine::TempPriority' has a wrong offset!");

// Class MarvelAI.AIAbilityActivationLogic
// 0x0008 (0x0038 - 0x0030)
class UAIAbilityActivationLogic : public UObject
{
public:
	bool                                          bShouldTick;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCouldUseDefaultObject;                            // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAIAbilityActivationLogic* GetAbilityActivationLogic(class AMarvelAIController* MarvelAIOwner, TSubclassOf<class UAIAbilityActivationLogic> ActivationLogicClass);

	bool BeginLogic(class UAIAbilityExecutor* OwnerExecutor, const struct FAIAbilityUsage& AbilityUsage, class AMarvelAIController* OwnerController);
	bool EndLogic(class UAIAbilityExecutor* OwnerExecutor, const struct FAIAbilityUsage& AbilityUsage, class AMarvelAIController* OwnerController);
	bool TickLogic(class UAIAbilityExecutor* OwnerExecutor, const struct FAIAbilityUsage& AbilityUsage, class AMarvelAIController* OwnerController, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityActivationLogic">();
	}
	static class UAIAbilityActivationLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityActivationLogic>();
	}
};
static_assert(alignof(UAIAbilityActivationLogic) == 0x000008, "Wrong alignment on UAIAbilityActivationLogic");
static_assert(sizeof(UAIAbilityActivationLogic) == 0x000038, "Wrong size on UAIAbilityActivationLogic");
static_assert(offsetof(UAIAbilityActivationLogic, bShouldTick) == 0x000030, "Member 'UAIAbilityActivationLogic::bShouldTick' has a wrong offset!");
static_assert(offsetof(UAIAbilityActivationLogic, bCouldUseDefaultObject) == 0x000031, "Member 'UAIAbilityActivationLogic::bCouldUseDefaultObject' has a wrong offset!");

// Class MarvelAI.AIAbilityMoveControlLogic
// 0x0070 (0x00B8 - 0x0048)
class UAIAbilityMoveControlLogic : public UAIMoveControlLogic
{
public:
	struct FGameplayTagContainer                  MoveTag;                                           // 0x0048(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UEnvQuery*                              MoveEQSTemplate;                                   // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityMoveControlLogic">();
	}
	static class UAIAbilityMoveControlLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityMoveControlLogic>();
	}
};
static_assert(alignof(UAIAbilityMoveControlLogic) == 0x000008, "Wrong alignment on UAIAbilityMoveControlLogic");
static_assert(sizeof(UAIAbilityMoveControlLogic) == 0x0000B8, "Wrong size on UAIAbilityMoveControlLogic");
static_assert(offsetof(UAIAbilityMoveControlLogic, MoveTag) == 0x000048, "Member 'UAIAbilityMoveControlLogic::MoveTag' has a wrong offset!");
static_assert(offsetof(UAIAbilityMoveControlLogic, MoveEQSTemplate) == 0x0000B0, "Member 'UAIAbilityMoveControlLogic::MoveEQSTemplate' has a wrong offset!");

// Class MarvelAI.BTS_UpdateAnthropomorphicType
// 0x0030 (0x00A8 - 0x0078)
class UBTS_UpdateAnthropomorphicType : public UBTService
{
public:
	struct FBlackboardKeySelector                 OutAnthropomorphic;                                // 0x0078(0x0030)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateAnthropomorphicType">();
	}
	static class UBTS_UpdateAnthropomorphicType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateAnthropomorphicType>();
	}
};
static_assert(alignof(UBTS_UpdateAnthropomorphicType) == 0x000008, "Wrong alignment on UBTS_UpdateAnthropomorphicType");
static_assert(sizeof(UBTS_UpdateAnthropomorphicType) == 0x0000A8, "Wrong size on UBTS_UpdateAnthropomorphicType");
static_assert(offsetof(UBTS_UpdateAnthropomorphicType, OutAnthropomorphic) == 0x000078, "Member 'UBTS_UpdateAnthropomorphicType::OutAnthropomorphic' has a wrong offset!");

// Class MarvelAI.AIAbilityActivationLogic_TargetHealth
// 0x0018 (0x0050 - 0x0038)
class UAIAbilityActivationLogic_TargetHealth : public UAIAbilityExitStageLogic
{
public:
	class FString                                 TargetBlackBoard;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMarvelArithmeticOperation                    Op;                                                // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CompareValue;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityActivationLogic_TargetHealth">();
	}
	static class UAIAbilityActivationLogic_TargetHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityActivationLogic_TargetHealth>();
	}
};
static_assert(alignof(UAIAbilityActivationLogic_TargetHealth) == 0x000008, "Wrong alignment on UAIAbilityActivationLogic_TargetHealth");
static_assert(sizeof(UAIAbilityActivationLogic_TargetHealth) == 0x000050, "Wrong size on UAIAbilityActivationLogic_TargetHealth");
static_assert(offsetof(UAIAbilityActivationLogic_TargetHealth, TargetBlackBoard) == 0x000038, "Member 'UAIAbilityActivationLogic_TargetHealth::TargetBlackBoard' has a wrong offset!");
static_assert(offsetof(UAIAbilityActivationLogic_TargetHealth, Op) == 0x000048, "Member 'UAIAbilityActivationLogic_TargetHealth::Op' has a wrong offset!");
static_assert(offsetof(UAIAbilityActivationLogic_TargetHealth, CompareValue) == 0x00004C, "Member 'UAIAbilityActivationLogic_TargetHealth::CompareValue' has a wrong offset!");

// Class MarvelAI.AIAbilityActivationLogic_TargetDistance
// 0x0018 (0x0050 - 0x0038)
class UAIAbilityActivationLogic_TargetDistance final : public UAIAbilityExitStageLogic
{
public:
	class FString                                 TargetBlackBoard;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMarvelArithmeticOperation                    Op;                                                // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CompareValue;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityActivationLogic_TargetDistance">();
	}
	static class UAIAbilityActivationLogic_TargetDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityActivationLogic_TargetDistance>();
	}
};
static_assert(alignof(UAIAbilityActivationLogic_TargetDistance) == 0x000008, "Wrong alignment on UAIAbilityActivationLogic_TargetDistance");
static_assert(sizeof(UAIAbilityActivationLogic_TargetDistance) == 0x000050, "Wrong size on UAIAbilityActivationLogic_TargetDistance");
static_assert(offsetof(UAIAbilityActivationLogic_TargetDistance, TargetBlackBoard) == 0x000038, "Member 'UAIAbilityActivationLogic_TargetDistance::TargetBlackBoard' has a wrong offset!");
static_assert(offsetof(UAIAbilityActivationLogic_TargetDistance, Op) == 0x000048, "Member 'UAIAbilityActivationLogic_TargetDistance::Op' has a wrong offset!");
static_assert(offsetof(UAIAbilityActivationLogic_TargetDistance, CompareValue) == 0x00004C, "Member 'UAIAbilityActivationLogic_TargetDistance::CompareValue' has a wrong offset!");

// Class MarvelAI.BTS_UpdateSight
// 0x0028 (0x00A0 - 0x0078)
class UBTS_UpdateSight : public UBTService
{
public:
	float                                         VisionRadius;                                      // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionRadiusForDamageSource;                       // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionHalfAngle;                                   // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAge;                                            // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelAIController*                    AIOwner;                                           // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAIPerceptionComponent*           AIPerceptionComponent;                             // 0x0090(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISenseConfig_Sight*                   SightConfig;                                       // 0x0098(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnResetSightConfig(float NewRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateSight">();
	}
	static class UBTS_UpdateSight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateSight>();
	}
};
static_assert(alignof(UBTS_UpdateSight) == 0x000008, "Wrong alignment on UBTS_UpdateSight");
static_assert(sizeof(UBTS_UpdateSight) == 0x0000A0, "Wrong size on UBTS_UpdateSight");
static_assert(offsetof(UBTS_UpdateSight, VisionRadius) == 0x000078, "Member 'UBTS_UpdateSight::VisionRadius' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateSight, VisionRadiusForDamageSource) == 0x00007C, "Member 'UBTS_UpdateSight::VisionRadiusForDamageSource' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateSight, VisionHalfAngle) == 0x000080, "Member 'UBTS_UpdateSight::VisionHalfAngle' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateSight, MaxAge) == 0x000084, "Member 'UBTS_UpdateSight::MaxAge' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateSight, AIOwner) == 0x000088, "Member 'UBTS_UpdateSight::AIOwner' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateSight, AIPerceptionComponent) == 0x000090, "Member 'UBTS_UpdateSight::AIPerceptionComponent' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateSight, SightConfig) == 0x000098, "Member 'UBTS_UpdateSight::SightConfig' has a wrong offset!");

// Class MarvelAI.AIAbilityObserver
// 0x0070 (0x00A8 - 0x0038)
class UAIAbilityObserver final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnAbilityActivate;                                 // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAbilityDeActivate;                               // 0x0048(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FAbilityList>      ActivatedAbility;                                  // 0x0058(0x0050)(NativeAccessSpecifierPrivate)

public:
	void OnActiveAbility(class AActor* Source, int32 AbilityID, const class FString& SessionID, class UMarvelGameplayAbility* SourceAbility);
	void OnEndAbility(class AActor* Source, int32 AbilityID, const class FString& SessionID, class UMarvelGameplayAbility* SourceAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityObserver">();
	}
	static class UAIAbilityObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityObserver>();
	}
};
static_assert(alignof(UAIAbilityObserver) == 0x000008, "Wrong alignment on UAIAbilityObserver");
static_assert(sizeof(UAIAbilityObserver) == 0x0000A8, "Wrong size on UAIAbilityObserver");
static_assert(offsetof(UAIAbilityObserver, OnAbilityActivate) == 0x000038, "Member 'UAIAbilityObserver::OnAbilityActivate' has a wrong offset!");
static_assert(offsetof(UAIAbilityObserver, OnAbilityDeActivate) == 0x000048, "Member 'UAIAbilityObserver::OnAbilityDeActivate' has a wrong offset!");
static_assert(offsetof(UAIAbilityObserver, ActivatedAbility) == 0x000058, "Member 'UAIAbilityObserver::ActivatedAbility' has a wrong offset!");

// Class MarvelAI.AIAbilitySelectCheckBase
// 0x0020 (0x0050 - 0x0030)
class UAIAbilitySelectCheckBase : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ReceivePostCheck(const struct FRequiredAIDataForAutoAbility& RequiredData, const struct FMarvelAIAutoAbilityTable& AbilityConfig, const struct FAIAbilityUsage& AbilityUsage) const;
	bool ReceivePreCheck(const struct FRequiredAIDataForAutoAbility& RequiredData, const struct FMarvelAIAutoAbilityTable& AbilityConfig) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilitySelectCheckBase">();
	}
	static class UAIAbilitySelectCheckBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilitySelectCheckBase>();
	}
};
static_assert(alignof(UAIAbilitySelectCheckBase) == 0x000008, "Wrong alignment on UAIAbilitySelectCheckBase");
static_assert(sizeof(UAIAbilitySelectCheckBase) == 0x000050, "Wrong size on UAIAbilitySelectCheckBase");

// Class MarvelAI.BTTask_MarvelRunEQSQuery
// 0x0048 (0x01C0 - 0x0178)
class UBTTask_MarvelRunEQSQuery final : public UBTTask_RunEQSQuery
{
public:
	struct FBlackboardKeySelector                 AbilityMoveLogicBlackboardKey;                     // 0x0178(0x0030)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x10];                                     // 0x01A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              DefaultEQSTemplate;                                // 0x01B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MarvelRunEQSQuery">();
	}
	static class UBTTask_MarvelRunEQSQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MarvelRunEQSQuery>();
	}
};
static_assert(alignof(UBTTask_MarvelRunEQSQuery) == 0x000008, "Wrong alignment on UBTTask_MarvelRunEQSQuery");
static_assert(sizeof(UBTTask_MarvelRunEQSQuery) == 0x0001C0, "Wrong size on UBTTask_MarvelRunEQSQuery");
static_assert(offsetof(UBTTask_MarvelRunEQSQuery, AbilityMoveLogicBlackboardKey) == 0x000178, "Member 'UBTTask_MarvelRunEQSQuery::AbilityMoveLogicBlackboardKey' has a wrong offset!");
static_assert(offsetof(UBTTask_MarvelRunEQSQuery, DefaultEQSTemplate) == 0x0001B8, "Member 'UBTTask_MarvelRunEQSQuery::DefaultEQSTemplate' has a wrong offset!");

// Class MarvelAI.AIAbilitySelectCheck_AILab
// 0x0000 (0x0050 - 0x0050)
class UAIAbilitySelectCheck_AILab final : public UAIAbilitySelectCheckBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilitySelectCheck_AILab">();
	}
	static class UAIAbilitySelectCheck_AILab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilitySelectCheck_AILab>();
	}
};
static_assert(alignof(UAIAbilitySelectCheck_AILab) == 0x000008, "Wrong alignment on UAIAbilitySelectCheck_AILab");
static_assert(sizeof(UAIAbilitySelectCheck_AILab) == 0x000050, "Wrong size on UAIAbilitySelectCheck_AILab");

// Class MarvelAI.AIAbilitySelectCheck_AutoAbility
// 0x0000 (0x0050 - 0x0050)
class UAIAbilitySelectCheck_AutoAbility final : public UAIAbilitySelectCheckBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilitySelectCheck_AutoAbility">();
	}
	static class UAIAbilitySelectCheck_AutoAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilitySelectCheck_AutoAbility>();
	}
};
static_assert(alignof(UAIAbilitySelectCheck_AutoAbility) == 0x000008, "Wrong alignment on UAIAbilitySelectCheck_AutoAbility");
static_assert(sizeof(UAIAbilitySelectCheck_AutoAbility) == 0x000050, "Wrong size on UAIAbilitySelectCheck_AutoAbility");

// Class MarvelAI.BTTask_GeneralActivateAbility
// 0x0038 (0x00B0 - 0x0078)
class UBTTask_GeneralActivateAbility : public UBTTaskNode
{
public:
	int32                                         AbilityID;                                         // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxActivateDuration;                               // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEndTaskByAbilityBreak : 1;                        // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCancelAbilityOnBreak : 1;                         // 0x0080(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelGameplayAbility*                 CurrentAbility;                                    // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndCurrentTask();
	void OnAbilityBreak();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_GeneralActivateAbility">();
	}
	static class UBTTask_GeneralActivateAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_GeneralActivateAbility>();
	}
};
static_assert(alignof(UBTTask_GeneralActivateAbility) == 0x000008, "Wrong alignment on UBTTask_GeneralActivateAbility");
static_assert(sizeof(UBTTask_GeneralActivateAbility) == 0x0000B0, "Wrong size on UBTTask_GeneralActivateAbility");
static_assert(offsetof(UBTTask_GeneralActivateAbility, AbilityID) == 0x000078, "Member 'UBTTask_GeneralActivateAbility::AbilityID' has a wrong offset!");
static_assert(offsetof(UBTTask_GeneralActivateAbility, MaxActivateDuration) == 0x00007C, "Member 'UBTTask_GeneralActivateAbility::MaxActivateDuration' has a wrong offset!");
static_assert(offsetof(UBTTask_GeneralActivateAbility, CurrentAbility) == 0x000088, "Member 'UBTTask_GeneralActivateAbility::CurrentAbility' has a wrong offset!");

// Class MarvelAI.AIAbilitySelectCheck_SingleAbility
// 0x0000 (0x0050 - 0x0050)
class UAIAbilitySelectCheck_SingleAbility final : public UAIAbilitySelectCheckBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilitySelectCheck_SingleAbility">();
	}
	static class UAIAbilitySelectCheck_SingleAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilitySelectCheck_SingleAbility>();
	}
};
static_assert(alignof(UAIAbilitySelectCheck_SingleAbility) == 0x000008, "Wrong alignment on UAIAbilitySelectCheck_SingleAbility");
static_assert(sizeof(UAIAbilitySelectCheck_SingleAbility) == 0x000050, "Wrong size on UAIAbilitySelectCheck_SingleAbility");

// Class MarvelAI.AIAbilityExecutor
// 0x0288 (0x02B8 - 0x0030)
class UAIAbilityExecutor final : public UObject
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTicking;                                        // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInRecover;                                      // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityUsageID;                                    // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelAIController*                    MarvelAIController;                                // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   MarvelAICharacter;                                 // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIAbilityUsage                        AbilityUsage;                                      // 0x0090(0x00E8)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourceList;                                      // 0x0178(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourcePriority;                                  // 0x017C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIResourceConflictBehavior                   ConflictBehavior;                                  // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAISelectTargetLogicBase*               FocusControlLogic;                                 // 0x0188(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIMoveControlLogic*                    MoveControlLogic;                                  // 0x0190(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIAbilityFlowCheckLogicBase*           StopAbilityCheckLogic;                             // 0x0198(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x01A0(0x0068)(NativeAccessSpecifierPublic)
	EAbilityInputBinds                            CancelButton;                                      // 0x0208(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentButtonIndex;                                // 0x020C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityInputBinds                            CurrentButton;                                     // 0x0210(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIAbilityExitStageLogic*               CurrentLoopCheckLogic;                             // 0x0218(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoopButton;                                     // 0x0220(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ButtonLoopCount;                                   // 0x0224(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ButtonLoopTime;                                    // 0x0228(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIActivationAbilityStage                     CurrentStage;                                      // 0x022C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAIAbilityActivationLogic*>      CurrentActivationLogicList;                        // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAIAbilityExitStageLogic*               CurrentStageCheckLogic;                            // 0x0240(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StageTimer;                                        // 0x0248(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInfinityStage;                                  // 0x024C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D[0x6B];                                     // 0x024D(0x006B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ActivateTask();
	void AttachExtraConfigs();
	void AttachTags();
	bool CancelTask();
	void ClearFocus();
	void DetachExtraConfigs();
	void DetachTags();
	void InitAIAbilityExecutor(class AMarvelAIController* InAIController, const struct FAIAbilityUsage& InAbilityUsage);
	bool IsAlive();
	bool PauseTask();
	void ResetMove();
	bool ResumeTask();
	bool ShouldExitLoop();
	bool ShouldSwitchToNextButtonStage();
	bool ShouldSwitchToNextStage();
	bool StopTask();
	void SwitchToButtonStart();
	bool SwitchToNextButton(bool bForceSwitch);
	bool SwitchToNextButtonStage();
	bool SwitchToNextStage();
	void SwitchToStart();
	void TickTask(float DeltaTime);
	void UpdateFocus();
	void UpdateMove();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityExecutor">();
	}
	static class UAIAbilityExecutor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityExecutor>();
	}
};
static_assert(alignof(UAIAbilityExecutor) == 0x000008, "Wrong alignment on UAIAbilityExecutor");
static_assert(sizeof(UAIAbilityExecutor) == 0x0002B8, "Wrong size on UAIAbilityExecutor");
static_assert(offsetof(UAIAbilityExecutor, bIsTicking) == 0x000070, "Member 'UAIAbilityExecutor::bIsTicking' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, bIsInRecover) == 0x000071, "Member 'UAIAbilityExecutor::bIsInRecover' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, AbilityID) == 0x000074, "Member 'UAIAbilityExecutor::AbilityID' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, AbilityUsageID) == 0x000078, "Member 'UAIAbilityExecutor::AbilityUsageID' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, MarvelAIController) == 0x000080, "Member 'UAIAbilityExecutor::MarvelAIController' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, MarvelAICharacter) == 0x000088, "Member 'UAIAbilityExecutor::MarvelAICharacter' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, AbilityUsage) == 0x000090, "Member 'UAIAbilityExecutor::AbilityUsage' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, ResourceList) == 0x000178, "Member 'UAIAbilityExecutor::ResourceList' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, ResourcePriority) == 0x00017C, "Member 'UAIAbilityExecutor::ResourcePriority' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, ConflictBehavior) == 0x000180, "Member 'UAIAbilityExecutor::ConflictBehavior' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, FocusControlLogic) == 0x000188, "Member 'UAIAbilityExecutor::FocusControlLogic' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, MoveControlLogic) == 0x000190, "Member 'UAIAbilityExecutor::MoveControlLogic' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, StopAbilityCheckLogic) == 0x000198, "Member 'UAIAbilityExecutor::StopAbilityCheckLogic' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, TagContainer) == 0x0001A0, "Member 'UAIAbilityExecutor::TagContainer' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, CancelButton) == 0x000208, "Member 'UAIAbilityExecutor::CancelButton' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, CurrentButtonIndex) == 0x00020C, "Member 'UAIAbilityExecutor::CurrentButtonIndex' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, CurrentButton) == 0x000210, "Member 'UAIAbilityExecutor::CurrentButton' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, CurrentLoopCheckLogic) == 0x000218, "Member 'UAIAbilityExecutor::CurrentLoopCheckLogic' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, bIsLoopButton) == 0x000220, "Member 'UAIAbilityExecutor::bIsLoopButton' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, ButtonLoopCount) == 0x000224, "Member 'UAIAbilityExecutor::ButtonLoopCount' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, ButtonLoopTime) == 0x000228, "Member 'UAIAbilityExecutor::ButtonLoopTime' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, CurrentStage) == 0x00022C, "Member 'UAIAbilityExecutor::CurrentStage' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, CurrentActivationLogicList) == 0x000230, "Member 'UAIAbilityExecutor::CurrentActivationLogicList' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, CurrentStageCheckLogic) == 0x000240, "Member 'UAIAbilityExecutor::CurrentStageCheckLogic' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, StageTimer) == 0x000248, "Member 'UAIAbilityExecutor::StageTimer' has a wrong offset!");
static_assert(offsetof(UAIAbilityExecutor, bIsInfinityStage) == 0x00024C, "Member 'UAIAbilityExecutor::bIsInfinityStage' has a wrong offset!");

// Class MarvelAI.BTS_UpdateMapID
// 0x0030 (0x00A8 - 0x0078)
class UBTS_UpdateMapID : public UBTService
{
public:
	struct FBlackboardKeySelector                 OutMapID;                                          // 0x0078(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateMapID">();
	}
	static class UBTS_UpdateMapID* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateMapID>();
	}
};
static_assert(alignof(UBTS_UpdateMapID) == 0x000008, "Wrong alignment on UBTS_UpdateMapID");
static_assert(sizeof(UBTS_UpdateMapID) == 0x0000A8, "Wrong size on UBTS_UpdateMapID");
static_assert(offsetof(UBTS_UpdateMapID, OutMapID) == 0x000078, "Member 'UBTS_UpdateMapID::OutMapID' has a wrong offset!");

// Class MarvelAI.AIAbilityUsageObject
// 0x00E8 (0x0118 - 0x0030)
class UAIAbilityUsageObject final : public UObject
{
public:
	struct FAIAbilityUsage                        UsageData;                                         // 0x0030(0x00E8)(Edit, BlueprintVisible, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	int32 GetAbilityID(const class AMarvelAIController* AIOwner) const;
	struct FMarvelAIAutoAbilityTable GetUsageConfig() const;
	int32 GetUsageID() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityUsageObject">();
	}
	static class UAIAbilityUsageObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityUsageObject>();
	}
};
static_assert(alignof(UAIAbilityUsageObject) == 0x000008, "Wrong alignment on UAIAbilityUsageObject");
static_assert(sizeof(UAIAbilityUsageObject) == 0x000118, "Wrong size on UAIAbilityUsageObject");
static_assert(offsetof(UAIAbilityUsageObject, UsageData) == 0x000030, "Member 'UAIAbilityUsageObject::UsageData' has a wrong offset!");

// Class MarvelAI.AIActionArea
// 0x0068 (0x04F8 - 0x0490)
class AAIActionArea final : public AActor
{
public:
	class USimpleBoxPlayerCheckComponent*         AICheckArea;                                       // 0x0490(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AAbilityUsageStandPoint*>        RelatedUsagePointConfig;                           // 0x0498(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FAbilityUsagePointCollection> ProcessedUsagePointData;                           // 0x04A8(0x0050)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void WhenAIEnter(class ACharacter* Player);
	void WhenAIExit(class ACharacter* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionArea">();
	}
	static class AAIActionArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIActionArea>();
	}
};
static_assert(alignof(AAIActionArea) == 0x000008, "Wrong alignment on AAIActionArea");
static_assert(sizeof(AAIActionArea) == 0x0004F8, "Wrong size on AAIActionArea");
static_assert(offsetof(AAIActionArea, AICheckArea) == 0x000490, "Member 'AAIActionArea::AICheckArea' has a wrong offset!");
static_assert(offsetof(AAIActionArea, RelatedUsagePointConfig) == 0x000498, "Member 'AAIActionArea::RelatedUsagePointConfig' has a wrong offset!");
static_assert(offsetof(AAIActionArea, ProcessedUsagePointData) == 0x0004A8, "Member 'AAIActionArea::ProcessedUsagePointData' has a wrong offset!");

// Class MarvelAI.AISpawnDataConfig
// 0x0000 (0x0030 - 0x0030)
class UAISpawnDataConfig final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISpawnDataConfig">();
	}
	static class UAISpawnDataConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISpawnDataConfig>();
	}
};
static_assert(alignof(UAISpawnDataConfig) == 0x000008, "Wrong alignment on UAISpawnDataConfig");
static_assert(sizeof(UAISpawnDataConfig) == 0x000030, "Wrong size on UAISpawnDataConfig");

// Class MarvelAI.AIAutoAbilityComponent
// 0x00B0 (0x01A0 - 0x00F0)
class UAIAutoAbilityComponent final : public UMarvelActorComponentBase
{
public:
	TArray<class UAIAbilityCondition*>            DynamicUsageConditions;                            // 0x00F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0xA0];                                     // 0x0100(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddUsageCondition(class UAIAbilityCondition* ConditionToAdd);
	void HandleAbilityActivated(int32 AbilityUsageID);
	void RemoveUsageCondition(class UAIAbilityCondition* ConditionToRemove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAutoAbilityComponent">();
	}
	static class UAIAutoAbilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAutoAbilityComponent>();
	}
};
static_assert(alignof(UAIAutoAbilityComponent) == 0x000008, "Wrong alignment on UAIAutoAbilityComponent");
static_assert(sizeof(UAIAutoAbilityComponent) == 0x0001A0, "Wrong size on UAIAutoAbilityComponent");
static_assert(offsetof(UAIAutoAbilityComponent, DynamicUsageConditions) == 0x0000F0, "Member 'UAIAutoAbilityComponent::DynamicUsageConditions' has a wrong offset!");

// Class MarvelAI.StoredPointDataBase
// 0x0000 (0x0030 - 0x0030)
class UStoredPointDataBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoredPointDataBase">();
	}
	static class UStoredPointDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoredPointDataBase>();
	}
};
static_assert(alignof(UStoredPointDataBase) == 0x000008, "Wrong alignment on UStoredPointDataBase");
static_assert(sizeof(UStoredPointDataBase) == 0x000030, "Wrong size on UStoredPointDataBase");

// Class MarvelAI.DynamicAbilityBindFilter
// 0x0008 (0x0038 - 0x0030)
class UDynamicAbilityBindFilter : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicAbilityBindFilter">();
	}
	static class UDynamicAbilityBindFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicAbilityBindFilter>();
	}
};
static_assert(alignof(UDynamicAbilityBindFilter) == 0x000008, "Wrong alignment on UDynamicAbilityBindFilter");
static_assert(sizeof(UDynamicAbilityBindFilter) == 0x000038, "Wrong size on UDynamicAbilityBindFilter");

// Class MarvelAI.AIBattleAreaBase
// 0x0048 (0x04D8 - 0x0490)
class AAIBattleAreaBase : public AActor
{
public:
	class FName                                   AreaName;                                          // 0x0490(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x04A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAIBattleAreaFilterBase*                BattleAreaFilter;                                  // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAreaType                               BattleAreaType;                                    // 0x04C0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C1[0x7];                                      // 0x04C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AStandPointBase*>                StandPointList;                                    // 0x04C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void BindStandPoint(class AStandPointBase* StandPoint);
	class AStandPointBase* GetRandomStandPoint(class AMarvelAIController* Controller);
	class AStandPointBase* GetRandomStandPointInList(const TArray<class AStandPointBase*>& InStandPointList);
	class AStandPointBase* GetStandPoint(class AMarvelAIController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIBattleAreaBase">();
	}
	static class AAIBattleAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIBattleAreaBase>();
	}
};
static_assert(alignof(AAIBattleAreaBase) == 0x000008, "Wrong alignment on AAIBattleAreaBase");
static_assert(sizeof(AAIBattleAreaBase) == 0x0004D8, "Wrong size on AAIBattleAreaBase");
static_assert(offsetof(AAIBattleAreaBase, AreaName) == 0x000490, "Member 'AAIBattleAreaBase::AreaName' has a wrong offset!");
static_assert(offsetof(AAIBattleAreaBase, Description) == 0x0004A0, "Member 'AAIBattleAreaBase::Description' has a wrong offset!");
static_assert(offsetof(AAIBattleAreaBase, BattleAreaFilter) == 0x0004B8, "Member 'AAIBattleAreaBase::BattleAreaFilter' has a wrong offset!");
static_assert(offsetof(AAIBattleAreaBase, BattleAreaType) == 0x0004C0, "Member 'AAIBattleAreaBase::BattleAreaType' has a wrong offset!");
static_assert(offsetof(AAIBattleAreaBase, StandPointList) == 0x0004C8, "Member 'AAIBattleAreaBase::StandPointList' has a wrong offset!");

// Class MarvelAI.AISniperBattleArea
// 0x0008 (0x04E0 - 0x04D8)
class AAISniperBattleArea final : public AAIBattleAreaBase
{
public:
	float                                         SwitchPointProbability;                            // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4DC[0x4];                                      // 0x04DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISniperBattleArea">();
	}
	static class AAISniperBattleArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAISniperBattleArea>();
	}
};
static_assert(alignof(AAISniperBattleArea) == 0x000008, "Wrong alignment on AAISniperBattleArea");
static_assert(sizeof(AAISniperBattleArea) == 0x0004E0, "Wrong size on AAISniperBattleArea");
static_assert(offsetof(AAISniperBattleArea, SwitchPointProbability) == 0x0004D8, "Member 'AAISniperBattleArea::SwitchPointProbability' has a wrong offset!");

// Class MarvelAI.AITargetFactorLibrary
// 0x0000 (0x0030 - 0x0030)
class UAITargetFactorLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CancelConcentrateTarget(class AMarvelAIController* MyController, class AActor* Target);
	static float GetDamageSourceFactorForTarget(const struct FAITargetFactorConfig& TargetFactorConfig, class AMarvelAIController* MyController, class AActor* Target);
	static float GetLowHpFactorForTarget(class AActor* Target, float MarkLife);
	static float GetRoleFactorForTarget(const struct FAITargetFactorConfig& TargetFactorConfig, class AActor* MyActor, class AActor* TargetActor);
	static float GetTargetChangeProbability(const struct FTargetChangeConfig& Config, float TargetHpRatio);
	static float GetVisibleFactorForTarget(const struct FAITargetFactorConfig& TargetFactorConfig, class AMarvelAIController* MyController, class AActor* Target);
	static void TryAddHpLowMarkToTarget(const struct FTargetChangeConfig& Config, class AActor* Target, float MarkLife);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITargetFactorLibrary">();
	}
	static class UAITargetFactorLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITargetFactorLibrary>();
	}
};
static_assert(alignof(UAITargetFactorLibrary) == 0x000008, "Wrong alignment on UAITargetFactorLibrary");
static_assert(sizeof(UAITargetFactorLibrary) == 0x000030, "Wrong size on UAITargetFactorLibrary");

// Class MarvelAI.AIDefendBattleArea
// 0x0000 (0x04D8 - 0x04D8)
class AAIDefendBattleArea final : public AAIBattleAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDefendBattleArea">();
	}
	static class AAIDefendBattleArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIDefendBattleArea>();
	}
};
static_assert(alignof(AAIDefendBattleArea) == 0x000008, "Wrong alignment on AAIDefendBattleArea");
static_assert(sizeof(AAIDefendBattleArea) == 0x0004D8, "Wrong size on AAIDefendBattleArea");

// Class MarvelAI.AIBattleAreaFilterBase
// 0x0000 (0x0030 - 0x0030)
class UAIBattleAreaFilterBase final : public UObject
{
public:
	bool CheckCouldPass(class AAIBattleAreaBase* BattleArea);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIBattleAreaFilterBase">();
	}
	static class UAIBattleAreaFilterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIBattleAreaFilterBase>();
	}
};
static_assert(alignof(UAIBattleAreaFilterBase) == 0x000008, "Wrong alignment on UAIBattleAreaFilterBase");
static_assert(sizeof(UAIBattleAreaFilterBase) == 0x000030, "Wrong size on UAIBattleAreaFilterBase");

// Class MarvelAI.AISenseConfig_DangerousTarget
// 0x0058 (0x00A8 - 0x0050)
class UAISenseConfig_DangerousTarget final : public UAISenseConfig
{
public:
	class UDangerousTargetAsset*                  DangerousTargetAsset;                              // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, struct FAISenseDangerousTargetConfig> DefaultDangerousTarget;                            // 0x0058(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_DangerousTarget">();
	}
	static class UAISenseConfig_DangerousTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_DangerousTarget>();
	}
};
static_assert(alignof(UAISenseConfig_DangerousTarget) == 0x000008, "Wrong alignment on UAISenseConfig_DangerousTarget");
static_assert(sizeof(UAISenseConfig_DangerousTarget) == 0x0000A8, "Wrong size on UAISenseConfig_DangerousTarget");
static_assert(offsetof(UAISenseConfig_DangerousTarget, DangerousTargetAsset) == 0x000050, "Member 'UAISenseConfig_DangerousTarget::DangerousTargetAsset' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_DangerousTarget, DefaultDangerousTarget) == 0x000058, "Member 'UAISenseConfig_DangerousTarget::DefaultDangerousTarget' has a wrong offset!");

// Class MarvelAI.MarvelAIBattleAreaManager
// 0x0078 (0x00A8 - 0x0030)
class UMarvelAIBattleAreaManager : public UObject
{
public:
	TMap<class FName, class AAIBattleAreaBase*>   BattleAreaMap;                                     // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           GameModeTag;                                       // 0x0080(0x000C)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInited;                                           // 0x008C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ULevelSubsystem>         LevelSystemPtr;                                    // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AAIBattleAreaBase* FindBattleArea(const class FName& AreaName);
	class AAIBattleAreaBase* GetCurrentBattleArea(class AActor* TargetActor, EBattleAreaType InBattleAreaType);
	bool Init();
	void RegisterBattleArea(class AAIBattleAreaBase* BattleArea);
	void UnRegisterBattleArea(class AAIBattleAreaBase* BattleArea);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIBattleAreaManager">();
	}
	static class UMarvelAIBattleAreaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIBattleAreaManager>();
	}
};
static_assert(alignof(UMarvelAIBattleAreaManager) == 0x000008, "Wrong alignment on UMarvelAIBattleAreaManager");
static_assert(sizeof(UMarvelAIBattleAreaManager) == 0x0000A8, "Wrong size on UMarvelAIBattleAreaManager");
static_assert(offsetof(UMarvelAIBattleAreaManager, BattleAreaMap) == 0x000030, "Member 'UMarvelAIBattleAreaManager::BattleAreaMap' has a wrong offset!");
static_assert(offsetof(UMarvelAIBattleAreaManager, GameModeTag) == 0x000080, "Member 'UMarvelAIBattleAreaManager::GameModeTag' has a wrong offset!");
static_assert(offsetof(UMarvelAIBattleAreaManager, bInited) == 0x00008C, "Member 'UMarvelAIBattleAreaManager::bInited' has a wrong offset!");
static_assert(offsetof(UMarvelAIBattleAreaManager, LevelSystemPtr) == 0x000090, "Member 'UMarvelAIBattleAreaManager::LevelSystemPtr' has a wrong offset!");

// Class MarvelAI.AIControllerInfo
// 0x04A8 (0x0598 - 0x00F0)
class UAIControllerInfo final : public UActorComponent
{
public:
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         EnemiesInView;                                     // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         SummonedEnemiesInView;                             // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         AlliesInView;                                      // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         DangerAroundAllys;                                 // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         DangerAroundEnemies;                               // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FWayPointPath                          WayPointPath;                                      // 0x0150(0x0048)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	float                                         LastReceiveAILabResponseTime;                      // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AILabConnectTimeOutCount;                          // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepDistanceInBattle;                              // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITeamAction                                 AITeamAction;                                      // 0x01A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTeamActionFromSelf;                             // 0x01A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A6[0xA];                                      // 0x01A6(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTeamActionChanged;                               // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	int32                                         ForbiddenSkillLevel;                               // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x2D4];                                    // 0x01C4(0x02D4)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AIComboIndex;                                      // 0x0498(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UAIAbilityActivationExtraConfig*> ExtraConfigs;                                      // 0x04A0(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0xA0];                                     // 0x04F0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelAIController*                    OwnerController;                                   // 0x0590(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool AddExtraConfig(class UAIAbilityActivationExtraConfig* NewConfig);
	bool AddTag(const struct FGameplayTag& Tag);
	void ApplyTagContainer(const struct FGameplayTagContainer& TagContainer);
	bool CheckIsConcentratingTarget(class AActor* Target);
	bool CheckTeamActionIsExpired(float ValidDuration);
	void Clear();
	void DeleteConcentratedTarget(class AActor* Target);
	class UAIAbilityActivationExtraConfig* GetExtraConfig(const class FString& ConfigName);
	bool HasExtraConfig(const class FString& ConfigName);
	bool OverwriteExtraConfig(class UAIAbilityActivationExtraConfig* NewConfig);
	void RemoveExtraConfig(const class FString& ConfigName);
	bool RemoveTag(const struct FGameplayTag& Tag);
	void RemoveTagContainer(const struct FGameplayTagContainer& TagContainer);
	void ResetAIDifficulty();
	void ResetViewInfo();
	void SetNewTeamAction(EAITeamAction NewAction, bool bNewIsActionFromSelf);
	bool TrySyncWaypointPathProgress(const struct FWayPointPath& Target);
	void UpdateConcentratedTarget(class AActor* Target, float DeltaTime);
	void WayPointPathGoNext();
	void WayPointPathUpdateProgress();

	bool CheckIsInBattle() const;
	TArray<class AActor*> GetConcentratedTargets() const;
	float GetCurrentTargetHitRate(class AActor* Target, const struct FAIHitRateTagContainer& HitRateTagContainer) const;
	int32 GetTagCount(const struct FGameplayTag& Tag) const;
	bool HasAllMatchingTags(const struct FGameplayTagContainer& TagContainer) const;
	bool HasAnyMatchingTags(const struct FGameplayTagContainer& TagContainer) const;
	bool HasMatchingTag(const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIControllerInfo">();
	}
	static class UAIControllerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIControllerInfo>();
	}
};
static_assert(alignof(UAIControllerInfo) == 0x000008, "Wrong alignment on UAIControllerInfo");
static_assert(sizeof(UAIControllerInfo) == 0x000598, "Wrong size on UAIControllerInfo");
static_assert(offsetof(UAIControllerInfo, EnemiesInView) == 0x000100, "Member 'UAIControllerInfo::EnemiesInView' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, SummonedEnemiesInView) == 0x000110, "Member 'UAIControllerInfo::SummonedEnemiesInView' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, AlliesInView) == 0x000120, "Member 'UAIControllerInfo::AlliesInView' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, DangerAroundAllys) == 0x000130, "Member 'UAIControllerInfo::DangerAroundAllys' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, DangerAroundEnemies) == 0x000140, "Member 'UAIControllerInfo::DangerAroundEnemies' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, WayPointPath) == 0x000150, "Member 'UAIControllerInfo::WayPointPath' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, LastReceiveAILabResponseTime) == 0x000198, "Member 'UAIControllerInfo::LastReceiveAILabResponseTime' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, AILabConnectTimeOutCount) == 0x00019C, "Member 'UAIControllerInfo::AILabConnectTimeOutCount' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, KeepDistanceInBattle) == 0x0001A0, "Member 'UAIControllerInfo::KeepDistanceInBattle' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, AITeamAction) == 0x0001A4, "Member 'UAIControllerInfo::AITeamAction' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, bIsTeamActionFromSelf) == 0x0001A5, "Member 'UAIControllerInfo::bIsTeamActionFromSelf' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, OnTeamActionChanged) == 0x0001B0, "Member 'UAIControllerInfo::OnTeamActionChanged' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, ForbiddenSkillLevel) == 0x0001C0, "Member 'UAIControllerInfo::ForbiddenSkillLevel' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, AIComboIndex) == 0x000498, "Member 'UAIControllerInfo::AIComboIndex' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, ExtraConfigs) == 0x0004A0, "Member 'UAIControllerInfo::ExtraConfigs' has a wrong offset!");
static_assert(offsetof(UAIControllerInfo, OwnerController) == 0x000590, "Member 'UAIControllerInfo::OwnerController' has a wrong offset!");

// Class MarvelAI.BTT_PlayEmotes
// 0x0068 (0x00E0 - 0x0078)
class UBTT_PlayEmotes : public UBTTaskNode
{
public:
	uint8                                         bUseAppointedEmoteID : 1;                          // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         EmoteID;                                           // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, struct FBTHeroEmoteConfig>        HeroEmoteConfigs;                                  // 0x0088(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	int32                                         DefaultEmoteSkinID;                                // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefaultEmoteActionID;                              // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_PlayEmotes">();
	}
	static class UBTT_PlayEmotes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_PlayEmotes>();
	}
};
static_assert(alignof(UBTT_PlayEmotes) == 0x000008, "Wrong alignment on UBTT_PlayEmotes");
static_assert(sizeof(UBTT_PlayEmotes) == 0x0000E0, "Wrong size on UBTT_PlayEmotes");
static_assert(offsetof(UBTT_PlayEmotes, EmoteID) == 0x000080, "Member 'UBTT_PlayEmotes::EmoteID' has a wrong offset!");
static_assert(offsetof(UBTT_PlayEmotes, HeroEmoteConfigs) == 0x000088, "Member 'UBTT_PlayEmotes::HeroEmoteConfigs' has a wrong offset!");
static_assert(offsetof(UBTT_PlayEmotes, DefaultEmoteSkinID) == 0x0000D8, "Member 'UBTT_PlayEmotes::DefaultEmoteSkinID' has a wrong offset!");
static_assert(offsetof(UBTT_PlayEmotes, DefaultEmoteActionID) == 0x0000DC, "Member 'UBTT_PlayEmotes::DefaultEmoteActionID' has a wrong offset!");

// Class MarvelAI.AICustomServiceLogicBase
// 0x0010 (0x0040 - 0x0030)
class UAICustomServiceLogicBase final : public UObject
{
public:
	class AAIController*                          OwnerController;                                   // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  ControlledPawn;                                    // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BeginService();
	void EndService();
	void TickService(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICustomServiceLogicBase">();
	}
	static class UAICustomServiceLogicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICustomServiceLogicBase>();
	}
};
static_assert(alignof(UAICustomServiceLogicBase) == 0x000008, "Wrong alignment on UAICustomServiceLogicBase");
static_assert(sizeof(UAICustomServiceLogicBase) == 0x000040, "Wrong size on UAICustomServiceLogicBase");
static_assert(offsetof(UAICustomServiceLogicBase, OwnerController) == 0x000030, "Member 'UAICustomServiceLogicBase::OwnerController' has a wrong offset!");
static_assert(offsetof(UAICustomServiceLogicBase, ControlledPawn) == 0x000038, "Member 'UAICustomServiceLogicBase::ControlledPawn' has a wrong offset!");

// Class MarvelAI.MarvelAIWorldSubsystem
// 0x0000 (0x0048 - 0x0048)
class UMarvelAIWorldSubsystem : public UTickableWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIWorldSubsystem">();
	}
	static class UMarvelAIWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIWorldSubsystem>();
	}
};
static_assert(alignof(UMarvelAIWorldSubsystem) == 0x000008, "Wrong alignment on UMarvelAIWorldSubsystem");
static_assert(sizeof(UMarvelAIWorldSubsystem) == 0x000048, "Wrong size on UMarvelAIWorldSubsystem");

// Class MarvelAI.EnvQueryContext_BlackboardActor
// 0x0010 (0x0040 - 0x0030)
class UEnvQueryContext_BlackboardActor : public UEnvQueryContext
{
public:
	class FName                                   BlackboardKeyName;                                 // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReturnQuerierIfValueInvalid;                      // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_BlackboardActor">();
	}
	static class UEnvQueryContext_BlackboardActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_BlackboardActor>();
	}
};
static_assert(alignof(UEnvQueryContext_BlackboardActor) == 0x000008, "Wrong alignment on UEnvQueryContext_BlackboardActor");
static_assert(sizeof(UEnvQueryContext_BlackboardActor) == 0x000040, "Wrong size on UEnvQueryContext_BlackboardActor");
static_assert(offsetof(UEnvQueryContext_BlackboardActor, BlackboardKeyName) == 0x000030, "Member 'UEnvQueryContext_BlackboardActor::BlackboardKeyName' has a wrong offset!");
static_assert(offsetof(UEnvQueryContext_BlackboardActor, bReturnQuerierIfValueInvalid) == 0x00003C, "Member 'UEnvQueryContext_BlackboardActor::bReturnQuerierIfValueInvalid' has a wrong offset!");

// Class MarvelAI.AIDebugSubSystem
// 0x0000 (0x0048 - 0x0048)
class UAIDebugSubSystem final : public UMarvelAIWorldSubsystem
{
public:
	static class UAIDebugSubSystem* GetSubsystem(class UObject* ContextObject);
	static void StoreMoveResultDebugInfo(class UObject* WCO, const struct FGameplayTag& NodeTag, bool MoveSuccess);
	static void StoreMoveTargetDebugInfo(class UObject* WCO, class AMarvelAIController* AIController, const class AActor* TargetActor, const struct FVector& TargetLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDebugSubSystem">();
	}
	static class UAIDebugSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDebugSubSystem>();
	}
};
static_assert(alignof(UAIDebugSubSystem) == 0x000008, "Wrong alignment on UAIDebugSubSystem");
static_assert(sizeof(UAIDebugSubSystem) == 0x000048, "Wrong size on UAIDebugSubSystem");

// Class MarvelAI.AIDifficultyExtendAsset
// 0x0020 (0x0058 - 0x0038)
class UAIDifficultyExtendAsset final : public UPrimaryDataAsset
{
public:
	struct FHitRateModifyAsset                    HitRateModify;                                     // 0x0038(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAIDifficultyExtendAsset*               DependencyAsset;                                   // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetHitRateModifyFactor(class AMarvelBaseCharacter* Source, const struct FAIHitRateTagContainer& HitRateTagContainer, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDifficultyExtendAsset">();
	}
	static class UAIDifficultyExtendAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDifficultyExtendAsset>();
	}
};
static_assert(alignof(UAIDifficultyExtendAsset) == 0x000008, "Wrong alignment on UAIDifficultyExtendAsset");
static_assert(sizeof(UAIDifficultyExtendAsset) == 0x000058, "Wrong size on UAIDifficultyExtendAsset");
static_assert(offsetof(UAIDifficultyExtendAsset, HitRateModify) == 0x000038, "Member 'UAIDifficultyExtendAsset::HitRateModify' has a wrong offset!");
static_assert(offsetof(UAIDifficultyExtendAsset, DependencyAsset) == 0x000048, "Member 'UAIDifficultyExtendAsset::DependencyAsset' has a wrong offset!");

// Class MarvelAI.AISelectTargetLogicBase
// 0x0040 (0x0070 - 0x0030)
class UAISelectTargetLogicBase : public UObject
{
public:
	bool                                          bShouldUpdateInTick;                               // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCouldUseDefaultObject;                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTryFindFromOwnerBeforeCreate;                     // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldClearFocusWhenEnd;                          // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseMissOffset;                              // 0x003B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectilePredicateSpeed;                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectilePredicateGravity;                        // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusSpeedFactorWhenMiss;                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MissBoxLength;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MissBoxPadding;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MissBoxHeightScale;                                // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MissBoxLengthFactorCurve;                          // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MissBoxPaddingFactorCurve;                         // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableDebugDraw;                                  // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAISelectTargetLogicBase* GetSelectTargetLogicObject(class AMarvelAIController* MarvelAIOwner, TSubclassOf<class UAISelectTargetLogicBase> SelectLogicClass);

	bool CheckMissAndAddMissOffset(class AMarvelAIController* MarvelAI, struct FMarvelAITarget& OutAITarget, const struct FAIAbilityUsage& AbilityUsage);
	void OnDestroy(class AMarvelAIController* MarvelAIController, struct FAIAbilityUsage* AbilityUsage);
	void OnInitialize(class AMarvelAIController* MarvelAIController, struct FAIAbilityUsage* AbilityUsage);
	bool SelectTargetForAbilityCheck(const struct FRequiredAIDataForAutoAbility& AbilityContext, struct FMarvelAITarget& OutAITarget);
	bool SelectTargetOrLocation(class AMarvelAIController* AIController, struct FMarvelAITarget& OutAITarget, const struct FAIAbilityUsage& AbilityUsage);
	bool TakeResultAITarget(class AMarvelAIController* AIController, struct FMarvelAITarget& OutAITarget, const struct FAIAbilityUsage& AbilityUsage);
	bool UpdateProjectilePredicateSpeed(class AMarvelAIController* AIController, const struct FAIAbilityUsage& AbilityUsage, const struct FMarvelProjectileAgentTable& ProjectileAgentTable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISelectTargetLogicBase">();
	}
	static class UAISelectTargetLogicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISelectTargetLogicBase>();
	}
};
static_assert(alignof(UAISelectTargetLogicBase) == 0x000008, "Wrong alignment on UAISelectTargetLogicBase");
static_assert(sizeof(UAISelectTargetLogicBase) == 0x000070, "Wrong size on UAISelectTargetLogicBase");
static_assert(offsetof(UAISelectTargetLogicBase, bShouldUpdateInTick) == 0x000030, "Member 'UAISelectTargetLogicBase::bShouldUpdateInTick' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, TickInterval) == 0x000034, "Member 'UAISelectTargetLogicBase::TickInterval' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, bCouldUseDefaultObject) == 0x000038, "Member 'UAISelectTargetLogicBase::bCouldUseDefaultObject' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, bTryFindFromOwnerBeforeCreate) == 0x000039, "Member 'UAISelectTargetLogicBase::bTryFindFromOwnerBeforeCreate' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, bShouldClearFocusWhenEnd) == 0x00003A, "Member 'UAISelectTargetLogicBase::bShouldClearFocusWhenEnd' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, bShouldUseMissOffset) == 0x00003B, "Member 'UAISelectTargetLogicBase::bShouldUseMissOffset' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, ProjectilePredicateSpeed) == 0x00003C, "Member 'UAISelectTargetLogicBase::ProjectilePredicateSpeed' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, ProjectilePredicateGravity) == 0x000040, "Member 'UAISelectTargetLogicBase::ProjectilePredicateGravity' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, FocusSpeedFactorWhenMiss) == 0x000044, "Member 'UAISelectTargetLogicBase::FocusSpeedFactorWhenMiss' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, MissBoxLength) == 0x000048, "Member 'UAISelectTargetLogicBase::MissBoxLength' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, MissBoxPadding) == 0x00004C, "Member 'UAISelectTargetLogicBase::MissBoxPadding' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, MissBoxHeightScale) == 0x000050, "Member 'UAISelectTargetLogicBase::MissBoxHeightScale' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, MissBoxLengthFactorCurve) == 0x000058, "Member 'UAISelectTargetLogicBase::MissBoxLengthFactorCurve' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, MissBoxPaddingFactorCurve) == 0x000060, "Member 'UAISelectTargetLogicBase::MissBoxPaddingFactorCurve' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase, bEnableDebugDraw) == 0x000068, "Member 'UAISelectTargetLogicBase::bEnableDebugDraw' has a wrong offset!");

// Class MarvelAI.AISelectTargetLogic_General
// 0x0030 (0x00A0 - 0x0070)
class UAISelectTargetLogic_General : public UAISelectTargetLogicBase
{
public:
	bool                                          bEnableAccumulateHitRate;                          // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceForTargetAsUnMoved;                     // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoxLengthFactorByDistance;                         // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x1C];                                      // 0x007C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseAimBoxLength;                                  // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISelectTargetLogic_General">();
	}
	static class UAISelectTargetLogic_General* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISelectTargetLogic_General>();
	}
};
static_assert(alignof(UAISelectTargetLogic_General) == 0x000008, "Wrong alignment on UAISelectTargetLogic_General");
static_assert(sizeof(UAISelectTargetLogic_General) == 0x0000A0, "Wrong size on UAISelectTargetLogic_General");
static_assert(offsetof(UAISelectTargetLogic_General, bEnableAccumulateHitRate) == 0x000070, "Member 'UAISelectTargetLogic_General::bEnableAccumulateHitRate' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_General, MaxDistanceForTargetAsUnMoved) == 0x000074, "Member 'UAISelectTargetLogic_General::MaxDistanceForTargetAsUnMoved' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_General, BoxLengthFactorByDistance) == 0x000078, "Member 'UAISelectTargetLogic_General::BoxLengthFactorByDistance' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_General, BaseAimBoxLength) == 0x000098, "Member 'UAISelectTargetLogic_General::BaseAimBoxLength' has a wrong offset!");

// Class MarvelAI.AIDashIntentionSelectTarget
// 0x0018 (0x00B8 - 0x00A0)
class UAIDashIntentionSelectTarget final : public UAISelectTargetLogic_General
{
public:
	struct FVector                                LocationOffset;                                    // 0x00A0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDashIntentionSelectTarget">();
	}
	static class UAIDashIntentionSelectTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDashIntentionSelectTarget>();
	}
};
static_assert(alignof(UAIDashIntentionSelectTarget) == 0x000008, "Wrong alignment on UAIDashIntentionSelectTarget");
static_assert(sizeof(UAIDashIntentionSelectTarget) == 0x0000B8, "Wrong size on UAIDashIntentionSelectTarget");
static_assert(offsetof(UAIDashIntentionSelectTarget, LocationOffset) == 0x0000A0, "Member 'UAIDashIntentionSelectTarget::LocationOffset' has a wrong offset!");

// Class MarvelAI.AIDynamicDifficultyAsset
// 0x0038 (0x0070 - 0x0038)
class UAIDynamicDifficultyAsset final : public UPrimaryDataAsset
{
public:
	class UCurveFloat*                            HealingScaleCurve;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            HitRateModifyCurve;                                // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MoveWaitTimeCurve;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JumpIntervalCurve;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            LowHealthMarkDurationCurve;                        // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            LowHealthMarkCooldownCurve;                        // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AILABFrequencyCurve;                               // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDynamicDifficultyAsset">();
	}
	static class UAIDynamicDifficultyAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDynamicDifficultyAsset>();
	}
};
static_assert(alignof(UAIDynamicDifficultyAsset) == 0x000008, "Wrong alignment on UAIDynamicDifficultyAsset");
static_assert(sizeof(UAIDynamicDifficultyAsset) == 0x000070, "Wrong size on UAIDynamicDifficultyAsset");
static_assert(offsetof(UAIDynamicDifficultyAsset, HealingScaleCurve) == 0x000038, "Member 'UAIDynamicDifficultyAsset::HealingScaleCurve' has a wrong offset!");
static_assert(offsetof(UAIDynamicDifficultyAsset, HitRateModifyCurve) == 0x000040, "Member 'UAIDynamicDifficultyAsset::HitRateModifyCurve' has a wrong offset!");
static_assert(offsetof(UAIDynamicDifficultyAsset, MoveWaitTimeCurve) == 0x000048, "Member 'UAIDynamicDifficultyAsset::MoveWaitTimeCurve' has a wrong offset!");
static_assert(offsetof(UAIDynamicDifficultyAsset, JumpIntervalCurve) == 0x000050, "Member 'UAIDynamicDifficultyAsset::JumpIntervalCurve' has a wrong offset!");
static_assert(offsetof(UAIDynamicDifficultyAsset, LowHealthMarkDurationCurve) == 0x000058, "Member 'UAIDynamicDifficultyAsset::LowHealthMarkDurationCurve' has a wrong offset!");
static_assert(offsetof(UAIDynamicDifficultyAsset, LowHealthMarkCooldownCurve) == 0x000060, "Member 'UAIDynamicDifficultyAsset::LowHealthMarkCooldownCurve' has a wrong offset!");
static_assert(offsetof(UAIDynamicDifficultyAsset, AILABFrequencyCurve) == 0x000068, "Member 'UAIDynamicDifficultyAsset::AILABFrequencyCurve' has a wrong offset!");

// Class MarvelAI.AIGameEventSubsystem
// 0x0078 (0x00B0 - 0x0038)
class UAIGameEventSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelGameplayEventManager*            MarvelGameplayEventManager;                        // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnActorEnergyFull(class AActor* Source, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnHealthChanged(class AActor* Source, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnPlayerKill(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void PreparingStartCallback();
	void QuittingStartCallback();
	void RegisterGameModeEvent();
	void UnRegisterGameModeEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIGameEventSubsystem">();
	}
	static class UAIGameEventSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIGameEventSubsystem>();
	}
};
static_assert(alignof(UAIGameEventSubsystem) == 0x000008, "Wrong alignment on UAIGameEventSubsystem");
static_assert(sizeof(UAIGameEventSubsystem) == 0x0000B0, "Wrong size on UAIGameEventSubsystem");
static_assert(offsetof(UAIGameEventSubsystem, MarvelGameplayEventManager) == 0x0000A8, "Member 'UAIGameEventSubsystem::MarvelGameplayEventManager' has a wrong offset!");

// Class MarvelAI.BTT_MarvelRunBehaviorDynamic
// 0x0030 (0x00C8 - 0x0098)
class UBTT_MarvelRunBehaviorDynamic final : public UBTTask_RunBehaviorDynamic
{
public:
	struct FBlackboardKeySelector                 TargetBehaviorTreeKey;                             // 0x0098(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_MarvelRunBehaviorDynamic">();
	}
	static class UBTT_MarvelRunBehaviorDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_MarvelRunBehaviorDynamic>();
	}
};
static_assert(alignof(UBTT_MarvelRunBehaviorDynamic) == 0x000008, "Wrong alignment on UBTT_MarvelRunBehaviorDynamic");
static_assert(sizeof(UBTT_MarvelRunBehaviorDynamic) == 0x0000C8, "Wrong size on UBTT_MarvelRunBehaviorDynamic");
static_assert(offsetof(UBTT_MarvelRunBehaviorDynamic, TargetBehaviorTreeKey) == 0x000098, "Member 'UBTT_MarvelRunBehaviorDynamic::TargetBehaviorTreeKey' has a wrong offset!");

// Class MarvelAI.AIGameInstanceSubsystem
// 0x0038 (0x0070 - 0x0038)
class UAIGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnAIAssetsLoadedSuccessfullyDelegate;              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBehaviorTree*>                  SubTreesNeedPreLoad;                               // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        AIAssets;                                          // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAIAssetsLoaded(const TArray<class UObject*>& AIAssets_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIGameInstanceSubsystem">();
	}
	static class UAIGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIGameInstanceSubsystem>();
	}
};
static_assert(alignof(UAIGameInstanceSubsystem) == 0x000008, "Wrong alignment on UAIGameInstanceSubsystem");
static_assert(sizeof(UAIGameInstanceSubsystem) == 0x000070, "Wrong size on UAIGameInstanceSubsystem");
static_assert(offsetof(UAIGameInstanceSubsystem, OnAIAssetsLoadedSuccessfullyDelegate) == 0x000038, "Member 'UAIGameInstanceSubsystem::OnAIAssetsLoadedSuccessfullyDelegate' has a wrong offset!");
static_assert(offsetof(UAIGameInstanceSubsystem, SubTreesNeedPreLoad) == 0x000048, "Member 'UAIGameInstanceSubsystem::SubTreesNeedPreLoad' has a wrong offset!");
static_assert(offsetof(UAIGameInstanceSubsystem, AIAssets) == 0x000058, "Member 'UAIGameInstanceSubsystem::AIAssets' has a wrong offset!");

// Class MarvelAI.AIGroupInfoBase
// 0x0068 (0x04F8 - 0x0490)
class AAIGroupInfoBase : public AInfo
{
public:
	struct FAIHeroTag                             IgnoreHeroTag;                                     // 0x0490(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIGroupInfoBase">();
	}
	static class AAIGroupInfoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIGroupInfoBase>();
	}
};
static_assert(alignof(AAIGroupInfoBase) == 0x000008, "Wrong alignment on AAIGroupInfoBase");
static_assert(sizeof(AAIGroupInfoBase) == 0x0004F8, "Wrong size on AAIGroupInfoBase");
static_assert(offsetof(AAIGroupInfoBase, IgnoreHeroTag) == 0x000490, "Member 'AAIGroupInfoBase::IgnoreHeroTag' has a wrong offset!");

// Class MarvelAI.EnvQueryContext_AllAliveTeammates
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_AllAliveTeammates final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_AllAliveTeammates">();
	}
	static class UEnvQueryContext_AllAliveTeammates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_AllAliveTeammates>();
	}
};
static_assert(alignof(UEnvQueryContext_AllAliveTeammates) == 0x000008, "Wrong alignment on UEnvQueryContext_AllAliveTeammates");
static_assert(sizeof(UEnvQueryContext_AllAliveTeammates) == 0x000030, "Wrong size on UEnvQueryContext_AllAliveTeammates");

// Class MarvelAI.AIHitRateModify
// 0x0028 (0x0058 - 0x0030)
class UAIHitRateModify : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTagMatch;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           MatchTag;                                          // 0x0044(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateHitRateModifyAI(class AMarvelBaseCharacter* Source, class AActor* Target) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHitRateModify">();
	}
	static class UAIHitRateModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHitRateModify>();
	}
};
static_assert(alignof(UAIHitRateModify) == 0x000008, "Wrong alignment on UAIHitRateModify");
static_assert(sizeof(UAIHitRateModify) == 0x000058, "Wrong size on UAIHitRateModify");
static_assert(offsetof(UAIHitRateModify, bTagMatch) == 0x000040, "Member 'UAIHitRateModify::bTagMatch' has a wrong offset!");
static_assert(offsetof(UAIHitRateModify, MatchTag) == 0x000044, "Member 'UAIHitRateModify::MatchTag' has a wrong offset!");

// Class MarvelAI.DistanceModify
// 0x0008 (0x0060 - 0x0058)
class UDistanceModify final : public UAIHitRateModify
{
public:
	class UCurveFloat*                            HitRateToDistance;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistanceModify">();
	}
	static class UDistanceModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistanceModify>();
	}
};
static_assert(alignof(UDistanceModify) == 0x000008, "Wrong alignment on UDistanceModify");
static_assert(sizeof(UDistanceModify) == 0x000060, "Wrong size on UDistanceModify");
static_assert(offsetof(UDistanceModify, HitRateToDistance) == 0x000058, "Member 'UDistanceModify::HitRateToDistance' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_1030Respond
// 0x0048 (0x02C8 - 0x0280)
class UEnvQueryTest_1030Respond final : public UEnvQueryTest
{
public:
	struct FAIDataProviderBoolValue               EnableThisTest;                                    // 0x0280(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_1030Respond">();
	}
	static class UEnvQueryTest_1030Respond* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_1030Respond>();
	}
};
static_assert(alignof(UEnvQueryTest_1030Respond) == 0x000008, "Wrong alignment on UEnvQueryTest_1030Respond");
static_assert(sizeof(UEnvQueryTest_1030Respond) == 0x0002C8, "Wrong size on UEnvQueryTest_1030Respond");
static_assert(offsetof(UEnvQueryTest_1030Respond, EnableThisTest) == 0x000280, "Member 'UEnvQueryTest_1030Respond::EnableThisTest' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_1030Respond, DistanceTo) == 0x0002C0, "Member 'UEnvQueryTest_1030Respond::DistanceTo' has a wrong offset!");

// Class MarvelAI.ShapeModify
// 0x0010 (0x0068 - 0x0058)
class UShapeModify final : public UAIHitRateModify
{
public:
	float                                         MinDistance;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            HitRateForShape;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShapeModify">();
	}
	static class UShapeModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShapeModify>();
	}
};
static_assert(alignof(UShapeModify) == 0x000008, "Wrong alignment on UShapeModify");
static_assert(sizeof(UShapeModify) == 0x000068, "Wrong size on UShapeModify");
static_assert(offsetof(UShapeModify, MinDistance) == 0x000058, "Member 'UShapeModify::MinDistance' has a wrong offset!");
static_assert(offsetof(UShapeModify, HitRateForShape) == 0x000060, "Member 'UShapeModify::HitRateForShape' has a wrong offset!");

// Class MarvelAI.FlyVelocityModify
// 0x0010 (0x0068 - 0x0058)
class UFlyVelocityModify final : public UAIHitRateModify
{
public:
	float                                         MinHeight;                                         // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            HitRateForFlyVelocity;                             // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlyVelocityModify">();
	}
	static class UFlyVelocityModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlyVelocityModify>();
	}
};
static_assert(alignof(UFlyVelocityModify) == 0x000008, "Wrong alignment on UFlyVelocityModify");
static_assert(sizeof(UFlyVelocityModify) == 0x000068, "Wrong size on UFlyVelocityModify");
static_assert(offsetof(UFlyVelocityModify, MinHeight) == 0x000058, "Member 'UFlyVelocityModify::MinHeight' has a wrong offset!");
static_assert(offsetof(UFlyVelocityModify, HitRateForFlyVelocity) == 0x000060, "Member 'UFlyVelocityModify::HitRateForFlyVelocity' has a wrong offset!");

// Class MarvelAI.EnvQueryContext_CharacterGroup
// 0x0008 (0x0038 - 0x0030)
class UEnvQueryContext_CharacterGroup : public UEnvQueryContext
{
public:
	EAICharacterSide                              CharacterGroupSide;                                // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHeroRole                                     CharacterGroupRole;                                // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IgnoreBBTarget;                                    // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_CharacterGroup">();
	}
	static class UEnvQueryContext_CharacterGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_CharacterGroup>();
	}
};
static_assert(alignof(UEnvQueryContext_CharacterGroup) == 0x000008, "Wrong alignment on UEnvQueryContext_CharacterGroup");
static_assert(sizeof(UEnvQueryContext_CharacterGroup) == 0x000038, "Wrong size on UEnvQueryContext_CharacterGroup");
static_assert(offsetof(UEnvQueryContext_CharacterGroup, CharacterGroupSide) == 0x000030, "Member 'UEnvQueryContext_CharacterGroup::CharacterGroupSide' has a wrong offset!");
static_assert(offsetof(UEnvQueryContext_CharacterGroup, CharacterGroupRole) == 0x000031, "Member 'UEnvQueryContext_CharacterGroup::CharacterGroupRole' has a wrong offset!");
static_assert(offsetof(UEnvQueryContext_CharacterGroup, IgnoreBBTarget) == 0x000032, "Member 'UEnvQueryContext_CharacterGroup::IgnoreBBTarget' has a wrong offset!");

// Class MarvelAI.ObstructedModify
// 0x0008 (0x0060 - 0x0058)
class UObstructedModify final : public UAIHitRateModify
{
public:
	float                                         ModifyHitRate;                                     // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObstructedModify">();
	}
	static class UObstructedModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObstructedModify>();
	}
};
static_assert(alignof(UObstructedModify) == 0x000008, "Wrong alignment on UObstructedModify");
static_assert(sizeof(UObstructedModify) == 0x000060, "Wrong size on UObstructedModify");
static_assert(offsetof(UObstructedModify, ModifyHitRate) == 0x000058, "Member 'UObstructedModify::ModifyHitRate' has a wrong offset!");

// Class MarvelAI.LowHealthModify
// 0x0008 (0x0060 - 0x0058)
class ULowHealthModify final : public UAIHitRateModify
{
public:
	class UCurveFloat*                            HitRateForLowHealth;                               // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowHealthModify">();
	}
	static class ULowHealthModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowHealthModify>();
	}
};
static_assert(alignof(ULowHealthModify) == 0x000008, "Wrong alignment on ULowHealthModify");
static_assert(sizeof(ULowHealthModify) == 0x000060, "Wrong size on ULowHealthModify");
static_assert(offsetof(ULowHealthModify, HitRateForLowHealth) == 0x000058, "Member 'ULowHealthModify::HitRateForLowHealth' has a wrong offset!");

// Class MarvelAI.DynamicAbilityBindFilterInterface
// 0x0000 (0x0030 - 0x0030)
class IDynamicAbilityBindFilterInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicAbilityBindFilterInterface">();
	}
	static class IDynamicAbilityBindFilterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDynamicAbilityBindFilterInterface>();
	}
};
static_assert(alignof(IDynamicAbilityBindFilterInterface) == 0x000008, "Wrong alignment on IDynamicAbilityBindFilterInterface");
static_assert(sizeof(IDynamicAbilityBindFilterInterface) == 0x000030, "Wrong size on IDynamicAbilityBindFilterInterface");

// Class MarvelAI.BehindShieldModify
// 0x0F98 (0x0FF0 - 0x0058)
class UBehindShieldModify final : public UAIHitRateModify
{
public:
	float                                         ModifyHitRate;                                     // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0xF94];                                     // 0x005C(0x0F94)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehindShieldModify">();
	}
	static class UBehindShieldModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehindShieldModify>();
	}
};
static_assert(alignof(UBehindShieldModify) == 0x000008, "Wrong alignment on UBehindShieldModify");
static_assert(sizeof(UBehindShieldModify) == 0x000FF0, "Wrong size on UBehindShieldModify");
static_assert(offsetof(UBehindShieldModify, ModifyHitRate) == 0x000058, "Member 'UBehindShieldModify::ModifyHitRate' has a wrong offset!");

// Class MarvelAI.DifficultyModify
// 0x0050 (0x00A8 - 0x0058)
class UDifficultyModify final : public UAIHitRateModify
{
public:
	TMap<int32, float>                            DifficultyToHitRateModify;                         // 0x0058(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DifficultyModify">();
	}
	static class UDifficultyModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDifficultyModify>();
	}
};
static_assert(alignof(UDifficultyModify) == 0x000008, "Wrong alignment on UDifficultyModify");
static_assert(sizeof(UDifficultyModify) == 0x0000A8, "Wrong size on UDifficultyModify");
static_assert(offsetof(UDifficultyModify, DifficultyToHitRateModify) == 0x000058, "Member 'UDifficultyModify::DifficultyToHitRateModify' has a wrong offset!");

// Class MarvelAI.EnvQueryGenerator_StaticActors
// 0x0058 (0x0140 - 0x00E8)
class UEnvQueryGenerator_StaticActors final : public UEnvQueryGenerator_ActorsOfClass
{
public:
	bool                                          bUseCachedData;                                    // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x57];                                      // 0x00E9(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_StaticActors">();
	}
	static class UEnvQueryGenerator_StaticActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_StaticActors>();
	}
};
static_assert(alignof(UEnvQueryGenerator_StaticActors) == 0x000008, "Wrong alignment on UEnvQueryGenerator_StaticActors");
static_assert(sizeof(UEnvQueryGenerator_StaticActors) == 0x000140, "Wrong size on UEnvQueryGenerator_StaticActors");
static_assert(offsetof(UEnvQueryGenerator_StaticActors, bUseCachedData) == 0x0000E8, "Member 'UEnvQueryGenerator_StaticActors::bUseCachedData' has a wrong offset!");

// Class MarvelAI.LowHealthMarkModify
// 0x0050 (0x00A8 - 0x0058)
class ULowHealthMarkModify final : public UAIHitRateModify
{
public:
	TMap<int32, float>                            DifficultyToHitRateModify;                         // 0x0058(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowHealthMarkModify">();
	}
	static class ULowHealthMarkModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowHealthMarkModify>();
	}
};
static_assert(alignof(ULowHealthMarkModify) == 0x000008, "Wrong alignment on ULowHealthMarkModify");
static_assert(sizeof(ULowHealthMarkModify) == 0x0000A8, "Wrong size on ULowHealthMarkModify");
static_assert(offsetof(ULowHealthMarkModify, DifficultyToHitRateModify) == 0x000058, "Member 'ULowHealthMarkModify::DifficultyToHitRateModify' has a wrong offset!");

// Class MarvelAI.TargetVelocity
// 0x0008 (0x0060 - 0x0058)
class UTargetVelocity final : public UAIHitRateModify
{
public:
	class UCurveFloat*                            HitRateForSpeed;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetVelocity">();
	}
	static class UTargetVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetVelocity>();
	}
};
static_assert(alignof(UTargetVelocity) == 0x000008, "Wrong alignment on UTargetVelocity");
static_assert(sizeof(UTargetVelocity) == 0x000060, "Wrong size on UTargetVelocity");
static_assert(offsetof(UTargetVelocity, HitRateForSpeed) == 0x000058, "Member 'UTargetVelocity::HitRateForSpeed' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_IsShelterBroken
// 0x0000 (0x0280 - 0x0280)
class UEnvQueryTest_IsShelterBroken final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_IsShelterBroken">();
	}
	static class UEnvQueryTest_IsShelterBroken* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_IsShelterBroken>();
	}
};
static_assert(alignof(UEnvQueryTest_IsShelterBroken) == 0x000008, "Wrong alignment on UEnvQueryTest_IsShelterBroken");
static_assert(sizeof(UEnvQueryTest_IsShelterBroken) == 0x000280, "Wrong size on UEnvQueryTest_IsShelterBroken");

// Class MarvelAI.AIGlobalConfigAsset
// 0x0000 (0x0038 - 0x0038)
class UAIGlobalConfigAsset : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIGlobalConfigAsset">();
	}
	static class UAIGlobalConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIGlobalConfigAsset>();
	}
};
static_assert(alignof(UAIGlobalConfigAsset) == 0x000008, "Wrong alignment on UAIGlobalConfigAsset");
static_assert(sizeof(UAIGlobalConfigAsset) == 0x000038, "Wrong size on UAIGlobalConfigAsset");

// Class MarvelAI.AILabConfigAsset
// 0x0068 (0x00A0 - 0x0038)
class UAILabConfigAsset final : public UAIGlobalConfigAsset
{
public:
	bool                                          bEnableAILab;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLog;                                        // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameOverRequestDelay;                              // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequestInterval;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        LowDataUpdateInterval;                             // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   AbilityWithoutCD;                                  // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AILabConfigAsset">();
	}
	static class UAILabConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAILabConfigAsset>();
	}
};
static_assert(alignof(UAILabConfigAsset) == 0x000008, "Wrong alignment on UAILabConfigAsset");
static_assert(sizeof(UAILabConfigAsset) == 0x0000A0, "Wrong size on UAILabConfigAsset");
static_assert(offsetof(UAILabConfigAsset, bEnableAILab) == 0x000038, "Member 'UAILabConfigAsset::bEnableAILab' has a wrong offset!");
static_assert(offsetof(UAILabConfigAsset, bEnableLog) == 0x000039, "Member 'UAILabConfigAsset::bEnableLog' has a wrong offset!");
static_assert(offsetof(UAILabConfigAsset, GameOverRequestDelay) == 0x00003C, "Member 'UAILabConfigAsset::GameOverRequestDelay' has a wrong offset!");
static_assert(offsetof(UAILabConfigAsset, RequestInterval) == 0x000040, "Member 'UAILabConfigAsset::RequestInterval' has a wrong offset!");
static_assert(offsetof(UAILabConfigAsset, LowDataUpdateInterval) == 0x000048, "Member 'UAILabConfigAsset::LowDataUpdateInterval' has a wrong offset!");
static_assert(offsetof(UAILabConfigAsset, AbilityWithoutCD) == 0x000050, "Member 'UAILabConfigAsset::AbilityWithoutCD' has a wrong offset!");

// Class MarvelAI.AILabSubSystem
// 0x0260 (0x02A8 - 0x0048)
class UAILabSubSystem : public UMarvelAIWorldSubsystem
{
public:
	uint8                                         Pad_48[0x4];                                       // 0x0048(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RedDifficulty;                                     // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BlueDifficulty;                                    // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTargetMgmtSys*                  AbilityTargetMgmt;                                 // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelGameInstance*                    MarvelGameInstance;                                // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMarvelGameState*                       MarvelGameState;                                   // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x50];                                      // 0x0070(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CacheModeName;                                     // 0x00C0(0x0010)(ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x1D8];                                     // 0x00D0(0x01D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAILabSubSystem* GetAILabSubSystem(class UObject* WorldContextObject);

	void GetAbilitySummonedDataList(TArray<struct FAILabProtoSummonedData>* OutSummonedDataList);
	void GetAILabProtoTickData(struct FAILabProtoTickData* OutTickData);
	void GetAmmoClipData(class AMarvelBaseCharacter* Character, struct FAILabProtoWeaponClipData* OutWeaponClipData);
	void GetBuffData(const class AMarvelBaseCharacter* Character, TArray<struct FAILabProtoBuffData>* OutBuffDataList);
	void GetCharacterAbilityData(class AMarvelBaseCharacter* Character, struct FAILabProtoAbilityData* OutAbilityData);
	TArray<int32> GetCurrentAmmoTypeList(class AMarvelBaseCharacter* Character);
	TArray<float> GetLevelParamData();
	void InitAILabLogic();
	void InitFromAILabConfig();
	void OnActorEndAbility(class AActor* Source, int32 AbilityID, const class FString& SessionID, class UMarvelGameplayAbility* SourceAbility);
	void OnGameQuittingStart();
	void PyBindEvents();
	void PyUnBindEvents();
	void ReceiveFirstRequestInit();
	void TryGetAICharacterView(const class AMarvelBaseCharacter* Characters, struct FAILabProtoEnvironmentData& OutEnvironmentData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AILabSubSystem">();
	}
	static class UAILabSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAILabSubSystem>();
	}
};
static_assert(alignof(UAILabSubSystem) == 0x000008, "Wrong alignment on UAILabSubSystem");
static_assert(sizeof(UAILabSubSystem) == 0x0002A8, "Wrong size on UAILabSubSystem");
static_assert(offsetof(UAILabSubSystem, RedDifficulty) == 0x00004C, "Member 'UAILabSubSystem::RedDifficulty' has a wrong offset!");
static_assert(offsetof(UAILabSubSystem, BlueDifficulty) == 0x000050, "Member 'UAILabSubSystem::BlueDifficulty' has a wrong offset!");
static_assert(offsetof(UAILabSubSystem, AbilityTargetMgmt) == 0x000058, "Member 'UAILabSubSystem::AbilityTargetMgmt' has a wrong offset!");
static_assert(offsetof(UAILabSubSystem, MarvelGameInstance) == 0x000060, "Member 'UAILabSubSystem::MarvelGameInstance' has a wrong offset!");
static_assert(offsetof(UAILabSubSystem, MarvelGameState) == 0x000068, "Member 'UAILabSubSystem::MarvelGameState' has a wrong offset!");
static_assert(offsetof(UAILabSubSystem, CacheModeName) == 0x0000C0, "Member 'UAILabSubSystem::CacheModeName' has a wrong offset!");

// Class MarvelAI.AIMementoComponent
// 0x0350 (0x0440 - 0x00F0)
class UAIMementoComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F0[0x120];                                     // 0x00F0(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIImpressionData                      AIImpressionData;                                  // 0x0210(0x0230)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnAbilityActivate(class UAbilitySystemComponent* ASC, int32 AbilityID, const class FString& String, const struct FGlobalEventExtraData& GlobalEventExtraData);
	void OnAbilityDeActivate(class UAbilitySystemComponent* ASC, int32 AbilityID, const class FString& String, const struct FGlobalEventExtraData& GlobalEventExtraData);
	void OnTagUpdated(class UAbilitySystemComponent* ASC, const struct FGameplayTag& GameplayTag, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMementoComponent">();
	}
	static class UAIMementoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMementoComponent>();
	}
};
static_assert(alignof(UAIMementoComponent) == 0x000008, "Wrong alignment on UAIMementoComponent");
static_assert(sizeof(UAIMementoComponent) == 0x000440, "Wrong size on UAIMementoComponent");
static_assert(offsetof(UAIMementoComponent, AIImpressionData) == 0x000210, "Member 'UAIMementoComponent::AIImpressionData' has a wrong offset!");

// Class MarvelAI.EnvQueryGenerator_ScopePoints
// 0x00D0 (0x0168 - 0x0098)
class UEnvQueryGenerator_ScopePoints final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              SpaceBetween;                                      // 0x0098(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   ScopeIDs;                                          // 0x00D8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              MaxDistanceToQuerier;                              // 0x0128(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_ScopePoints">();
	}
	static class UEnvQueryGenerator_ScopePoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_ScopePoints>();
	}
};
static_assert(alignof(UEnvQueryGenerator_ScopePoints) == 0x000008, "Wrong alignment on UEnvQueryGenerator_ScopePoints");
static_assert(sizeof(UEnvQueryGenerator_ScopePoints) == 0x000168, "Wrong size on UEnvQueryGenerator_ScopePoints");
static_assert(offsetof(UEnvQueryGenerator_ScopePoints, SpaceBetween) == 0x000098, "Member 'UEnvQueryGenerator_ScopePoints::SpaceBetween' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_ScopePoints, ScopeIDs) == 0x0000D8, "Member 'UEnvQueryGenerator_ScopePoints::ScopeIDs' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_ScopePoints, MaxDistanceToQuerier) == 0x000128, "Member 'UEnvQueryGenerator_ScopePoints::MaxDistanceToQuerier' has a wrong offset!");

// Class MarvelAI.AIPathSelectComponent
// 0x00A0 (0x0190 - 0x00F0)
class UAIPathSelectComponent final : public UActorComponent
{
public:
	TMap<class AActor*, class AStartWayPoint*>    TargetToPathStart;                                 // 0x00F0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class AActor>, TSoftObjectPtr<class AStartWayPoint>> TargetToPathStart_Soft;                            // 0x0140(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static void GetPathToTargetFromActor(class AActor* PathSelector, class AActor* ActorMovingAlong, class AActor* Target, struct FWayPointPath* OutWayPointPath, bool ShouldUpdateProgressInPath);

	void GetPathToTarget(class AActor* ActorMovingAlong, class AActor* Target, struct FWayPointPath* OutWayPointPath, bool ShouldUpdateProgressInPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIPathSelectComponent">();
	}
	static class UAIPathSelectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIPathSelectComponent>();
	}
};
static_assert(alignof(UAIPathSelectComponent) == 0x000008, "Wrong alignment on UAIPathSelectComponent");
static_assert(sizeof(UAIPathSelectComponent) == 0x000190, "Wrong size on UAIPathSelectComponent");
static_assert(offsetof(UAIPathSelectComponent, TargetToPathStart) == 0x0000F0, "Member 'UAIPathSelectComponent::TargetToPathStart' has a wrong offset!");
static_assert(offsetof(UAIPathSelectComponent, TargetToPathStart_Soft) == 0x000140, "Member 'UAIPathSelectComponent::TargetToPathStart_Soft' has a wrong offset!");

// Class MarvelAI.AISceneConfigActorBase
// 0x0000 (0x04B8 - 0x04B8)
class AAISceneConfigActorBase : public ANavigationObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISceneConfigActorBase">();
	}
	static class AAISceneConfigActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAISceneConfigActorBase>();
	}
};
static_assert(alignof(AAISceneConfigActorBase) == 0x000008, "Wrong alignment on AAISceneConfigActorBase");
static_assert(sizeof(AAISceneConfigActorBase) == 0x0004B8, "Wrong size on AAISceneConfigActorBase");

// Class MarvelAI.AIScoreModuleCondition
// 0x0000 (0x0030 - 0x0030)
class UAIScoreModuleCondition : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModuleCondition">();
	}
	static class UAIScoreModuleCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModuleCondition>();
	}
};
static_assert(alignof(UAIScoreModuleCondition) == 0x000008, "Wrong alignment on UAIScoreModuleCondition");
static_assert(sizeof(UAIScoreModuleCondition) == 0x000030, "Wrong size on UAIScoreModuleCondition");

// Class MarvelAI.AIScoreModuleCondition_Distance
// 0x0008 (0x0038 - 0x0030)
class UAIScoreModuleCondition_Distance : public UAIScoreModuleCondition
{
public:
	struct FRange_FloatValue                      DistanceRange;                                     // 0x0030(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModuleCondition_Distance">();
	}
	static class UAIScoreModuleCondition_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModuleCondition_Distance>();
	}
};
static_assert(alignof(UAIScoreModuleCondition_Distance) == 0x000008, "Wrong alignment on UAIScoreModuleCondition_Distance");
static_assert(sizeof(UAIScoreModuleCondition_Distance) == 0x000038, "Wrong size on UAIScoreModuleCondition_Distance");
static_assert(offsetof(UAIScoreModuleCondition_Distance, DistanceRange) == 0x000030, "Member 'UAIScoreModuleCondition_Distance::DistanceRange' has a wrong offset!");

// Class MarvelAI.AIScoreModule
// 0x0010 (0x0040 - 0x0030)
class UAIScoreModule : public UObject
{
public:
	class FString                                 DisplayName;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule">();
	}
	static class UAIScoreModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule>();
	}
};
static_assert(alignof(UAIScoreModule) == 0x000008, "Wrong alignment on UAIScoreModule");
static_assert(sizeof(UAIScoreModule) == 0x000040, "Wrong size on UAIScoreModule");
static_assert(offsetof(UAIScoreModule, DisplayName) == 0x000030, "Member 'UAIScoreModule::DisplayName' has a wrong offset!");

// Class MarvelAI.AIScoreModule_CurTarget
// 0x0018 (0x0058 - 0x0040)
class UAIScoreModule_CurTarget : public UAIScoreModule
{
public:
	class FName                                   TargetBBKeyName;                                   // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurTargetScore;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotCurTargetScore;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_CurTarget">();
	}
	static class UAIScoreModule_CurTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_CurTarget>();
	}
};
static_assert(alignof(UAIScoreModule_CurTarget) == 0x000008, "Wrong alignment on UAIScoreModule_CurTarget");
static_assert(sizeof(UAIScoreModule_CurTarget) == 0x000058, "Wrong size on UAIScoreModule_CurTarget");
static_assert(offsetof(UAIScoreModule_CurTarget, TargetBBKeyName) == 0x000040, "Member 'UAIScoreModule_CurTarget::TargetBBKeyName' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_CurTarget, CurTargetScore) == 0x00004C, "Member 'UAIScoreModule_CurTarget::CurTargetScore' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_CurTarget, NotCurTargetScore) == 0x000050, "Member 'UAIScoreModule_CurTarget::NotCurTargetScore' has a wrong offset!");

// Class MarvelAI.AIScoreModule_Damage
// 0x0008 (0x0048 - 0x0040)
class UAIScoreModule_Damage : public UAIScoreModule
{
public:
	class UCurveFloat*                            DamageScoreCurve;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_Damage">();
	}
	static class UAIScoreModule_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_Damage>();
	}
};
static_assert(alignof(UAIScoreModule_Damage) == 0x000008, "Wrong alignment on UAIScoreModule_Damage");
static_assert(sizeof(UAIScoreModule_Damage) == 0x000048, "Wrong size on UAIScoreModule_Damage");
static_assert(offsetof(UAIScoreModule_Damage, DamageScoreCurve) == 0x000040, "Member 'UAIScoreModule_Damage::DamageScoreCurve' has a wrong offset!");

// Class MarvelAI.AIScoreModule_Distance
// 0x0020 (0x0060 - 0x0040)
class UAIScoreModule_Distance : public UAIScoreModule
{
public:
	class UCurveFloat*                            DistanceCurve;                                     // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIDistanceSMTarget                           TargetType;                                        // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TargetBBKey;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_Distance">();
	}
	static class UAIScoreModule_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_Distance>();
	}
};
static_assert(alignof(UAIScoreModule_Distance) == 0x000008, "Wrong alignment on UAIScoreModule_Distance");
static_assert(sizeof(UAIScoreModule_Distance) == 0x000060, "Wrong size on UAIScoreModule_Distance");
static_assert(offsetof(UAIScoreModule_Distance, DistanceCurve) == 0x000040, "Member 'UAIScoreModule_Distance::DistanceCurve' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_Distance, TargetType) == 0x000048, "Member 'UAIScoreModule_Distance::TargetType' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_Distance, TargetBBKey) == 0x000050, "Member 'UAIScoreModule_Distance::TargetBBKey' has a wrong offset!");

// Class MarvelAI.AIScoreModule_FromPortal
// 0x0008 (0x0048 - 0x0040)
class UAIScoreModule_FromPortal : public UAIScoreModule
{
public:
	float                                         FromPortalScore;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OtherScore;                                        // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_FromPortal">();
	}
	static class UAIScoreModule_FromPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_FromPortal>();
	}
};
static_assert(alignof(UAIScoreModule_FromPortal) == 0x000008, "Wrong alignment on UAIScoreModule_FromPortal");
static_assert(sizeof(UAIScoreModule_FromPortal) == 0x000048, "Wrong size on UAIScoreModule_FromPortal");
static_assert(offsetof(UAIScoreModule_FromPortal, FromPortalScore) == 0x000040, "Member 'UAIScoreModule_FromPortal::FromPortalScore' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_FromPortal, OtherScore) == 0x000044, "Member 'UAIScoreModule_FromPortal::OtherScore' has a wrong offset!");

// Class MarvelAI.AIScoreModule_Frontier
// 0x0010 (0x0050 - 0x0040)
class UAIScoreModule_Frontier : public UAIScoreModule
{
public:
	float                                         FrontierRadius;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntFrontierScore;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutFrontierScore;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_Frontier">();
	}
	static class UAIScoreModule_Frontier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_Frontier>();
	}
};
static_assert(alignof(UAIScoreModule_Frontier) == 0x000008, "Wrong alignment on UAIScoreModule_Frontier");
static_assert(sizeof(UAIScoreModule_Frontier) == 0x000050, "Wrong size on UAIScoreModule_Frontier");
static_assert(offsetof(UAIScoreModule_Frontier, FrontierRadius) == 0x000040, "Member 'UAIScoreModule_Frontier::FrontierRadius' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_Frontier, IntFrontierScore) == 0x000044, "Member 'UAIScoreModule_Frontier::IntFrontierScore' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_Frontier, OutFrontierScore) == 0x000048, "Member 'UAIScoreModule_Frontier::OutFrontierScore' has a wrong offset!");

// Class MarvelAI.AIScoreModule_Health
// 0x0008 (0x0048 - 0x0040)
class UAIScoreModule_Health : public UAIScoreModule
{
public:
	class UCurveFloat*                            HealthProportionCurve;                             // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_Health">();
	}
	static class UAIScoreModule_Health* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_Health>();
	}
};
static_assert(alignof(UAIScoreModule_Health) == 0x000008, "Wrong alignment on UAIScoreModule_Health");
static_assert(sizeof(UAIScoreModule_Health) == 0x000048, "Wrong size on UAIScoreModule_Health");
static_assert(offsetof(UAIScoreModule_Health, HealthProportionCurve) == 0x000040, "Member 'UAIScoreModule_Health::HealthProportionCurve' has a wrong offset!");

// Class MarvelAI.AIScoreModule_IsPlayer
// 0x0008 (0x0048 - 0x0040)
class UAIScoreModule_IsPlayer final : public UAIScoreModule
{
public:
	float                                         PlayerScore;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIScore;                                           // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_IsPlayer">();
	}
	static class UAIScoreModule_IsPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_IsPlayer>();
	}
};
static_assert(alignof(UAIScoreModule_IsPlayer) == 0x000008, "Wrong alignment on UAIScoreModule_IsPlayer");
static_assert(sizeof(UAIScoreModule_IsPlayer) == 0x000048, "Wrong size on UAIScoreModule_IsPlayer");
static_assert(offsetof(UAIScoreModule_IsPlayer, PlayerScore) == 0x000040, "Member 'UAIScoreModule_IsPlayer::PlayerScore' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_IsPlayer, AIScore) == 0x000044, "Member 'UAIScoreModule_IsPlayer::AIScore' has a wrong offset!");

// Class MarvelAI.AIScoreModule_PositionProgressControl
// 0x0008 (0x0048 - 0x0040)
class UAIScoreModule_PositionProgressControl : public UAIScoreModule
{
public:
	class UCurveFloat*                            ProgressCurve;                                     // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_PositionProgressControl">();
	}
	static class UAIScoreModule_PositionProgressControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_PositionProgressControl>();
	}
};
static_assert(alignof(UAIScoreModule_PositionProgressControl) == 0x000008, "Wrong alignment on UAIScoreModule_PositionProgressControl");
static_assert(sizeof(UAIScoreModule_PositionProgressControl) == 0x000048, "Wrong size on UAIScoreModule_PositionProgressControl");
static_assert(offsetof(UAIScoreModule_PositionProgressControl, ProgressCurve) == 0x000040, "Member 'UAIScoreModule_PositionProgressControl::ProgressCurve' has a wrong offset!");

// Class MarvelAI.AIScoreModule_Random
// 0x0008 (0x0048 - 0x0040)
class UAIScoreModule_Random : public UAIScoreModule
{
public:
	struct FRange_FloatValue                      RandomRange;                                       // 0x0040(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_Random">();
	}
	static class UAIScoreModule_Random* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_Random>();
	}
};
static_assert(alignof(UAIScoreModule_Random) == 0x000008, "Wrong alignment on UAIScoreModule_Random");
static_assert(sizeof(UAIScoreModule_Random) == 0x000048, "Wrong size on UAIScoreModule_Random");
static_assert(offsetof(UAIScoreModule_Random, RandomRange) == 0x000040, "Member 'UAIScoreModule_Random::RandomRange' has a wrong offset!");

// Class MarvelAI.AIScoreModule_Role
// 0x0058 (0x0098 - 0x0040)
class UAIScoreModule_Role : public UAIScoreModule
{
public:
	float                                         DefaultScore;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EHeroRole, float>                        RoleConfig;                                        // 0x0048(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_Role">();
	}
	static class UAIScoreModule_Role* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_Role>();
	}
};
static_assert(alignof(UAIScoreModule_Role) == 0x000008, "Wrong alignment on UAIScoreModule_Role");
static_assert(sizeof(UAIScoreModule_Role) == 0x000098, "Wrong size on UAIScoreModule_Role");
static_assert(offsetof(UAIScoreModule_Role, DefaultScore) == 0x000040, "Member 'UAIScoreModule_Role::DefaultScore' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_Role, RoleConfig) == 0x000048, "Member 'UAIScoreModule_Role::RoleConfig' has a wrong offset!");

// Class MarvelAI.AIScoreModule_SpecificHero
// 0x0010 (0x0050 - 0x0040)
class UAIScoreModule_SpecificHero final : public UAIScoreModule
{
public:
	int32                                         SpecificHeroID;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpecificHeroScore;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OtherScore;                                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_SpecificHero">();
	}
	static class UAIScoreModule_SpecificHero* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_SpecificHero>();
	}
};
static_assert(alignof(UAIScoreModule_SpecificHero) == 0x000008, "Wrong alignment on UAIScoreModule_SpecificHero");
static_assert(sizeof(UAIScoreModule_SpecificHero) == 0x000050, "Wrong size on UAIScoreModule_SpecificHero");
static_assert(offsetof(UAIScoreModule_SpecificHero, SpecificHeroID) == 0x000040, "Member 'UAIScoreModule_SpecificHero::SpecificHeroID' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_SpecificHero, SpecificHeroScore) == 0x000044, "Member 'UAIScoreModule_SpecificHero::SpecificHeroScore' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_SpecificHero, OtherScore) == 0x000048, "Member 'UAIScoreModule_SpecificHero::OtherScore' has a wrong offset!");

// Class MarvelAI.AIScoreModule_Visible
// 0x0008 (0x0048 - 0x0040)
class UAIScoreModule_Visible : public UAIScoreModule
{
public:
	float                                         VisibleScore;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvisibleScore;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModule_Visible">();
	}
	static class UAIScoreModule_Visible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModule_Visible>();
	}
};
static_assert(alignof(UAIScoreModule_Visible) == 0x000008, "Wrong alignment on UAIScoreModule_Visible");
static_assert(sizeof(UAIScoreModule_Visible) == 0x000048, "Wrong size on UAIScoreModule_Visible");
static_assert(offsetof(UAIScoreModule_Visible, VisibleScore) == 0x000040, "Member 'UAIScoreModule_Visible::VisibleScore' has a wrong offset!");
static_assert(offsetof(UAIScoreModule_Visible, InvisibleScore) == 0x000044, "Member 'UAIScoreModule_Visible::InvisibleScore' has a wrong offset!");

// Class MarvelAI.AISelectTargetLogicBase_RunEQS
// 0x0048 (0x00B8 - 0x0070)
class UAISelectTargetLogicBase_RunEQS : public UAISelectTargetLogicBase
{
public:
	class UEnvQuery*                              QueryTemplate;                                     // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnvQueryRunMode                              RunMode;                                           // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QueryInterval;                                     // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                QueryLocation;                                     // 0x0080(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           QueryEQSTimer;                                     // 0x0098(0x0018)(Edit, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReady;                                            // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISelectTargetLogicBase_RunEQS">();
	}
	static class UAISelectTargetLogicBase_RunEQS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISelectTargetLogicBase_RunEQS>();
	}
};
static_assert(alignof(UAISelectTargetLogicBase_RunEQS) == 0x000008, "Wrong alignment on UAISelectTargetLogicBase_RunEQS");
static_assert(sizeof(UAISelectTargetLogicBase_RunEQS) == 0x0000B8, "Wrong size on UAISelectTargetLogicBase_RunEQS");
static_assert(offsetof(UAISelectTargetLogicBase_RunEQS, QueryTemplate) == 0x000070, "Member 'UAISelectTargetLogicBase_RunEQS::QueryTemplate' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase_RunEQS, RunMode) == 0x000078, "Member 'UAISelectTargetLogicBase_RunEQS::RunMode' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase_RunEQS, QueryInterval) == 0x00007C, "Member 'UAISelectTargetLogicBase_RunEQS::QueryInterval' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase_RunEQS, QueryLocation) == 0x000080, "Member 'UAISelectTargetLogicBase_RunEQS::QueryLocation' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase_RunEQS, QueryEQSTimer) == 0x000098, "Member 'UAISelectTargetLogicBase_RunEQS::QueryEQSTimer' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogicBase_RunEQS, bReady) == 0x0000B0, "Member 'UAISelectTargetLogicBase_RunEQS::bReady' has a wrong offset!");

// Class MarvelAI.AISelectTargetLogic_BaseAddOffset
// 0x0008 (0x0078 - 0x0070)
class UAISelectTargetLogic_BaseAddOffset : public UAISelectTargetLogicBase
{
public:
	bool                                          bIsInLocalSpace;                                   // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCommonHeightOffset;                            // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightValue;                                       // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISelectTargetLogic_BaseAddOffset">();
	}
	static class UAISelectTargetLogic_BaseAddOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISelectTargetLogic_BaseAddOffset>();
	}
};
static_assert(alignof(UAISelectTargetLogic_BaseAddOffset) == 0x000008, "Wrong alignment on UAISelectTargetLogic_BaseAddOffset");
static_assert(sizeof(UAISelectTargetLogic_BaseAddOffset) == 0x000078, "Wrong size on UAISelectTargetLogic_BaseAddOffset");
static_assert(offsetof(UAISelectTargetLogic_BaseAddOffset, bIsInLocalSpace) == 0x000070, "Member 'UAISelectTargetLogic_BaseAddOffset::bIsInLocalSpace' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_BaseAddOffset, bUseCommonHeightOffset) == 0x000071, "Member 'UAISelectTargetLogic_BaseAddOffset::bUseCommonHeightOffset' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_BaseAddOffset, HeightValue) == 0x000074, "Member 'UAISelectTargetLogic_BaseAddOffset::HeightValue' has a wrong offset!");

// Class MarvelAI.AISelectTargetLogic_Blackboard
// 0x0010 (0x0080 - 0x0070)
class UAISelectTargetLogic_Blackboard final : public UAISelectTargetLogicBase
{
public:
	class FName                                   BlackboardKeyName;                                 // 0x0070(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISelectTargetLogic_Blackboard">();
	}
	static class UAISelectTargetLogic_Blackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISelectTargetLogic_Blackboard>();
	}
};
static_assert(alignof(UAISelectTargetLogic_Blackboard) == 0x000008, "Wrong alignment on UAISelectTargetLogic_Blackboard");
static_assert(sizeof(UAISelectTargetLogic_Blackboard) == 0x000080, "Wrong size on UAISelectTargetLogic_Blackboard");
static_assert(offsetof(UAISelectTargetLogic_Blackboard, BlackboardKeyName) == 0x000070, "Member 'UAISelectTargetLogic_Blackboard::BlackboardKeyName' has a wrong offset!");

// Class MarvelAI.AISelectTargetLogic_Destructible
// 0x0018 (0x0088 - 0x0070)
class UAISelectTargetLogic_Destructible : public UAISelectTargetLogicBase
{
public:
	float                                         DetectRange;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDetectBlastMesh;                            // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RequiredBlastUnbrokenRatio;                        // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDetectPhysicalInteraction;                  // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PhysicsDetectType;                                 // 0x007D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhysicsImpulseThresholdLimit;                      // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTakeRandomTarget;                                 // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckVisibility;                            // 0x0085(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86[0x2];                                       // 0x0086(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISelectTargetLogic_Destructible">();
	}
	static class UAISelectTargetLogic_Destructible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISelectTargetLogic_Destructible>();
	}
};
static_assert(alignof(UAISelectTargetLogic_Destructible) == 0x000008, "Wrong alignment on UAISelectTargetLogic_Destructible");
static_assert(sizeof(UAISelectTargetLogic_Destructible) == 0x000088, "Wrong size on UAISelectTargetLogic_Destructible");
static_assert(offsetof(UAISelectTargetLogic_Destructible, DetectRange) == 0x000070, "Member 'UAISelectTargetLogic_Destructible::DetectRange' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_Destructible, bShouldDetectBlastMesh) == 0x000074, "Member 'UAISelectTargetLogic_Destructible::bShouldDetectBlastMesh' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_Destructible, RequiredBlastUnbrokenRatio) == 0x000078, "Member 'UAISelectTargetLogic_Destructible::RequiredBlastUnbrokenRatio' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_Destructible, bShouldDetectPhysicalInteraction) == 0x00007C, "Member 'UAISelectTargetLogic_Destructible::bShouldDetectPhysicalInteraction' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_Destructible, PhysicsDetectType) == 0x00007D, "Member 'UAISelectTargetLogic_Destructible::PhysicsDetectType' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_Destructible, PhysicsImpulseThresholdLimit) == 0x000080, "Member 'UAISelectTargetLogic_Destructible::PhysicsImpulseThresholdLimit' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_Destructible, bTakeRandomTarget) == 0x000084, "Member 'UAISelectTargetLogic_Destructible::bTakeRandomTarget' has a wrong offset!");
static_assert(offsetof(UAISelectTargetLogic_Destructible, bShouldCheckVisibility) == 0x000085, "Member 'UAISelectTargetLogic_Destructible::bShouldCheckVisibility' has a wrong offset!");

// Class MarvelAI.AISelectTarget_BuffedCharacter
// 0x0088 (0x00F8 - 0x0070)
class UAISelectTarget_BuffedCharacter : public UAISelectTargetLogicBase
{
public:
	int32                                         BuffID;                                            // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHeroFilter                            HeroFilter;                                        // 0x0078(0x0080)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISelectTarget_BuffedCharacter">();
	}
	static class UAISelectTarget_BuffedCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISelectTarget_BuffedCharacter>();
	}
};
static_assert(alignof(UAISelectTarget_BuffedCharacter) == 0x000008, "Wrong alignment on UAISelectTarget_BuffedCharacter");
static_assert(sizeof(UAISelectTarget_BuffedCharacter) == 0x0000F8, "Wrong size on UAISelectTarget_BuffedCharacter");
static_assert(offsetof(UAISelectTarget_BuffedCharacter, BuffID) == 0x000070, "Member 'UAISelectTarget_BuffedCharacter::BuffID' has a wrong offset!");
static_assert(offsetof(UAISelectTarget_BuffedCharacter, HeroFilter) == 0x000078, "Member 'UAISelectTarget_BuffedCharacter::HeroFilter' has a wrong offset!");

// Class MarvelAI.DangerousTargetAsset
// 0x0050 (0x0088 - 0x0038)
class UDangerousTargetAsset final : public UDataAsset
{
public:
	TMap<int32, struct FAISenseDangerousTargetConfig> DangerousTarget;                                   // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DangerousTargetAsset">();
	}
	static class UDangerousTargetAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDangerousTargetAsset>();
	}
};
static_assert(alignof(UDangerousTargetAsset) == 0x000008, "Wrong alignment on UDangerousTargetAsset");
static_assert(sizeof(UDangerousTargetAsset) == 0x000088, "Wrong size on UDangerousTargetAsset");
static_assert(offsetof(UDangerousTargetAsset, DangerousTarget) == 0x000038, "Member 'UDangerousTargetAsset::DangerousTarget' has a wrong offset!");

// Class MarvelAI.AIServerRequestServices
// 0x02B8 (0x0300 - 0x0048)
class UAIServerRequestServices final : public UMarvelAIWorldSubsystem
{
public:
	uint8                                         Pad_48[0x70];                                      // 0x0048(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AILabServerUrl;                                    // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTimeOut;                                        // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0xDC];                                      // 0x00CC(0x00DC)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RequestInterval;                                   // 0x01A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RequestIndexID;                                    // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x148];                                    // 0x01B8(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetAILabServerUrl();
	void InitRequestServicesLogic();
	void RequestTimer(bool bRetry);
	void SetAILabServerUrl(const class FString& NewUrl, const class FString& Msg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIServerRequestServices">();
	}
	static class UAIServerRequestServices* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIServerRequestServices>();
	}
};
static_assert(alignof(UAIServerRequestServices) == 0x000008, "Wrong alignment on UAIServerRequestServices");
static_assert(sizeof(UAIServerRequestServices) == 0x000300, "Wrong size on UAIServerRequestServices");
static_assert(offsetof(UAIServerRequestServices, AILabServerUrl) == 0x0000B8, "Member 'UAIServerRequestServices::AILabServerUrl' has a wrong offset!");
static_assert(offsetof(UAIServerRequestServices, MaxTimeOut) == 0x0000C8, "Member 'UAIServerRequestServices::MaxTimeOut' has a wrong offset!");
static_assert(offsetof(UAIServerRequestServices, RequestInterval) == 0x0001A8, "Member 'UAIServerRequestServices::RequestInterval' has a wrong offset!");
static_assert(offsetof(UAIServerRequestServices, RequestIndexID) == 0x0001B0, "Member 'UAIServerRequestServices::RequestIndexID' has a wrong offset!");

// Class MarvelAI.AISpawner
// 0x0008 (0x04C0 - 0x04B8)
class AAISpawner final : public AAISceneConfigActorBase
{
public:
	class UAISpawnDataConfig*                     SpawnDataConfig;                                   // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISpawner">();
	}
	static class AAISpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAISpawner>();
	}
};
static_assert(alignof(AAISpawner) == 0x000008, "Wrong alignment on AAISpawner");
static_assert(sizeof(AAISpawner) == 0x0004C0, "Wrong size on AAISpawner");
static_assert(offsetof(AAISpawner, SpawnDataConfig) == 0x0004B8, "Member 'AAISpawner::SpawnDataConfig' has a wrong offset!");

// Class MarvelAI.MarvelAIStandPointManager
// 0x0050 (0x0080 - 0x0030)
class UMarvelAIStandPointManager : public UObject
{
public:
	TMap<class FName, class AStandPointBase*>     StandPointMap;                                     // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	class AStandPointBase* FindStandPoint(const class FName& PointName);
	void RegisterStandPoint(class AStandPointBase* StandPoint);
	void UnRegisterStandPoint(class AStandPointBase* StandPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIStandPointManager">();
	}
	static class UMarvelAIStandPointManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIStandPointManager>();
	}
};
static_assert(alignof(UMarvelAIStandPointManager) == 0x000008, "Wrong alignment on UMarvelAIStandPointManager");
static_assert(sizeof(UMarvelAIStandPointManager) == 0x000080, "Wrong size on UMarvelAIStandPointManager");
static_assert(offsetof(UMarvelAIStandPointManager, StandPointMap) == 0x000030, "Member 'UMarvelAIStandPointManager::StandPointMap' has a wrong offset!");

// Class MarvelAI.AIStrategyAreaVolume
// 0x0010 (0x04D8 - 0x04C8)
class AAIStrategyAreaVolume final : public AVolume
{
public:
	int32                                         MatchState;                                        // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStrategyType                                 StrategyType;                                      // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGroupState                                   GroupState;                                        // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EGroupState GetGroupState() const;
	int32 GetMatchState() const;
	EStrategyType GetStrategyType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIStrategyAreaVolume">();
	}
	static class AAIStrategyAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIStrategyAreaVolume>();
	}
};
static_assert(alignof(AAIStrategyAreaVolume) == 0x000008, "Wrong alignment on AAIStrategyAreaVolume");
static_assert(sizeof(AAIStrategyAreaVolume) == 0x0004D8, "Wrong size on AAIStrategyAreaVolume");
static_assert(offsetof(AAIStrategyAreaVolume, MatchState) == 0x0004C8, "Member 'AAIStrategyAreaVolume::MatchState' has a wrong offset!");
static_assert(offsetof(AAIStrategyAreaVolume, StrategyType) == 0x0004CC, "Member 'AAIStrategyAreaVolume::StrategyType' has a wrong offset!");
static_assert(offsetof(AAIStrategyAreaVolume, GroupState) == 0x0004D0, "Member 'AAIStrategyAreaVolume::GroupState' has a wrong offset!");

// Class MarvelAI.AIVisualLoggerConfig
// 0x0058 (0x0090 - 0x0038)
class UAIVisualLoggerConfig final : public UAIGlobalConfigAsset
{
public:
	bool                                          bLimitLogging;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             CategoriesNeedLogging;                             // 0x0040(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIVisualLoggerConfig">();
	}
	static class UAIVisualLoggerConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIVisualLoggerConfig>();
	}
};
static_assert(alignof(UAIVisualLoggerConfig) == 0x000008, "Wrong alignment on UAIVisualLoggerConfig");
static_assert(sizeof(UAIVisualLoggerConfig) == 0x000090, "Wrong size on UAIVisualLoggerConfig");
static_assert(offsetof(UAIVisualLoggerConfig, bLimitLogging) == 0x000038, "Member 'UAIVisualLoggerConfig::bLimitLogging' has a wrong offset!");
static_assert(offsetof(UAIVisualLoggerConfig, CategoriesNeedLogging) == 0x000040, "Member 'UAIVisualLoggerConfig::CategoriesNeedLogging' has a wrong offset!");

// Class MarvelAI.AIAbilityUsageLibrary
// 0x0000 (0x0030 - 0x0030)
class UAIAbilityUsageLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UMarvelGameplayAbility* GetAbilityByUsageID(int32 AbilityUsageID, class AMarvelAIController* OwnerController);
	static class UMarvelGameplayAbility* GetAbilityFromContext(const struct FRequiredAIDataForAutoAbility& AutoAbilityContext);
	static class FString GetAbilityUsageDescription(const struct FAIAbilityUsage& AbilityUsage);
	static struct FVector GetTargetLocation(const struct FAIAbilityUsage& AbilityUsage);
	static struct FMarvelAIAutoAbilityTable GetUsageConfig(const struct FAIAbilityUsage& AbilityUsage);
	static bool GetUsageConfigFromContext(const struct FRequiredAIDataForAutoAbility& AutoAbilityContext, struct FMarvelAIAutoAbilityTable* OutUsageConfig);
	static bool IsValidAbilityUsage(const struct FAIAbilityUsage& AbilityUsage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityUsageLibrary">();
	}
	static class UAIAbilityUsageLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityUsageLibrary>();
	}
};
static_assert(alignof(UAIAbilityUsageLibrary) == 0x000008, "Wrong alignment on UAIAbilityUsageLibrary");
static_assert(sizeof(UAIAbilityUsageLibrary) == 0x000030, "Wrong size on UAIAbilityUsageLibrary");

// Class MarvelAI.AIAbilityUsagePointCondition
// 0x0008 (0x0038 - 0x0030)
class UAIAbilityUsagePointCondition final : public UObject
{
public:
	bool                                          bInverseResult;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckIsValidPoint(const struct FAbilityUsagePointData& StandPoint, const class AMarvelAIController* AIController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityUsagePointCondition">();
	}
	static class UAIAbilityUsagePointCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityUsagePointCondition>();
	}
};
static_assert(alignof(UAIAbilityUsagePointCondition) == 0x000008, "Wrong alignment on UAIAbilityUsagePointCondition");
static_assert(sizeof(UAIAbilityUsagePointCondition) == 0x000038, "Wrong size on UAIAbilityUsagePointCondition");
static_assert(offsetof(UAIAbilityUsagePointCondition, bInverseResult) == 0x000030, "Member 'UAIAbilityUsagePointCondition::bInverseResult' has a wrong offset!");

// Class MarvelAI.AIAbilityUsagePointCalculator
// 0x0000 (0x0030 - 0x0030)
class UAIAbilityUsagePointCalculator final : public UObject
{
public:
	bool CalculateUsagePointPosition(struct FAbilityUsagePointData& StandPoint, class AMarvelAIController* AIController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityUsagePointCalculator">();
	}
	static class UAIAbilityUsagePointCalculator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityUsagePointCalculator>();
	}
};
static_assert(alignof(UAIAbilityUsagePointCalculator) == 0x000008, "Wrong alignment on UAIAbilityUsagePointCalculator");
static_assert(sizeof(UAIAbilityUsagePointCalculator) == 0x000030, "Wrong size on UAIAbilityUsagePointCalculator");

// Class MarvelAI.AIAbilityPreAction
// 0x0000 (0x0030 - 0x0030)
class UAIAbilityPreAction : public UObject
{
public:
	void DoPreAction(class UMarvelGameplayAbility* Ability, class AMarvelAIController* AIController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityPreAction">();
	}
	static class UAIAbilityPreAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityPreAction>();
	}
};
static_assert(alignof(UAIAbilityPreAction) == 0x000008, "Wrong alignment on UAIAbilityPreAction");
static_assert(sizeof(UAIAbilityPreAction) == 0x000030, "Wrong size on UAIAbilityPreAction");

// Class MarvelAI.AIAbilityUsageAsset
// 0x0050 (0x0088 - 0x0038)
class UAIAbilityUsageAsset final : public UPrimaryDataAsset
{
public:
	TArray<class UAIAbilityCondition*>            CustomConditions;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAIAbilityUsagePointCondition*>  CustomUsagePointConditions;                        // 0x0048(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAIAbilityUsagePointCalculator*         CustomUsagePointCalculator;                        // 0x0058(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAIAbilityPreAction*>            AbilityPreActions;                                 // 0x0060(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAIAbilityActivationExtraConfig*> ActivationExtraConfigs;                            // 0x0070(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bSkipCanActivateCheck;                             // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoAllPreActions(class UMarvelGameplayAbility* Ability, class AMarvelAIController* AIController);
	bool ShouldSkipCanActivateCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityUsageAsset">();
	}
	static class UAIAbilityUsageAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityUsageAsset>();
	}
};
static_assert(alignof(UAIAbilityUsageAsset) == 0x000008, "Wrong alignment on UAIAbilityUsageAsset");
static_assert(sizeof(UAIAbilityUsageAsset) == 0x000088, "Wrong size on UAIAbilityUsageAsset");
static_assert(offsetof(UAIAbilityUsageAsset, CustomConditions) == 0x000038, "Member 'UAIAbilityUsageAsset::CustomConditions' has a wrong offset!");
static_assert(offsetof(UAIAbilityUsageAsset, CustomUsagePointConditions) == 0x000048, "Member 'UAIAbilityUsageAsset::CustomUsagePointConditions' has a wrong offset!");
static_assert(offsetof(UAIAbilityUsageAsset, CustomUsagePointCalculator) == 0x000058, "Member 'UAIAbilityUsageAsset::CustomUsagePointCalculator' has a wrong offset!");
static_assert(offsetof(UAIAbilityUsageAsset, AbilityPreActions) == 0x000060, "Member 'UAIAbilityUsageAsset::AbilityPreActions' has a wrong offset!");
static_assert(offsetof(UAIAbilityUsageAsset, ActivationExtraConfigs) == 0x000070, "Member 'UAIAbilityUsageAsset::ActivationExtraConfigs' has a wrong offset!");
static_assert(offsetof(UAIAbilityUsageAsset, bSkipCanActivateCheck) == 0x000080, "Member 'UAIAbilityUsageAsset::bSkipCanActivateCheck' has a wrong offset!");

// Class MarvelAI.AIAutoAbilitySolver
// 0x00A8 (0x0198 - 0x00F0)
class UAIAutoAbilitySolver final : public UActorComponent
{
public:
	uint8                                         Pad_F0[0x70];                                      // 0x00F0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAIAutoAbilityGlobalConfig*       CachedGlobalConfig;                                // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x30];                                     // 0x0168(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(const TArray<int32>& UsageList);
	void OnUsageFailed();

	bool TryGetAbilityUsage(const struct FRequiredAIDataForAutoAbility& RequiredData, struct FAIAbilityUsage* OutAbilityUsage) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAutoAbilitySolver">();
	}
	static class UAIAutoAbilitySolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAutoAbilitySolver>();
	}
};
static_assert(alignof(UAIAutoAbilitySolver) == 0x000008, "Wrong alignment on UAIAutoAbilitySolver");
static_assert(sizeof(UAIAutoAbilitySolver) == 0x000198, "Wrong size on UAIAutoAbilitySolver");
static_assert(offsetof(UAIAutoAbilitySolver, CachedGlobalConfig) == 0x000160, "Member 'UAIAutoAbilitySolver::CachedGlobalConfig' has a wrong offset!");

// Class MarvelAI.BattleScoreSubsystem
// 0x0068 (0x00A0 - 0x0038)
class UBattleScoreSubsystem final : public UWorldSubsystem
{
public:
	TArray<float>                                 GroupRoleNumToScoreFactor;                         // 0x0038(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TMap<EHeroRole, float>                        HeroRoleToDefaultBaseScore;                        // 0x0048(0x0050)(Edit, Config, Protected, NativeAccessSpecifierProtected)
	float                                         EnergyPropThreshold;                               // 0x0098(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnergyPropFactor;                                  // 0x009C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UBattleScoreSubsystem* GetBattleScoreSubsystem(const class UObject* WorldContextObject);

	float GetBattleScoreForActor(const class AActor* TargetActor);
	float GetBattleScoreForCharacter(const class AMarvelBaseCharacter* HeroCharacter);
	float GetBattleScoreForCharacterGroup(const TArray<class AMarvelBaseCharacter*>& CharacterGroup);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleScoreSubsystem">();
	}
	static class UBattleScoreSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleScoreSubsystem>();
	}
};
static_assert(alignof(UBattleScoreSubsystem) == 0x000008, "Wrong alignment on UBattleScoreSubsystem");
static_assert(sizeof(UBattleScoreSubsystem) == 0x0000A0, "Wrong size on UBattleScoreSubsystem");
static_assert(offsetof(UBattleScoreSubsystem, GroupRoleNumToScoreFactor) == 0x000038, "Member 'UBattleScoreSubsystem::GroupRoleNumToScoreFactor' has a wrong offset!");
static_assert(offsetof(UBattleScoreSubsystem, HeroRoleToDefaultBaseScore) == 0x000048, "Member 'UBattleScoreSubsystem::HeroRoleToDefaultBaseScore' has a wrong offset!");
static_assert(offsetof(UBattleScoreSubsystem, EnergyPropThreshold) == 0x000098, "Member 'UBattleScoreSubsystem::EnergyPropThreshold' has a wrong offset!");
static_assert(offsetof(UBattleScoreSubsystem, EnergyPropFactor) == 0x00009C, "Member 'UBattleScoreSubsystem::EnergyPropFactor' has a wrong offset!");

// Class MarvelAI.BTDecorator_BBDifferenceOp
// 0x0048 (0x00E8 - 0x00A0)
class UBTDecorator_BBDifferenceOp : public UBTDecorator_BlackboardBase
{
public:
	EDiffOperator                                 Operator;                                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 Target;                                            // 0x00A8(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FFloatRange                            InRange;                                           // 0x00D8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_BBDifferenceOp">();
	}
	static class UBTDecorator_BBDifferenceOp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_BBDifferenceOp>();
	}
};
static_assert(alignof(UBTDecorator_BBDifferenceOp) == 0x000008, "Wrong alignment on UBTDecorator_BBDifferenceOp");
static_assert(sizeof(UBTDecorator_BBDifferenceOp) == 0x0000E8, "Wrong size on UBTDecorator_BBDifferenceOp");
static_assert(offsetof(UBTDecorator_BBDifferenceOp, Operator) == 0x0000A0, "Member 'UBTDecorator_BBDifferenceOp::Operator' has a wrong offset!");
static_assert(offsetof(UBTDecorator_BBDifferenceOp, Target) == 0x0000A8, "Member 'UBTDecorator_BBDifferenceOp::Target' has a wrong offset!");
static_assert(offsetof(UBTDecorator_BBDifferenceOp, InRange) == 0x0000D8, "Member 'UBTDecorator_BBDifferenceOp::InRange' has a wrong offset!");

// Class MarvelAI.BTDecorator_CheckBuff
// 0x0050 (0x00C0 - 0x0070)
class UBTDecorator_CheckBuff final : public UBTDecorator
{
public:
	TSet<int32>                                   BuffIds;                                           // 0x0070(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CheckBuff">();
	}
	static class UBTDecorator_CheckBuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CheckBuff>();
	}
};
static_assert(alignof(UBTDecorator_CheckBuff) == 0x000008, "Wrong alignment on UBTDecorator_CheckBuff");
static_assert(sizeof(UBTDecorator_CheckBuff) == 0x0000C0, "Wrong size on UBTDecorator_CheckBuff");
static_assert(offsetof(UBTDecorator_CheckBuff, BuffIds) == 0x000070, "Member 'UBTDecorator_CheckBuff::BuffIds' has a wrong offset!");

// Class MarvelAI.BTDecorator_CheckHeroType
// 0x00A8 (0x0118 - 0x0070)
class UBTDecorator_CheckHeroType : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 HeroToCheck;                                       // 0x0070(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	EHeroRole                                     HeroRole;                                          // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIHeroTag                             AIHeroTag;                                         // 0x00A8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EGameplayContainerMatchType                   TagMatchType;                                      // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CheckHeroType">();
	}
	static class UBTDecorator_CheckHeroType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CheckHeroType>();
	}
};
static_assert(alignof(UBTDecorator_CheckHeroType) == 0x000008, "Wrong alignment on UBTDecorator_CheckHeroType");
static_assert(sizeof(UBTDecorator_CheckHeroType) == 0x000118, "Wrong size on UBTDecorator_CheckHeroType");
static_assert(offsetof(UBTDecorator_CheckHeroType, HeroToCheck) == 0x000070, "Member 'UBTDecorator_CheckHeroType::HeroToCheck' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CheckHeroType, HeroRole) == 0x0000A0, "Member 'UBTDecorator_CheckHeroType::HeroRole' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CheckHeroType, AIHeroTag) == 0x0000A8, "Member 'UBTDecorator_CheckHeroType::AIHeroTag' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CheckHeroType, TagMatchType) == 0x000110, "Member 'UBTDecorator_CheckHeroType::TagMatchType' has a wrong offset!");

// Class MarvelAI.BTDecorator_CheckRequirement
// 0x0008 (0x0078 - 0x0070)
class UBTDecorator_CheckRequirement final : public UBTDecorator
{
public:
	class UActionRequirementBase*                 Requirement;                                       // 0x0070(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CheckRequirement">();
	}
	static class UBTDecorator_CheckRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CheckRequirement>();
	}
};
static_assert(alignof(UBTDecorator_CheckRequirement) == 0x000008, "Wrong alignment on UBTDecorator_CheckRequirement");
static_assert(sizeof(UBTDecorator_CheckRequirement) == 0x000078, "Wrong size on UBTDecorator_CheckRequirement");
static_assert(offsetof(UBTDecorator_CheckRequirement, Requirement) == 0x000070, "Member 'UBTDecorator_CheckRequirement::Requirement' has a wrong offset!");

// Class MarvelAI.BTDecorator_MarvelBlackboard
// 0x0038 (0x00D8 - 0x00A0)
class UBTDecorator_MarvelBlackboard final : public UBTDecorator_BlackboardBase
{
public:
	EMarvelArithmeticOperation                    Operation;                                         // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 Target;                                            // 0x00A8(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_MarvelBlackboard">();
	}
	static class UBTDecorator_MarvelBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_MarvelBlackboard>();
	}
};
static_assert(alignof(UBTDecorator_MarvelBlackboard) == 0x000008, "Wrong alignment on UBTDecorator_MarvelBlackboard");
static_assert(sizeof(UBTDecorator_MarvelBlackboard) == 0x0000D8, "Wrong size on UBTDecorator_MarvelBlackboard");
static_assert(offsetof(UBTDecorator_MarvelBlackboard, Operation) == 0x0000A0, "Member 'UBTDecorator_MarvelBlackboard::Operation' has a wrong offset!");
static_assert(offsetof(UBTDecorator_MarvelBlackboard, Target) == 0x0000A8, "Member 'UBTDecorator_MarvelBlackboard::Target' has a wrong offset!");

// Class MarvelAI.BTD_CampCheck
// 0x0050 (0x0108 - 0x00B8)
class UBTD_CampCheck : public UBTDecorator_MarvelInstancedBase
{
public:
	struct FBlackboardKeySelector                 CampActor;                                         // 0x00B8(0x0030)(Edit, NativeAccessSpecifierPublic)
	ECheckOption                                  CheckOption;                                       // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSideScoreConfig                       SideScoreConfig;                                   // 0x00EC(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCampStateConfig                       CampStateConfig;                                   // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Check(const class UBehaviorTreeComponent* OwnerComp) const;
	bool CheckOwnershipType(class AMarvelBaseCharacter* OwnerCharacter, EAIFilterSide BattleSide) const;
	float GetScoreForSide(class AMarvelBaseCharacter* OwnerCharacter, EAIFilterSide BattleSide) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_CampCheck">();
	}
	static class UBTD_CampCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_CampCheck>();
	}
};
static_assert(alignof(UBTD_CampCheck) == 0x000008, "Wrong alignment on UBTD_CampCheck");
static_assert(sizeof(UBTD_CampCheck) == 0x000108, "Wrong size on UBTD_CampCheck");
static_assert(offsetof(UBTD_CampCheck, CampActor) == 0x0000B8, "Member 'UBTD_CampCheck::CampActor' has a wrong offset!");
static_assert(offsetof(UBTD_CampCheck, CheckOption) == 0x0000E8, "Member 'UBTD_CampCheck::CheckOption' has a wrong offset!");
static_assert(offsetof(UBTD_CampCheck, SideScoreConfig) == 0x0000EC, "Member 'UBTD_CampCheck::SideScoreConfig' has a wrong offset!");
static_assert(offsetof(UBTD_CampCheck, CampStateConfig) == 0x000100, "Member 'UBTD_CampCheck::CampStateConfig' has a wrong offset!");

// Class MarvelAI.BTD_CheckAroundCharacter
// 0x00D8 (0x0148 - 0x0070)
class UBTD_CheckAroundCharacter : public UBTDecorator
{
public:
	bool                                          ConsiderDist;                                      // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 FocusActor;                                        // 0x0078(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHeroFilter                            HeroFilter;                                        // 0x00B0(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FInt32Range                            RangeNum;                                          // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomDeviation;                                   // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_CheckAroundCharacter">();
	}
	static class UBTD_CheckAroundCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_CheckAroundCharacter>();
	}
};
static_assert(alignof(UBTD_CheckAroundCharacter) == 0x000008, "Wrong alignment on UBTD_CheckAroundCharacter");
static_assert(sizeof(UBTD_CheckAroundCharacter) == 0x000148, "Wrong size on UBTD_CheckAroundCharacter");
static_assert(offsetof(UBTD_CheckAroundCharacter, ConsiderDist) == 0x000070, "Member 'UBTD_CheckAroundCharacter::ConsiderDist' has a wrong offset!");
static_assert(offsetof(UBTD_CheckAroundCharacter, FocusActor) == 0x000078, "Member 'UBTD_CheckAroundCharacter::FocusActor' has a wrong offset!");
static_assert(offsetof(UBTD_CheckAroundCharacter, Radius) == 0x0000A8, "Member 'UBTD_CheckAroundCharacter::Radius' has a wrong offset!");
static_assert(offsetof(UBTD_CheckAroundCharacter, HeroFilter) == 0x0000B0, "Member 'UBTD_CheckAroundCharacter::HeroFilter' has a wrong offset!");
static_assert(offsetof(UBTD_CheckAroundCharacter, RangeNum) == 0x000130, "Member 'UBTD_CheckAroundCharacter::RangeNum' has a wrong offset!");
static_assert(offsetof(UBTD_CheckAroundCharacter, Interval) == 0x000140, "Member 'UBTD_CheckAroundCharacter::Interval' has a wrong offset!");
static_assert(offsetof(UBTD_CheckAroundCharacter, RandomDeviation) == 0x000144, "Member 'UBTD_CheckAroundCharacter::RandomDeviation' has a wrong offset!");

// Class MarvelAI.BTD_CheckFrontCharacter
// 0x0038 (0x00A8 - 0x0070)
class UBTD_CheckFrontCharacter final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0070(0x0030)(Edit, NativeAccessSpecifierPrivate)
	float                                         CheckRadius;                                       // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CheckAngle;                                        // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_CheckFrontCharacter">();
	}
	static class UBTD_CheckFrontCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_CheckFrontCharacter>();
	}
};
static_assert(alignof(UBTD_CheckFrontCharacter) == 0x000008, "Wrong alignment on UBTD_CheckFrontCharacter");
static_assert(sizeof(UBTD_CheckFrontCharacter) == 0x0000A8, "Wrong size on UBTD_CheckFrontCharacter");
static_assert(offsetof(UBTD_CheckFrontCharacter, BlackboardKey) == 0x000070, "Member 'UBTD_CheckFrontCharacter::BlackboardKey' has a wrong offset!");
static_assert(offsetof(UBTD_CheckFrontCharacter, CheckRadius) == 0x0000A0, "Member 'UBTD_CheckFrontCharacter::CheckRadius' has a wrong offset!");
static_assert(offsetof(UBTD_CheckFrontCharacter, CheckAngle) == 0x0000A4, "Member 'UBTD_CheckFrontCharacter::CheckAngle' has a wrong offset!");

// Class MarvelAI.BTD_IsSelfWoodenWall
// 0x0030 (0x00A0 - 0x0070)
class UBTD_IsSelfWoodenWall : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 InCheckTarget;                                     // 0x0070(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsSelfWoodenWall">();
	}
	static class UBTD_IsSelfWoodenWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsSelfWoodenWall>();
	}
};
static_assert(alignof(UBTD_IsSelfWoodenWall) == 0x000008, "Wrong alignment on UBTD_IsSelfWoodenWall");
static_assert(sizeof(UBTD_IsSelfWoodenWall) == 0x0000A0, "Wrong size on UBTD_IsSelfWoodenWall");
static_assert(offsetof(UBTD_IsSelfWoodenWall, InCheckTarget) == 0x000070, "Member 'UBTD_IsSelfWoodenWall::InCheckTarget' has a wrong offset!");

// Class MarvelAI.BTD_PayloadCheck
// 0x0050 (0x0108 - 0x00B8)
class UBTD_PayloadCheck : public UBTDecorator_MarvelInstancedBase
{
public:
	struct FBlackboardKeySelector                 InPlayloadActor;                                   // 0x00B8(0x0030)(Edit, NativeAccessSpecifierPublic)
	ECheckOption                                  InCheckOption;                                     // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InStage;                                           // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            InScore;                                           // 0x00F0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InPayloadState;                                    // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Check(int32 Stage, float Score, float Speed, int32 Team, EOwnershipType Ownership) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_PayloadCheck">();
	}
	static class UBTD_PayloadCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_PayloadCheck>();
	}
};
static_assert(alignof(UBTD_PayloadCheck) == 0x000008, "Wrong alignment on UBTD_PayloadCheck");
static_assert(sizeof(UBTD_PayloadCheck) == 0x000108, "Wrong size on UBTD_PayloadCheck");
static_assert(offsetof(UBTD_PayloadCheck, InPlayloadActor) == 0x0000B8, "Member 'UBTD_PayloadCheck::InPlayloadActor' has a wrong offset!");
static_assert(offsetof(UBTD_PayloadCheck, InCheckOption) == 0x0000E8, "Member 'UBTD_PayloadCheck::InCheckOption' has a wrong offset!");
static_assert(offsetof(UBTD_PayloadCheck, InStage) == 0x0000EC, "Member 'UBTD_PayloadCheck::InStage' has a wrong offset!");
static_assert(offsetof(UBTD_PayloadCheck, InScore) == 0x0000F0, "Member 'UBTD_PayloadCheck::InScore' has a wrong offset!");
static_assert(offsetof(UBTD_PayloadCheck, InPayloadState) == 0x000100, "Member 'UBTD_PayloadCheck::InPayloadState' has a wrong offset!");

// Class MarvelAI.BTD_SpaceDistCheck
// 0x0020 (0x00D8 - 0x00B8)
class UBTD_SpaceDistCheck : public UBTDecorator_MarvelInstancedBase
{
public:
	TArray<struct FCoupleActorStruct>             CoupledActors;                                     // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FFloatRange                            DistRange;                                         // 0x00C8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool Check(class UBehaviorTreeComponent* OwnerComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_SpaceDistCheck">();
	}
	static class UBTD_SpaceDistCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_SpaceDistCheck>();
	}
};
static_assert(alignof(UBTD_SpaceDistCheck) == 0x000008, "Wrong alignment on UBTD_SpaceDistCheck");
static_assert(sizeof(UBTD_SpaceDistCheck) == 0x0000D8, "Wrong size on UBTD_SpaceDistCheck");
static_assert(offsetof(UBTD_SpaceDistCheck, CoupledActors) == 0x0000B8, "Member 'UBTD_SpaceDistCheck::CoupledActors' has a wrong offset!");
static_assert(offsetof(UBTD_SpaceDistCheck, DistRange) == 0x0000C8, "Member 'UBTD_SpaceDistCheck::DistRange' has a wrong offset!");

// Class MarvelAI.BTD_TargetIsSummoned
// 0x0080 (0x00F0 - 0x0070)
class UBTD_TargetIsSummoned : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 InCheckTarget;                                     // 0x0070(0x0030)(Edit, NativeAccessSpecifierPrivate)
	TSet<int32>                                   ExcludeList;                                       // 0x00A0(0x0050)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_TargetIsSummoned">();
	}
	static class UBTD_TargetIsSummoned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_TargetIsSummoned>();
	}
};
static_assert(alignof(UBTD_TargetIsSummoned) == 0x000008, "Wrong alignment on UBTD_TargetIsSummoned");
static_assert(sizeof(UBTD_TargetIsSummoned) == 0x0000F0, "Wrong size on UBTD_TargetIsSummoned");
static_assert(offsetof(UBTD_TargetIsSummoned, InCheckTarget) == 0x000070, "Member 'UBTD_TargetIsSummoned::InCheckTarget' has a wrong offset!");
static_assert(offsetof(UBTD_TargetIsSummoned, ExcludeList) == 0x0000A0, "Member 'UBTD_TargetIsSummoned::ExcludeList' has a wrong offset!");

// Class MarvelAI.BTService_AbilityFocus_BB
// 0x0108 (0x01B0 - 0x00A8)
class UBTService_AbilityFocus_BB final : public UBTService_BlackboardBase
{
public:
	bool                                          bShouldClearFocusWhenEnd;                          // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAISelectTargetLogicBase*               TargetSelectLogic;                                 // 0x00B0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAISelectTargetLogicBase>   TargetSelectLogicClass;                            // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0xF0];                                      // 0x00C0(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_AbilityFocus_BB">();
	}
	static class UBTService_AbilityFocus_BB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_AbilityFocus_BB>();
	}
};
static_assert(alignof(UBTService_AbilityFocus_BB) == 0x000008, "Wrong alignment on UBTService_AbilityFocus_BB");
static_assert(sizeof(UBTService_AbilityFocus_BB) == 0x0001B0, "Wrong size on UBTService_AbilityFocus_BB");
static_assert(offsetof(UBTService_AbilityFocus_BB, bShouldClearFocusWhenEnd) == 0x0000A8, "Member 'UBTService_AbilityFocus_BB::bShouldClearFocusWhenEnd' has a wrong offset!");
static_assert(offsetof(UBTService_AbilityFocus_BB, TargetSelectLogic) == 0x0000B0, "Member 'UBTService_AbilityFocus_BB::TargetSelectLogic' has a wrong offset!");
static_assert(offsetof(UBTService_AbilityFocus_BB, TargetSelectLogicClass) == 0x0000B8, "Member 'UBTService_AbilityFocus_BB::TargetSelectLogicClass' has a wrong offset!");

// Class MarvelAI.BTService_MarvelRunEQS
// 0x0030 (0x0140 - 0x0110)
class UBTService_MarvelRunEQS final : public UBTService_RunEQS
{
public:
	struct FBlackboardKeySelector                 AbilityMoveLogicBlackboardKey;                     // 0x0110(0x0030)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_MarvelRunEQS">();
	}
	static class UBTService_MarvelRunEQS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_MarvelRunEQS>();
	}
};
static_assert(alignof(UBTService_MarvelRunEQS) == 0x000008, "Wrong alignment on UBTService_MarvelRunEQS");
static_assert(sizeof(UBTService_MarvelRunEQS) == 0x000140, "Wrong size on UBTService_MarvelRunEQS");
static_assert(offsetof(UBTService_MarvelRunEQS, AbilityMoveLogicBlackboardKey) == 0x000110, "Member 'UBTService_MarvelRunEQS::AbilityMoveLogicBlackboardKey' has a wrong offset!");

// Class MarvelAI.BTService_StrategyActionSelect
// 0x0040 (0x00B8 - 0x0078)
class UBTService_StrategyActionSelect final : public UBTService
{
public:
	EActionCategory                               CurrentAction;                                     // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 OutNewAction;                                      // 0x0080(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UActionRequirementAsset*                ActionTableAsset;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StrategyActionSelect">();
	}
	static class UBTService_StrategyActionSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StrategyActionSelect>();
	}
};
static_assert(alignof(UBTService_StrategyActionSelect) == 0x000008, "Wrong alignment on UBTService_StrategyActionSelect");
static_assert(sizeof(UBTService_StrategyActionSelect) == 0x0000B8, "Wrong size on UBTService_StrategyActionSelect");
static_assert(offsetof(UBTService_StrategyActionSelect, CurrentAction) == 0x000078, "Member 'UBTService_StrategyActionSelect::CurrentAction' has a wrong offset!");
static_assert(offsetof(UBTService_StrategyActionSelect, OutNewAction) == 0x000080, "Member 'UBTService_StrategyActionSelect::OutNewAction' has a wrong offset!");
static_assert(offsetof(UBTService_StrategyActionSelect, ActionTableAsset) == 0x0000B0, "Member 'UBTService_StrategyActionSelect::ActionTableAsset' has a wrong offset!");

// Class MarvelAI.ActionRequirementAsset
// 0x0010 (0x0048 - 0x0038)
class UActionRequirementAsset final : public UPrimaryDataAsset
{
public:
	TArray<struct FActionRequirementNode>         ActionRequirementNode;                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionRequirementAsset">();
	}
	static class UActionRequirementAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionRequirementAsset>();
	}
};
static_assert(alignof(UActionRequirementAsset) == 0x000008, "Wrong alignment on UActionRequirementAsset");
static_assert(sizeof(UActionRequirementAsset) == 0x000048, "Wrong size on UActionRequirementAsset");
static_assert(offsetof(UActionRequirementAsset, ActionRequirementNode) == 0x000038, "Member 'UActionRequirementAsset::ActionRequirementNode' has a wrong offset!");

// Class MarvelAI.Requirement_ReturnValue
// 0x0008 (0x0040 - 0x0038)
class URequirement_ReturnValue final : public UActionRequirementBase
{
public:
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Requirement_ReturnValue">();
	}
	static class URequirement_ReturnValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<URequirement_ReturnValue>();
	}
};
static_assert(alignof(URequirement_ReturnValue) == 0x000008, "Wrong alignment on URequirement_ReturnValue");
static_assert(sizeof(URequirement_ReturnValue) == 0x000040, "Wrong size on URequirement_ReturnValue");
static_assert(offsetof(URequirement_ReturnValue, ReturnValue) == 0x000038, "Member 'URequirement_ReturnValue::ReturnValue' has a wrong offset!");

// Class MarvelAI.BTS_AroundCharacter
// 0x00C8 (0x0140 - 0x0078)
class UBTS_AroundCharacter : public UBTService
{
public:
	bool                                          ConsiderDist;                                      // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAroundCharacterCheckStruct>    AroundCharacterCheckList;                          // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHeroFilter                            HeroFilter;                                        // 0x0090(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 PassCharacterNum;                                  // 0x0110(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_AroundCharacter">();
	}
	static class UBTS_AroundCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_AroundCharacter>();
	}
};
static_assert(alignof(UBTS_AroundCharacter) == 0x000008, "Wrong alignment on UBTS_AroundCharacter");
static_assert(sizeof(UBTS_AroundCharacter) == 0x000140, "Wrong size on UBTS_AroundCharacter");
static_assert(offsetof(UBTS_AroundCharacter, ConsiderDist) == 0x000078, "Member 'UBTS_AroundCharacter::ConsiderDist' has a wrong offset!");
static_assert(offsetof(UBTS_AroundCharacter, AroundCharacterCheckList) == 0x000080, "Member 'UBTS_AroundCharacter::AroundCharacterCheckList' has a wrong offset!");
static_assert(offsetof(UBTS_AroundCharacter, HeroFilter) == 0x000090, "Member 'UBTS_AroundCharacter::HeroFilter' has a wrong offset!");
static_assert(offsetof(UBTS_AroundCharacter, PassCharacterNum) == 0x000110, "Member 'UBTS_AroundCharacter::PassCharacterNum' has a wrong offset!");

// Class MarvelAI.BTS_AutoAbilityService
// 0x00F0 (0x0168 - 0x0078)
class UBTS_AutoAbilityService : public UBTService
{
public:
	bool                                          bUseAIInfoGroupTags;                               // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  UsageGroupTags;                                    // 0x0080(0x0068)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  BlockTag;                                          // 0x00E8(0x0068)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bUseDynamicFrequency;                              // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideTactics;                                  // 0x0151(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_152[0x6];                                      // 0x0152(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAbilityTacticsTask>        OverrideRequestClass;                              // 0x0158(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UAIAbilitySelectCheckBase>  OverrideSelectCheckClass;                          // 0x0160(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_AutoAbilityService">();
	}
	static class UBTS_AutoAbilityService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_AutoAbilityService>();
	}
};
static_assert(alignof(UBTS_AutoAbilityService) == 0x000008, "Wrong alignment on UBTS_AutoAbilityService");
static_assert(sizeof(UBTS_AutoAbilityService) == 0x000168, "Wrong size on UBTS_AutoAbilityService");
static_assert(offsetof(UBTS_AutoAbilityService, bUseAIInfoGroupTags) == 0x000078, "Member 'UBTS_AutoAbilityService::bUseAIInfoGroupTags' has a wrong offset!");
static_assert(offsetof(UBTS_AutoAbilityService, UsageGroupTags) == 0x000080, "Member 'UBTS_AutoAbilityService::UsageGroupTags' has a wrong offset!");
static_assert(offsetof(UBTS_AutoAbilityService, BlockTag) == 0x0000E8, "Member 'UBTS_AutoAbilityService::BlockTag' has a wrong offset!");
static_assert(offsetof(UBTS_AutoAbilityService, bUseDynamicFrequency) == 0x000150, "Member 'UBTS_AutoAbilityService::bUseDynamicFrequency' has a wrong offset!");
static_assert(offsetof(UBTS_AutoAbilityService, bOverrideTactics) == 0x000151, "Member 'UBTS_AutoAbilityService::bOverrideTactics' has a wrong offset!");
static_assert(offsetof(UBTS_AutoAbilityService, OverrideRequestClass) == 0x000158, "Member 'UBTS_AutoAbilityService::OverrideRequestClass' has a wrong offset!");
static_assert(offsetof(UBTS_AutoAbilityService, OverrideSelectCheckClass) == 0x000160, "Member 'UBTS_AutoAbilityService::OverrideSelectCheckClass' has a wrong offset!");

// Class MarvelAI.BTS_AutoInjection
// 0x03C8 (0x0440 - 0x0078)
class UBTS_AutoInjection final : public UBTService
{
public:
	struct FAIAbilityUsage                        AIAbilityData;                                     // 0x0078(0x00E8)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAIAutoAbilityTable              UsageConfig;                                       // 0x0160(0x0268)(Edit, EditConst, NativeAccessSpecifierPublic)
	class UAIAbilityUsageObject*                  AbilityUsageObject;                                // 0x03C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 AbilityUsageBlackboardKey;                         // 0x03D0(0x0030)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 AttackTargetBlackboardKey;                         // 0x0400(0x0030)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 AbilityID;                                         // 0x0430(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_AutoInjection">();
	}
	static class UBTS_AutoInjection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_AutoInjection>();
	}
};
static_assert(alignof(UBTS_AutoInjection) == 0x000008, "Wrong alignment on UBTS_AutoInjection");
static_assert(sizeof(UBTS_AutoInjection) == 0x000440, "Wrong size on UBTS_AutoInjection");
static_assert(offsetof(UBTS_AutoInjection, AIAbilityData) == 0x000078, "Member 'UBTS_AutoInjection::AIAbilityData' has a wrong offset!");
static_assert(offsetof(UBTS_AutoInjection, UsageConfig) == 0x000160, "Member 'UBTS_AutoInjection::UsageConfig' has a wrong offset!");
static_assert(offsetof(UBTS_AutoInjection, AbilityUsageObject) == 0x0003C8, "Member 'UBTS_AutoInjection::AbilityUsageObject' has a wrong offset!");
static_assert(offsetof(UBTS_AutoInjection, AbilityUsageBlackboardKey) == 0x0003D0, "Member 'UBTS_AutoInjection::AbilityUsageBlackboardKey' has a wrong offset!");
static_assert(offsetof(UBTS_AutoInjection, AttackTargetBlackboardKey) == 0x000400, "Member 'UBTS_AutoInjection::AttackTargetBlackboardKey' has a wrong offset!");
static_assert(offsetof(UBTS_AutoInjection, AbilityID) == 0x000430, "Member 'UBTS_AutoInjection::AbilityID' has a wrong offset!");

// Class MarvelAI.BTS_CheckRemainTime
// 0x0038 (0x00B0 - 0x0078)
class UBTS_CheckRemainTime : public UBTService
{
public:
	struct FBlackboardKeySelector                 OutRemainTime;                                     // 0x0078(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_CheckRemainTime">();
	}
	static class UBTS_CheckRemainTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_CheckRemainTime>();
	}
};
static_assert(alignof(UBTS_CheckRemainTime) == 0x000008, "Wrong alignment on UBTS_CheckRemainTime");
static_assert(sizeof(UBTS_CheckRemainTime) == 0x0000B0, "Wrong size on UBTS_CheckRemainTime");
static_assert(offsetof(UBTS_CheckRemainTime, OutRemainTime) == 0x000078, "Member 'UBTS_CheckRemainTime::OutRemainTime' has a wrong offset!");

// Class MarvelAI.BTS_SelectTargetNew
// 0x01B8 (0x0230 - 0x0078)
class UBTS_SelectTargetNew : public UBTService
{
public:
	bool                                          bEnableDebug;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugName;                                         // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 InOutTarget;                                       // 0x0090(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 OutSenseFromPortal;                                // 0x00C0(0x0030)(Edit, NativeAccessSpecifierPublic)
	EAITargetType                                 CharacterGroupType;                                // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHeroRole                                     LimitRole;                                         // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAIScoreModuleRule>         ScoreRuleConfigClass;                              // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIScoreModuleRule>         SummonScoreRuleConfigClass;                        // 0x0100(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   HighPrioritySummoners;                             // 0x0108(0x0050)(Edit, NativeAccessSpecifierPublic)
	class UAIScoreModuleRule*                     RuleConfig;                                        // 0x0158(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIScoreModuleRule*                     SummonedRuleConfig;                                // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMarvelAIController*                    AIOwner;                                           // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           Candidates;                                        // 0x0170(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class AMarvelGameState*                       CacheMarvelGameState;                              // 0x01C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x68];                                     // 0x01C8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTargetTakingDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_SelectTargetNew">();
	}
	static class UBTS_SelectTargetNew* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_SelectTargetNew>();
	}
};
static_assert(alignof(UBTS_SelectTargetNew) == 0x000008, "Wrong alignment on UBTS_SelectTargetNew");
static_assert(sizeof(UBTS_SelectTargetNew) == 0x000230, "Wrong size on UBTS_SelectTargetNew");
static_assert(offsetof(UBTS_SelectTargetNew, bEnableDebug) == 0x000078, "Member 'UBTS_SelectTargetNew::bEnableDebug' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, DebugName) == 0x000080, "Member 'UBTS_SelectTargetNew::DebugName' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, InOutTarget) == 0x000090, "Member 'UBTS_SelectTargetNew::InOutTarget' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, OutSenseFromPortal) == 0x0000C0, "Member 'UBTS_SelectTargetNew::OutSenseFromPortal' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, CharacterGroupType) == 0x0000F0, "Member 'UBTS_SelectTargetNew::CharacterGroupType' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, LimitRole) == 0x0000F1, "Member 'UBTS_SelectTargetNew::LimitRole' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, ScoreRuleConfigClass) == 0x0000F8, "Member 'UBTS_SelectTargetNew::ScoreRuleConfigClass' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, SummonScoreRuleConfigClass) == 0x000100, "Member 'UBTS_SelectTargetNew::SummonScoreRuleConfigClass' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, HighPrioritySummoners) == 0x000108, "Member 'UBTS_SelectTargetNew::HighPrioritySummoners' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, RuleConfig) == 0x000158, "Member 'UBTS_SelectTargetNew::RuleConfig' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, SummonedRuleConfig) == 0x000160, "Member 'UBTS_SelectTargetNew::SummonedRuleConfig' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, AIOwner) == 0x000168, "Member 'UBTS_SelectTargetNew::AIOwner' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, Candidates) == 0x000170, "Member 'UBTS_SelectTargetNew::Candidates' has a wrong offset!");
static_assert(offsetof(UBTS_SelectTargetNew, CacheMarvelGameState) == 0x0001C0, "Member 'UBTS_SelectTargetNew::CacheMarvelGameState' has a wrong offset!");

// Class MarvelAI.BTS_SendChatMessage
// 0x0050 (0x00C8 - 0x0078)
class UBTS_SendChatMessage final : public UBTService
{
public:
	int32                                         MessageSide;                                       // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Timestamp;                                         // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChannelType;                                       // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialType;                                       // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PoolHealth;                                        // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendMessageCD;                                     // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AICommunicateDataTableAsset;                       // 0x0090(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAICommunicateAsset*                    WeightsAsset;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelAIController*                    AIOwner;                                           // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              LastSendMessageTime;                               // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetAIUserName(class AActor* Target);
	void OnAllDeath(const struct FAIEventArgs& Args);
	void OnDeath(const struct FAIEventArgs& Args);
	void OnEnergyFull(const struct FAIEventArgs& Args);
	void OnGameBegin(const struct FAIEventArgs& Args);
	void OnGameEnd(const struct FAIEventArgs& Args);
	void OnHeal(const struct FAIEventArgs& Args);
	void OnHealthChanged(const struct FAIEventArgs& Args);
	void SendChatMessage(const class FString& Msg, class AActor* Target);
	void SendMessage(struct FAICommunicateEx* Communicate, class AActor* Target);
	void SendQuickMessage(const int32& ID, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_SendChatMessage">();
	}
	static class UBTS_SendChatMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_SendChatMessage>();
	}
};
static_assert(alignof(UBTS_SendChatMessage) == 0x000008, "Wrong alignment on UBTS_SendChatMessage");
static_assert(sizeof(UBTS_SendChatMessage) == 0x0000C8, "Wrong size on UBTS_SendChatMessage");
static_assert(offsetof(UBTS_SendChatMessage, MessageSide) == 0x000078, "Member 'UBTS_SendChatMessage::MessageSide' has a wrong offset!");
static_assert(offsetof(UBTS_SendChatMessage, Timestamp) == 0x00007C, "Member 'UBTS_SendChatMessage::Timestamp' has a wrong offset!");
static_assert(offsetof(UBTS_SendChatMessage, ChannelType) == 0x000080, "Member 'UBTS_SendChatMessage::ChannelType' has a wrong offset!");
static_assert(offsetof(UBTS_SendChatMessage, SpecialType) == 0x000084, "Member 'UBTS_SendChatMessage::SpecialType' has a wrong offset!");
static_assert(offsetof(UBTS_SendChatMessage, PoolHealth) == 0x000088, "Member 'UBTS_SendChatMessage::PoolHealth' has a wrong offset!");
static_assert(offsetof(UBTS_SendChatMessage, SendMessageCD) == 0x00008C, "Member 'UBTS_SendChatMessage::SendMessageCD' has a wrong offset!");
static_assert(offsetof(UBTS_SendChatMessage, AICommunicateDataTableAsset) == 0x000090, "Member 'UBTS_SendChatMessage::AICommunicateDataTableAsset' has a wrong offset!");
static_assert(offsetof(UBTS_SendChatMessage, WeightsAsset) == 0x000098, "Member 'UBTS_SendChatMessage::WeightsAsset' has a wrong offset!");
static_assert(offsetof(UBTS_SendChatMessage, AIOwner) == 0x0000A0, "Member 'UBTS_SendChatMessage::AIOwner' has a wrong offset!");
static_assert(offsetof(UBTS_SendChatMessage, LastSendMessageTime) == 0x0000A8, "Member 'UBTS_SendChatMessage::LastSendMessageTime' has a wrong offset!");

// Class MarvelAI.BTS_SetMapPoint_Payload
// 0x01F0 (0x0268 - 0x0078)
class UBTS_SetMapPoint_Payload : public UBTService
{
public:
	struct FBlackboardKeySelector                 InMatchStateInput;                                 // 0x0078(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FStrategyArea                          OutStrategyArea;                                   // 0x00A8(0x0090)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 FrontierBBKey;                                     // 0x0138(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 EnemyPlayerStartBBKey;                             // 0x0168(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 AllyPlayerStartBBKey;                              // 0x0198(0x0030)(Edit, NativeAccessSpecifierPrivate)
	float                                         SuppressDist;                                      // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RetreatDist;                                       // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHotPoint_DataAsset*                    DA_HotPoint;                                       // 0x01D0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 SuppressPointBBKey;                                // 0x01D8(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 RetreatPointBBKey;                                 // 0x0208(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 OutHotPointBBKey;                                  // 0x0238(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_SetMapPoint_Payload">();
	}
	static class UBTS_SetMapPoint_Payload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_SetMapPoint_Payload>();
	}
};
static_assert(alignof(UBTS_SetMapPoint_Payload) == 0x000008, "Wrong alignment on UBTS_SetMapPoint_Payload");
static_assert(sizeof(UBTS_SetMapPoint_Payload) == 0x000268, "Wrong size on UBTS_SetMapPoint_Payload");
static_assert(offsetof(UBTS_SetMapPoint_Payload, InMatchStateInput) == 0x000078, "Member 'UBTS_SetMapPoint_Payload::InMatchStateInput' has a wrong offset!");
static_assert(offsetof(UBTS_SetMapPoint_Payload, OutStrategyArea) == 0x0000A8, "Member 'UBTS_SetMapPoint_Payload::OutStrategyArea' has a wrong offset!");
static_assert(offsetof(UBTS_SetMapPoint_Payload, FrontierBBKey) == 0x000138, "Member 'UBTS_SetMapPoint_Payload::FrontierBBKey' has a wrong offset!");
static_assert(offsetof(UBTS_SetMapPoint_Payload, EnemyPlayerStartBBKey) == 0x000168, "Member 'UBTS_SetMapPoint_Payload::EnemyPlayerStartBBKey' has a wrong offset!");
static_assert(offsetof(UBTS_SetMapPoint_Payload, AllyPlayerStartBBKey) == 0x000198, "Member 'UBTS_SetMapPoint_Payload::AllyPlayerStartBBKey' has a wrong offset!");
static_assert(offsetof(UBTS_SetMapPoint_Payload, SuppressDist) == 0x0001C8, "Member 'UBTS_SetMapPoint_Payload::SuppressDist' has a wrong offset!");
static_assert(offsetof(UBTS_SetMapPoint_Payload, RetreatDist) == 0x0001CC, "Member 'UBTS_SetMapPoint_Payload::RetreatDist' has a wrong offset!");
static_assert(offsetof(UBTS_SetMapPoint_Payload, DA_HotPoint) == 0x0001D0, "Member 'UBTS_SetMapPoint_Payload::DA_HotPoint' has a wrong offset!");
static_assert(offsetof(UBTS_SetMapPoint_Payload, SuppressPointBBKey) == 0x0001D8, "Member 'UBTS_SetMapPoint_Payload::SuppressPointBBKey' has a wrong offset!");
static_assert(offsetof(UBTS_SetMapPoint_Payload, RetreatPointBBKey) == 0x000208, "Member 'UBTS_SetMapPoint_Payload::RetreatPointBBKey' has a wrong offset!");
static_assert(offsetof(UBTS_SetMapPoint_Payload, OutHotPointBBKey) == 0x000238, "Member 'UBTS_SetMapPoint_Payload::OutHotPointBBKey' has a wrong offset!");

// Class MarvelAI.BTS_UpdateCampState
// 0x0030 (0x00A8 - 0x0078)
class UBTS_UpdateCampState : public UBTService
{
public:
	struct FBlackboardKeySelector                 OutCampState;                                      // 0x0078(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateCampState">();
	}
	static class UBTS_UpdateCampState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateCampState>();
	}
};
static_assert(alignof(UBTS_UpdateCampState) == 0x000008, "Wrong alignment on UBTS_UpdateCampState");
static_assert(sizeof(UBTS_UpdateCampState) == 0x0000A8, "Wrong size on UBTS_UpdateCampState");
static_assert(offsetof(UBTS_UpdateCampState, OutCampState) == 0x000078, "Member 'UBTS_UpdateCampState::OutCampState' has a wrong offset!");

// Class MarvelAI.BTS_UpdateControlState
// 0x0090 (0x01A8 - 0x0118)
class UBTS_UpdateControlState final : public UBTS_UpdateMatchState_New
{
public:
	struct FBlackboardKeySelector                 AllyCampProgressKey;                               // 0x0118(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 EnemyCampProgressKey;                              // 0x0148(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 ControlStateKey;                                   // 0x0178(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	EAIFilterSide GetCampControlState(class AMarvelBaseCharacter* OwnerCharacter);
	TArray<float> GetCampProgress(class AMarvelBaseCharacter* OwnerCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateControlState">();
	}
	static class UBTS_UpdateControlState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateControlState>();
	}
};
static_assert(alignof(UBTS_UpdateControlState) == 0x000008, "Wrong alignment on UBTS_UpdateControlState");
static_assert(sizeof(UBTS_UpdateControlState) == 0x0001A8, "Wrong size on UBTS_UpdateControlState");
static_assert(offsetof(UBTS_UpdateControlState, AllyCampProgressKey) == 0x000118, "Member 'UBTS_UpdateControlState::AllyCampProgressKey' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateControlState, EnemyCampProgressKey) == 0x000148, "Member 'UBTS_UpdateControlState::EnemyCampProgressKey' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateControlState, ControlStateKey) == 0x000178, "Member 'UBTS_UpdateControlState::ControlStateKey' has a wrong offset!");

// Class MarvelAI.BTS_UpdateEscortStateNew
// 0x0090 (0x01A8 - 0x0118)
class UBTS_UpdateEscortStateNew final : public UBTS_UpdateMatchState_New
{
public:
	struct FBlackboardKeySelector                 GameStageKey;                                      // 0x0118(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 PayloadStateKey;                                   // 0x0148(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 PayloadProgressKey;                                // 0x0178(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	EOwnershipType GetPayloadOwnership();
	float GetPayLoadProgress();
	float GetPayLoadSpeed();
	void SetCurrentStage(const class FString& StageName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateEscortStateNew">();
	}
	static class UBTS_UpdateEscortStateNew* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateEscortStateNew>();
	}
};
static_assert(alignof(UBTS_UpdateEscortStateNew) == 0x000008, "Wrong alignment on UBTS_UpdateEscortStateNew");
static_assert(sizeof(UBTS_UpdateEscortStateNew) == 0x0001A8, "Wrong size on UBTS_UpdateEscortStateNew");
static_assert(offsetof(UBTS_UpdateEscortStateNew, GameStageKey) == 0x000118, "Member 'UBTS_UpdateEscortStateNew::GameStageKey' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateEscortStateNew, PayloadStateKey) == 0x000148, "Member 'UBTS_UpdateEscortStateNew::PayloadStateKey' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateEscortStateNew, PayloadProgressKey) == 0x000178, "Member 'UBTS_UpdateEscortStateNew::PayloadProgressKey' has a wrong offset!");

// Class MarvelAI.BTS_UpdateFrontier
// 0x0030 (0x00A8 - 0x0078)
class UBTS_UpdateFrontier : public UBTService
{
public:
	struct FBlackboardKeySelector                 OutFrontier;                                       // 0x0078(0x0030)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateFrontier">();
	}
	static class UBTS_UpdateFrontier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateFrontier>();
	}
};
static_assert(alignof(UBTS_UpdateFrontier) == 0x000008, "Wrong alignment on UBTS_UpdateFrontier");
static_assert(sizeof(UBTS_UpdateFrontier) == 0x0000A8, "Wrong size on UBTS_UpdateFrontier");
static_assert(offsetof(UBTS_UpdateFrontier, OutFrontier) == 0x000078, "Member 'UBTS_UpdateFrontier::OutFrontier' has a wrong offset!");

// Class MarvelAI.BTS_UpdateMatchState
// 0x0068 (0x00E0 - 0x0078)
class UBTS_UpdateMatchState : public UBTService
{
public:
	struct FBlackboardKeySelector                 OutMatchState;                                     // 0x0078(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 OutBattleState;                                    // 0x00A8(0x0030)(Edit, NativeAccessSpecifierPublic)
	class AAIController*                          AIOwner;                                           // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMatchStateChange(EMatchState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateMatchState">();
	}
	static class UBTS_UpdateMatchState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateMatchState>();
	}
};
static_assert(alignof(UBTS_UpdateMatchState) == 0x000008, "Wrong alignment on UBTS_UpdateMatchState");
static_assert(sizeof(UBTS_UpdateMatchState) == 0x0000E0, "Wrong size on UBTS_UpdateMatchState");
static_assert(offsetof(UBTS_UpdateMatchState, OutMatchState) == 0x000078, "Member 'UBTS_UpdateMatchState::OutMatchState' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateMatchState, OutBattleState) == 0x0000A8, "Member 'UBTS_UpdateMatchState::OutBattleState' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateMatchState, AIOwner) == 0x0000D8, "Member 'UBTS_UpdateMatchState::AIOwner' has a wrong offset!");

// Class MarvelAI.BTS_UpdateSpineDist2Payload
// 0x00A0 (0x0118 - 0x0078)
class UBTS_UpdateSpineDist2Payload final : public UBTService
{
public:
	struct FBlackboardKeySelector                 InTarget;                                          // 0x0078(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 InFrontier;                                        // 0x00A8(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 OutDistance;                                       // 0x00D8(0x0030)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class USplineComponent*>               SplineComponents;                                  // 0x0108(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdateSpineDist2Payload">();
	}
	static class UBTS_UpdateSpineDist2Payload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdateSpineDist2Payload>();
	}
};
static_assert(alignof(UBTS_UpdateSpineDist2Payload) == 0x000008, "Wrong alignment on UBTS_UpdateSpineDist2Payload");
static_assert(sizeof(UBTS_UpdateSpineDist2Payload) == 0x000118, "Wrong size on UBTS_UpdateSpineDist2Payload");
static_assert(offsetof(UBTS_UpdateSpineDist2Payload, InTarget) == 0x000078, "Member 'UBTS_UpdateSpineDist2Payload::InTarget' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateSpineDist2Payload, InFrontier) == 0x0000A8, "Member 'UBTS_UpdateSpineDist2Payload::InFrontier' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateSpineDist2Payload, OutDistance) == 0x0000D8, "Member 'UBTS_UpdateSpineDist2Payload::OutDistance' has a wrong offset!");
static_assert(offsetof(UBTS_UpdateSpineDist2Payload, SplineComponents) == 0x000108, "Member 'UBTS_UpdateSpineDist2Payload::SplineComponents' has a wrong offset!");

// Class MarvelAI.BTTask_AbilityDelayWait_BB
// 0x0030 (0x00B0 - 0x0080)
class UBTTask_AbilityDelayWait_BB final : public UBTTask_Wait
{
public:
	struct FBlackboardKeySelector                 InAbilityUsage;                                    // 0x0080(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AbilityDelayWait_BB">();
	}
	static class UBTTask_AbilityDelayWait_BB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AbilityDelayWait_BB>();
	}
};
static_assert(alignof(UBTTask_AbilityDelayWait_BB) == 0x000008, "Wrong alignment on UBTTask_AbilityDelayWait_BB");
static_assert(sizeof(UBTTask_AbilityDelayWait_BB) == 0x0000B0, "Wrong size on UBTTask_AbilityDelayWait_BB");
static_assert(offsetof(UBTTask_AbilityDelayWait_BB, InAbilityUsage) == 0x000080, "Member 'UBTTask_AbilityDelayWait_BB::InAbilityUsage' has a wrong offset!");

// Class MarvelAI.BTTask_ActivateAbility_BB
// 0x0118 (0x01C8 - 0x00B0)
class UBTTask_ActivateAbility_BB final : public UBTTask_GeneralActivateAbility
{
public:
	struct FBlackboardKeySelector                 InAbilityUsageObject;                              // 0x00B0(0x0030)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0xE8];                                      // 0x00E0(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ActivateAbility_BB">();
	}
	static class UBTTask_ActivateAbility_BB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ActivateAbility_BB>();
	}
};
static_assert(alignof(UBTTask_ActivateAbility_BB) == 0x000008, "Wrong alignment on UBTTask_ActivateAbility_BB");
static_assert(sizeof(UBTTask_ActivateAbility_BB) == 0x0001C8, "Wrong size on UBTTask_ActivateAbility_BB");
static_assert(offsetof(UBTTask_ActivateAbility_BB, InAbilityUsageObject) == 0x0000B0, "Member 'UBTTask_ActivateAbility_BB::InAbilityUsageObject' has a wrong offset!");

// Class MarvelAI.BTTask_AIActivateAbilityTask
// 0x0048 (0x00C0 - 0x0078)
class UBTTask_AIActivateAbilityTask final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 InAbilityUsageObject;                              // 0x0078(0x0030)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           InjectionTag;                                      // 0x00A8(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BehaviorAsset;                                     // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitAbilityTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIActivateAbilityTask">();
	}
	static class UBTTask_AIActivateAbilityTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIActivateAbilityTask>();
	}
};
static_assert(alignof(UBTTask_AIActivateAbilityTask) == 0x000008, "Wrong alignment on UBTTask_AIActivateAbilityTask");
static_assert(sizeof(UBTTask_AIActivateAbilityTask) == 0x0000C0, "Wrong size on UBTTask_AIActivateAbilityTask");
static_assert(offsetof(UBTTask_AIActivateAbilityTask, InAbilityUsageObject) == 0x000078, "Member 'UBTTask_AIActivateAbilityTask::InAbilityUsageObject' has a wrong offset!");
static_assert(offsetof(UBTTask_AIActivateAbilityTask, InjectionTag) == 0x0000A8, "Member 'UBTTask_AIActivateAbilityTask::InjectionTag' has a wrong offset!");
static_assert(offsetof(UBTTask_AIActivateAbilityTask, BehaviorAsset) == 0x0000B8, "Member 'UBTTask_AIActivateAbilityTask::BehaviorAsset' has a wrong offset!");

// Class MarvelAI.BTTask_ChaseTarget
// 0x00C8 (0x0140 - 0x0078)
class UBTTask_ChaseTarget final : public UBTTaskNode
{
public:
	float                                         AcceptableRadius;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectDistFactor;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseDirectMoveWithJump;                      // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDirectMoving;                                // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPartialPath;                                 // 0x0082(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDrawDebug;                                  // 0x0083(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpDistance;                                        // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardDistance;                                   // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownAngle;                                         // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredProgress;                                  // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleSizeFactor;                                 // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZDistToTryPreJump;                              // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreJumpCoolDown;                                   // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CliffCheckFrontDistance;                           // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CliffCheckDownDistance;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CliffCheckVerticalMoveRange;                       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CliffCheckExtentFactor;                            // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CliffCheckCoolDown;                                // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnNavMeshCheckFrontDistance;                       // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAddHalfHeightOnCheckPoint;                  // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 InMoveGoal;                                        // 0x00C0(0x0030)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x50];                                      // 0x00F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBump(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ChaseTarget">();
	}
	static class UBTTask_ChaseTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ChaseTarget>();
	}
};
static_assert(alignof(UBTTask_ChaseTarget) == 0x000008, "Wrong alignment on UBTTask_ChaseTarget");
static_assert(sizeof(UBTTask_ChaseTarget) == 0x000140, "Wrong size on UBTTask_ChaseTarget");
static_assert(offsetof(UBTTask_ChaseTarget, AcceptableRadius) == 0x000078, "Member 'UBTTask_ChaseTarget::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, DirectDistFactor) == 0x00007C, "Member 'UBTTask_ChaseTarget::DirectDistFactor' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, bShouldUseDirectMoveWithJump) == 0x000080, "Member 'UBTTask_ChaseTarget::bShouldUseDirectMoveWithJump' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, bForceDirectMoving) == 0x000081, "Member 'UBTTask_ChaseTarget::bForceDirectMoving' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, bAllowPartialPath) == 0x000082, "Member 'UBTTask_ChaseTarget::bAllowPartialPath' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, bEnableDrawDebug) == 0x000083, "Member 'UBTTask_ChaseTarget::bEnableDrawDebug' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, UpDistance) == 0x000084, "Member 'UBTTask_ChaseTarget::UpDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, ForwardDistance) == 0x000088, "Member 'UBTTask_ChaseTarget::ForwardDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, DownAngle) == 0x00008C, "Member 'UBTTask_ChaseTarget::DownAngle' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, RequiredProgress) == 0x000090, "Member 'UBTTask_ChaseTarget::RequiredProgress' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, CapsuleSizeFactor) == 0x000094, "Member 'UBTTask_ChaseTarget::CapsuleSizeFactor' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, MaxZDistToTryPreJump) == 0x000098, "Member 'UBTTask_ChaseTarget::MaxZDistToTryPreJump' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, PreJumpCoolDown) == 0x00009C, "Member 'UBTTask_ChaseTarget::PreJumpCoolDown' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, CliffCheckFrontDistance) == 0x0000A0, "Member 'UBTTask_ChaseTarget::CliffCheckFrontDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, CliffCheckDownDistance) == 0x0000A4, "Member 'UBTTask_ChaseTarget::CliffCheckDownDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, CliffCheckVerticalMoveRange) == 0x0000A8, "Member 'UBTTask_ChaseTarget::CliffCheckVerticalMoveRange' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, CliffCheckExtentFactor) == 0x0000AC, "Member 'UBTTask_ChaseTarget::CliffCheckExtentFactor' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, CliffCheckCoolDown) == 0x0000B0, "Member 'UBTTask_ChaseTarget::CliffCheckCoolDown' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, OnNavMeshCheckFrontDistance) == 0x0000B4, "Member 'UBTTask_ChaseTarget::OnNavMeshCheckFrontDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, bShouldAddHalfHeightOnCheckPoint) == 0x0000B8, "Member 'UBTTask_ChaseTarget::bShouldAddHalfHeightOnCheckPoint' has a wrong offset!");
static_assert(offsetof(UBTTask_ChaseTarget, InMoveGoal) == 0x0000C0, "Member 'UBTTask_ChaseTarget::InMoveGoal' has a wrong offset!");

// Class MarvelAI.BTTask_MarvelInstancedBase
// 0x0010 (0x00C0 - 0x00B0)
class UBTTask_MarvelInstancedBase : public UBTTask_BlueprintBase
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelAIController*                    MarvelAIOwner;                                     // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsTaskEnded();
	void ReceiveOnTaskFinished(class AAIController* OwnerController, class APawn* ControlledPawn, EBTNodeResult Result);
	void SetTickInterval(float NewTickInterval);

	class AMarvelBaseCharacter* K2_GetControlledHero() const;
	class APawn* K2_GetControlledPawn() const;
	class AMarvelAIController* K2_GetMarvelAIOwner() const;
	class UBehaviorTreeComponent* K2_GetOwnerBTComp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MarvelInstancedBase">();
	}
	static class UBTTask_MarvelInstancedBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MarvelInstancedBase>();
	}
};
static_assert(alignof(UBTTask_MarvelInstancedBase) == 0x000008, "Wrong alignment on UBTTask_MarvelInstancedBase");
static_assert(sizeof(UBTTask_MarvelInstancedBase) == 0x0000C0, "Wrong size on UBTTask_MarvelInstancedBase");
static_assert(offsetof(UBTTask_MarvelInstancedBase, MarvelAIOwner) == 0x0000B8, "Member 'UBTTask_MarvelInstancedBase::MarvelAIOwner' has a wrong offset!");

// Class MarvelAI.BTTask_MarvelRunBehaviorStatic
// 0x0000 (0x0080 - 0x0080)
class UBTTask_MarvelRunBehaviorStatic final : public UBTTask_RunBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MarvelRunBehaviorStatic">();
	}
	static class UBTTask_MarvelRunBehaviorStatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MarvelRunBehaviorStatic>();
	}
};
static_assert(alignof(UBTTask_MarvelRunBehaviorStatic) == 0x000008, "Wrong alignment on UBTTask_MarvelRunBehaviorStatic");
static_assert(sizeof(UBTTask_MarvelRunBehaviorStatic) == 0x000080, "Wrong size on UBTTask_MarvelRunBehaviorStatic");

// Class MarvelAI.BTTask_SwitchWeapon
// 0x0010 (0x00C0 - 0x00B0)
class UBTTask_SwitchWeapon final : public UBTTask_GeneralActivateAbility
{
public:
	class FName                                   WeaponActionName;                                  // 0x00B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SwitchWeapon">();
	}
	static class UBTTask_SwitchWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SwitchWeapon>();
	}
};
static_assert(alignof(UBTTask_SwitchWeapon) == 0x000008, "Wrong alignment on UBTTask_SwitchWeapon");
static_assert(sizeof(UBTTask_SwitchWeapon) == 0x0000C0, "Wrong size on UBTTask_SwitchWeapon");
static_assert(offsetof(UBTTask_SwitchWeapon, WeaponActionName) == 0x0000B0, "Member 'UBTTask_SwitchWeapon::WeaponActionName' has a wrong offset!");

// Class MarvelAI.BTT_ActiveAbilityByUsage
// 0x0050 (0x00C8 - 0x0078)
class UBTT_ActiveAbilityByUsage final : public UBTTaskNode
{
public:
	int32                                         AbilityID;                                         // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AbilityUsageID;                                    // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 BlackboardAbilityID;                               // 0x0080(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayAITag                         AbilityGroupTag;                                   // 0x00B0(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAbilityTacticsTask>        TaskClasses;                                       // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_ActiveAbilityByUsage">();
	}
	static class UBTT_ActiveAbilityByUsage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_ActiveAbilityByUsage>();
	}
};
static_assert(alignof(UBTT_ActiveAbilityByUsage) == 0x000008, "Wrong alignment on UBTT_ActiveAbilityByUsage");
static_assert(sizeof(UBTT_ActiveAbilityByUsage) == 0x0000C8, "Wrong size on UBTT_ActiveAbilityByUsage");
static_assert(offsetof(UBTT_ActiveAbilityByUsage, AbilityID) == 0x000078, "Member 'UBTT_ActiveAbilityByUsage::AbilityID' has a wrong offset!");
static_assert(offsetof(UBTT_ActiveAbilityByUsage, AbilityUsageID) == 0x00007C, "Member 'UBTT_ActiveAbilityByUsage::AbilityUsageID' has a wrong offset!");
static_assert(offsetof(UBTT_ActiveAbilityByUsage, BlackboardAbilityID) == 0x000080, "Member 'UBTT_ActiveAbilityByUsage::BlackboardAbilityID' has a wrong offset!");
static_assert(offsetof(UBTT_ActiveAbilityByUsage, AbilityGroupTag) == 0x0000B0, "Member 'UBTT_ActiveAbilityByUsage::AbilityGroupTag' has a wrong offset!");
static_assert(offsetof(UBTT_ActiveAbilityByUsage, TaskClasses) == 0x0000C0, "Member 'UBTT_ActiveAbilityByUsage::TaskClasses' has a wrong offset!");

// Class MarvelAI.BTT_FindStrategyArea
// 0x0068 (0x00E0 - 0x0078)
class UBTT_FindStrategyArea : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 StrategyAreaVolume;                                // 0x0078(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 OutLandPoint;                                      // 0x00A8(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         MaxSearchNode;                                     // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_FindStrategyArea">();
	}
	static class UBTT_FindStrategyArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_FindStrategyArea>();
	}
};
static_assert(alignof(UBTT_FindStrategyArea) == 0x000008, "Wrong alignment on UBTT_FindStrategyArea");
static_assert(sizeof(UBTT_FindStrategyArea) == 0x0000E0, "Wrong size on UBTT_FindStrategyArea");
static_assert(offsetof(UBTT_FindStrategyArea, StrategyAreaVolume) == 0x000078, "Member 'UBTT_FindStrategyArea::StrategyAreaVolume' has a wrong offset!");
static_assert(offsetof(UBTT_FindStrategyArea, OutLandPoint) == 0x0000A8, "Member 'UBTT_FindStrategyArea::OutLandPoint' has a wrong offset!");
static_assert(offsetof(UBTT_FindStrategyArea, MaxSearchNode) == 0x0000D8, "Member 'UBTT_FindStrategyArea::MaxSearchNode' has a wrong offset!");

// Class MarvelAI.BTT_PinPoint
// 0x1048 (0x10C0 - 0x0078)
class UBTT_PinPoint : public UBTTaskNode
{
public:
	TMap<EPinEnum, struct FPinPointInfo>          SignalInfoMap;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PinEventTag;                                       // 0x00C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRandomPinType : 1;                                // 0x00D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EPinEnum                                      PinType;                                           // 0x00D5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NeedFrontSightLength;                              // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00E0(0x0F90)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, int32>                            UltimateAbilityIDMap;                              // 0x1070(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_PinPoint">();
	}
	static class UBTT_PinPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_PinPoint>();
	}
};
static_assert(alignof(UBTT_PinPoint) == 0x000010, "Wrong alignment on UBTT_PinPoint");
static_assert(sizeof(UBTT_PinPoint) == 0x0010C0, "Wrong size on UBTT_PinPoint");
static_assert(offsetof(UBTT_PinPoint, SignalInfoMap) == 0x000078, "Member 'UBTT_PinPoint::SignalInfoMap' has a wrong offset!");
static_assert(offsetof(UBTT_PinPoint, PinEventTag) == 0x0000C8, "Member 'UBTT_PinPoint::PinEventTag' has a wrong offset!");
static_assert(offsetof(UBTT_PinPoint, PinType) == 0x0000D5, "Member 'UBTT_PinPoint::PinType' has a wrong offset!");
static_assert(offsetof(UBTT_PinPoint, NeedFrontSightLength) == 0x0000D8, "Member 'UBTT_PinPoint::NeedFrontSightLength' has a wrong offset!");
static_assert(offsetof(UBTT_PinPoint, TraceContext) == 0x0000E0, "Member 'UBTT_PinPoint::TraceContext' has a wrong offset!");
static_assert(offsetof(UBTT_PinPoint, UltimateAbilityIDMap) == 0x001070, "Member 'UBTT_PinPoint::UltimateAbilityIDMap' has a wrong offset!");

// Class MarvelAI.BTT_SprayNew
// 0x0028 (0x00A0 - 0x0078)
class UBTT_SprayNew : public UBTTaskNode
{
public:
	TArray<struct FMarvelAISprayTable>            DefaultSprayConfigs;                               // 0x0078(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bOnlyUseDefaultSprayConfig : 1;                    // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SprayConfigTableName;                              // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_SprayNew">();
	}
	static class UBTT_SprayNew* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_SprayNew>();
	}
};
static_assert(alignof(UBTT_SprayNew) == 0x000008, "Wrong alignment on UBTT_SprayNew");
static_assert(sizeof(UBTT_SprayNew) == 0x0000A0, "Wrong size on UBTT_SprayNew");
static_assert(offsetof(UBTT_SprayNew, DefaultSprayConfigs) == 0x000078, "Member 'UBTT_SprayNew::DefaultSprayConfigs' has a wrong offset!");
static_assert(offsetof(UBTT_SprayNew, SprayConfigTableName) == 0x000090, "Member 'UBTT_SprayNew::SprayConfigTableName' has a wrong offset!");

// Class MarvelAI.DashAbilityFilter
// 0x0000 (0x0038 - 0x0038)
class UDashAbilityFilter final : public UDynamicAbilityBindFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DashAbilityFilter">();
	}
	static class UDashAbilityFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDashAbilityFilter>();
	}
};
static_assert(alignof(UDashAbilityFilter) == 0x000008, "Wrong alignment on UDashAbilityFilter");
static_assert(sizeof(UDashAbilityFilter) == 0x000038, "Wrong size on UDashAbilityFilter");

// Class MarvelAI.DefendStandPoint
// 0x00A8 (0x0608 - 0x0560)
class ADefendStandPoint final : public AStandPointBase
{
public:
	TSet<int32>                                   HeroIDSet;                                         // 0x0560(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSet<EDefendStandPointHeroType>               HeroTypeSet;                                       // 0x05B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bShared;                                           // 0x0600(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_601[0x7];                                      // 0x0601(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefendStandPoint">();
	}
	static class ADefendStandPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADefendStandPoint>();
	}
};
static_assert(alignof(ADefendStandPoint) == 0x000008, "Wrong alignment on ADefendStandPoint");
static_assert(sizeof(ADefendStandPoint) == 0x000608, "Wrong size on ADefendStandPoint");
static_assert(offsetof(ADefendStandPoint, HeroIDSet) == 0x000560, "Member 'ADefendStandPoint::HeroIDSet' has a wrong offset!");
static_assert(offsetof(ADefendStandPoint, HeroTypeSet) == 0x0005B0, "Member 'ADefendStandPoint::HeroTypeSet' has a wrong offset!");
static_assert(offsetof(ADefendStandPoint, bShared) == 0x000600, "Member 'ADefendStandPoint::bShared' has a wrong offset!");

// Class MarvelAI.EnvQueryContext_AllAliveEnemies
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_AllAliveEnemies final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_AllAliveEnemies">();
	}
	static class UEnvQueryContext_AllAliveEnemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_AllAliveEnemies>();
	}
};
static_assert(alignof(UEnvQueryContext_AllAliveEnemies) == 0x000008, "Wrong alignment on UEnvQueryContext_AllAliveEnemies");
static_assert(sizeof(UEnvQueryContext_AllAliveEnemies) == 0x000030, "Wrong size on UEnvQueryContext_AllAliveEnemies");

// Class MarvelAI.EnvQueryContext_Ally
// 0x0008 (0x0038 - 0x0030)
class UEnvQueryContext_Ally final : public UEnvQueryContext
{
public:
	bool                                          bNeedAlive;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNeedParticularRole;                               // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHeroRole                                     HeroType;                                          // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Ally">();
	}
	static class UEnvQueryContext_Ally* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Ally>();
	}
};
static_assert(alignof(UEnvQueryContext_Ally) == 0x000008, "Wrong alignment on UEnvQueryContext_Ally");
static_assert(sizeof(UEnvQueryContext_Ally) == 0x000038, "Wrong size on UEnvQueryContext_Ally");
static_assert(offsetof(UEnvQueryContext_Ally, bNeedAlive) == 0x000030, "Member 'UEnvQueryContext_Ally::bNeedAlive' has a wrong offset!");
static_assert(offsetof(UEnvQueryContext_Ally, bNeedParticularRole) == 0x000031, "Member 'UEnvQueryContext_Ally::bNeedParticularRole' has a wrong offset!");
static_assert(offsetof(UEnvQueryContext_Ally, HeroType) == 0x000032, "Member 'UEnvQueryContext_Ally::HeroType' has a wrong offset!");

// Class MarvelAI.EnvQueryContext_BuffedCharacter
// 0x0088 (0x00B8 - 0x0030)
class UEnvQueryContext_BuffedCharacter final : public UEnvQueryContext
{
public:
	int32                                         BuffID;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHeroFilter                            HeroFilter;                                        // 0x0038(0x0080)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_BuffedCharacter">();
	}
	static class UEnvQueryContext_BuffedCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_BuffedCharacter>();
	}
};
static_assert(alignof(UEnvQueryContext_BuffedCharacter) == 0x000008, "Wrong alignment on UEnvQueryContext_BuffedCharacter");
static_assert(sizeof(UEnvQueryContext_BuffedCharacter) == 0x0000B8, "Wrong size on UEnvQueryContext_BuffedCharacter");
static_assert(offsetof(UEnvQueryContext_BuffedCharacter, BuffID) == 0x000030, "Member 'UEnvQueryContext_BuffedCharacter::BuffID' has a wrong offset!");
static_assert(offsetof(UEnvQueryContext_BuffedCharacter, HeroFilter) == 0x000038, "Member 'UEnvQueryContext_BuffedCharacter::HeroFilter' has a wrong offset!");

// Class MarvelAI.EnvQueryContext_Enemy
// 0x0008 (0x0038 - 0x0030)
class UEnvQueryContext_Enemy final : public UEnvQueryContext
{
public:
	bool                                          bNeedAlive;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNeedParticularRole;                               // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHeroRole                                     HeroType;                                          // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreCurrentAttackTarget;                        // 0x0033(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Enemy">();
	}
	static class UEnvQueryContext_Enemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Enemy>();
	}
};
static_assert(alignof(UEnvQueryContext_Enemy) == 0x000008, "Wrong alignment on UEnvQueryContext_Enemy");
static_assert(sizeof(UEnvQueryContext_Enemy) == 0x000038, "Wrong size on UEnvQueryContext_Enemy");
static_assert(offsetof(UEnvQueryContext_Enemy, bNeedAlive) == 0x000030, "Member 'UEnvQueryContext_Enemy::bNeedAlive' has a wrong offset!");
static_assert(offsetof(UEnvQueryContext_Enemy, bNeedParticularRole) == 0x000031, "Member 'UEnvQueryContext_Enemy::bNeedParticularRole' has a wrong offset!");
static_assert(offsetof(UEnvQueryContext_Enemy, HeroType) == 0x000032, "Member 'UEnvQueryContext_Enemy::HeroType' has a wrong offset!");
static_assert(offsetof(UEnvQueryContext_Enemy, bIgnoreCurrentAttackTarget) == 0x000033, "Member 'UEnvQueryContext_Enemy::bIgnoreCurrentAttackTarget' has a wrong offset!");

// Class MarvelAI.EnvQueryGenerator_Sphere
// 0x0108 (0x0160 - 0x0058)
class UEnvQueryGenerator_Sphere : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              DistanceInSameDirection;                           // 0x0060(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              OuterRange;                                        // 0x00A0(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              InnerRange;                                        // 0x00E0(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              AngleStep;                                         // 0x0120(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Sphere">();
	}
	static class UEnvQueryGenerator_Sphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Sphere>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Sphere) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Sphere");
static_assert(sizeof(UEnvQueryGenerator_Sphere) == 0x000160, "Wrong size on UEnvQueryGenerator_Sphere");
static_assert(offsetof(UEnvQueryGenerator_Sphere, GenerateAround) == 0x000058, "Member 'UEnvQueryGenerator_Sphere::GenerateAround' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Sphere, DistanceInSameDirection) == 0x000060, "Member 'UEnvQueryGenerator_Sphere::DistanceInSameDirection' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Sphere, OuterRange) == 0x0000A0, "Member 'UEnvQueryGenerator_Sphere::OuterRange' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Sphere, InnerRange) == 0x0000E0, "Member 'UEnvQueryGenerator_Sphere::InnerRange' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Sphere, AngleStep) == 0x000120, "Member 'UEnvQueryGenerator_Sphere::AngleStep' has a wrong offset!");

// Class MarvelAI.EnvQueryGenerator_SVONSphere
// 0x0000 (0x0160 - 0x0160)
class UEnvQueryGenerator_SVONSphere final : public UEnvQueryGenerator_Sphere
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_SVONSphere">();
	}
	static class UEnvQueryGenerator_SVONSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_SVONSphere>();
	}
};
static_assert(alignof(UEnvQueryGenerator_SVONSphere) == 0x000008, "Wrong alignment on UEnvQueryGenerator_SVONSphere");
static_assert(sizeof(UEnvQueryGenerator_SVONSphere) == 0x000160, "Wrong size on UEnvQueryGenerator_SVONSphere");

// Class MarvelAI.EnvQueryTest_AllyShield
// 0x0048 (0x02C8 - 0x0280)
class UEnvQueryTest_AllyShield final : public UEnvQueryTest
{
public:
	struct FAIDataProviderBoolValue               EnableThisTest;                                    // 0x0280(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         ShieldValidDistance;                               // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_AllyShield">();
	}
	static class UEnvQueryTest_AllyShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_AllyShield>();
	}
};
static_assert(alignof(UEnvQueryTest_AllyShield) == 0x000008, "Wrong alignment on UEnvQueryTest_AllyShield");
static_assert(sizeof(UEnvQueryTest_AllyShield) == 0x0002C8, "Wrong size on UEnvQueryTest_AllyShield");
static_assert(offsetof(UEnvQueryTest_AllyShield, EnableThisTest) == 0x000280, "Member 'UEnvQueryTest_AllyShield::EnableThisTest' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_AllyShield, ShieldValidDistance) == 0x0002C0, "Member 'UEnvQueryTest_AllyShield::ShieldValidDistance' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_CheckGameplayTag
// 0x0078 (0x02F8 - 0x0280)
class UEnvQueryTest_CheckGameplayTag final : public UMarvelEnvQueryTest
{
public:
	struct FAITagMatchParameter                   GamePlayParameter;                                 // 0x0280(0x0070)(Edit, NativeAccessSpecifierPublic)
	EAIFilterSide                                 Side;                                              // 0x02F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_CheckGameplayTag">();
	}
	static class UEnvQueryTest_CheckGameplayTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_CheckGameplayTag>();
	}
};
static_assert(alignof(UEnvQueryTest_CheckGameplayTag) == 0x000008, "Wrong alignment on UEnvQueryTest_CheckGameplayTag");
static_assert(sizeof(UEnvQueryTest_CheckGameplayTag) == 0x0002F8, "Wrong size on UEnvQueryTest_CheckGameplayTag");
static_assert(offsetof(UEnvQueryTest_CheckGameplayTag, GamePlayParameter) == 0x000280, "Member 'UEnvQueryTest_CheckGameplayTag::GamePlayParameter' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_CheckGameplayTag, Side) == 0x0002F0, "Member 'UEnvQueryTest_CheckGameplayTag::Side' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_EffectByGroup
// 0x0050 (0x02D0 - 0x0280)
class UEnvQueryTest_EffectByGroup final : public UEnvQueryTest
{
public:
	struct FAIDataProviderBoolValue               EnableThisTest;                                    // 0x0280(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           TargetGroup;                                       // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxEffectDistance;                                 // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_EffectByGroup">();
	}
	static class UEnvQueryTest_EffectByGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_EffectByGroup>();
	}
};
static_assert(alignof(UEnvQueryTest_EffectByGroup) == 0x000008, "Wrong alignment on UEnvQueryTest_EffectByGroup");
static_assert(sizeof(UEnvQueryTest_EffectByGroup) == 0x0002D0, "Wrong size on UEnvQueryTest_EffectByGroup");
static_assert(offsetof(UEnvQueryTest_EffectByGroup, EnableThisTest) == 0x000280, "Member 'UEnvQueryTest_EffectByGroup::EnableThisTest' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_EffectByGroup, TargetGroup) == 0x0002C0, "Member 'UEnvQueryTest_EffectByGroup::TargetGroup' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_EffectByGroup, MaxEffectDistance) == 0x0002C8, "Member 'UEnvQueryTest_EffectByGroup::MaxEffectDistance' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_FireLine
// 0x00C0 (0x0340 - 0x0280)
class UEnvQueryTest_FireLine final : public UEnvQueryTest
{
public:
	struct FAIDataProviderFloatValue              MaxDistanceToFireLine;                             // 0x0280(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              MaxFireLineLen;                                    // 0x02C0(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              FireLineWidth;                                     // 0x0300(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_FireLine">();
	}
	static class UEnvQueryTest_FireLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_FireLine>();
	}
};
static_assert(alignof(UEnvQueryTest_FireLine) == 0x000008, "Wrong alignment on UEnvQueryTest_FireLine");
static_assert(sizeof(UEnvQueryTest_FireLine) == 0x000340, "Wrong size on UEnvQueryTest_FireLine");
static_assert(offsetof(UEnvQueryTest_FireLine, MaxDistanceToFireLine) == 0x000280, "Member 'UEnvQueryTest_FireLine::MaxDistanceToFireLine' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_FireLine, MaxFireLineLen) == 0x0002C0, "Member 'UEnvQueryTest_FireLine::MaxFireLineLen' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_FireLine, FireLineWidth) == 0x000300, "Member 'UEnvQueryTest_FireLine::FireLineWidth' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_KeepDistance
// 0x0010 (0x0290 - 0x0280)
class UEnvQueryTest_KeepDistance : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           TargetsContext;                                    // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_KeepDistance">();
	}
	static class UEnvQueryTest_KeepDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_KeepDistance>();
	}
};
static_assert(alignof(UEnvQueryTest_KeepDistance) == 0x000008, "Wrong alignment on UEnvQueryTest_KeepDistance");
static_assert(sizeof(UEnvQueryTest_KeepDistance) == 0x000290, "Wrong size on UEnvQueryTest_KeepDistance");
static_assert(offsetof(UEnvQueryTest_KeepDistance, TargetsContext) == 0x000280, "Member 'UEnvQueryTest_KeepDistance::TargetsContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_KeepDistance, Tolerance) == 0x000288, "Member 'UEnvQueryTest_KeepDistance::Tolerance' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_ProjectilePath
// 0x0058 (0x02D8 - 0x0280)
class UEnvQueryTest_ProjectilePath final : public UMarvelEnvQueryTest
{
public:
	TSet<struct FEnvQueryProjectileInfo>          ProjectileInfos;                                   // 0x0280(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bAddCharHeight;                                    // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_ProjectilePath">();
	}
	static class UEnvQueryTest_ProjectilePath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_ProjectilePath>();
	}
};
static_assert(alignof(UEnvQueryTest_ProjectilePath) == 0x000008, "Wrong alignment on UEnvQueryTest_ProjectilePath");
static_assert(sizeof(UEnvQueryTest_ProjectilePath) == 0x0002D8, "Wrong size on UEnvQueryTest_ProjectilePath");
static_assert(offsetof(UEnvQueryTest_ProjectilePath, ProjectileInfos) == 0x000280, "Member 'UEnvQueryTest_ProjectilePath::ProjectileInfos' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ProjectilePath, bAddCharHeight) == 0x0002D0, "Member 'UEnvQueryTest_ProjectilePath::bAddCharHeight' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_RelativeGroundHeight
// 0x0010 (0x0290 - 0x0280)
class UEnvQueryTest_RelativeGroundHeight : public UEnvQueryTest
{
public:
	class UCurveFloat*                            DamageScoreCurve;                                  // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bConsiderDestructible;                             // 0x0288(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bConsiderSceneSummoned;                            // 0x0289(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28A[0x2];                                      // 0x028A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxGroundSlope;                                    // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_RelativeGroundHeight">();
	}
	static class UEnvQueryTest_RelativeGroundHeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_RelativeGroundHeight>();
	}
};
static_assert(alignof(UEnvQueryTest_RelativeGroundHeight) == 0x000008, "Wrong alignment on UEnvQueryTest_RelativeGroundHeight");
static_assert(sizeof(UEnvQueryTest_RelativeGroundHeight) == 0x000290, "Wrong size on UEnvQueryTest_RelativeGroundHeight");
static_assert(offsetof(UEnvQueryTest_RelativeGroundHeight, DamageScoreCurve) == 0x000280, "Member 'UEnvQueryTest_RelativeGroundHeight::DamageScoreCurve' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_RelativeGroundHeight, bConsiderDestructible) == 0x000288, "Member 'UEnvQueryTest_RelativeGroundHeight::bConsiderDestructible' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_RelativeGroundHeight, bConsiderSceneSummoned) == 0x000289, "Member 'UEnvQueryTest_RelativeGroundHeight::bConsiderSceneSummoned' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_RelativeGroundHeight, MaxGroundSlope) == 0x00028C, "Member 'UEnvQueryTest_RelativeGroundHeight::MaxGroundSlope' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_ShelterHeightCover
// 0x0000 (0x0280 - 0x0280)
class UEnvQueryTest_ShelterHeightCover final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_ShelterHeightCover">();
	}
	static class UEnvQueryTest_ShelterHeightCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_ShelterHeightCover>();
	}
};
static_assert(alignof(UEnvQueryTest_ShelterHeightCover) == 0x000008, "Wrong alignment on UEnvQueryTest_ShelterHeightCover");
static_assert(sizeof(UEnvQueryTest_ShelterHeightCover) == 0x000280, "Wrong size on UEnvQueryTest_ShelterHeightCover");

// Class MarvelAI.EnvQueryTest_ShelterTrace
// 0x00B0 (0x0440 - 0x0390)
class UEnvQueryTest_ShelterTrace final : public UEnvQueryTest_Trace
{
public:
	struct FAIDataProviderFloatValue              MaxTraceDist;                                      // 0x0390(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseCacheResult;                                   // 0x03D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ValidSecondsForCache;                              // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           ImportantTargetsContext;                           // 0x03D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseScore;                                         // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalScoreForImportant;                       // 0x03E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWantsHitAsResult;                                 // 0x03E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x57];                                     // 0x03E9(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_ShelterTrace">();
	}
	static class UEnvQueryTest_ShelterTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_ShelterTrace>();
	}
};
static_assert(alignof(UEnvQueryTest_ShelterTrace) == 0x000008, "Wrong alignment on UEnvQueryTest_ShelterTrace");
static_assert(sizeof(UEnvQueryTest_ShelterTrace) == 0x000440, "Wrong size on UEnvQueryTest_ShelterTrace");
static_assert(offsetof(UEnvQueryTest_ShelterTrace, MaxTraceDist) == 0x000390, "Member 'UEnvQueryTest_ShelterTrace::MaxTraceDist' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ShelterTrace, bUseCacheResult) == 0x0003D0, "Member 'UEnvQueryTest_ShelterTrace::bUseCacheResult' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ShelterTrace, ValidSecondsForCache) == 0x0003D4, "Member 'UEnvQueryTest_ShelterTrace::ValidSecondsForCache' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ShelterTrace, ImportantTargetsContext) == 0x0003D8, "Member 'UEnvQueryTest_ShelterTrace::ImportantTargetsContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ShelterTrace, BaseScore) == 0x0003E0, "Member 'UEnvQueryTest_ShelterTrace::BaseScore' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ShelterTrace, AdditionalScoreForImportant) == 0x0003E4, "Member 'UEnvQueryTest_ShelterTrace::AdditionalScoreForImportant' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ShelterTrace, bWantsHitAsResult) == 0x0003E8, "Member 'UEnvQueryTest_ShelterTrace::bWantsHitAsResult' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_SurroundedCharacter
// 0x0010 (0x0290 - 0x0280)
class UEnvQueryTest_SurroundedCharacter : public UEnvQueryTest
{
public:
	TArray<struct FEQSTargetConfig>               TargetGroups;                                      // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_SurroundedCharacter">();
	}
	static class UEnvQueryTest_SurroundedCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_SurroundedCharacter>();
	}
};
static_assert(alignof(UEnvQueryTest_SurroundedCharacter) == 0x000008, "Wrong alignment on UEnvQueryTest_SurroundedCharacter");
static_assert(sizeof(UEnvQueryTest_SurroundedCharacter) == 0x000290, "Wrong size on UEnvQueryTest_SurroundedCharacter");
static_assert(offsetof(UEnvQueryTest_SurroundedCharacter, TargetGroups) == 0x000280, "Member 'UEnvQueryTest_SurroundedCharacter::TargetGroups' has a wrong offset!");

// Class MarvelAI.EnvQueryTest_SVONReachable
// 0x0008 (0x0288 - 0x0280)
class UEnvQueryTest_SVONReachable final : public UEnvQueryTest
{
public:
	int32                                         NumIteration;                                      // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_SVONReachable">();
	}
	static class UEnvQueryTest_SVONReachable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_SVONReachable>();
	}
};
static_assert(alignof(UEnvQueryTest_SVONReachable) == 0x000008, "Wrong alignment on UEnvQueryTest_SVONReachable");
static_assert(sizeof(UEnvQueryTest_SVONReachable) == 0x000288, "Wrong size on UEnvQueryTest_SVONReachable");
static_assert(offsetof(UEnvQueryTest_SVONReachable, NumIteration) == 0x000280, "Member 'UEnvQueryTest_SVONReachable::NumIteration' has a wrong offset!");

// Class MarvelAI.MarvelAIAssetLibrary
// 0x0000 (0x0030 - 0x0030)
class UMarvelAIAssetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIAssetLibrary">();
	}
	static class UMarvelAIAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIAssetLibrary>();
	}
};
static_assert(alignof(UMarvelAIAssetLibrary) == 0x000008, "Wrong alignment on UMarvelAIAssetLibrary");
static_assert(sizeof(UMarvelAIAssetLibrary) == 0x000030, "Wrong size on UMarvelAIAssetLibrary");

// Class MarvelAI.MarvelAIAutoAbilityGlobalConfig
// 0x0058 (0x0090 - 0x0038)
class UMarvelAIAutoAbilityGlobalConfig final : public UPrimaryDataAsset
{
public:
	TMap<EAbilityEffectPriority, struct FAbilityUsagePriorityConfig> UsageTypeBasePriorityConfig;                       // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         ComboUsageExtraPriority;                           // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseNewPriorityCalculation;                        // 0x008C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIAutoAbilityGlobalConfig">();
	}
	static class UMarvelAIAutoAbilityGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIAutoAbilityGlobalConfig>();
	}
};
static_assert(alignof(UMarvelAIAutoAbilityGlobalConfig) == 0x000008, "Wrong alignment on UMarvelAIAutoAbilityGlobalConfig");
static_assert(sizeof(UMarvelAIAutoAbilityGlobalConfig) == 0x000090, "Wrong size on UMarvelAIAutoAbilityGlobalConfig");
static_assert(offsetof(UMarvelAIAutoAbilityGlobalConfig, UsageTypeBasePriorityConfig) == 0x000038, "Member 'UMarvelAIAutoAbilityGlobalConfig::UsageTypeBasePriorityConfig' has a wrong offset!");
static_assert(offsetof(UMarvelAIAutoAbilityGlobalConfig, ComboUsageExtraPriority) == 0x000088, "Member 'UMarvelAIAutoAbilityGlobalConfig::ComboUsageExtraPriority' has a wrong offset!");
static_assert(offsetof(UMarvelAIAutoAbilityGlobalConfig, bUseNewPriorityCalculation) == 0x00008C, "Member 'UMarvelAIAutoAbilityGlobalConfig::bUseNewPriorityCalculation' has a wrong offset!");

// Class MarvelAI.AIAbilityActivationExtraConfig
// 0x0010 (0x0040 - 0x0030)
class UAIAbilityActivationExtraConfig : public UObject
{
public:
	class FString                                 ConfigName;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FString GetConfigName();
	void InitExtraConfig(class UObject* AIOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAbilityActivationExtraConfig">();
	}
	static class UAIAbilityActivationExtraConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAbilityActivationExtraConfig>();
	}
};
static_assert(alignof(UAIAbilityActivationExtraConfig) == 0x000008, "Wrong alignment on UAIAbilityActivationExtraConfig");
static_assert(sizeof(UAIAbilityActivationExtraConfig) == 0x000040, "Wrong size on UAIAbilityActivationExtraConfig");
static_assert(offsetof(UAIAbilityActivationExtraConfig, ConfigName) == 0x000030, "Member 'UAIAbilityActivationExtraConfig::ConfigName' has a wrong offset!");

// Class MarvelAI.AbilityCheckInfoAsset
// 0x0190 (0x01C8 - 0x0038)
class UAbilityCheckInfoAsset final : public UPrimaryDataAsset
{
public:
	struct FAIAbilityCheckInfo                    CheckInfo;                                         // 0x0038(0x0190)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityCheckInfoAsset">();
	}
	static class UAbilityCheckInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityCheckInfoAsset>();
	}
};
static_assert(alignof(UAbilityCheckInfoAsset) == 0x000008, "Wrong alignment on UAbilityCheckInfoAsset");
static_assert(sizeof(UAbilityCheckInfoAsset) == 0x0001C8, "Wrong size on UAbilityCheckInfoAsset");
static_assert(offsetof(UAbilityCheckInfoAsset, CheckInfo) == 0x000038, "Member 'UAbilityCheckInfoAsset::CheckInfo' has a wrong offset!");

// Class MarvelAI.MarvelAIController
// 0x0390 (0x0A30 - 0x06A0)
class AMarvelAIController : public AMarvelAIControllerBase
{
public:
	TMap<TWeakObjectPtr<class AActor>, struct FDateTime> DamageSourceRecord;                                // 0x06A0(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UClass*                                 AbilityTacticClass;                                // 0x06F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F8[0x18];                                     // 0x06F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          OldBehaviorTree;                                   // 0x0710(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FocalOffsetOnActor;                                // 0x0718(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            QA_ChangeHeroEnergyAttribute;                      // 0x0730(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableMyPawnAsFocusTarget;                       // 0x0738(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseSmoothRotationWhenFocusChange;                  // 0x0739(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateFocusSpeedWhenSet;                          // 0x073A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73B[0x5];                                      // 0x073B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              FocusSpeedRange;                                   // 0x0740(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentFocusSpeed;                                 // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusSpeedFactor;                                  // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableFocusUpdateDelay;                           // 0x0758(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_759[0x3];                                      // 0x0759(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotatorToleranceToRegardAsMatched;                 // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusUpdateDelayForPrevMatched;                    // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusUpdateDelayForUnMatched;                      // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_768[0x58];                                     // 0x0768(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UseAIAbilityServer;                                // 0x07C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C4[0x24];                                     // 0x07C4(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIControllerInfo*                      AIInfo;                                            // 0x07E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIAutoAbilityComponent*                AutoAbilityComponent;                              // 0x07F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIMementoComponent*                    AIMementoComponent;                                // 0x07F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIAutoAbilitySolver*                   AbilitySolver;                                     // 0x0800(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIAbilityExecutorManagerComponent*     AbilityExecutorManagerComponent;                   // 0x0808(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAgentHandleCom*                  AbilityAgentComponent;                             // 0x0810(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_818[0x10];                                     // 0x0818(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAITask_MoveTo*                         TaskMoveTo;                                        // 0x0828(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_830[0x70];                                     // 0x0830(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           BlockBodyTurnTag;                                  // 0x08A0(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           BlockCameraLookUpTag;                              // 0x08AC(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           BlockCameraTurnTag;                                // 0x08B8(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C4[0x4];                                      // 0x08C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAIPerceptionComponent*           MarvelAIPerceptionComponent;                       // 0x08C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ReceiveSVONMoveRequestFailed;                      // 0x08D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ReceiveBehaviorTreeMoveTaskEnd;                    // 0x08E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnableUsageFocusClearDelay;                       // 0x08F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F1[0x3];                                      // 0x08F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UsageFocusClearDelay;                              // 0x08F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F8[0x80];                                     // 0x08F8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerInput*                           PlayerInput;                                       // 0x0978(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_980[0x19];                                     // 0x0980(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableAutoChangeHero;                             // 0x0999(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPreSelectHero;                               // 0x099A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99B[0x1D];                                     // 0x099B(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActiveGameplayEffectHandle            TreatApplyGEHandler;                               // 0x09B8(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurDynamicDifficultyFactor;                        // 0x09C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C4[0xC];                                      // 0x09C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastEnemyTarget;                                   // 0x09D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 LastAllyTarget;                                    // 0x09D8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9E0[0x40];                                     // 0x09E0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UAISenseConfig_Sight*                   SightConfig;                                       // 0x0A20(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A28[0x8];                                      // 0x0A28(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AllowPreSelectHeroDelay(float Delay);
	struct FActiveGameplayEffectHandle ApplyGameplayEffectToPawn(TSubclassOf<class UGameplayEffect> EffectClass, const struct FGameplayTag& DataTag, float CallerMagnitude, float Period, bool bUseControllerAsCauser);
	void CallInputAction(int32 AbilityID, class FName ActionName, bool bPressed);
	bool CanActivateAbility(int32 AbilityID);
	bool CheckInitAIDifficulty();
	void ClearBehaviorTreeFocus(float Delay);
	struct FVector GetCurrentMoveDirection();
	bool InitAIDifficulty(EAIDifficultyMode DifficultyMode, int32 DifficultyLevel);
	void InitDifficultyEffect(bool ForceInit);
	void InitSummonedForAI(class AActor* Source);
	bool IsInArea(TSubclassOf<class AAIActionArea> AreaClassType);
	bool IsInView(const class AActor* ToCheckTarget);
	bool IsTakingCure();
	void K2_ClearAllFocus();
	void K2_ClearFocusByPriority(uint8 FocusPriority);
	bool K2_GetAIDifficultyConfig(struct FMarvelAIDifficultyTable* OutDifficultyConfig);
	float K2_GetPriorityFactorInPerceptionComp(class AActor* TargetActor);
	bool K2_PauseCurrentMove();
	bool K2_ResumeCurrentMove();
	void K2_SetFocalPointByPriority(const struct FVector& NewFocus, uint8 FocusPriority);
	void K2_SetFocusByPriority(class AActor* NewFocus, uint8 FocusPriority);
	void K2_SetFocusByTarget(const struct FMarvelAITarget& Target, uint8 FocusPriority);
	void K2_StopMovement();
	void MarkAsTrainingTarget();
	void OnAIApplyFogEffect(const struct FGameplayTag& TagUpdated, bool TagExists);
	void OnAIChangeHero(class APawn* NewPawn);
	void OnAIMoveBlockTagUpdated(const struct FGameplayTag& TagUpdated, bool TagExists);
	void OnEnterArea(class AAIActionArea* NewArea);
	void OnExitArea(class AAIActionArea* OldArea);
	void OnPawnDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnPawnTakeDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnPostReplaceController(class AController* Old_controller);
	void OnPreReplaceController(class AController* New_controller);
	void OnResetBTFocusTarget();
	void OnSculptChanged(int32 SculptID);
	void OnSVONMoveRequestFailed();
	void OverrideJumpAbility(int32 NewJumpAbilityID);
	void ReceiveLoadHeroConfig();
	bool ResetBehaviorTree(class UBehaviorTree* BTAsset);
	void ResetFocalOffsetOnActor();
	void ResetTreatApplyToStatic();
	int32 SelectChangeHero(bool NeedChangeRole, bool AllowRepeatHero);
	void SetAbilityTacticClass(class UClass* AbilityTacticClass_0);
	void SetAIAbilityServer(int32 NewValue);
	void SetAIAnthropomorphic(bool bEnable);
	void SetDynamicDifficultyEnabled(bool Enable);
	void SetEnableAIProcessInput(bool Enable);
	void SetEnergyFull();
	void SetFocusOffsetOnActor(const struct FVector& Offset, bool IsInLocalCoordinate);
	void SetFocusSpeedFactor(const float NewFocusSpeedFactor);
	void SetIsTestAI(bool NewIsTestAI);
	void SetSVONPathFindingMethod(ESVONPathFindingMethod ModeMethod);
	bool SetTestAttributeRatio(float NewRatio);
	void SetUsePreciseReachLogic(bool UsePrecise);
	EPathFollowingRequestResult SvonMoveToLocation(const struct FVector& Dest, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, bool bProjectDestinationToNavigation, bool bCanStrafe, TSubclassOf<class UNavigationQueryFilter> FilterClass, bool bAllowPartialPath);
	void TriggerAbilityLocalInput(int32 InputID, int32 AbilityID, bool bIsPressed);
	void TriggerPawnAbilityInputBinding(int32 InputID, int32 AbilityID, bool IsPressed);
	void TriggerPawnLocalInputBind(int32 InputID, bool IsConfirmed);
	bool TryActivateAbilityWithID(int32 AbilityID, bool UseInputPressed, struct FGameplayAbilitySpecHandle* OutHandle);
	bool TryEndAbility(const struct FGameplayAbilitySpecHandle& SpecHandle, bool UseInputRelease);
	bool TryGetActionArea(TSubclassOf<class AAIActionArea> AreaClassType, class AAIActionArea** OutArea);
	bool UpdateAIDifficulty(EAIDifficultyMode DifficultyMode, int32 DifficultyLevel);
	bool UpdateAILevel();
	void UpdateMoveBlockFlag(bool bAdd);
	void UpdatePreviewHeroID(int32 NewHeroID, bool Immediate);

	bool CanChangeSelectedHero(bool* OutNeedChangeRole, bool OnlyCheckForLineup) const;
	int32 GetAIAbilityServer() const;
	bool GetAIAnthropomorphic() const;
	class UAIControllerInfo* GetAIInfo() const;
	class UMarvelBehaviorTreeComponent* GetBehaviorTreeComp() const;
	class FString GetCurrentTreeName() const;
	float GetDynamicTreatApplyMagnitude(float DynamicDifficultyFactor) const;
	bool GetEnableAIProcessInput() const;
	bool GetHasMeetEnemy() const;
	bool GetHeroBTConfig(struct FMarvelHeroBehaviorTreeTable* OutHeroBTConfig) const;
	bool GetIsTestAI() const;
	class UMarvelAIPerceptionComponent* GetMarvelAIPerceptionComp() const;
	class UMarvelGameplayAbility* GetPawnAbilityByID(int32 AbilityID) const;
	int32 GetPawnAbilityIdByInputBind(const EAbilityInputBinds InputBind) const;
	EHeroRole GetPawnHeroRole() const;
	float GetRotateSpeed() const;
	float GetTestAttributeRatio() const;
	void GetTestAttributeValues(TMap<class FString, float>* OutAttributesList) const;
	bool GetUsePreciseReachLogic() const;
	bool IsAlreadyRequestAsyncPathFinding() const;
	bool IsDynamicDifficultyEnabled() const;
	bool IsMoveBlocked() const;
	bool IsTakingDamage() const;
	bool IsTakingDamageByTarget(const class AActor* ToCheckTarget) const;
	bool IsTrainingTarget() const;
	void K2_GetCurrentFocusAsAITarget(struct FMarvelAITarget* OutTarget) const;
	bool K2_GetHeroBattleConfig(struct FAIBattleConfig* OutBattleConfig) const;
	void OverrideSightRadius(const float NewRadius) const;
	void StoreAutoChangeHeroDebugInfo(int32 UID, EAIChangeHeroReason ChangeReason, bool ChangeResult, float Curve_Energy, int32 ChangeCD, float Curve_KD) const;
	bool TryActivatePawnAbilityByID(int32 AbilityID) const;
	bool TryActivatePawnAbilityByInputBind(EAbilityInputBinds InputBind) const;
	bool TryActivatePawnNormalJump() const;
	bool TryCancelPawnAbilityByID(int32 AbilityID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIController">();
	}
	static class AMarvelAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelAIController>();
	}
};
static_assert(alignof(AMarvelAIController) == 0x000008, "Wrong alignment on AMarvelAIController");
static_assert(sizeof(AMarvelAIController) == 0x000A30, "Wrong size on AMarvelAIController");
static_assert(offsetof(AMarvelAIController, DamageSourceRecord) == 0x0006A0, "Member 'AMarvelAIController::DamageSourceRecord' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, AbilityTacticClass) == 0x0006F0, "Member 'AMarvelAIController::AbilityTacticClass' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, OldBehaviorTree) == 0x000710, "Member 'AMarvelAIController::OldBehaviorTree' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, FocalOffsetOnActor) == 0x000718, "Member 'AMarvelAIController::FocalOffsetOnActor' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, QA_ChangeHeroEnergyAttribute) == 0x000730, "Member 'AMarvelAIController::QA_ChangeHeroEnergyAttribute' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, bDisableMyPawnAsFocusTarget) == 0x000738, "Member 'AMarvelAIController::bDisableMyPawnAsFocusTarget' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, UseSmoothRotationWhenFocusChange) == 0x000739, "Member 'AMarvelAIController::UseSmoothRotationWhenFocusChange' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, bUpdateFocusSpeedWhenSet) == 0x00073A, "Member 'AMarvelAIController::bUpdateFocusSpeedWhenSet' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, FocusSpeedRange) == 0x000740, "Member 'AMarvelAIController::FocusSpeedRange' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, CurrentFocusSpeed) == 0x000750, "Member 'AMarvelAIController::CurrentFocusSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, FocusSpeedFactor) == 0x000754, "Member 'AMarvelAIController::FocusSpeedFactor' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, bEnableFocusUpdateDelay) == 0x000758, "Member 'AMarvelAIController::bEnableFocusUpdateDelay' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, RotatorToleranceToRegardAsMatched) == 0x00075C, "Member 'AMarvelAIController::RotatorToleranceToRegardAsMatched' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, FocusUpdateDelayForPrevMatched) == 0x000760, "Member 'AMarvelAIController::FocusUpdateDelayForPrevMatched' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, FocusUpdateDelayForUnMatched) == 0x000764, "Member 'AMarvelAIController::FocusUpdateDelayForUnMatched' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, UseAIAbilityServer) == 0x0007C0, "Member 'AMarvelAIController::UseAIAbilityServer' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, AIInfo) == 0x0007E8, "Member 'AMarvelAIController::AIInfo' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, AutoAbilityComponent) == 0x0007F0, "Member 'AMarvelAIController::AutoAbilityComponent' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, AIMementoComponent) == 0x0007F8, "Member 'AMarvelAIController::AIMementoComponent' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, AbilitySolver) == 0x000800, "Member 'AMarvelAIController::AbilitySolver' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, AbilityExecutorManagerComponent) == 0x000808, "Member 'AMarvelAIController::AbilityExecutorManagerComponent' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, AbilityAgentComponent) == 0x000810, "Member 'AMarvelAIController::AbilityAgentComponent' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, TaskMoveTo) == 0x000828, "Member 'AMarvelAIController::TaskMoveTo' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, BlockBodyTurnTag) == 0x0008A0, "Member 'AMarvelAIController::BlockBodyTurnTag' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, BlockCameraLookUpTag) == 0x0008AC, "Member 'AMarvelAIController::BlockCameraLookUpTag' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, BlockCameraTurnTag) == 0x0008B8, "Member 'AMarvelAIController::BlockCameraTurnTag' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, MarvelAIPerceptionComponent) == 0x0008C8, "Member 'AMarvelAIController::MarvelAIPerceptionComponent' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, ReceiveSVONMoveRequestFailed) == 0x0008D0, "Member 'AMarvelAIController::ReceiveSVONMoveRequestFailed' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, ReceiveBehaviorTreeMoveTaskEnd) == 0x0008E0, "Member 'AMarvelAIController::ReceiveBehaviorTreeMoveTaskEnd' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, bEnableUsageFocusClearDelay) == 0x0008F0, "Member 'AMarvelAIController::bEnableUsageFocusClearDelay' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, UsageFocusClearDelay) == 0x0008F4, "Member 'AMarvelAIController::UsageFocusClearDelay' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, PlayerInput) == 0x000978, "Member 'AMarvelAIController::PlayerInput' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, bEnableAutoChangeHero) == 0x000999, "Member 'AMarvelAIController::bEnableAutoChangeHero' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, bAllowPreSelectHero) == 0x00099A, "Member 'AMarvelAIController::bAllowPreSelectHero' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, TreatApplyGEHandler) == 0x0009B8, "Member 'AMarvelAIController::TreatApplyGEHandler' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, CurDynamicDifficultyFactor) == 0x0009C0, "Member 'AMarvelAIController::CurDynamicDifficultyFactor' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, LastEnemyTarget) == 0x0009D0, "Member 'AMarvelAIController::LastEnemyTarget' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, LastAllyTarget) == 0x0009D8, "Member 'AMarvelAIController::LastAllyTarget' has a wrong offset!");
static_assert(offsetof(AMarvelAIController, SightConfig) == 0x000A20, "Member 'AMarvelAIController::SightConfig' has a wrong offset!");

// Class MarvelAI.MarvelAIDataProvider
// 0x0010 (0x0040 - 0x0030)
class UMarvelAIDataProvider : public UAIDataProvider
{
public:
	float                                         FloatValue;                                        // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IntValue;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BoolValue;                                         // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetBoolValue(const struct FAIDataProviderBoolValue& InProvider, const class UObject* Owner, int32 RequestID);
	static float GetFloatValue(const struct FAIDataProviderFloatValue& InProvider, const class UObject* Owner, int32 RequestID);
	static float GetFloatValue_Blueprint(const struct FAIDataProviderFloatValue& InProvider, const class UObject* Owner);
	static int32 GetIntValue(const struct FAIDataProviderIntValue& InProvider, const class UObject* Owner, int32 RequestID);
	static int32 GetIntValue_Blueprint(const struct FAIDataProviderIntValue& InProvider, const class UObject* Owner);

	void SetAllValue(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIDataProvider">();
	}
	static class UMarvelAIDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIDataProvider>();
	}
};
static_assert(alignof(UMarvelAIDataProvider) == 0x000008, "Wrong alignment on UMarvelAIDataProvider");
static_assert(sizeof(UMarvelAIDataProvider) == 0x000040, "Wrong size on UMarvelAIDataProvider");
static_assert(offsetof(UMarvelAIDataProvider, FloatValue) == 0x000030, "Member 'UMarvelAIDataProvider::FloatValue' has a wrong offset!");
static_assert(offsetof(UMarvelAIDataProvider, IntValue) == 0x000034, "Member 'UMarvelAIDataProvider::IntValue' has a wrong offset!");
static_assert(offsetof(UMarvelAIDataProvider, BoolValue) == 0x000038, "Member 'UMarvelAIDataProvider::BoolValue' has a wrong offset!");

// Class MarvelAI.MarvelAIDataProvider_AttackRange
// 0x0008 (0x0048 - 0x0040)
class UMarvelAIDataProvider_AttackRange final : public UMarvelAIDataProvider
{
public:
	float                                         ValueForRangeHero;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ValueForMeleeHero;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIDataProvider_AttackRange">();
	}
	static class UMarvelAIDataProvider_AttackRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIDataProvider_AttackRange>();
	}
};
static_assert(alignof(UMarvelAIDataProvider_AttackRange) == 0x000008, "Wrong alignment on UMarvelAIDataProvider_AttackRange");
static_assert(sizeof(UMarvelAIDataProvider_AttackRange) == 0x000048, "Wrong size on UMarvelAIDataProvider_AttackRange");
static_assert(offsetof(UMarvelAIDataProvider_AttackRange, ValueForRangeHero) == 0x000040, "Member 'UMarvelAIDataProvider_AttackRange::ValueForRangeHero' has a wrong offset!");
static_assert(offsetof(UMarvelAIDataProvider_AttackRange, ValueForMeleeHero) == 0x000044, "Member 'UMarvelAIDataProvider_AttackRange::ValueForMeleeHero' has a wrong offset!");

// Class MarvelAI.MarvelAIDataProvider_BattleDist
// 0x0008 (0x0048 - 0x0040)
class UMarvelAIDataProvider_BattleDist final : public UMarvelAIDataProvider
{
public:
	bool                                          bUseWiderDistance;                                 // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIDataProvider_BattleDist">();
	}
	static class UMarvelAIDataProvider_BattleDist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIDataProvider_BattleDist>();
	}
};
static_assert(alignof(UMarvelAIDataProvider_BattleDist) == 0x000008, "Wrong alignment on UMarvelAIDataProvider_BattleDist");
static_assert(sizeof(UMarvelAIDataProvider_BattleDist) == 0x000048, "Wrong size on UMarvelAIDataProvider_BattleDist");
static_assert(offsetof(UMarvelAIDataProvider_BattleDist, bUseWiderDistance) == 0x000040, "Member 'UMarvelAIDataProvider_BattleDist::bUseWiderDistance' has a wrong offset!");

// Class MarvelAI.MarvelAIDataProvider_PyBase
// 0x0000 (0x0040 - 0x0040)
class UMarvelAIDataProvider_PyBase final : public UMarvelAIDataProvider
{
public:
	bool PyBindData(const class UObject* Owner, int32 RequestID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIDataProvider_PyBase">();
	}
	static class UMarvelAIDataProvider_PyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIDataProvider_PyBase>();
	}
};
static_assert(alignof(UMarvelAIDataProvider_PyBase) == 0x000008, "Wrong alignment on UMarvelAIDataProvider_PyBase");
static_assert(sizeof(UMarvelAIDataProvider_PyBase) == 0x000040, "Wrong size on UMarvelAIDataProvider_PyBase");

// Class MarvelAI.MarvelAIDataProvider_StandPointRange
// 0x0000 (0x0040 - 0x0040)
class UMarvelAIDataProvider_StandPointRange final : public UMarvelAIDataProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIDataProvider_StandPointRange">();
	}
	static class UMarvelAIDataProvider_StandPointRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIDataProvider_StandPointRange>();
	}
};
static_assert(alignof(UMarvelAIDataProvider_StandPointRange) == 0x000008, "Wrong alignment on UMarvelAIDataProvider_StandPointRange");
static_assert(sizeof(UMarvelAIDataProvider_StandPointRange) == 0x000040, "Wrong size on UMarvelAIDataProvider_StandPointRange");

// Class MarvelAI.MarvelAIDifficultyGlobalConfig
// 0x0020 (0x0058 - 0x0038)
class UMarvelAIDifficultyGlobalConfig final : public UPrimaryDataAsset
{
public:
	TSubclassOf<class UGameplayEffect>            GE_AI_DamageTarget;                                // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GE_AI_DamageSource;                                // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GE_AI_TreatTarget;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GE_AI_TreatSource;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIDifficultyGlobalConfig">();
	}
	static class UMarvelAIDifficultyGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIDifficultyGlobalConfig>();
	}
};
static_assert(alignof(UMarvelAIDifficultyGlobalConfig) == 0x000008, "Wrong alignment on UMarvelAIDifficultyGlobalConfig");
static_assert(sizeof(UMarvelAIDifficultyGlobalConfig) == 0x000058, "Wrong size on UMarvelAIDifficultyGlobalConfig");
static_assert(offsetof(UMarvelAIDifficultyGlobalConfig, GE_AI_DamageTarget) == 0x000038, "Member 'UMarvelAIDifficultyGlobalConfig::GE_AI_DamageTarget' has a wrong offset!");
static_assert(offsetof(UMarvelAIDifficultyGlobalConfig, GE_AI_DamageSource) == 0x000040, "Member 'UMarvelAIDifficultyGlobalConfig::GE_AI_DamageSource' has a wrong offset!");
static_assert(offsetof(UMarvelAIDifficultyGlobalConfig, GE_AI_TreatTarget) == 0x000048, "Member 'UMarvelAIDifficultyGlobalConfig::GE_AI_TreatTarget' has a wrong offset!");
static_assert(offsetof(UMarvelAIDifficultyGlobalConfig, GE_AI_TreatSource) == 0x000050, "Member 'UMarvelAIDifficultyGlobalConfig::GE_AI_TreatSource' has a wrong offset!");

// Class MarvelAI.AIDifficultyTableHelper
// 0x0000 (0x0030 - 0x0030)
class UAIDifficultyTableHelper final : public UBlueprintFunctionLibrary
{
public:
	static float GetAttributeValueForHero(const struct FAIDifficultyAttributeConfig& AttributeConfig, class AMarvelBaseCharacter* MarvelHero);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDifficultyTableHelper">();
	}
	static class UAIDifficultyTableHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDifficultyTableHelper>();
	}
};
static_assert(alignof(UAIDifficultyTableHelper) == 0x000008, "Wrong alignment on UAIDifficultyTableHelper");
static_assert(sizeof(UAIDifficultyTableHelper) == 0x000030, "Wrong size on UAIDifficultyTableHelper");

// Class MarvelAI.MarvelAIGameModeDefaultConfigAsset
// 0x00B8 (0x00F0 - 0x0038)
class UMarvelAIGameModeDefaultConfigAsset final : public UAIGlobalConfigAsset
{
public:
	TMap<struct FGameplayTag, struct FAIGameModeConfig> AIGameModeConfigMap;                               // 0x0038(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnablePersonificationAIForDDA;                    // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNormalAIForDDA;                             // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDifficultyConfig                    DifficultyConfig;                                  // 0x008C(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIChangeHeroConfig                    ChangeHeroConfig;                                  // 0x0098(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          BackBaseBehaviorTree;                              // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          FollowBehaviorTree;                                // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          AIDelegateBehaviorTree;                            // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIGameModeDefaultConfigAsset">();
	}
	static class UMarvelAIGameModeDefaultConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIGameModeDefaultConfigAsset>();
	}
};
static_assert(alignof(UMarvelAIGameModeDefaultConfigAsset) == 0x000008, "Wrong alignment on UMarvelAIGameModeDefaultConfigAsset");
static_assert(sizeof(UMarvelAIGameModeDefaultConfigAsset) == 0x0000F0, "Wrong size on UMarvelAIGameModeDefaultConfigAsset");
static_assert(offsetof(UMarvelAIGameModeDefaultConfigAsset, AIGameModeConfigMap) == 0x000038, "Member 'UMarvelAIGameModeDefaultConfigAsset::AIGameModeConfigMap' has a wrong offset!");
static_assert(offsetof(UMarvelAIGameModeDefaultConfigAsset, bEnablePersonificationAIForDDA) == 0x000088, "Member 'UMarvelAIGameModeDefaultConfigAsset::bEnablePersonificationAIForDDA' has a wrong offset!");
static_assert(offsetof(UMarvelAIGameModeDefaultConfigAsset, bEnableNormalAIForDDA) == 0x000089, "Member 'UMarvelAIGameModeDefaultConfigAsset::bEnableNormalAIForDDA' has a wrong offset!");
static_assert(offsetof(UMarvelAIGameModeDefaultConfigAsset, DifficultyConfig) == 0x00008C, "Member 'UMarvelAIGameModeDefaultConfigAsset::DifficultyConfig' has a wrong offset!");
static_assert(offsetof(UMarvelAIGameModeDefaultConfigAsset, ChangeHeroConfig) == 0x000098, "Member 'UMarvelAIGameModeDefaultConfigAsset::ChangeHeroConfig' has a wrong offset!");
static_assert(offsetof(UMarvelAIGameModeDefaultConfigAsset, BackBaseBehaviorTree) == 0x0000D8, "Member 'UMarvelAIGameModeDefaultConfigAsset::BackBaseBehaviorTree' has a wrong offset!");
static_assert(offsetof(UMarvelAIGameModeDefaultConfigAsset, FollowBehaviorTree) == 0x0000E0, "Member 'UMarvelAIGameModeDefaultConfigAsset::FollowBehaviorTree' has a wrong offset!");
static_assert(offsetof(UMarvelAIGameModeDefaultConfigAsset, AIDelegateBehaviorTree) == 0x0000E8, "Member 'UMarvelAIGameModeDefaultConfigAsset::AIDelegateBehaviorTree' has a wrong offset!");

// Class MarvelAI.MarvelAIGlobalDataSubsystem
// 0x0148 (0x0190 - 0x0048)
class UMarvelAIGlobalDataSubsystem final : public UMarvelAIWorldSubsystem
{
public:
	TMap<TSubclassOf<class AActor>, struct FLevelStaticActorCache> LevelStaticActorCache;                             // 0x0048(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0xF8];                                      // 0x0098(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMarvelAIGlobalDataSubsystem* GetAIGlobalDataSubsystem(const class UObject* WorldContextObject);

	bool CheckExistLevelStaticActor(TSubclassOf<class AActor> ActorClass);
	int32 GetActorUID(const class AActor* Actor);
	void GetLevelStaticActors(TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors);
	void GetLevelStaticActorsWithTag(TSubclassOf<class AActor> ActorClass, const class FName& Tag, TArray<class AActor*>* OutActors);
	class APortalViewActor_Level* GetNearestPortal(const struct FVector& QueryLocation, const double LimitDistance);
	bool GetPositionProgress(const class AMarvelAIController* QueryAI, const class AMarvelBaseCharacter* TargetChar, float* PositionProgress);
	bool IsAIUsableHero_Static(const class UObject* WorldContextObject, int32 HeroID);
	void OnLevelPrepareStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIGlobalDataSubsystem">();
	}
	static class UMarvelAIGlobalDataSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIGlobalDataSubsystem>();
	}
};
static_assert(alignof(UMarvelAIGlobalDataSubsystem) == 0x000008, "Wrong alignment on UMarvelAIGlobalDataSubsystem");
static_assert(sizeof(UMarvelAIGlobalDataSubsystem) == 0x000190, "Wrong size on UMarvelAIGlobalDataSubsystem");
static_assert(offsetof(UMarvelAIGlobalDataSubsystem, LevelStaticActorCache) == 0x000048, "Member 'UMarvelAIGlobalDataSubsystem::LevelStaticActorCache' has a wrong offset!");

// Class MarvelAI.MarvelAILibrary
// 0x0000 (0x0030 - 0x0030)
class UMarvelAILibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateAbilityUsage(class AMarvelAIController* AIController, const struct FRequiredAIDataForAutoAbility& AutoAbilityContext, int32 UsageID, bool ImitateAILab);
	static class UInputRecordComponent* AddInputRecordToAI(class AMarvelAIController* AIController);
	static bool CanFindNavPathToLocation(class AController* Controller, const struct FVector& TargetLocation);
	static void ChangeGamePlayDebuggerNetUpdateFrequency(class UObject* WorldContextObject, bool UseHighFrequency);
	static void ChangeHero(class AMarvelAIController* AIController, const int32 HeroID, const struct FTransform& SpawnTransform);
	static bool CheckAbilityIsReady(class AMarvelAIController* MyController, int32 AbilityUsageID, bool bCheckCanUseNow);
	static bool CheckActorHasTag(const class AActor* TargetActor, const struct FGameplayTag& TagToCheck);
	static bool CheckAICharacterTag(const class AMarvelBaseCharacter* Character, const struct FAIHeroTag& Tags, EGameplayContainerMatchType MatchType);
	static bool CheckDashBarrierFree(class AMarvelBaseCharacter* AICharacter, class AMarvelAIController* AIController, float DashDistance);
	static bool CheckIsImportantTarget(const class AActor* Target);
	static bool CheckIsInStealth(const class AActor* TargetActor);
	static bool CheckIsRangeHero(const class AMarvelBaseCharacter* MarvelHero);
	static bool CheckLowHealthMarkValid(class AMarvelAIController* AIController, class AActor* Target);
	static bool CompareActorRelationWithFilter(const class AActor* FromActor, const class AActor* ToActor, EAIFilterSide Side);
	static bool CompareAIFilterSide(float A, float B, EMarvelArithmeticOperation ArithmeticOperation);
	static bool CompareOwnerShipTypeToAIFilterSide(class AAIController* Controller, EOwnershipType ShipType, EAIFilterSide Side);
	static EAIFilterSide ConvertOwnerShipTypeToAIFilterSide(class AMarvelAIController* Controller, EOwnershipType ShipType);
	static void DebugDrawPathPoints(class AActor* StartActor, const TArray<struct FVector>& PathPoints, float Duration, bool bDrawStartActor, const struct FColor& DrawColor, float Thickness);
	static bool DoesAIExistInGame(class UObject* WorldContextObject);
	static TArray<struct FVector> FindNavPathToLocation(class AController* Controller, const struct FVector& TargetLocation);
	static void ForceUpdateAllGCNavigationData(class UObject* WorldContextObject);
	static EPathFollowingRequestResult GeneralMoveToLocation(class AMarvelAIController* AIController, const struct FVector& DestLocation);
	static EPathFollowingRequestResult GeneralMoveToLocationAdvance(class AMarvelAIController* AIController, const struct FVector& DestLocation, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, bool bProjectDestinationToNavigation, bool bCanStrafe, TSubclassOf<class UNavigationQueryFilter> FilterClass, bool bAllowPartialPath);
	static EPathFollowingRequestResult GeneralMoveToStaticActor(class AMarvelAIController* AIController, class AActor* DestActor, float RandomRadius);
	static int32 GetAbilityIDByConfig(const struct FMarvelAIAutoAbilityTable& Data, const class AMarvelAIController* OwnerController);
	static int32 GetAbilityIDByUsage(const struct FAIAbilityUsage& AbilityUsage, class AMarvelAIController* OwnerController);
	static struct FMarvelAIAutoAbilityTable GetAIAutoAbilityConfig(int32 ID);
	static TArray<class AMarvelAIController*> GetAIByTag(class UObject* WorldContextObject, const struct FGameplayTag& GameplayTag);
	static int32 GetAICount(class AMarvelBaseCharacter* Character, EAIFilterSide FilterSide);
	static bool GetAIDifficultyConfigByModeAndLevel(EAIDifficultyMode DifficultyMode, int32 DifficultyLevel, struct FMarvelAIDifficultyTable* OutDifficultyConfig);
	static class UDataTable* GetAIHeroTable();
	static class UAILabConfigAsset* GetAILabConfigAsset();
	static float GetAISenseMaxAge(class AMarvelAIController* AIController, class UClass* AISenseClass);
	static class UAIVisualLoggerConfig* GetAIVisualLoggerConfig(const class UObject* WorldContext);
	static int32 GetAllAICount(class AMarvelBaseCharacter* Character);
	static float GetAmmoClip(class UMarvelAbilitySystemCom* AbilitySystemComponent, EAmmoClipType AmmoType);
	static int32 GetAndUpdatePreviewHeroIDForAI(class AMarvelPlayerState* PlayerState, bool ImmediatelyUpdate);
	static float GetBattleDistanceFromTable(class AMarvelAIController* Controller);
	static float GetBattleScoreOfActor(const class AActor* TargetActor);
	static bool GetCheckedHeroBehaviorTreeConfig(const class AMarvelBaseCharacter* MarvelHero, struct FMarvelHeroBehaviorTreeTable* OutConfigData);
	static bool GetCheckedHeroBehaviorTreeConfigByID(const int32 HeroID, const int32 SculptID, struct FMarvelHeroBehaviorTreeTable* OutConfigData);
	static int32 GetDefaultRequestServerIndex(const class AMarvelAIController* Controller);
	static int32 GetEnemyAICount(class AMarvelBaseCharacter* Character);
	static float GetEnergyProportionOfActor(const class AActor* ActorWithEnergy);
	static float GetHealthProportionOfActor(const class AActor* ActorWithHealth, int32 HealthBarTypeMask);
	static struct FMarvelHeroBehaviorTreeTable GetHeroBehaviorTreeConfig(const class AMarvelBaseCharacter* MarvelHero);
	static class UBehaviorTree* GetHeroGameModeBehaviorTree(class AMarvelAIController* Controller);
	static struct FVector GetInvalidLocation();
	static TArray<struct FMarvelAIStandPointGroupTable> GetMarvelAIStandPointGroupTables();
	static const struct FMarvelHeroAutoAITable GetMarvelHeroAutoAITable(int32 HeroID);
	static float GetMaxHealthPropertyOfActor(const class AActor* ActorWithHealth, int32 HealthBarTypeMask);
	static struct FVector GetNavNowSegmentEnd(class AAIController* Controller);
	static TArray<struct FVector> GetNavPathArray(class AAIController* Controller);
	static struct FVector GetNavPathEnd(class AAIController* Controller);
	static struct FVector GetNearestReachableLocation(class UObject* WorldContextObject, const struct FVector& QueryLocation, const struct FVector& SearchExtent);
	static float GetPathPointsLength(const TArray<struct FVector>& PathPoints);
	static float GetRandomJumpIntervalsScale(const struct FMarvelAIDifficultyTable& Table, float DynamicDifficultyFactor);
	static bool GetRandomLocationAroundLocation(const class UObject* WorldContext, const struct FVector& InLocation, struct FVector* OutLocation, float RandomRadius);
	static struct FVector GetRandomLocationInnerBoxArea(const class UBoxComponent* Area);
	static bool GetRandomLocationOnNavMesh(const class AActor* DestActor, struct FVector* OutLocation, float RandomRadius);
	static float GetRandomUpdatePreSelectHeroDelay(class UObject* WorldContextObject);
	static class AStandPointBase* GetStandPointByName(const class UObject* WorldContext, const class FName& PointName);
	static struct FVector GetTargetLocationForAI(const class AActor* TargetActor, class AActor* OptRequestedBy);
	static int32 GetTeammateAICount(class AMarvelBaseCharacter* Character);
	static void GetTeammateSummoned(class AMarvelAIController* AIController, int32 SummonedID, TArray<class AActor*>* OutSummonedComps);
	static bool IsAbilityActive(const class AMarvelBaseCharacter* Character, int32 AbilityID);
	static bool IsAILabEnabled(class UObject* WorldContextObject);
	static bool IsAIUsableHero(class UObject* WorldContextObject, int32 HeroID);
	static bool IsTargetSeenFromPortal(const class AMarvelAIController* QueryAI, const class AActor* Target);
	static bool IsValidAbilityUsage(const struct FAIAbilityUsage& AbilityUsage);
	static bool IsValidAIAutoAbilityConfig(const struct FMarvelAIAutoAbilityTable& Data);
	static bool IsValidHeroBehaviorTreeConfig(const struct FMarvelHeroBehaviorTreeTable& Data);
	static bool IsValidLocation(const struct FVector& LocationToCheck);
	static void LoadAndPlayRecord(class AMarvelAIController* AIController, const class FString& RecordName, EInputRecordPath RecordPath);
	static void MarkIfSelectTargetNodeUseSense(class AMarvelAIController* AIController, const class FString& NodeName, bool UseSense);
	static void PlayInputRecordByAI(class UObject* WorldContextObject, const struct FAISpawnParam& AISpawnParam, const class FString& RecordName, EInputRecordPath RecordPath, const bool DiscardLocationCorrection, const bool bLoopPlay);
	static void RemoveScoreModuleDebugData(class AMarvelAIController* AIController, class AActor* Target, const class FString& NodeName, const class FString& ModuleName, EAIScoreArea ScoreArea);
	static bool SetAIAbilityServer(const class UObject* WCO, int32 AbilityServerIndex);
	static void SetAIChangeHeroDebugInfo(class AMarvelAIController* AIController, EAIChangeHeroReason ChangeReason, bool ChangeResult, float Curve_Energy, int32 ChangeCD, float Curve_CD);
	static void SetAILabServerUrl(class UObject* WorldContextObject, const class FString& NewUrl, const class FString& Msg);
	static void SetTeamAIAbilityTactic(const class UObject* WorldContextObject, const TSet<int32>& TeamIDs, class UClass* AbilityTacticClass);
	static void SetTeamAIAbilityTacticClass(class UObject* WorldContextObject, EBattleSide BattleSide, class UClass* AbilityTacticClass);
	static bool ShouldUseFlyPath(class AActor* MovingActor);
	static bool SolveThreeSphereIntersections(const TArray<struct FVector>& Points, const TArray<float>& RadiusSq, TArray<struct FVector>* OutIntersections);
	static void StopInputRecordByAI(class UObject* WorldContextObject);
	static void StoreScoreModuleDebugData(class AMarvelAIController* AIController, class AActor* Target, const class FString& NodeName, const class FString& ModuleName, EAIScoreArea ScoreArea, float Score);
	static void StoreTargetFinalScoreForDebug(class AMarvelAIController* AIController, class AActor* Target, const class FString& NodeName, float FinalScore);
	static struct FVector TakeFlyLocationFromBox(class AActor* MovingActor, const class UBoxComponent* Area, int32 MaxAttemptTime);
	static struct FVector TakeTargetLocationForStaticActor(class AActor* MovingActor, class AActor* DestActor, float RandomRadius, bool UseNavAgent);
	static struct FVector TestRotateVector(const struct FVector& InVec, const struct FRotator& InRot);
	static void TryAddLowHealthMark(class AMarvelAIController* AIController, class AActor* Target);
	static bool UpdateAIGameModeConfigDataAsset(const class FString& DataExec);
	static bool UpdateAIHitRateDataAsset(const int32 DifficultyLevel, const class FString& DataExec);
	static void UpdateTeamDifficulty(class UObject* WorldContextObject, int32 TeamNum, float DifficultyLevel);
	static void UpdateTeamDynamicDifficulty(class UObject* WorldContextObject, int32 TeamID, float DynamicDifficultyFactor);
	static void VlogPathPoints(const class AActor* LogOwner, const TArray<struct FVector>& PathPoints);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAILibrary">();
	}
	static class UMarvelAILibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAILibrary>();
	}
};
static_assert(alignof(UMarvelAILibrary) == 0x000008, "Wrong alignment on UMarvelAILibrary");
static_assert(sizeof(UMarvelAILibrary) == 0x000030, "Wrong size on UMarvelAILibrary");

// Class MarvelAI.MarvelAIPerceptionComponent
// 0x00A8 (0x0288 - 0x01E0)
class UMarvelAIPerceptionComponent final : public UMarvelAIPerceptionComponentBase
{
public:
	float                                         AgeRatioForStealthTarget;                          // 0x01E0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E4[0xA4];                                     // 0x01E4(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_ConfigureSense(class UAISenseConfig* SenseConfig);
	void K2_NotifyTargetToTeam(class AActor* TargetActor, float NotifyRange, float NotifyStrength);
	void NotifyEnemyTarget(class AActor* TargetActor, float NotifyRange);

	void GetPerceivedActors(TSubclassOf<class UAISense> SenseClass, TArray<class AActor*>* OutActors) const;
	bool GetTargetTeleportTransform(const int32 TargetUID, struct FTransform* OutTeleportTransform) const;
	bool IsCurrentlyInSight(const class AActor* TargetToCheck) const;
	float K2_GetPriorityFactor(class AActor* Target) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIPerceptionComponent">();
	}
	static class UMarvelAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIPerceptionComponent>();
	}
};
static_assert(alignof(UMarvelAIPerceptionComponent) == 0x000008, "Wrong alignment on UMarvelAIPerceptionComponent");
static_assert(sizeof(UMarvelAIPerceptionComponent) == 0x000288, "Wrong size on UMarvelAIPerceptionComponent");
static_assert(offsetof(UMarvelAIPerceptionComponent, AgeRatioForStealthTarget) == 0x0001E0, "Member 'UMarvelAIPerceptionComponent::AgeRatioForStealthTarget' has a wrong offset!");

// Class MarvelAI.MarvelAISenseConfig_Team
// 0x0000 (0x0050 - 0x0050)
class UMarvelAISenseConfig_Team final : public UAISenseConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAISenseConfig_Team">();
	}
	static class UMarvelAISenseConfig_Team* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAISenseConfig_Team>();
	}
};
static_assert(alignof(UMarvelAISenseConfig_Team) == 0x000008, "Wrong alignment on UMarvelAISenseConfig_Team");
static_assert(sizeof(UMarvelAISenseConfig_Team) == 0x000050, "Wrong size on UMarvelAISenseConfig_Team");

// Class MarvelAI.MarvelAISense_Damage
// 0x0000 (0x0098 - 0x0098)
class UMarvelAISense_Damage final : public UAISense_Damage
{
public:
	static void MarvelReportDamageEvent(class UObject* WorldContextObject, class AActor* DamagedActor, class AActor* Instigator, float DamageAmount, const struct FVector& EventLocation, const struct FVector& HitLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAISense_Damage">();
	}
	static class UMarvelAISense_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAISense_Damage>();
	}
};
static_assert(alignof(UMarvelAISense_Damage) == 0x000008, "Wrong alignment on UMarvelAISense_Damage");
static_assert(sizeof(UMarvelAISense_Damage) == 0x000098, "Wrong size on UMarvelAISense_Damage");

// Class MarvelAI.MarvelAISense_DangerousTarget
// 0x0010 (0x0098 - 0x0088)
class UMarvelAISense_DangerousTarget final : public UAISense
{
public:
	TArray<struct FDangerousTargetAbilityEvent>   RegisteredEvents;                                  // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static void ReportAbilityEvent(class AActor* Source, class UGameplayAbility* Ability, EAbilitySenseNotify Notify);

	void EndAbility(class AActor* Source, int32 AbilityID, const class FString& SessionID, class UMarvelGameplayAbility* SourceAbility);
	void OnAbilityActivate(class AActor* Source, int32 AbilityID, const class FString& SessionID, class UMarvelGameplayAbility* SourceAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAISense_DangerousTarget">();
	}
	static class UMarvelAISense_DangerousTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAISense_DangerousTarget>();
	}
};
static_assert(alignof(UMarvelAISense_DangerousTarget) == 0x000008, "Wrong alignment on UMarvelAISense_DangerousTarget");
static_assert(sizeof(UMarvelAISense_DangerousTarget) == 0x000098, "Wrong size on UMarvelAISense_DangerousTarget");
static_assert(offsetof(UMarvelAISense_DangerousTarget, RegisteredEvents) == 0x000088, "Member 'UMarvelAISense_DangerousTarget::RegisteredEvents' has a wrong offset!");

// Class MarvelAI.MarvelAISense_Sight
// 0x0058 (0x0210 - 0x01B8)
class UMarvelAISense_Sight final : public UAISense_Sight
{
public:
	uint8                                         Pad_1B8[0x58];                                     // 0x01B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAISense_Sight">();
	}
	static class UMarvelAISense_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAISense_Sight>();
	}
};
static_assert(alignof(UMarvelAISense_Sight) == 0x000008, "Wrong alignment on UMarvelAISense_Sight");
static_assert(sizeof(UMarvelAISense_Sight) == 0x000210, "Wrong size on UMarvelAISense_Sight");

// Class MarvelAI.MarvelAISense_Team
// 0x0010 (0x0098 - 0x0088)
class UMarvelAISense_Team final : public UAISense
{
public:
	TArray<struct FMarvelAITeamEvent>             RegisteredEvents;                                  // 0x0088(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAISense_Team">();
	}
	static class UMarvelAISense_Team* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAISense_Team>();
	}
};
static_assert(alignof(UMarvelAISense_Team) == 0x000008, "Wrong alignment on UMarvelAISense_Team");
static_assert(sizeof(UMarvelAISense_Team) == 0x000098, "Wrong size on UMarvelAISense_Team");
static_assert(offsetof(UMarvelAISense_Team, RegisteredEvents) == 0x000088, "Member 'UMarvelAISense_Team::RegisteredEvents' has a wrong offset!");

// Class MarvelAI.MarvelAISettings
// 0x0258 (0x02A0 - 0x0048)
class UMarvelAISettings final : public UDeveloperSettings
{
public:
	struct FSoftClassPath                         AITeamManagerClass;                                // 0x0048(0x0028)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         WayPointManagerClass;                              // 0x0070(0x0028)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         StandPointManagerClass;                            // 0x0098(0x0028)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleAreaManagerClass;                            // 0x00C0(0x0028)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         StandPointRecorderClass;                           // 0x00E8(0x0028)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DifficultyConfig;                                  // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AutoAbilityConfig;                                 // 0x0138(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        QaAIGlobalConfig;                                  // 0x0160(0x0028)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GameModeDefaultConfig;                             // 0x0188(0x0028)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSoftObjectPath>   GlobalConfig;                                      // 0x01B0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<struct FSoftObjectPath>                  PreLoadSubBehaviorTrees;                           // 0x0200(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 DefaultAILabServerURLSetting;                      // 0x0250(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 X20_Inner_URL;                                     // 0x0260(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 X20_URL;                                           // 0x0270(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 X20Na_Inner_URL;                                   // 0x0280(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 X20Na_URL;                                         // 0x0290(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAISettings">();
	}
	static class UMarvelAISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAISettings>();
	}
};
static_assert(alignof(UMarvelAISettings) == 0x000008, "Wrong alignment on UMarvelAISettings");
static_assert(sizeof(UMarvelAISettings) == 0x0002A0, "Wrong size on UMarvelAISettings");
static_assert(offsetof(UMarvelAISettings, AITeamManagerClass) == 0x000048, "Member 'UMarvelAISettings::AITeamManagerClass' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, WayPointManagerClass) == 0x000070, "Member 'UMarvelAISettings::WayPointManagerClass' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, StandPointManagerClass) == 0x000098, "Member 'UMarvelAISettings::StandPointManagerClass' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, BattleAreaManagerClass) == 0x0000C0, "Member 'UMarvelAISettings::BattleAreaManagerClass' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, StandPointRecorderClass) == 0x0000E8, "Member 'UMarvelAISettings::StandPointRecorderClass' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, DifficultyConfig) == 0x000110, "Member 'UMarvelAISettings::DifficultyConfig' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, AutoAbilityConfig) == 0x000138, "Member 'UMarvelAISettings::AutoAbilityConfig' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, QaAIGlobalConfig) == 0x000160, "Member 'UMarvelAISettings::QaAIGlobalConfig' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, GameModeDefaultConfig) == 0x000188, "Member 'UMarvelAISettings::GameModeDefaultConfig' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, GlobalConfig) == 0x0001B0, "Member 'UMarvelAISettings::GlobalConfig' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, PreLoadSubBehaviorTrees) == 0x000200, "Member 'UMarvelAISettings::PreLoadSubBehaviorTrees' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, DefaultAILabServerURLSetting) == 0x000250, "Member 'UMarvelAISettings::DefaultAILabServerURLSetting' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, X20_Inner_URL) == 0x000260, "Member 'UMarvelAISettings::X20_Inner_URL' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, X20_URL) == 0x000270, "Member 'UMarvelAISettings::X20_URL' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, X20Na_Inner_URL) == 0x000280, "Member 'UMarvelAISettings::X20Na_Inner_URL' has a wrong offset!");
static_assert(offsetof(UMarvelAISettings, X20Na_URL) == 0x000290, "Member 'UMarvelAISettings::X20Na_URL' has a wrong offset!");

// Class MarvelAI.MarvelAIStimuliSourceComponent
// 0x0000 (0x0108 - 0x0108)
class UMarvelAIStimuliSourceComponent final : public UMarvelAIStimuliSourceComponentBase
{
public:
	void OnSummonedBeginAgent(class AActor* SummonerTarget);
	void OnSummonedEndAgent(class AActor* SummonerTarget);
	void WhenOwnerDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ParamHandle);
	void WhenOwnerReborn(class AActor* TargetActor, const struct FCharacterRebornParam& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAIStimuliSourceComponent">();
	}
	static class UMarvelAIStimuliSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAIStimuliSourceComponent>();
	}
};
static_assert(alignof(UMarvelAIStimuliSourceComponent) == 0x000008, "Wrong alignment on UMarvelAIStimuliSourceComponent");
static_assert(sizeof(UMarvelAIStimuliSourceComponent) == 0x000108, "Wrong size on UMarvelAIStimuliSourceComponent");

// Class MarvelAI.MarvelSummonerAIStimuliSourceComponent
// 0x0000 (0x0108 - 0x0108)
class UMarvelSummonerAIStimuliSourceComponent final : public UAIPerceptionStimuliSourceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelSummonerAIStimuliSourceComponent">();
	}
	static class UMarvelSummonerAIStimuliSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelSummonerAIStimuliSourceComponent>();
	}
};
static_assert(alignof(UMarvelSummonerAIStimuliSourceComponent) == 0x000008, "Wrong alignment on UMarvelSummonerAIStimuliSourceComponent");
static_assert(sizeof(UMarvelSummonerAIStimuliSourceComponent) == 0x000108, "Wrong size on UMarvelSummonerAIStimuliSourceComponent");

// Class MarvelAI.MarvelAISystem
// 0x00F0 (0x02C8 - 0x01D8)
class UMarvelAISystem : public UAISystem
{
public:
	class UMarvelAIGameModeDefaultConfigAsset*    AIGameModeConfig;                                  // 0x01D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelAITeamManager*                   AITeamManager;                                     // 0x01E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelWayPointManager*                 WayPointManager;                                   // 0x01E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAIStandPointManager*             StandPointManager;                                 // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAIBattleAreaManager*             BattleAreaManager;                                 // 0x01F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStandPointRecorder*                    StandPointRecorder;                                // 0x0200(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTacticsManager*                 AbilityTacticsManager;                             // 0x0208(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableNavLinkDynamicPostProcess;                  // 0x0210(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableShelterMove;                                // 0x0211(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateClientNavmeshBoundOnMapLoaded;              // 0x0212(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_213[0x1];                                      // 0x0213(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EAIAnthropomorphic                            AIAnthropomorphicType;                             // 0x0214(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_215[0x1];                                      // 0x0215(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableVisLogWhenServerStart;                      // 0x0216(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomVisLogFilename;                          // 0x0217(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class FName>                             CustomVisLogCategories;                            // 0x0218(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelAIController*>            AIControllers;                                     // 0x0268(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<int32, class AMarvelAIController*>       AIControllerMap;                                   // 0x0278(0x0050)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)

public:
	static class UAbilityTacticsManager* GetAbilityTacticsManager(const class UObject* WorldContextObject);
	static class AMarvelAITeamManager* GetAITeamManager(const class UObject* WorldContextObject);
	static const class UMarvelAIAutoAbilityGlobalConfig* GetAutoAbilityGlobalConfig(const class UObject* WorldContextObject);
	static class UMarvelAIBattleAreaManager* GetBattleAreaManager(const class UObject* WorldContextObject);
	static const class UMarvelAIDifficultyGlobalConfig* GetDifficultyGlobalConfig(const class UObject* WorldContextObject);
	static class UMarvelAISystem* GetMarvelAISystem(const class UObject* WorldContextObject);
	static const class UQA_AIGlobalConfig* GetQaAIGlobalConfig(const class UObject* WorldContextObject);
	static class UMarvelAIStandPointManager* GetStandPointManager(const class UObject* WorldContextObject);
	static class UStandPointRecorder* GetStandPointRecorder(const class UObject* WorldContextObject);
	static class AMarvelWayPointManager* GetWayPointManager(const class UObject* WorldContextObject);

	class AMarvelAIController* AddAICustom(const struct FAISpawnParam& SpawnParam);
	void BeforeLoadSubLevels();
	void InitAIAnthropomorphic(const TSet<int32>& TeamHasHumanPlayer);
	void InitBattleAreaData(const class FString& LevelName);
	void OnAIAssetLoaded();
	void OnGameMapLoadFinished();
	void OnLevelPrepareStageStart();
	void ReceiveAIRoundStart();
	void ReceiveStartPlay();
	void RegisterNewAI(class AMarvelAIController* NewAI);
	void RemoveAI(class AController* Controller);
	bool RemoveAIByUID(int32 UID);
	void SetCustomVisLogCategories(const TSet<class FName>& NewCategories);
	void SetVisLogRecording(bool bNewEnabled, bool bShouldCleanUp);
	void UnregisterAI(class AMarvelAIController* AIController);

	class AMarvelAIControllerBase* AddAI(int32 UID, int32 HeroID, EBattleSide BattleSide, const class FString& Name_0, int32 DifficultyMode, int32 DifficultyLevel) const;
	bool CheckIsInMarvelGameWorld() const;
	const class UMarvelAIGameModeDefaultConfigAsset* GetAIGameModeConfig() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAISystem">();
	}
	static class UMarvelAISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAISystem>();
	}
};
static_assert(alignof(UMarvelAISystem) == 0x000008, "Wrong alignment on UMarvelAISystem");
static_assert(sizeof(UMarvelAISystem) == 0x0002C8, "Wrong size on UMarvelAISystem");
static_assert(offsetof(UMarvelAISystem, AIGameModeConfig) == 0x0001D8, "Member 'UMarvelAISystem::AIGameModeConfig' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, AITeamManager) == 0x0001E0, "Member 'UMarvelAISystem::AITeamManager' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, WayPointManager) == 0x0001E8, "Member 'UMarvelAISystem::WayPointManager' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, StandPointManager) == 0x0001F0, "Member 'UMarvelAISystem::StandPointManager' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, BattleAreaManager) == 0x0001F8, "Member 'UMarvelAISystem::BattleAreaManager' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, StandPointRecorder) == 0x000200, "Member 'UMarvelAISystem::StandPointRecorder' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, AbilityTacticsManager) == 0x000208, "Member 'UMarvelAISystem::AbilityTacticsManager' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, bEnableNavLinkDynamicPostProcess) == 0x000210, "Member 'UMarvelAISystem::bEnableNavLinkDynamicPostProcess' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, bEnableShelterMove) == 0x000211, "Member 'UMarvelAISystem::bEnableShelterMove' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, bUpdateClientNavmeshBoundOnMapLoaded) == 0x000212, "Member 'UMarvelAISystem::bUpdateClientNavmeshBoundOnMapLoaded' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, AIAnthropomorphicType) == 0x000214, "Member 'UMarvelAISystem::AIAnthropomorphicType' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, bEnableVisLogWhenServerStart) == 0x000216, "Member 'UMarvelAISystem::bEnableVisLogWhenServerStart' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, bUseCustomVisLogFilename) == 0x000217, "Member 'UMarvelAISystem::bUseCustomVisLogFilename' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, CustomVisLogCategories) == 0x000218, "Member 'UMarvelAISystem::CustomVisLogCategories' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, AIControllers) == 0x000268, "Member 'UMarvelAISystem::AIControllers' has a wrong offset!");
static_assert(offsetof(UMarvelAISystem, AIControllerMap) == 0x000278, "Member 'UMarvelAISystem::AIControllerMap' has a wrong offset!");

// Class MarvelAI.MarvelAITeamManager
// 0x01C8 (0x0678 - 0x04B0)
class AMarvelAITeamManager : public AMarvelActorBase
{
public:
	TMap<class AActor*, struct FDateTime>         LowHpMark;                                         // 0x04B0(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AutoChangeHeroDelegate;                            // 0x0500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMap<int32, struct FMarvelAITeamInfo>         TeamInfos;                                         // 0x0510(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHasInitTeamInfo;                                  // 0x0560(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMatchStart;                                     // 0x0561(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRepeatHero;                                  // 0x0562(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_563[0x5];                                      // 0x0563(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAISystem*                        CacheAISystem;                                     // 0x0568(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAIGameModeDefaultConfigAsset*    CacheAIGameModeConfig;                             // 0x0570(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EHeroRole, int32>                        RoleLimits;                                        // 0x0578(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C8[0x50];                                     // 0x05C8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   BanHeroes;                                         // 0x0618(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_668[0x10];                                     // 0x0668(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckAITeamLineup(int32 TeamID);
	void CheckCanBuildBondInPreSelect(const int32 OldPlayerHroID, const int32 NewPlayerHeroID, struct FMarvelAITeamInfo* TeamInfo);
	bool CheckLowHealthMarkValid(class AMarvelAIController* AIController, class AActor* Target);
	bool CheckLowHpMarkValid(class AActor* Target, float MarkLife);
	int32 GetAndUpdatePreviewHeroIDForAI(class AMarvelAIController* AIController, bool ImmediatelyUpdate);
	void InitHeroBondInfo();
	void InitRoleLimits();
	void InitTeamInfo();
	bool IsAutoChangeHeroAI(const class AMarvelPlayerState* PlayerState);
	void NotifyAIPreSelect();
	void OnBanPickEnd();
	void OnPlayerChangeHero(class AMarvelPlayerState* PlayerState, int32 HeroID);
	void TryAddLowHealthMark(class AMarvelAIController* AIController, class AActor* Target);
	void UpdateTeamInfo(const int32 UID, const int32 TeamID, const bool IsAutoChangeHeroAI, const int32 NewHeroID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAITeamManager">();
	}
	static class AMarvelAITeamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelAITeamManager>();
	}
};
static_assert(alignof(AMarvelAITeamManager) == 0x000008, "Wrong alignment on AMarvelAITeamManager");
static_assert(sizeof(AMarvelAITeamManager) == 0x000678, "Wrong size on AMarvelAITeamManager");
static_assert(offsetof(AMarvelAITeamManager, LowHpMark) == 0x0004B0, "Member 'AMarvelAITeamManager::LowHpMark' has a wrong offset!");
static_assert(offsetof(AMarvelAITeamManager, AutoChangeHeroDelegate) == 0x000500, "Member 'AMarvelAITeamManager::AutoChangeHeroDelegate' has a wrong offset!");
static_assert(offsetof(AMarvelAITeamManager, TeamInfos) == 0x000510, "Member 'AMarvelAITeamManager::TeamInfos' has a wrong offset!");
static_assert(offsetof(AMarvelAITeamManager, bHasInitTeamInfo) == 0x000560, "Member 'AMarvelAITeamManager::bHasInitTeamInfo' has a wrong offset!");
static_assert(offsetof(AMarvelAITeamManager, bIsMatchStart) == 0x000561, "Member 'AMarvelAITeamManager::bIsMatchStart' has a wrong offset!");
static_assert(offsetof(AMarvelAITeamManager, bAllowRepeatHero) == 0x000562, "Member 'AMarvelAITeamManager::bAllowRepeatHero' has a wrong offset!");
static_assert(offsetof(AMarvelAITeamManager, CacheAISystem) == 0x000568, "Member 'AMarvelAITeamManager::CacheAISystem' has a wrong offset!");
static_assert(offsetof(AMarvelAITeamManager, CacheAIGameModeConfig) == 0x000570, "Member 'AMarvelAITeamManager::CacheAIGameModeConfig' has a wrong offset!");
static_assert(offsetof(AMarvelAITeamManager, RoleLimits) == 0x000578, "Member 'AMarvelAITeamManager::RoleLimits' has a wrong offset!");
static_assert(offsetof(AMarvelAITeamManager, BanHeroes) == 0x000618, "Member 'AMarvelAITeamManager::BanHeroes' has a wrong offset!");

// Class MarvelAI.MarvelBehaviorTreeComponent
// 0x0050 (0x0330 - 0x02E0)
class UMarvelBehaviorTreeComponent final : public UBehaviorTreeComponent
{
public:
	TMap<struct FGameplayTag, class UBehaviorTree*> HeroSubBTMap;                                      // 0x02E0(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	class UBehaviorTree* GetBTAssetByTag(const struct FGameplayTag& GameplayTag);
	bool IsBTRunning(class UBehaviorTree* BehaviorTreeAsset);
	void K2_PauseLogic(const class FString& Reason);
	void K2_ResumeLogic(const class FString& Reason);
	void K2_ScheduleExecutionUpdate();
	void K2_StartLogic();
	void K2_StopLogic(const class FString& Reason);
	void UpdateSubTreeMap(const TMap<struct FGameplayTag, class UBehaviorTree*>& SubTreeMap);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelBehaviorTreeComponent">();
	}
	static class UMarvelBehaviorTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelBehaviorTreeComponent>();
	}
};
static_assert(alignof(UMarvelBehaviorTreeComponent) == 0x000008, "Wrong alignment on UMarvelBehaviorTreeComponent");
static_assert(sizeof(UMarvelBehaviorTreeComponent) == 0x000330, "Wrong size on UMarvelBehaviorTreeComponent");
static_assert(offsetof(UMarvelBehaviorTreeComponent, HeroSubBTMap) == 0x0002E0, "Member 'UMarvelBehaviorTreeComponent::HeroSubBTMap' has a wrong offset!");

// Class MarvelAI.MarvelBlackboardComponent
// 0x0000 (0x01F8 - 0x01F8)
class UMarvelBlackboardComponent final : public UBlackboardComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelBlackboardComponent">();
	}
	static class UMarvelBlackboardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelBlackboardComponent>();
	}
};
static_assert(alignof(UMarvelBlackboardComponent) == 0x000008, "Wrong alignment on UMarvelBlackboardComponent");
static_assert(sizeof(UMarvelBlackboardComponent) == 0x0001F8, "Wrong size on UMarvelBlackboardComponent");

// Class MarvelAI.MarvelBTFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMarvelBTFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddClassFilterForBBKeySelector(struct FBlackboardKeySelector& KeySelector, class UObject* Owner, class FName PropertyName, TSubclassOf<class UObject> AllowedClass);
	static void AddEnumFilterForBBKeySelector(struct FBlackboardKeySelector& KeySelector, class UObject* Owner, class FName PropertyName, class UEnum* AllowedEnum);
	static void AddObjectFilterForBBKeySelector(struct FBlackboardKeySelector& KeySelector, class UObject* Owner, class FName PropertyName, TSubclassOf<class UObject> AllowedClass);
	static void AddSimpleFilterForBBKeySelector(struct FBlackboardKeySelector& KeySelector, class UObject* Owner, class FName PropertyName, const TArray<TSubclassOf<class UBlackboardKeyType>>& FilterTypes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelBTFunctionLibrary">();
	}
	static class UMarvelBTFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelBTFunctionLibrary>();
	}
};
static_assert(alignof(UMarvelBTFunctionLibrary) == 0x000008, "Wrong alignment on UMarvelBTFunctionLibrary");
static_assert(sizeof(UMarvelBTFunctionLibrary) == 0x000030, "Wrong size on UMarvelBTFunctionLibrary");

// Class MarvelAI.MarvelNavAgentInterface
// 0x0000 (0x0030 - 0x0030)
class IMarvelNavAgentInterface final : public INavAgentInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavAgentInterface">();
	}
	static class IMarvelNavAgentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMarvelNavAgentInterface>();
	}
};
static_assert(alignof(IMarvelNavAgentInterface) == 0x000008, "Wrong alignment on IMarvelNavAgentInterface");
static_assert(sizeof(IMarvelNavAgentInterface) == 0x000030, "Wrong size on IMarvelNavAgentInterface");

// Class MarvelAI.MarvelNavArea
// 0x0000 (0x0050 - 0x0050)
class UMarvelNavArea : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavArea">();
	}
	static class UMarvelNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavArea>();
	}
};
static_assert(alignof(UMarvelNavArea) == 0x000008, "Wrong alignment on UMarvelNavArea");
static_assert(sizeof(UMarvelNavArea) == 0x000050, "Wrong size on UMarvelNavArea");

// Class MarvelAI.MarvelNavArea_NormalJump
// 0x0000 (0x0050 - 0x0050)
class UMarvelNavArea_NormalJump final : public UMarvelNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavArea_NormalJump">();
	}
	static class UMarvelNavArea_NormalJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavArea_NormalJump>();
	}
};
static_assert(alignof(UMarvelNavArea_NormalJump) == 0x000008, "Wrong alignment on UMarvelNavArea_NormalJump");
static_assert(sizeof(UMarvelNavArea_NormalJump) == 0x000050, "Wrong size on UMarvelNavArea_NormalJump");

// Class MarvelAI.MarvelNavArea_HighJump
// 0x0000 (0x0050 - 0x0050)
class UMarvelNavArea_HighJump final : public UMarvelNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavArea_HighJump">();
	}
	static class UMarvelNavArea_HighJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavArea_HighJump>();
	}
};
static_assert(alignof(UMarvelNavArea_HighJump) == 0x000008, "Wrong alignment on UMarvelNavArea_HighJump");
static_assert(sizeof(UMarvelNavArea_HighJump) == 0x000050, "Wrong size on UMarvelNavArea_HighJump");

// Class MarvelAI.MarvelNavArea_VeryHighJump
// 0x0000 (0x0050 - 0x0050)
class UMarvelNavArea_VeryHighJump final : public UMarvelNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavArea_VeryHighJump">();
	}
	static class UMarvelNavArea_VeryHighJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavArea_VeryHighJump>();
	}
};
static_assert(alignof(UMarvelNavArea_VeryHighJump) == 0x000008, "Wrong alignment on UMarvelNavArea_VeryHighJump");
static_assert(sizeof(UMarvelNavArea_VeryHighJump) == 0x000050, "Wrong size on UMarvelNavArea_VeryHighJump");

// Class MarvelAI.MarvelNavArea_GoDownLink
// 0x0000 (0x0050 - 0x0050)
class UMarvelNavArea_GoDownLink final : public UMarvelNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavArea_GoDownLink">();
	}
	static class UMarvelNavArea_GoDownLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavArea_GoDownLink>();
	}
};
static_assert(alignof(UMarvelNavArea_GoDownLink) == 0x000008, "Wrong alignment on UMarvelNavArea_GoDownLink");
static_assert(sizeof(UMarvelNavArea_GoDownLink) == 0x000050, "Wrong size on UMarvelNavArea_GoDownLink");

// Class MarvelAI.MarvelNavArea_LevelJump
// 0x0000 (0x0050 - 0x0050)
class UMarvelNavArea_LevelJump final : public UMarvelNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavArea_LevelJump">();
	}
	static class UMarvelNavArea_LevelJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavArea_LevelJump>();
	}
};
static_assert(alignof(UMarvelNavArea_LevelJump) == 0x000008, "Wrong alignment on UMarvelNavArea_LevelJump");
static_assert(sizeof(UMarvelNavArea_LevelJump) == 0x000050, "Wrong size on UMarvelNavArea_LevelJump");

// Class MarvelAI.MarvelNavArea_Walk
// 0x0000 (0x0050 - 0x0050)
class UMarvelNavArea_Walk final : public UMarvelNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavArea_Walk">();
	}
	static class UMarvelNavArea_Walk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavArea_Walk>();
	}
};
static_assert(alignof(UMarvelNavArea_Walk) == 0x000008, "Wrong alignment on UMarvelNavArea_Walk");
static_assert(sizeof(UMarvelNavArea_Walk) == 0x000050, "Wrong size on UMarvelNavArea_Walk");

// Class MarvelAI.MarvelNavArea_TeleportJump
// 0x0000 (0x0050 - 0x0050)
class UMarvelNavArea_TeleportJump final : public UMarvelNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavArea_TeleportJump">();
	}
	static class UMarvelNavArea_TeleportJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavArea_TeleportJump>();
	}
};
static_assert(alignof(UMarvelNavArea_TeleportJump) == 0x000008, "Wrong alignment on UMarvelNavArea_TeleportJump");
static_assert(sizeof(UMarvelNavArea_TeleportJump) == 0x000050, "Wrong size on UMarvelNavArea_TeleportJump");

// Class MarvelAI.MarvelNavArea_CampLink
// 0x0008 (0x0058 - 0x0050)
class UMarvelNavArea_CampLink final : public UMarvelNavArea
{
public:
	EBattleSide                                   PassSide;                                          // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavArea_CampLink">();
	}
	static class UMarvelNavArea_CampLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavArea_CampLink>();
	}
};
static_assert(alignof(UMarvelNavArea_CampLink) == 0x000008, "Wrong alignment on UMarvelNavArea_CampLink");
static_assert(sizeof(UMarvelNavArea_CampLink) == 0x000058, "Wrong size on UMarvelNavArea_CampLink");
static_assert(offsetof(UMarvelNavArea_CampLink, PassSide) == 0x000050, "Member 'UMarvelNavArea_CampLink::PassSide' has a wrong offset!");

// Class MarvelAI.MarvelNavArea_ObstacleLink
// 0x0000 (0x0050 - 0x0050)
class UMarvelNavArea_ObstacleLink final : public UMarvelNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavArea_ObstacleLink">();
	}
	static class UMarvelNavArea_ObstacleLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavArea_ObstacleLink>();
	}
};
static_assert(alignof(UMarvelNavArea_ObstacleLink) == 0x000008, "Wrong alignment on UMarvelNavArea_ObstacleLink");
static_assert(sizeof(UMarvelNavArea_ObstacleLink) == 0x000050, "Wrong size on UMarvelNavArea_ObstacleLink");

// Class MarvelAI.MarvelNavigationLibrary
// 0x0000 (0x0030 - 0x0030)
class UMarvelNavigationLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckShortDistancePointReachable(class AAIController* AIController, const struct FVector& TargetLocation, int32 MaxSearchNode);
	static void DebugDrawTileLayersBB(class UObject* WorldContextObject, const struct FVector& WorldPosition);
	static bool GetLocationTileCoord(class UObject* WorldContext, const struct FVector& InLocation, bool ShouldMarkDebug, int32* OutTileX, int32* OutTileY);
	static bool HasValidFlyPath(class UObject* WCO, const struct FVector& StartLocation, const struct FVector& TargetLocation);
	static bool K2_ProjectLocationToNavMesh(class UObject* WorldContext, const struct FVector& InLocation, const struct FVector& InExtent, struct FVector* OutLocation);
	static void RebuildNavmesh(class UObject* WorldContextObject);
	static void SetDirtyAreaMarkEnabled(class UObject* WorldContext, bool NewIsEnabled);
	static void SetStaticNavigation(bool bNewIsStrictlyStatic);
	static bool VLogNavData(class AActor* CenterActor, const struct FVector& Extent);
	static bool VLogTileData(class UObject* WorldContext, int32 InTileX, int32 InTileY);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavigationLibrary">();
	}
	static class UMarvelNavigationLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavigationLibrary>();
	}
};
static_assert(alignof(UMarvelNavigationLibrary) == 0x000008, "Wrong alignment on UMarvelNavigationLibrary");
static_assert(sizeof(UMarvelNavigationLibrary) == 0x000030, "Wrong size on UMarvelNavigationLibrary");

// Class MarvelAI.MarvelNavigationQueryFilter
// 0x0008 (0x0058 - 0x0050)
class UMarvelNavigationQueryFilter : public UNavigationQueryFilter
{
public:
	uint8                                         Pad_50[0x4];                                       // 0x0050(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCouldClimbWall;                                   // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavigationQueryFilter">();
	}
	static class UMarvelNavigationQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavigationQueryFilter>();
	}
};
static_assert(alignof(UMarvelNavigationQueryFilter) == 0x000008, "Wrong alignment on UMarvelNavigationQueryFilter");
static_assert(sizeof(UMarvelNavigationQueryFilter) == 0x000058, "Wrong size on UMarvelNavigationQueryFilter");
static_assert(offsetof(UMarvelNavigationQueryFilter, bCouldClimbWall) == 0x000054, "Member 'UMarvelNavigationQueryFilter::bCouldClimbWall' has a wrong offset!");

// Class MarvelAI.MarvelNavFilter_JumpNormal
// 0x0000 (0x0058 - 0x0058)
class UMarvelNavFilter_JumpNormal final : public UMarvelNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavFilter_JumpNormal">();
	}
	static class UMarvelNavFilter_JumpNormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavFilter_JumpNormal>();
	}
};
static_assert(alignof(UMarvelNavFilter_JumpNormal) == 0x000008, "Wrong alignment on UMarvelNavFilter_JumpNormal");
static_assert(sizeof(UMarvelNavFilter_JumpNormal) == 0x000058, "Wrong size on UMarvelNavFilter_JumpNormal");

// Class MarvelAI.MarvelNavFilter_JumpHigh
// 0x0000 (0x0058 - 0x0058)
class UMarvelNavFilter_JumpHigh final : public UMarvelNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavFilter_JumpHigh">();
	}
	static class UMarvelNavFilter_JumpHigh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavFilter_JumpHigh>();
	}
};
static_assert(alignof(UMarvelNavFilter_JumpHigh) == 0x000008, "Wrong alignment on UMarvelNavFilter_JumpHigh");
static_assert(sizeof(UMarvelNavFilter_JumpHigh) == 0x000058, "Wrong size on UMarvelNavFilter_JumpHigh");

// Class MarvelAI.MarvelNavFilter_JumpVeryHigh
// 0x0000 (0x0058 - 0x0058)
class UMarvelNavFilter_JumpVeryHigh final : public UMarvelNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavFilter_JumpVeryHigh">();
	}
	static class UMarvelNavFilter_JumpVeryHigh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavFilter_JumpVeryHigh>();
	}
};
static_assert(alignof(UMarvelNavFilter_JumpVeryHigh) == 0x000008, "Wrong alignment on UMarvelNavFilter_JumpVeryHigh");
static_assert(sizeof(UMarvelNavFilter_JumpVeryHigh) == 0x000058, "Wrong size on UMarvelNavFilter_JumpVeryHigh");

// Class MarvelAI.MarvelNavFilter_NoLinkPass
// 0x0000 (0x0058 - 0x0058)
class UMarvelNavFilter_NoLinkPass final : public UMarvelNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavFilter_NoLinkPass">();
	}
	static class UMarvelNavFilter_NoLinkPass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavFilter_NoLinkPass>();
	}
};
static_assert(alignof(UMarvelNavFilter_NoLinkPass) == 0x000008, "Wrong alignment on UMarvelNavFilter_NoLinkPass");
static_assert(sizeof(UMarvelNavFilter_NoLinkPass) == 0x000058, "Wrong size on UMarvelNavFilter_NoLinkPass");

// Class MarvelAI.MarvelNavFilter_ShortDistance
// 0x0000 (0x0058 - 0x0058)
class UMarvelNavFilter_ShortDistance final : public UMarvelNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavFilter_ShortDistance">();
	}
	static class UMarvelNavFilter_ShortDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavFilter_ShortDistance>();
	}
};
static_assert(alignof(UMarvelNavFilter_ShortDistance) == 0x000008, "Wrong alignment on UMarvelNavFilter_ShortDistance");
static_assert(sizeof(UMarvelNavFilter_ShortDistance) == 0x000058, "Wrong size on UMarvelNavFilter_ShortDistance");

// Class MarvelAI.MarvelNavigationSystem
// 0x0000 (0x15C0 - 0x15C0)
class UMarvelNavigationSystem final : public UNavigationSystemV1
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavigationSystem">();
	}
	static class UMarvelNavigationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavigationSystem>();
	}
};
static_assert(alignof(UMarvelNavigationSystem) == 0x000008, "Wrong alignment on UMarvelNavigationSystem");
static_assert(sizeof(UMarvelNavigationSystem) == 0x0015C0, "Wrong size on UMarvelNavigationSystem");

// Class MarvelAI.MarvelNavLinkCustomComponent
// 0x0040 (0x0280 - 0x0240)
class UMarvelNavLinkCustomComponent : public UNavLinkCustomComponent
{
public:
	struct FVector                                TeleportStart;                                     // 0x0240(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TeleportEnd;                                       // 0x0258(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttachedToWall;                                 // 0x0270(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUpdateConfigDataWhenEdit;                   // 0x0271(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_272[0xE];                                      // 0x0272(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavLinkCustomComponent">();
	}
	static class UMarvelNavLinkCustomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavLinkCustomComponent>();
	}
};
static_assert(alignof(UMarvelNavLinkCustomComponent) == 0x000008, "Wrong alignment on UMarvelNavLinkCustomComponent");
static_assert(sizeof(UMarvelNavLinkCustomComponent) == 0x000280, "Wrong size on UMarvelNavLinkCustomComponent");
static_assert(offsetof(UMarvelNavLinkCustomComponent, TeleportStart) == 0x000240, "Member 'UMarvelNavLinkCustomComponent::TeleportStart' has a wrong offset!");
static_assert(offsetof(UMarvelNavLinkCustomComponent, TeleportEnd) == 0x000258, "Member 'UMarvelNavLinkCustomComponent::TeleportEnd' has a wrong offset!");
static_assert(offsetof(UMarvelNavLinkCustomComponent, bIsAttachedToWall) == 0x000270, "Member 'UMarvelNavLinkCustomComponent::bIsAttachedToWall' has a wrong offset!");
static_assert(offsetof(UMarvelNavLinkCustomComponent, bShouldUpdateConfigDataWhenEdit) == 0x000271, "Member 'UMarvelNavLinkCustomComponent::bShouldUpdateConfigDataWhenEdit' has a wrong offset!");

// Class MarvelAI.MarvelNavLinkProxy
// 0x0008 (0x04E8 - 0x04E0)
class AMarvelNavLinkProxy : public ANavLinkProxy
{
public:
	uint8                                         bShouldCheckBlockWhenUpdateNavData : 1;            // 0x04E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShouldCheckBothSide : 1;                          // 0x04E0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4E1[0x7];                                      // 0x04E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawNavigationBound() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavLinkProxy">();
	}
	static class AMarvelNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelNavLinkProxy>();
	}
};
static_assert(alignof(AMarvelNavLinkProxy) == 0x000008, "Wrong alignment on AMarvelNavLinkProxy");
static_assert(sizeof(AMarvelNavLinkProxy) == 0x0004E8, "Wrong size on AMarvelNavLinkProxy");

// Class MarvelAI.MarvelNavModifierComponent
// 0x00B0 (0x0290 - 0x01E0)
class UMarvelNavModifierComponent final : public UNavModifierComponent
{
public:
	bool                                          bUseStaticMeshAsBound;                             // 0x01E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateInterval;                                    // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateNavWhenStopMoving;                          // 0x01E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUpdateWhenMovingStatusChange;                 // 0x01E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EA[0x2];                                      // 0x01EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxSampleNum;                                      // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SampleInterval;                                    // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionDistance;                                 // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x94];                                     // 0x01FC(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavModifierComponent">();
	}
	static class UMarvelNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelNavModifierComponent>();
	}
};
static_assert(alignof(UMarvelNavModifierComponent) == 0x000010, "Wrong alignment on UMarvelNavModifierComponent");
static_assert(sizeof(UMarvelNavModifierComponent) == 0x000290, "Wrong size on UMarvelNavModifierComponent");
static_assert(offsetof(UMarvelNavModifierComponent, bUseStaticMeshAsBound) == 0x0001E0, "Member 'UMarvelNavModifierComponent::bUseStaticMeshAsBound' has a wrong offset!");
static_assert(offsetof(UMarvelNavModifierComponent, UpdateInterval) == 0x0001E4, "Member 'UMarvelNavModifierComponent::UpdateInterval' has a wrong offset!");
static_assert(offsetof(UMarvelNavModifierComponent, bUpdateNavWhenStopMoving) == 0x0001E8, "Member 'UMarvelNavModifierComponent::bUpdateNavWhenStopMoving' has a wrong offset!");
static_assert(offsetof(UMarvelNavModifierComponent, bOnlyUpdateWhenMovingStatusChange) == 0x0001E9, "Member 'UMarvelNavModifierComponent::bOnlyUpdateWhenMovingStatusChange' has a wrong offset!");
static_assert(offsetof(UMarvelNavModifierComponent, MaxSampleNum) == 0x0001EC, "Member 'UMarvelNavModifierComponent::MaxSampleNum' has a wrong offset!");
static_assert(offsetof(UMarvelNavModifierComponent, SampleInterval) == 0x0001F0, "Member 'UMarvelNavModifierComponent::SampleInterval' has a wrong offset!");
static_assert(offsetof(UMarvelNavModifierComponent, DetectionDistance) == 0x0001F8, "Member 'UMarvelNavModifierComponent::DetectionDistance' has a wrong offset!");

// Class MarvelAI.MarvelNavModifierVolume
// 0x0008 (0x04E8 - 0x04E0)
class AMarvelNavModifierVolume final : public ANavModifierVolume
{
public:
	bool                                          bOverrideTileConfig;                               // 0x04E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E1[0x1];                                      // 0x04E1(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTileCustomGeneralConfig               TileCustomGeneralConfig;                           // 0x04E2(0x0006)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelNavModifierVolume">();
	}
	static class AMarvelNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelNavModifierVolume>();
	}
};
static_assert(alignof(AMarvelNavModifierVolume) == 0x000008, "Wrong alignment on AMarvelNavModifierVolume");
static_assert(sizeof(AMarvelNavModifierVolume) == 0x0004E8, "Wrong size on AMarvelNavModifierVolume");
static_assert(offsetof(AMarvelNavModifierVolume, bOverrideTileConfig) == 0x0004E0, "Member 'AMarvelNavModifierVolume::bOverrideTileConfig' has a wrong offset!");
static_assert(offsetof(AMarvelNavModifierVolume, TileCustomGeneralConfig) == 0x0004E2, "Member 'AMarvelNavModifierVolume::TileCustomGeneralConfig' has a wrong offset!");

// Class MarvelAI.MarvelObstacleNavLinkComponent
// 0x0008 (0x0288 - 0x0280)
class UMarvelObstacleNavLinkComponent final : public UMarvelNavLinkCustomComponent
{
public:
	float                                         BlockCheckInterval;                                // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelObstacleNavLinkComponent">();
	}
	static class UMarvelObstacleNavLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelObstacleNavLinkComponent>();
	}
};
static_assert(alignof(UMarvelObstacleNavLinkComponent) == 0x000008, "Wrong alignment on UMarvelObstacleNavLinkComponent");
static_assert(sizeof(UMarvelObstacleNavLinkComponent) == 0x000288, "Wrong size on UMarvelObstacleNavLinkComponent");
static_assert(offsetof(UMarvelObstacleNavLinkComponent, BlockCheckInterval) == 0x000280, "Member 'UMarvelObstacleNavLinkComponent::BlockCheckInterval' has a wrong offset!");

// Class MarvelAI.MarvelObstacleNavLinkProxy
// 0x0008 (0x04F0 - 0x04E8)
class AMarvelObstacleNavLinkProxy final : public AMarvelNavLinkProxy
{
public:
	class UBoxComponent*                          BlockCheckBoxComp;                                 // 0x04E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void TestBlockTrace();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelObstacleNavLinkProxy">();
	}
	static class AMarvelObstacleNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelObstacleNavLinkProxy>();
	}
};
static_assert(alignof(AMarvelObstacleNavLinkProxy) == 0x000008, "Wrong alignment on AMarvelObstacleNavLinkProxy");
static_assert(sizeof(AMarvelObstacleNavLinkProxy) == 0x0004F0, "Wrong size on AMarvelObstacleNavLinkProxy");
static_assert(offsetof(AMarvelObstacleNavLinkProxy, BlockCheckBoxComp) == 0x0004E8, "Member 'AMarvelObstacleNavLinkProxy::BlockCheckBoxComp' has a wrong offset!");

// Class MarvelAI.MarvelPathFollowingComponent
// 0x0118 (0x0440 - 0x0328)
class UMarvelPathFollowingComponent final : public UPathFollowingComponent
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMovePathSegmentDispatcher;                       // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x30];                                     // 0x0340(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableDebugDraw;                                  // 0x0370(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMoveAbility;                                   // 0x0371(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepJumpWhenMove;                                 // 0x0372(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_373[0x1];                                      // 0x0373(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreJumpCoolDown;                                   // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleSizeFactorForPreJump;                       // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldTryJumpOnBlocked;                           // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEnableCrossMove;                             // 0x0381(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_382[0x2];                                      // 0x0382(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrossMoveInputFactor;                              // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRange_FloatValue                      CrossMoveDistRange;                                // 0x0388(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableCrossMove;                                  // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHorizontalDirectionForForward;                 // 0x0391(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableOverrideFocusWhenFollowNavLink;             // 0x0392(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_393[0x1];                                      // 0x0393(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveFocusForwardOffset;                            // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveFocusUpOffset;                                 // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideMoveFocus;                                 // 0x03A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathFollowingResult                          LastPathFollowResult;                              // 0x03B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x57];                                     // 0x03B9(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USteeringBehavior>          DefaultSteeringClass;                              // 0x0410(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USteeringBehavior*                      MySteering;                                        // 0x0418(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_420[0x18];                                     // 0x0420(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceNotDecelerateForLastPathSegment;             // 0x0438(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceDisableDefaultPathFollowMoveInput;           // 0x0439(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43A[0x6];                                      // 0x043A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearOverrideMoveFocus();
	void MarkCrossMoveForDuration(float NewDuration);
	void OnMovePathSegmentDelegate__DelegateSignature(const struct FVector& MoveEnd);
	void SetCrossMoveEnabled(bool NewIsEnabled);
	void SetDecelerateForLastPathSegment(bool bNewIsEnabled);
	void SetOverrideMoveFocus(const struct FVector& NewMoveFocus);

	bool CheckCurrentStatus(EPathFollowingStatus TargetStatus) const;
	EPathFollowingStatus GetCurrentStatus() const;
	bool IsHandlingLinkMove() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelPathFollowingComponent">();
	}
	static class UMarvelPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelPathFollowingComponent>();
	}
};
static_assert(alignof(UMarvelPathFollowingComponent) == 0x000008, "Wrong alignment on UMarvelPathFollowingComponent");
static_assert(sizeof(UMarvelPathFollowingComponent) == 0x000440, "Wrong size on UMarvelPathFollowingComponent");
static_assert(offsetof(UMarvelPathFollowingComponent, OnMovePathSegmentDispatcher) == 0x000330, "Member 'UMarvelPathFollowingComponent::OnMovePathSegmentDispatcher' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, bEnableDebugDraw) == 0x000370, "Member 'UMarvelPathFollowingComponent::bEnableDebugDraw' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, bUseMoveAbility) == 0x000371, "Member 'UMarvelPathFollowingComponent::bUseMoveAbility' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, bKeepJumpWhenMove) == 0x000372, "Member 'UMarvelPathFollowingComponent::bKeepJumpWhenMove' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, PreJumpCoolDown) == 0x000374, "Member 'UMarvelPathFollowingComponent::PreJumpCoolDown' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, CapsuleSizeFactorForPreJump) == 0x000378, "Member 'UMarvelPathFollowingComponent::CapsuleSizeFactorForPreJump' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, bShouldTryJumpOnBlocked) == 0x000380, "Member 'UMarvelPathFollowingComponent::bShouldTryJumpOnBlocked' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, bForceEnableCrossMove) == 0x000381, "Member 'UMarvelPathFollowingComponent::bForceEnableCrossMove' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, CrossMoveInputFactor) == 0x000384, "Member 'UMarvelPathFollowingComponent::CrossMoveInputFactor' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, CrossMoveDistRange) == 0x000388, "Member 'UMarvelPathFollowingComponent::CrossMoveDistRange' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, bEnableCrossMove) == 0x000390, "Member 'UMarvelPathFollowingComponent::bEnableCrossMove' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, bUseHorizontalDirectionForForward) == 0x000391, "Member 'UMarvelPathFollowingComponent::bUseHorizontalDirectionForForward' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, bEnableOverrideFocusWhenFollowNavLink) == 0x000392, "Member 'UMarvelPathFollowingComponent::bEnableOverrideFocusWhenFollowNavLink' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, MoveFocusForwardOffset) == 0x000394, "Member 'UMarvelPathFollowingComponent::MoveFocusForwardOffset' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, MoveFocusUpOffset) == 0x000398, "Member 'UMarvelPathFollowingComponent::MoveFocusUpOffset' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, OverrideMoveFocus) == 0x0003A0, "Member 'UMarvelPathFollowingComponent::OverrideMoveFocus' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, LastPathFollowResult) == 0x0003B8, "Member 'UMarvelPathFollowingComponent::LastPathFollowResult' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, DefaultSteeringClass) == 0x000410, "Member 'UMarvelPathFollowingComponent::DefaultSteeringClass' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, MySteering) == 0x000418, "Member 'UMarvelPathFollowingComponent::MySteering' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, bForceNotDecelerateForLastPathSegment) == 0x000438, "Member 'UMarvelPathFollowingComponent::bForceNotDecelerateForLastPathSegment' has a wrong offset!");
static_assert(offsetof(UMarvelPathFollowingComponent, bForceDisableDefaultPathFollowMoveInput) == 0x000439, "Member 'UMarvelPathFollowingComponent::bForceDisableDefaultPathFollowMoveInput' has a wrong offset!");

// Class MarvelAI.MarvelWayPointManager
// 0x00A0 (0x0550 - 0x04B0)
class AMarvelWayPointManager : public AMarvelActorBase
{
public:
	TMap<TSoftObjectPtr<class AActor>, struct FPathSelectorData> PathSelectConfig;                                  // 0x04B0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, TSoftObjectPtr<class AStartWayPoint>> StartWayPointMap;                                  // 0x0500(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void CollectDataFromOldConfig();
	bool GetPathToTargetFromActor(class AActor* PathSelector, class AActor* ActorMovingAlong, class AActor* Target, struct FWayPointPath* OutWayPointPath, bool ShouldUpdateProgressInPath);

	class AStartWayPoint* GetStartWayPointFromConfig(class AActor* PathStart, class AActor* PathTarget) const;
	class AStartWayPoint* GetStartWayPointFromMap(const class FName& StartWayPointID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelWayPointManager">();
	}
	static class AMarvelWayPointManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelWayPointManager>();
	}
};
static_assert(alignof(AMarvelWayPointManager) == 0x000008, "Wrong alignment on AMarvelWayPointManager");
static_assert(sizeof(AMarvelWayPointManager) == 0x000550, "Wrong size on AMarvelWayPointManager");
static_assert(offsetof(AMarvelWayPointManager, PathSelectConfig) == 0x0004B0, "Member 'AMarvelWayPointManager::PathSelectConfig' has a wrong offset!");
static_assert(offsetof(AMarvelWayPointManager, StartWayPointMap) == 0x000500, "Member 'AMarvelWayPointManager::StartWayPointMap' has a wrong offset!");

// Class MarvelAI.NavEffectBoxComponent
// 0x0000 (0x08A0 - 0x08A0)
class UNavEffectBoxComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavEffectBoxComponent">();
	}
	static class UNavEffectBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavEffectBoxComponent>();
	}
};
static_assert(alignof(UNavEffectBoxComponent) == 0x000010, "Wrong alignment on UNavEffectBoxComponent");
static_assert(sizeof(UNavEffectBoxComponent) == 0x0008A0, "Wrong size on UNavEffectBoxComponent");

// Class MarvelAI.NavLinkAutoGenerator
// 0x0178 (0x0630 - 0x04B8)
class ANavLinkAutoGenerator final : public AAISceneConfigActorBase
{
public:
	bool                                          bShouldModifyNavLinks;                             // 0x04B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldModifyStrategyPoints;                       // 0x04B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BA[0x6];                                      // 0x04BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANavLinkProxy*>                  GeneratedNavLinks;                                 // 0x04C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x10];                                     // 0x04D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FTileRef, struct FTileData>       TileRefToData;                                     // 0x04E0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         LevelKnockUpCache;                                 // 0x0530(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x4];                                      // 0x0540(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTileDebugDrawConfig                   DebugConfig;                                       // 0x0544(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPreviewLinkWithoutCreate;                         // 0x054C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefreshNavLinkIdAfterCreate;                      // 0x054D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkWallAttachedAfterGenerate;                    // 0x054E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54F[0x1];                                      // 0x054F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWallAttachCheckConfig                 WallAttachedCheckConfig;                           // 0x0550(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ANavLinkProxy>              NavLinkProxyClass;                                 // 0x0570(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNavLinkGenerateConfig                 GenerateConfig;                                    // 0x0578(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B0[0x38];                                     // 0x05B0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableRuntimeGeneration;                          // 0x05E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableLinkPool;                                   // 0x05E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EA[0x2];                                      // 0x05EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LinkPoolInitCapacity;                              // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x8];                                      // 0x05F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavLinkProxy*                          ToCheckLink;                                       // 0x05F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AStrategyPointActor*>            GeneratedStrategyPoints;                           // 0x0600(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FStrategyPointGenerateConfig           StrategyPointGenerateConfig;                       // 0x0610(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AStrategyPointActor>        StrategyPointClass;                                // 0x0620(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawHeightDetect;                                 // 0x0628(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_629[0x7];                                      // 0x0629(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CleanUp();
	void DebugDrawEdges();
	void DebugDrawLevelKnockUp();
	void DebugDrawLinks();
	void DoGenerate();
	void ToggleGlobalDebugDraw();

	void DebugCheckCollisionForLink() const;
	void DebugDrawStrategyPoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkAutoGenerator">();
	}
	static class ANavLinkAutoGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkAutoGenerator>();
	}
};
static_assert(alignof(ANavLinkAutoGenerator) == 0x000008, "Wrong alignment on ANavLinkAutoGenerator");
static_assert(sizeof(ANavLinkAutoGenerator) == 0x000630, "Wrong size on ANavLinkAutoGenerator");
static_assert(offsetof(ANavLinkAutoGenerator, bShouldModifyNavLinks) == 0x0004B8, "Member 'ANavLinkAutoGenerator::bShouldModifyNavLinks' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, bShouldModifyStrategyPoints) == 0x0004B9, "Member 'ANavLinkAutoGenerator::bShouldModifyStrategyPoints' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, GeneratedNavLinks) == 0x0004C0, "Member 'ANavLinkAutoGenerator::GeneratedNavLinks' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, TileRefToData) == 0x0004E0, "Member 'ANavLinkAutoGenerator::TileRefToData' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, LevelKnockUpCache) == 0x000530, "Member 'ANavLinkAutoGenerator::LevelKnockUpCache' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, DebugConfig) == 0x000544, "Member 'ANavLinkAutoGenerator::DebugConfig' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, bPreviewLinkWithoutCreate) == 0x00054C, "Member 'ANavLinkAutoGenerator::bPreviewLinkWithoutCreate' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, bRefreshNavLinkIdAfterCreate) == 0x00054D, "Member 'ANavLinkAutoGenerator::bRefreshNavLinkIdAfterCreate' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, bMarkWallAttachedAfterGenerate) == 0x00054E, "Member 'ANavLinkAutoGenerator::bMarkWallAttachedAfterGenerate' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, WallAttachedCheckConfig) == 0x000550, "Member 'ANavLinkAutoGenerator::WallAttachedCheckConfig' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, NavLinkProxyClass) == 0x000570, "Member 'ANavLinkAutoGenerator::NavLinkProxyClass' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, GenerateConfig) == 0x000578, "Member 'ANavLinkAutoGenerator::GenerateConfig' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, bEnableRuntimeGeneration) == 0x0005E8, "Member 'ANavLinkAutoGenerator::bEnableRuntimeGeneration' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, bEnableLinkPool) == 0x0005E9, "Member 'ANavLinkAutoGenerator::bEnableLinkPool' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, LinkPoolInitCapacity) == 0x0005EC, "Member 'ANavLinkAutoGenerator::LinkPoolInitCapacity' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, ToCheckLink) == 0x0005F8, "Member 'ANavLinkAutoGenerator::ToCheckLink' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, GeneratedStrategyPoints) == 0x000600, "Member 'ANavLinkAutoGenerator::GeneratedStrategyPoints' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, StrategyPointGenerateConfig) == 0x000610, "Member 'ANavLinkAutoGenerator::StrategyPointGenerateConfig' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, StrategyPointClass) == 0x000620, "Member 'ANavLinkAutoGenerator::StrategyPointClass' has a wrong offset!");
static_assert(offsetof(ANavLinkAutoGenerator, bDrawHeightDetect) == 0x000628, "Member 'ANavLinkAutoGenerator::bDrawHeightDetect' has a wrong offset!");

// Class MarvelAI.NavLinkMoveMethod
// 0x0010 (0x0048 - 0x0038)
class UNavLinkMoveMethod : public UPrimaryDataAsset
{
public:
	float                                         MaxVerticalMoveHeight;                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomLogicToCheckHasPass;                     // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomMoveInput;                               // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkMoveMethod">();
	}
	static class UNavLinkMoveMethod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkMoveMethod>();
	}
};
static_assert(alignof(UNavLinkMoveMethod) == 0x000008, "Wrong alignment on UNavLinkMoveMethod");
static_assert(sizeof(UNavLinkMoveMethod) == 0x000048, "Wrong size on UNavLinkMoveMethod");
static_assert(offsetof(UNavLinkMoveMethod, MaxVerticalMoveHeight) == 0x000038, "Member 'UNavLinkMoveMethod::MaxVerticalMoveHeight' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod, bUseCustomLogicToCheckHasPass) == 0x00003C, "Member 'UNavLinkMoveMethod::bUseCustomLogicToCheckHasPass' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod, bUseCustomMoveInput) == 0x00003D, "Member 'UNavLinkMoveMethod::bUseCustomMoveInput' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod, TickInterval) == 0x000040, "Member 'UNavLinkMoveMethod::TickInterval' has a wrong offset!");

// Class MarvelAI.NavLinkMoveMethod_DoubleJump
// 0x0008 (0x0050 - 0x0048)
class UNavLinkMoveMethod_DoubleJump final : public UNavLinkMoveMethod
{
public:
	int32                                         AbilityID;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDelayForDoubleJump;                            // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkMoveMethod_DoubleJump">();
	}
	static class UNavLinkMoveMethod_DoubleJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkMoveMethod_DoubleJump>();
	}
};
static_assert(alignof(UNavLinkMoveMethod_DoubleJump) == 0x000008, "Wrong alignment on UNavLinkMoveMethod_DoubleJump");
static_assert(sizeof(UNavLinkMoveMethod_DoubleJump) == 0x000050, "Wrong size on UNavLinkMoveMethod_DoubleJump");
static_assert(offsetof(UNavLinkMoveMethod_DoubleJump, AbilityID) == 0x000048, "Member 'UNavLinkMoveMethod_DoubleJump::AbilityID' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod_DoubleJump, TimeDelayForDoubleJump) == 0x00004C, "Member 'UNavLinkMoveMethod_DoubleJump::TimeDelayForDoubleJump' has a wrong offset!");

// Class MarvelAI.NavLinkMoveMethod_BigJump
// 0x0010 (0x0058 - 0x0048)
class UNavLinkMoveMethod_BigJump final : public UNavLinkMoveMethod
{
public:
	uint8                                         Pad_48[0x4];                                       // 0x0048(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputRate;                                         // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinInputRate;                                      // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkMoveMethod_BigJump">();
	}
	static class UNavLinkMoveMethod_BigJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkMoveMethod_BigJump>();
	}
};
static_assert(alignof(UNavLinkMoveMethod_BigJump) == 0x000008, "Wrong alignment on UNavLinkMoveMethod_BigJump");
static_assert(sizeof(UNavLinkMoveMethod_BigJump) == 0x000058, "Wrong size on UNavLinkMoveMethod_BigJump");
static_assert(offsetof(UNavLinkMoveMethod_BigJump, InputRate) == 0x00004C, "Member 'UNavLinkMoveMethod_BigJump::InputRate' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod_BigJump, FinInputRate) == 0x000050, "Member 'UNavLinkMoveMethod_BigJump::FinInputRate' has a wrong offset!");

// Class MarvelAI.NavLinkMoveMethod_CleanObstacle
// 0x0010 (0x0058 - 0x0048)
class UNavLinkMoveMethod_CleanObstacle final : public UNavLinkMoveMethod
{
public:
	EAbilityInputBinds                            AbilityInput;                                      // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackRange;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TakeAttackLocationInterval;                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableIfInBattle;                                // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkMoveMethod_CleanObstacle">();
	}
	static class UNavLinkMoveMethod_CleanObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkMoveMethod_CleanObstacle>();
	}
};
static_assert(alignof(UNavLinkMoveMethod_CleanObstacle) == 0x000008, "Wrong alignment on UNavLinkMoveMethod_CleanObstacle");
static_assert(sizeof(UNavLinkMoveMethod_CleanObstacle) == 0x000058, "Wrong size on UNavLinkMoveMethod_CleanObstacle");
static_assert(offsetof(UNavLinkMoveMethod_CleanObstacle, AbilityInput) == 0x000048, "Member 'UNavLinkMoveMethod_CleanObstacle::AbilityInput' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod_CleanObstacle, AttackRange) == 0x00004C, "Member 'UNavLinkMoveMethod_CleanObstacle::AttackRange' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod_CleanObstacle, TakeAttackLocationInterval) == 0x000050, "Member 'UNavLinkMoveMethod_CleanObstacle::TakeAttackLocationInterval' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod_CleanObstacle, bDisableIfInBattle) == 0x000054, "Member 'UNavLinkMoveMethod_CleanObstacle::bDisableIfInBattle' has a wrong offset!");

// Class MarvelAI.NavLinkMoveMethod_DirectlyMove
// 0x0000 (0x0048 - 0x0048)
class UNavLinkMoveMethod_DirectlyMove final : public UNavLinkMoveMethod
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkMoveMethod_DirectlyMove">();
	}
	static class UNavLinkMoveMethod_DirectlyMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkMoveMethod_DirectlyMove>();
	}
};
static_assert(alignof(UNavLinkMoveMethod_DirectlyMove) == 0x000008, "Wrong alignment on UNavLinkMoveMethod_DirectlyMove");
static_assert(sizeof(UNavLinkMoveMethod_DirectlyMove) == 0x000048, "Wrong size on UNavLinkMoveMethod_DirectlyMove");

// Class MarvelAI.NavLinkMoveMethod_ForceFly
// 0x0008 (0x0050 - 0x0048)
class UNavLinkMoveMethod_ForceFly final : public UNavLinkMoveMethod
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkMoveMethod_ForceFly">();
	}
	static class UNavLinkMoveMethod_ForceFly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkMoveMethod_ForceFly>();
	}
};
static_assert(alignof(UNavLinkMoveMethod_ForceFly) == 0x000008, "Wrong alignment on UNavLinkMoveMethod_ForceFly");
static_assert(sizeof(UNavLinkMoveMethod_ForceFly) == 0x000050, "Wrong size on UNavLinkMoveMethod_ForceFly");

// Class MarvelAI.NavLinkMoveMethod_TeleportJump
// 0x0000 (0x0048 - 0x0048)
class UNavLinkMoveMethod_TeleportJump final : public UNavLinkMoveMethod
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkMoveMethod_TeleportJump">();
	}
	static class UNavLinkMoveMethod_TeleportJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkMoveMethod_TeleportJump>();
	}
};
static_assert(alignof(UNavLinkMoveMethod_TeleportJump) == 0x000008, "Wrong alignment on UNavLinkMoveMethod_TeleportJump");
static_assert(sizeof(UNavLinkMoveMethod_TeleportJump) == 0x000048, "Wrong size on UNavLinkMoveMethod_TeleportJump");

// Class MarvelAI.NavLinkMoveMethod_WallClimb
// 0x0018 (0x0060 - 0x0048)
class UNavLinkMoveMethod_WallClimb final : public UNavLinkMoveMethod
{
public:
	int32                                         ClimbAbilityID;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClimbInputDetectAbilityID;                         // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckClimbAbilityCouldUse;                        // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAdjustDestPoint;                            // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalOffsetToDestPoint;                       // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAdjustWithNavData;                          // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavDataLerpFactor;                                 // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkMoveMethod_WallClimb">();
	}
	static class UNavLinkMoveMethod_WallClimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkMoveMethod_WallClimb>();
	}
};
static_assert(alignof(UNavLinkMoveMethod_WallClimb) == 0x000008, "Wrong alignment on UNavLinkMoveMethod_WallClimb");
static_assert(sizeof(UNavLinkMoveMethod_WallClimb) == 0x000060, "Wrong size on UNavLinkMoveMethod_WallClimb");
static_assert(offsetof(UNavLinkMoveMethod_WallClimb, ClimbAbilityID) == 0x000048, "Member 'UNavLinkMoveMethod_WallClimb::ClimbAbilityID' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod_WallClimb, ClimbInputDetectAbilityID) == 0x00004C, "Member 'UNavLinkMoveMethod_WallClimb::ClimbInputDetectAbilityID' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod_WallClimb, bCheckClimbAbilityCouldUse) == 0x000050, "Member 'UNavLinkMoveMethod_WallClimb::bCheckClimbAbilityCouldUse' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod_WallClimb, bShouldAdjustDestPoint) == 0x000051, "Member 'UNavLinkMoveMethod_WallClimb::bShouldAdjustDestPoint' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod_WallClimb, AdditionalOffsetToDestPoint) == 0x000054, "Member 'UNavLinkMoveMethod_WallClimb::AdditionalOffsetToDestPoint' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod_WallClimb, bShouldAdjustWithNavData) == 0x000058, "Member 'UNavLinkMoveMethod_WallClimb::bShouldAdjustWithNavData' has a wrong offset!");
static_assert(offsetof(UNavLinkMoveMethod_WallClimb, NavDataLerpFactor) == 0x00005C, "Member 'UNavLinkMoveMethod_WallClimb::NavDataLerpFactor' has a wrong offset!");

// Class MarvelAI.PrepareAreaComponent
// 0x0030 (0x08D0 - 0x08A0)
class UPrepareAreaComponent final : public UBoxComponent
{
public:
	EBattleSide                                   MyBattleSide;                                      // 0x08A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A1[0x3];                                      // 0x08A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateIsValidInterval;                             // 0x08A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarkToInvalidDuration;                             // 0x08A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsValidArea;                                      // 0x08AC(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8AD[0x23];                                     // 0x08AD(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckIsActorInRange(const class AActor* ToCheckActor) const;
	bool CheckIsValidArea() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrepareAreaComponent">();
	}
	static class UPrepareAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrepareAreaComponent>();
	}
};
static_assert(alignof(UPrepareAreaComponent) == 0x000010, "Wrong alignment on UPrepareAreaComponent");
static_assert(sizeof(UPrepareAreaComponent) == 0x0008D0, "Wrong size on UPrepareAreaComponent");
static_assert(offsetof(UPrepareAreaComponent, MyBattleSide) == 0x0008A0, "Member 'UPrepareAreaComponent::MyBattleSide' has a wrong offset!");
static_assert(offsetof(UPrepareAreaComponent, UpdateIsValidInterval) == 0x0008A4, "Member 'UPrepareAreaComponent::UpdateIsValidInterval' has a wrong offset!");
static_assert(offsetof(UPrepareAreaComponent, MarkToInvalidDuration) == 0x0008A8, "Member 'UPrepareAreaComponent::MarkToInvalidDuration' has a wrong offset!");
static_assert(offsetof(UPrepareAreaComponent, bIsValidArea) == 0x0008AC, "Member 'UPrepareAreaComponent::bIsValidArea' has a wrong offset!");

// Class MarvelAI.QA_AIGlobalConfig
// 0x0060 (0x0098 - 0x0038)
class UQA_AIGlobalConfig final : public UPrimaryDataAsset
{
public:
	TMap<int32, struct FQA_AIHeroConfig>          HeroConfig;                                        // 0x0038(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UObject>>            ForceLoadClasses;                                  // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QA_AIGlobalConfig">();
	}
	static class UQA_AIGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQA_AIGlobalConfig>();
	}
};
static_assert(alignof(UQA_AIGlobalConfig) == 0x000008, "Wrong alignment on UQA_AIGlobalConfig");
static_assert(sizeof(UQA_AIGlobalConfig) == 0x000098, "Wrong size on UQA_AIGlobalConfig");
static_assert(offsetof(UQA_AIGlobalConfig, HeroConfig) == 0x000038, "Member 'UQA_AIGlobalConfig::HeroConfig' has a wrong offset!");
static_assert(offsetof(UQA_AIGlobalConfig, ForceLoadClasses) == 0x000088, "Member 'UQA_AIGlobalConfig::ForceLoadClasses' has a wrong offset!");

// Class MarvelAI.AIScoreModuleRule
// 0x0030 (0x0060 - 0x0030)
class UAIScoreModuleRule : public UObject
{
public:
	TArray<struct FAIScoreModuleStruct>           ScoreModuleList_BasePlusArea;                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAIScoreModuleStruct>           ScoreModuleList_MultipleArea;                      // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAIScoreModuleStruct>           ScoreModuleList_ExtraPlusArea;                     // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScoreModuleRule">();
	}
	static class UAIScoreModuleRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScoreModuleRule>();
	}
};
static_assert(alignof(UAIScoreModuleRule) == 0x000008, "Wrong alignment on UAIScoreModuleRule");
static_assert(sizeof(UAIScoreModuleRule) == 0x000060, "Wrong size on UAIScoreModuleRule");
static_assert(offsetof(UAIScoreModuleRule, ScoreModuleList_BasePlusArea) == 0x000030, "Member 'UAIScoreModuleRule::ScoreModuleList_BasePlusArea' has a wrong offset!");
static_assert(offsetof(UAIScoreModuleRule, ScoreModuleList_MultipleArea) == 0x000040, "Member 'UAIScoreModuleRule::ScoreModuleList_MultipleArea' has a wrong offset!");
static_assert(offsetof(UAIScoreModuleRule, ScoreModuleList_ExtraPlusArea) == 0x000050, "Member 'UAIScoreModuleRule::ScoreModuleList_ExtraPlusArea' has a wrong offset!");

// Class MarvelAI.ShelterPathFinder
// 0x0040 (0x0070 - 0x0030)
class UShelterPathFinder final : public UObject
{
public:
	struct FShelterPathFindConfig                 PathFindConfig;                                    // 0x0030(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	EPathFollowingRequestResult RequestMove(class AMarvelAIController* AIOwner, const struct FVector& TargetLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterPathFinder">();
	}
	static class UShelterPathFinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShelterPathFinder>();
	}
};
static_assert(alignof(UShelterPathFinder) == 0x000008, "Wrong alignment on UShelterPathFinder");
static_assert(sizeof(UShelterPathFinder) == 0x000070, "Wrong size on UShelterPathFinder");
static_assert(offsetof(UShelterPathFinder, PathFindConfig) == 0x000030, "Member 'UShelterPathFinder::PathFindConfig' has a wrong offset!");

// Class MarvelAI.ShelterPathTestActor
// 0x0038 (0x04C8 - 0x0490)
class AShelterPathTestActor final : public AActor
{
public:
	TSubclassOf<class UShelterPathFinder>         PathFinderClass;                                   // 0x0490(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x0498(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        EnemiesLocation;                                   // 0x04B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UShelterPathFinder*                     TempPathFinder;                                    // 0x04C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void TestFindPath();

	void EnableDrawDebug() const;
	void FlushDebugLines() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterPathTestActor">();
	}
	static class AShelterPathTestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShelterPathTestActor>();
	}
};
static_assert(alignof(AShelterPathTestActor) == 0x000008, "Wrong alignment on AShelterPathTestActor");
static_assert(sizeof(AShelterPathTestActor) == 0x0004C8, "Wrong size on AShelterPathTestActor");
static_assert(offsetof(AShelterPathTestActor, PathFinderClass) == 0x000490, "Member 'AShelterPathTestActor::PathFinderClass' has a wrong offset!");
static_assert(offsetof(AShelterPathTestActor, TargetLocation) == 0x000498, "Member 'AShelterPathTestActor::TargetLocation' has a wrong offset!");
static_assert(offsetof(AShelterPathTestActor, EnemiesLocation) == 0x0004B0, "Member 'AShelterPathTestActor::EnemiesLocation' has a wrong offset!");
static_assert(offsetof(AShelterPathTestActor, TempPathFinder) == 0x0004C0, "Member 'AShelterPathTestActor::TempPathFinder' has a wrong offset!");

// Class MarvelAI.SniperStandPoint
// 0x0008 (0x0568 - 0x0560)
class ASniperStandPoint final : public AStandPointBase
{
public:
	float                                         WarningRadius;                                     // 0x0560(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_564[0x4];                                      // 0x0564(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckEnemyIsInWarningRange(class AActor* EnemyActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SniperStandPoint">();
	}
	static class ASniperStandPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASniperStandPoint>();
	}
};
static_assert(alignof(ASniperStandPoint) == 0x000008, "Wrong alignment on ASniperStandPoint");
static_assert(sizeof(ASniperStandPoint) == 0x000568, "Wrong size on ASniperStandPoint");
static_assert(offsetof(ASniperStandPoint, WarningRadius) == 0x000560, "Member 'ASniperStandPoint::WarningRadius' has a wrong offset!");

// Class MarvelAI.StandPointRecorder
// 0x0050 (0x0080 - 0x0030)
class UStandPointRecorder : public UObject
{
public:
	TMap<class FName, class AStandPointBase*>     StandPointMap;                                     // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	class AStandPointBase* FindStandPoint(const class FName& PointName);
	TArray<class AStandPointBase*> GetPointsByClassWithRadius(TSubclassOf<class AStandPointBase> PointClass, const struct FVector& Center, float Radius);
	TArray<class AStandPointBase*> GetStandPointsByClass(TSubclassOf<class AStandPointBase> PointClass);
	TArray<class AStandPointBase*> GetValidAbilityUsagePoints(class AMarvelBaseCharacter* ToCheckHero, class UAIAbilityUsageObject* ToCheckUsage);
	void RegisterStandPoint(class AStandPointBase* StandPoint);
	void UnRegisterStandPoint(class AStandPointBase* StandPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StandPointRecorder">();
	}
	static class UStandPointRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStandPointRecorder>();
	}
};
static_assert(alignof(UStandPointRecorder) == 0x000008, "Wrong alignment on UStandPointRecorder");
static_assert(sizeof(UStandPointRecorder) == 0x000080, "Wrong size on UStandPointRecorder");
static_assert(offsetof(UStandPointRecorder, StandPointMap) == 0x000030, "Member 'UStandPointRecorder::StandPointMap' has a wrong offset!");

// Class MarvelAI.WayPoint
// 0x0050 (0x0508 - 0x04B8)
class AWayPoint : public AAISceneConfigActorBase
{
public:
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GoalRandomRadius;                                  // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinFlyHeight;                                      // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFlyHeight;                                      // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPrepareArea;                                    // 0x04CC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CD[0x3];                                      // 0x04CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrepareAreaComponent*                  PrepareAreaComp;                                   // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EWayPointMark>                         WaypointPathTypeMarks;                             // 0x04D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWayPointToWeight>              NextWayPointsWithWeight;                           // 0x04E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRange_FloatValue                      RequiredPayloadProgress;                           // 0x04F8(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          EnableControlAIRotation;                           // 0x0500(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedWait;                                          // 0x0501(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_502[0x2];                                      // 0x0502(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitTime;                                          // 0x0504(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CheckValid();
	class AWayPoint* SelectNextWayPoint(class AActor* ActorMovingAlong, class AActor* Target);

	bool CheckIsProgressInRange(float CurrentProgress) const;
	float GetMaxSafeFactorInNextRoutes() const;
	bool IsPrepareArea() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WayPoint">();
	}
	static class AWayPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWayPoint>();
	}
};
static_assert(alignof(AWayPoint) == 0x000008, "Wrong alignment on AWayPoint");
static_assert(sizeof(AWayPoint) == 0x000508, "Wrong size on AWayPoint");
static_assert(offsetof(AWayPoint, GoalRandomRadius) == 0x0004C0, "Member 'AWayPoint::GoalRandomRadius' has a wrong offset!");
static_assert(offsetof(AWayPoint, MinFlyHeight) == 0x0004C4, "Member 'AWayPoint::MinFlyHeight' has a wrong offset!");
static_assert(offsetof(AWayPoint, MaxFlyHeight) == 0x0004C8, "Member 'AWayPoint::MaxFlyHeight' has a wrong offset!");
static_assert(offsetof(AWayPoint, bIsPrepareArea) == 0x0004CC, "Member 'AWayPoint::bIsPrepareArea' has a wrong offset!");
static_assert(offsetof(AWayPoint, PrepareAreaComp) == 0x0004D0, "Member 'AWayPoint::PrepareAreaComp' has a wrong offset!");
static_assert(offsetof(AWayPoint, WaypointPathTypeMarks) == 0x0004D8, "Member 'AWayPoint::WaypointPathTypeMarks' has a wrong offset!");
static_assert(offsetof(AWayPoint, NextWayPointsWithWeight) == 0x0004E8, "Member 'AWayPoint::NextWayPointsWithWeight' has a wrong offset!");
static_assert(offsetof(AWayPoint, RequiredPayloadProgress) == 0x0004F8, "Member 'AWayPoint::RequiredPayloadProgress' has a wrong offset!");
static_assert(offsetof(AWayPoint, EnableControlAIRotation) == 0x000500, "Member 'AWayPoint::EnableControlAIRotation' has a wrong offset!");
static_assert(offsetof(AWayPoint, NeedWait) == 0x000501, "Member 'AWayPoint::NeedWait' has a wrong offset!");
static_assert(offsetof(AWayPoint, WaitTime) == 0x000504, "Member 'AWayPoint::WaitTime' has a wrong offset!");

// Class MarvelAI.StartWayPoint
// 0x0070 (0x0578 - 0x0508)
class AStartWayPoint final : public AWayPoint
{
public:
	uint8                                         Pad_508[0x20];                                     // 0x0508(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWayPointPath                          CurrentWayPointPath;                               // 0x0528(0x0048)(NativeAccessSpecifierPrivate)
	float                                         PathValidDurationAfterFetch;                       // 0x0570(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static EWayPointMark GetMarkFromActor(class AActor* ActorMovingAlong);

	void FetchWayPointPath(class AActor* ActorMovingAlong, class AActor* Target, struct FWayPointPath* OutWayPointPath, bool UseLastValidPath);
	void GenerateWayPointPath(class AActor* ActorMovingAlong, class AWayPoint* Target, struct FWayPointPath* OutWayPointPath);
	void GenerateWayPointPathByMark(EWayPointMark WayPointMark, class AActor* FinalTarget, struct FWayPointPath* OutWayPointPath);
	struct FWayPointPath PyFetchWayPointPath(class AActor* ActorMovingAlong, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartWayPoint">();
	}
	static class AStartWayPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStartWayPoint>();
	}
};
static_assert(alignof(AStartWayPoint) == 0x000008, "Wrong alignment on AStartWayPoint");
static_assert(sizeof(AStartWayPoint) == 0x000578, "Wrong size on AStartWayPoint");
static_assert(offsetof(AStartWayPoint, CurrentWayPointPath) == 0x000528, "Member 'AStartWayPoint::CurrentWayPointPath' has a wrong offset!");
static_assert(offsetof(AStartWayPoint, PathValidDurationAfterFetch) == 0x000570, "Member 'AStartWayPoint::PathValidDurationAfterFetch' has a wrong offset!");

// Class MarvelAI.SteeringLimiter
// 0x0000 (0x0030 - 0x0030)
class ISteeringLimiter : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringLimiter">();
	}
	static class ISteeringLimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISteeringLimiter>();
	}
};
static_assert(alignof(ISteeringLimiter) == 0x000008, "Wrong alignment on ISteeringLimiter");
static_assert(sizeof(ISteeringLimiter) == 0x000030, "Wrong size on ISteeringLimiter");

// Class MarvelAI.Steerable
// 0x0000 (0x0030 - 0x0030)
class ISteerable final : public ISteeringLimiter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Steerable">();
	}
	static class ISteerable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISteerable>();
	}
};
static_assert(alignof(ISteerable) == 0x000008, "Wrong alignment on ISteerable");
static_assert(sizeof(ISteerable) == 0x000030, "Wrong size on ISteerable");

// Class MarvelAI.SteeringBehavior
// 0x0020 (0x0050 - 0x0030)
class USteeringBehavior : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedContextMarkAngleInDegree;                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 DrawDebugColor;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DrawDebugLengthFactor;                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDrawDebug;                                  // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehavior">();
	}
	static class USteeringBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehavior>();
	}
};
static_assert(alignof(USteeringBehavior) == 0x000008, "Wrong alignment on USteeringBehavior");
static_assert(sizeof(USteeringBehavior) == 0x000050, "Wrong size on USteeringBehavior");
static_assert(offsetof(USteeringBehavior, FixedContextMarkAngleInDegree) == 0x000040, "Member 'USteeringBehavior::FixedContextMarkAngleInDegree' has a wrong offset!");
static_assert(offsetof(USteeringBehavior, DrawDebugColor) == 0x000044, "Member 'USteeringBehavior::DrawDebugColor' has a wrong offset!");
static_assert(offsetof(USteeringBehavior, DrawDebugLengthFactor) == 0x000048, "Member 'USteeringBehavior::DrawDebugLengthFactor' has a wrong offset!");
static_assert(offsetof(USteeringBehavior, bShouldDrawDebug) == 0x00004C, "Member 'USteeringBehavior::bShouldDrawDebug' has a wrong offset!");

// Class MarvelAI.Steering_AvoidDamage
// 0x0090 (0x00E0 - 0x0050)
class USteering_AvoidDamage final : public USteeringBehavior
{
public:
	float                                         ConsiderRangeForDamageArea;                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AllowDistanceForNoUpdate;                          // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalRadiusToStartAvoid;                      // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalForceToLeaveWhenNotIn;                   // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyConsiderBestOne;                              // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAgentManager*                    CachedAbilityAgentManager;                         // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x70];                                      // 0x0070(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Steering_AvoidDamage">();
	}
	static class USteering_AvoidDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteering_AvoidDamage>();
	}
};
static_assert(alignof(USteering_AvoidDamage) == 0x000008, "Wrong alignment on USteering_AvoidDamage");
static_assert(sizeof(USteering_AvoidDamage) == 0x0000E0, "Wrong size on USteering_AvoidDamage");
static_assert(offsetof(USteering_AvoidDamage, ConsiderRangeForDamageArea) == 0x000050, "Member 'USteering_AvoidDamage::ConsiderRangeForDamageArea' has a wrong offset!");
static_assert(offsetof(USteering_AvoidDamage, AllowDistanceForNoUpdate) == 0x000054, "Member 'USteering_AvoidDamage::AllowDistanceForNoUpdate' has a wrong offset!");
static_assert(offsetof(USteering_AvoidDamage, AdditionalRadiusToStartAvoid) == 0x000058, "Member 'USteering_AvoidDamage::AdditionalRadiusToStartAvoid' has a wrong offset!");
static_assert(offsetof(USteering_AvoidDamage, AdditionalForceToLeaveWhenNotIn) == 0x00005C, "Member 'USteering_AvoidDamage::AdditionalForceToLeaveWhenNotIn' has a wrong offset!");
static_assert(offsetof(USteering_AvoidDamage, bOnlyConsiderBestOne) == 0x000060, "Member 'USteering_AvoidDamage::bOnlyConsiderBestOne' has a wrong offset!");
static_assert(offsetof(USteering_AvoidDamage, CachedAbilityAgentManager) == 0x000068, "Member 'USteering_AvoidDamage::CachedAbilityAgentManager' has a wrong offset!");

// Class MarvelAI.Steering_AvoidFireLine
// 0x0030 (0x0080 - 0x0050)
class USteering_AvoidFireLine final : public USteeringBehavior
{
public:
	float                                         RunEQSDeltaTime;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              QueryTemplate;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkipDistance;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x1C];                                      // 0x0064(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Steering_AvoidFireLine">();
	}
	static class USteering_AvoidFireLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteering_AvoidFireLine>();
	}
};
static_assert(alignof(USteering_AvoidFireLine) == 0x000008, "Wrong alignment on USteering_AvoidFireLine");
static_assert(sizeof(USteering_AvoidFireLine) == 0x000080, "Wrong size on USteering_AvoidFireLine");
static_assert(offsetof(USteering_AvoidFireLine, RunEQSDeltaTime) == 0x000050, "Member 'USteering_AvoidFireLine::RunEQSDeltaTime' has a wrong offset!");
static_assert(offsetof(USteering_AvoidFireLine, QueryTemplate) == 0x000058, "Member 'USteering_AvoidFireLine::QueryTemplate' has a wrong offset!");
static_assert(offsetof(USteering_AvoidFireLine, SkipDistance) == 0x000060, "Member 'USteering_AvoidFireLine::SkipDistance' has a wrong offset!");

// Class MarvelAI.Steering_AvoidFromImpact
// 0x0030 (0x0080 - 0x0050)
class USteering_AvoidFromImpact final : public USteeringBehavior
{
public:
	float                                         Duration;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x2C];                                      // 0x0054(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Steering_AvoidFromImpact">();
	}
	static class USteering_AvoidFromImpact* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteering_AvoidFromImpact>();
	}
};
static_assert(alignof(USteering_AvoidFromImpact) == 0x000008, "Wrong alignment on USteering_AvoidFromImpact");
static_assert(sizeof(USteering_AvoidFromImpact) == 0x000080, "Wrong size on USteering_AvoidFromImpact");
static_assert(offsetof(USteering_AvoidFromImpact, Duration) == 0x000050, "Member 'USteering_AvoidFromImpact::Duration' has a wrong offset!");

// Class MarvelAI.Steering_AvoidNavBorder
// 0x0688 (0x06D8 - 0x0050)
class USteering_AvoidNavBorder final : public USteeringBehavior
{
public:
	float                                         NavMeshBlockCheckDistance;                         // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlockValidDuration;                                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseInverseVelocityToAvoid;                        // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScaleAvoidByPastTime;                             // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxMoveWrongDirSampleMaxCount;                     // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x678];                                     // 0x0060(0x0678)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Steering_AvoidNavBorder">();
	}
	static class USteering_AvoidNavBorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteering_AvoidNavBorder>();
	}
};
static_assert(alignof(USteering_AvoidNavBorder) == 0x000008, "Wrong alignment on USteering_AvoidNavBorder");
static_assert(sizeof(USteering_AvoidNavBorder) == 0x0006D8, "Wrong size on USteering_AvoidNavBorder");
static_assert(offsetof(USteering_AvoidNavBorder, NavMeshBlockCheckDistance) == 0x000050, "Member 'USteering_AvoidNavBorder::NavMeshBlockCheckDistance' has a wrong offset!");
static_assert(offsetof(USteering_AvoidNavBorder, BlockValidDuration) == 0x000054, "Member 'USteering_AvoidNavBorder::BlockValidDuration' has a wrong offset!");
static_assert(offsetof(USteering_AvoidNavBorder, bUseInverseVelocityToAvoid) == 0x000058, "Member 'USteering_AvoidNavBorder::bUseInverseVelocityToAvoid' has a wrong offset!");
static_assert(offsetof(USteering_AvoidNavBorder, bScaleAvoidByPastTime) == 0x000059, "Member 'USteering_AvoidNavBorder::bScaleAvoidByPastTime' has a wrong offset!");
static_assert(offsetof(USteering_AvoidNavBorder, MaxMoveWrongDirSampleMaxCount) == 0x00005C, "Member 'USteering_AvoidNavBorder::MaxMoveWrongDirSampleMaxCount' has a wrong offset!");

// Class MarvelAI.Steering_Blend
// 0x0028 (0x0078 - 0x0050)
class USteering_Blend final : public USteeringBehavior
{
public:
	TArray<struct FSteeringWithWeight>            SteeringWithWeights;                               // 0x0050(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseContext;                                       // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ContextSampleNum;                                  // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62[0x16];                                      // 0x0062(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Steering_Blend">();
	}
	static class USteering_Blend* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteering_Blend>();
	}
};
static_assert(alignof(USteering_Blend) == 0x000008, "Wrong alignment on USteering_Blend");
static_assert(sizeof(USteering_Blend) == 0x000078, "Wrong size on USteering_Blend");
static_assert(offsetof(USteering_Blend, SteeringWithWeights) == 0x000050, "Member 'USteering_Blend::SteeringWithWeights' has a wrong offset!");
static_assert(offsetof(USteering_Blend, bUseContext) == 0x000060, "Member 'USteering_Blend::bUseContext' has a wrong offset!");
static_assert(offsetof(USteering_Blend, ContextSampleNum) == 0x000061, "Member 'USteering_Blend::ContextSampleNum' has a wrong offset!");

// Class MarvelAI.Steering_CrossMove
// 0x0000 (0x0050 - 0x0050)
class USteering_CrossMove final : public USteeringBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Steering_CrossMove">();
	}
	static class USteering_CrossMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteering_CrossMove>();
	}
};
static_assert(alignof(USteering_CrossMove) == 0x000008, "Wrong alignment on USteering_CrossMove");
static_assert(sizeof(USteering_CrossMove) == 0x000050, "Wrong size on USteering_CrossMove");

// Class MarvelAI.Steering_PathFollow
// 0x0000 (0x0050 - 0x0050)
class USteering_PathFollow final : public USteeringBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Steering_PathFollow">();
	}
	static class USteering_PathFollow* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteering_PathFollow>();
	}
};
static_assert(alignof(USteering_PathFollow) == 0x000008, "Wrong alignment on USteering_PathFollow");
static_assert(sizeof(USteering_PathFollow) == 0x000050, "Wrong size on USteering_PathFollow");

// Class MarvelAI.StrategyPointActor
// 0x0010 (0x04C8 - 0x04B8)
class AStrategyPointActor final : public AAISceneConfigActorBase
{
public:
	int32                                         GroupId;                                           // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsMainInGroup : 1;                                // 0x04BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsShelter : 1;                                    // 0x04BC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4BD[0x3];                                      // 0x04BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FShelterInstanceData                   ShelterData;                                       // 0x04C0(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	void SetShelterIsBroken(bool bNewIsBroken);

	void DebugDrawPointData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrategyPointActor">();
	}
	static class AStrategyPointActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStrategyPointActor>();
	}
};
static_assert(alignof(AStrategyPointActor) == 0x000008, "Wrong alignment on AStrategyPointActor");
static_assert(sizeof(AStrategyPointActor) == 0x0004C8, "Wrong size on AStrategyPointActor");
static_assert(offsetof(AStrategyPointActor, GroupId) == 0x0004B8, "Member 'AStrategyPointActor::GroupId' has a wrong offset!");
static_assert(offsetof(AStrategyPointActor, ShelterData) == 0x0004C0, "Member 'AStrategyPointActor::ShelterData' has a wrong offset!");

// Class MarvelAI.StrategyPointSubsystem
// 0x0078 (0x00B0 - 0x0038)
class UStrategyPointSubsystem final : public UWorldSubsystem
{
public:
	TArray<float>                                 AgentHeightLevels;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x68];                                      // 0x0048(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugDrawPoints();
	TArray<class AStrategyPointActor*> GetAllStrategyPointActors();
	TArray<class AStrategyPointActor*> GetAllStrategyPointActorsWithRadius(const struct FVector& Center, float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrategyPointSubsystem">();
	}
	static class UStrategyPointSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStrategyPointSubsystem>();
	}
};
static_assert(alignof(UStrategyPointSubsystem) == 0x000008, "Wrong alignment on UStrategyPointSubsystem");
static_assert(sizeof(UStrategyPointSubsystem) == 0x0000B0, "Wrong size on UStrategyPointSubsystem");
static_assert(offsetof(UStrategyPointSubsystem, AgentHeightLevels) == 0x000038, "Member 'UStrategyPointSubsystem::AgentHeightLevels' has a wrong offset!");

// Class MarvelAI.SVONPathFindTester
// 0x00D8 (0x0590 - 0x04B8)
class ASVONPathFindTester final : public AAISceneConfigActorBase
{
public:
	class AActor*                                 TestStartActor;                                    // 0x04B8(0x0008)(Edit, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TestTargetActor;                                   // 0x04C0(0x0008)(Edit, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyTestValidPath;                                // 0x04C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C9[0x3];                                      // 0x04C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TestCategoryIndex;                                 // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CertainTestCaseIndex;                              // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckPathLength;                                  // 0x04D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D5[0x3];                                      // 0x04D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            AllowedPathLengthDiffRange;                        // 0x04D8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckPathIsTheSame;                               // 0x04E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawDebugPath;                                    // 0x04E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawDebugTargetPath;                              // 0x04EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EB[0x1];                                      // 0x04EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDebugDuration;                                 // 0x04EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DrawDebugThickness;                                // 0x04F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowGenerateTestCaseForSingleActor;              // 0x04F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F5[0x3];                                      // 0x04F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActorLocationRandomRadius;                         // 0x04F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TestCaseGenerateTryTimes;                          // 0x04FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireTestCaseHavePath;                          // 0x0500(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldTakeDataFromRuntimeDataVolume;              // 0x0501(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_502[0x6];                                      // 0x0502(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPathTestCaseCategory>          TestCaseCategories;                                // 0x0508(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPathFindTestCase>              TestCaseList;                                      // 0x0518(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldStoreStatData;                              // 0x0528(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_529[0x7];                                      // 0x0529(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FAStarStat>                StatForLastTestList;                               // 0x0530(0x0050)(Edit, Transient, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnablePathPostProcess;                            // 0x0580(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_581[0x7];                                      // 0x0581(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USVONNavigationComponent*               SVONavComp;                                        // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddConfigDataAsTestCase();
	void AnalyzeStatData();
	void ClassifyTestCases();
	void GenerateRandomTestCasesFromActorList(const TArray<class AActor*>& ActorList, int32 TryTimes);
	void GenerateTestCaseFromWayPoints();
	bool MakeDataForTestCase(const struct FVector& StartPoint, const struct FVector& TargetPoint, bool bRequireHavePath);
	void ReceiveAnalyzeStatData();
	void UpdateTestCasePathResult();

	bool K2_FindPath(const struct FVector& StartPoint, const struct FVector& TargetPoint, TArray<struct FVector>* OutPathPoints) const;
	bool K2_RunCheckForCase(const struct FPathFindTestCase& TestCase) const;
	bool RunTestCaseWithIndexList(const TArray<int32>& CaseIndexList) const;
	void RunTestCategory(const struct FPathTestCaseCategory& TestCaseCategory) const;
	void RunTestCategoryByIndex() const;
	void TestAllCase() const;
	void TestAllCategory() const;
	void TestCertainCase() const;
	void UpdateVolume() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SVONPathFindTester">();
	}
	static class ASVONPathFindTester* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASVONPathFindTester>();
	}
};
static_assert(alignof(ASVONPathFindTester) == 0x000008, "Wrong alignment on ASVONPathFindTester");
static_assert(sizeof(ASVONPathFindTester) == 0x000590, "Wrong size on ASVONPathFindTester");
static_assert(offsetof(ASVONPathFindTester, TestStartActor) == 0x0004B8, "Member 'ASVONPathFindTester::TestStartActor' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, TestTargetActor) == 0x0004C0, "Member 'ASVONPathFindTester::TestTargetActor' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, bOnlyTestValidPath) == 0x0004C8, "Member 'ASVONPathFindTester::bOnlyTestValidPath' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, TestCategoryIndex) == 0x0004CC, "Member 'ASVONPathFindTester::TestCategoryIndex' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, CertainTestCaseIndex) == 0x0004D0, "Member 'ASVONPathFindTester::CertainTestCaseIndex' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, bCheckPathLength) == 0x0004D4, "Member 'ASVONPathFindTester::bCheckPathLength' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, AllowedPathLengthDiffRange) == 0x0004D8, "Member 'ASVONPathFindTester::AllowedPathLengthDiffRange' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, bCheckPathIsTheSame) == 0x0004E8, "Member 'ASVONPathFindTester::bCheckPathIsTheSame' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, bDrawDebugPath) == 0x0004E9, "Member 'ASVONPathFindTester::bDrawDebugPath' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, bDrawDebugTargetPath) == 0x0004EA, "Member 'ASVONPathFindTester::bDrawDebugTargetPath' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, DrawDebugDuration) == 0x0004EC, "Member 'ASVONPathFindTester::DrawDebugDuration' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, DrawDebugThickness) == 0x0004F0, "Member 'ASVONPathFindTester::DrawDebugThickness' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, bAllowGenerateTestCaseForSingleActor) == 0x0004F4, "Member 'ASVONPathFindTester::bAllowGenerateTestCaseForSingleActor' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, ActorLocationRandomRadius) == 0x0004F8, "Member 'ASVONPathFindTester::ActorLocationRandomRadius' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, TestCaseGenerateTryTimes) == 0x0004FC, "Member 'ASVONPathFindTester::TestCaseGenerateTryTimes' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, bRequireTestCaseHavePath) == 0x000500, "Member 'ASVONPathFindTester::bRequireTestCaseHavePath' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, bShouldTakeDataFromRuntimeDataVolume) == 0x000501, "Member 'ASVONPathFindTester::bShouldTakeDataFromRuntimeDataVolume' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, TestCaseCategories) == 0x000508, "Member 'ASVONPathFindTester::TestCaseCategories' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, TestCaseList) == 0x000518, "Member 'ASVONPathFindTester::TestCaseList' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, bShouldStoreStatData) == 0x000528, "Member 'ASVONPathFindTester::bShouldStoreStatData' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, StatForLastTestList) == 0x000530, "Member 'ASVONPathFindTester::StatForLastTestList' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, bEnablePathPostProcess) == 0x000580, "Member 'ASVONPathFindTester::bEnablePathPostProcess' has a wrong offset!");
static_assert(offsetof(ASVONPathFindTester, SVONavComp) == 0x000588, "Member 'ASVONPathFindTester::SVONavComp' has a wrong offset!");

// Class MarvelAI.WayPointRandomSelectComponent
// 0x0038 (0x0128 - 0x00F0)
class UWayPointRandomSelectComponent final : public UActorComponent
{
public:
	TArray<EWayPointMark>                         WaypointPathTypeMarks;                             // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWayPointToWeight>              NextWayPointsWithWeight;                           // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DebugDrawDuration;                                 // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x14];                                     // 0x0114(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugDraw();
	class AActor* SelectNextWayPoint(class AActor* ActorMovingAlong, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WayPointRandomSelectComponent">();
	}
	static class UWayPointRandomSelectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWayPointRandomSelectComponent>();
	}
};
static_assert(alignof(UWayPointRandomSelectComponent) == 0x000008, "Wrong alignment on UWayPointRandomSelectComponent");
static_assert(sizeof(UWayPointRandomSelectComponent) == 0x000128, "Wrong size on UWayPointRandomSelectComponent");
static_assert(offsetof(UWayPointRandomSelectComponent, WaypointPathTypeMarks) == 0x0000F0, "Member 'UWayPointRandomSelectComponent::WaypointPathTypeMarks' has a wrong offset!");
static_assert(offsetof(UWayPointRandomSelectComponent, NextWayPointsWithWeight) == 0x000100, "Member 'UWayPointRandomSelectComponent::NextWayPointsWithWeight' has a wrong offset!");
static_assert(offsetof(UWayPointRandomSelectComponent, DebugDrawDuration) == 0x000110, "Member 'UWayPointRandomSelectComponent::DebugDrawDuration' has a wrong offset!");

// Class MarvelAI.WayPointPathFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UWayPointPathFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BuildDefaultSimplePath(struct FWayPointPath& WayPointPath, class AActor* MovingActor, class AActor* FinalTarget);
	static void Clear(struct FWayPointPath& WayPointPath);
	static class AActor* GetCurrentWayPoint(struct FWayPointPath& WayPointPath);
	static class AActor* GetFinalTarget(struct FWayPointPath& WayPointPath);
	static bool GoNext(struct FWayPointPath& WayPointPath);
	static void InitPathForMovingActor(struct FWayPointPath& WayPointPath, class AActor* MovingActor, bool ShouldUpdateProgress, EWayPointMark PathMark);
	static bool IsMovingActorOutOfPath(const struct FWayPointPath& WayPointPath, float AllowedRadius);
	static bool IsPathFinished(const struct FWayPointPath& WayPointPath);
	static bool IsPathValid(const struct FWayPointPath& WayPointPath);
	static bool IsRingPath(struct FWayPointPath& WayPointPath);
	static void MarkRingPath(struct FWayPointPath& WayPointPath, class AActor* RingStartPoint);
	static void ResetProgress(struct FWayPointPath& WayPointPath);
	static void SetPathMark(struct FWayPointPath& WayPointPath, EWayPointMark NewWayPointMark);
	static struct FVector TakeNextLocationToReach(struct FWayPointPath& WayPointPath);
	static void UpdateProgressInPath(struct FWayPointPath& WayPointPath);
	static bool UpdateSafeFactorForRoutes(const struct FWayPointPath& WayPointPath, float SafeFactor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WayPointPathFunctionLibrary">();
	}
	static class UWayPointPathFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWayPointPathFunctionLibrary>();
	}
};
static_assert(alignof(UWayPointPathFunctionLibrary) == 0x000008, "Wrong alignment on UWayPointPathFunctionLibrary");
static_assert(sizeof(UWayPointPathFunctionLibrary) == 0x000030, "Wrong size on UWayPointPathFunctionLibrary");

// Class MarvelAI.BTT_MoveWait
// 0x0008 (0x0088 - 0x0080)
class UBTT_MoveWait final : public UBTTask_Wait
{
public:
	bool                                          OverrideWaitTime;                                  // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_MoveWait">();
	}
	static class UBTT_MoveWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_MoveWait>();
	}
};
static_assert(alignof(UBTT_MoveWait) == 0x000008, "Wrong alignment on UBTT_MoveWait");
static_assert(sizeof(UBTT_MoveWait) == 0x000088, "Wrong size on UBTT_MoveWait");
static_assert(offsetof(UBTT_MoveWait, OverrideWaitTime) == 0x000080, "Member 'UBTT_MoveWait::OverrideWaitTime' has a wrong offset!");

}

