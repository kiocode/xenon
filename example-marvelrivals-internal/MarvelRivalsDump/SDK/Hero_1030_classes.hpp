#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1030

#include "Basic.hpp"

#include "Hero_1030_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Hero_1026_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"


namespace SDK
{

// Class Hero_1030.Config_103021
// 0x1048 (0x1110 - 0x00C8)
class UConfig_103021 final : public UConfig_106
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProjectileConductInfo                 ConductInfo;                                       // 0x00D0(0x1030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         TargetBuffID;                                      // 0x1100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnkaSummonerID;                                    // 0x1104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnhancedAnkaSummonedID;                            // 0x1108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110C[0x4];                                     // 0x110C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103021">();
	}
	static class UConfig_103021* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103021>();
	}
};
static_assert(alignof(UConfig_103021) == 0x000010, "Wrong alignment on UConfig_103021");
static_assert(sizeof(UConfig_103021) == 0x001110, "Wrong size on UConfig_103021");
static_assert(offsetof(UConfig_103021, ConductInfo) == 0x0000D0, "Member 'UConfig_103021::ConductInfo' has a wrong offset!");
static_assert(offsetof(UConfig_103021, TargetBuffID) == 0x001100, "Member 'UConfig_103021::TargetBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103021, AnkaSummonerID) == 0x001104, "Member 'UConfig_103021::AnkaSummonerID' has a wrong offset!");
static_assert(offsetof(UConfig_103021, EnhancedAnkaSummonedID) == 0x001108, "Member 'UConfig_103021::EnhancedAnkaSummonedID' has a wrong offset!");

// Class Hero_1030.ProjectileConductBase
// 0x1050 (0x40A0 - 0x3050)
class AProjectileConductBase : public AMarvelAbilityTargetActor_Projectile
{
public:
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x3050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103021*                         AbilityConfig;                                     // 0x3058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3060[0x10];                                    // 0x3060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class AActor>, int32>     ConductedTargets;                                  // 0x3070(0x0050)(Transient, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  LastTarget;                                        // 0x30C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HomingTarget;                                      // 0x30C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HomingSource;                                      // 0x30D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       AbsorbedMovingComponent;                           // 0x30D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30E0[0x18];                                    // 0x30E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PendingAbsorbedAnka;                               // 0x30F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3100[0xFA0];                                   // 0x3100(0x0FA0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void RemoteProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileConductBase">();
	}
	static class AProjectileConductBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileConductBase>();
	}
};
static_assert(alignof(AProjectileConductBase) == 0x000010, "Wrong alignment on AProjectileConductBase");
static_assert(sizeof(AProjectileConductBase) == 0x0040A0, "Wrong size on AProjectileConductBase");
static_assert(offsetof(AProjectileConductBase, OwnerCharacter) == 0x003050, "Member 'AProjectileConductBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, AbilityConfig) == 0x003058, "Member 'AProjectileConductBase::AbilityConfig' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, ConductedTargets) == 0x003070, "Member 'AProjectileConductBase::ConductedTargets' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, LastTarget) == 0x0030C0, "Member 'AProjectileConductBase::LastTarget' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, HomingTarget) == 0x0030C8, "Member 'AProjectileConductBase::HomingTarget' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, HomingSource) == 0x0030D0, "Member 'AProjectileConductBase::HomingSource' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, AbsorbedMovingComponent) == 0x0030D8, "Member 'AProjectileConductBase::AbsorbedMovingComponent' has a wrong offset!");
static_assert(offsetof(AProjectileConductBase, PendingAbsorbedAnka) == 0x0030F8, "Member 'AProjectileConductBase::PendingAbsorbedAnka' has a wrong offset!");

// Class Hero_1030.Projectile_10302101
// 0x0000 (0x40A0 - 0x40A0)
class AProjectile_10302101 : public AProjectileConductBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10302101">();
	}
	static class AProjectile_10302101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10302101>();
	}
};
static_assert(alignof(AProjectile_10302101) == 0x000010, "Wrong alignment on AProjectile_10302101");
static_assert(sizeof(AProjectile_10302101) == 0x0040A0, "Wrong size on AProjectile_10302101");

// Class Hero_1030.ConductProjectileMovement
// 0x0000 (0x1FF0 - 0x1FF0)
class UConductProjectileMovement final : public UMarvelProjectileComponent
{
public:
	float                                         DeltaRadius;                                       // 0x1FE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncTargetPoint;                                  // 0x1FEC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FED[0x3];                                     // 0x1FED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConductProjectileMovement">();
	}
	static class UConductProjectileMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConductProjectileMovement>();
	}
};
static_assert(alignof(UConductProjectileMovement) == 0x000010, "Wrong alignment on UConductProjectileMovement");
static_assert(sizeof(UConductProjectileMovement) == 0x001FF0, "Wrong size on UConductProjectileMovement");
static_assert(offsetof(UConductProjectileMovement, DeltaRadius) == 0x001FE8, "Member 'UConductProjectileMovement::DeltaRadius' has a wrong offset!");
static_assert(offsetof(UConductProjectileMovement, bSyncTargetPoint) == 0x001FEC, "Member 'UConductProjectileMovement::bSyncTargetPoint' has a wrong offset!");

// Class Hero_1030.Ability_103031
// 0x0000 (0x2580 - 0x2580)
class UAbility_103031 final : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103031">();
	}
	static class UAbility_103031* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103031>();
	}
};
static_assert(alignof(UAbility_103031) == 0x000008, "Wrong alignment on UAbility_103031");
static_assert(sizeof(UAbility_103031) == 0x002580, "Wrong size on UAbility_103031");

// Class Hero_1030.Cue_Ability_Loop_10303101
// 0x0008 (0x0E58 - 0x0E50)
class ACue_Ability_Loop_10303101 final : public AMarvelCueNotify_Ability
{
public:
	class USkeletalMeshComponent*                 MoonWeaponMesh;                                    // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10303101">();
	}
	static class ACue_Ability_Loop_10303101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10303101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10303101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10303101");
static_assert(sizeof(ACue_Ability_Loop_10303101) == 0x000E58, "Wrong size on ACue_Ability_Loop_10303101");
static_assert(offsetof(ACue_Ability_Loop_10303101, MoonWeaponMesh) == 0x000E50, "Member 'ACue_Ability_Loop_10303101::MoonWeaponMesh' has a wrong offset!");

// Class Hero_1030.Config_103041
// 0x1038 (0x10D0 - 0x0098)
class UConfig_103041 final : public UMarvelAbilityConfig
{
public:
	TArray<int32>                                 SummonerDontSpawnAnka;                             // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         WallTraceDepth;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetOutsideWall;                                 // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetInsideWall;                                  // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00C0(0x0F90)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         AnkaSummonerID;                                    // 0x1050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageScopeID;                                     // 0x1054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldBuffID;                                      // 0x1058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorPerTarget;                                    // 0x105C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AddShieldTags;                                     // 0x1060(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C8[0x8];                                     // 0x10C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103041">();
	}
	static class UConfig_103041* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103041>();
	}
};
static_assert(alignof(UConfig_103041) == 0x000010, "Wrong alignment on UConfig_103041");
static_assert(sizeof(UConfig_103041) == 0x0010D0, "Wrong size on UConfig_103041");
static_assert(offsetof(UConfig_103041, SummonerDontSpawnAnka) == 0x000098, "Member 'UConfig_103041::SummonerDontSpawnAnka' has a wrong offset!");
static_assert(offsetof(UConfig_103041, WallTraceDepth) == 0x0000A8, "Member 'UConfig_103041::WallTraceDepth' has a wrong offset!");
static_assert(offsetof(UConfig_103041, OffsetOutsideWall) == 0x0000AC, "Member 'UConfig_103041::OffsetOutsideWall' has a wrong offset!");
static_assert(offsetof(UConfig_103041, OffsetInsideWall) == 0x0000B0, "Member 'UConfig_103041::OffsetInsideWall' has a wrong offset!");
static_assert(offsetof(UConfig_103041, TraceContext) == 0x0000C0, "Member 'UConfig_103041::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103041, AnkaSummonerID) == 0x001050, "Member 'UConfig_103041::AnkaSummonerID' has a wrong offset!");
static_assert(offsetof(UConfig_103041, DamageScopeID) == 0x001054, "Member 'UConfig_103041::DamageScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103041, ShieldBuffID) == 0x001058, "Member 'UConfig_103041::ShieldBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103041, ArmorPerTarget) == 0x00105C, "Member 'UConfig_103041::ArmorPerTarget' has a wrong offset!");
static_assert(offsetof(UConfig_103041, AddShieldTags) == 0x001060, "Member 'UConfig_103041::AddShieldTags' has a wrong offset!");

// Class Hero_1030.Projectile_10304101
// 0x0180 (0x31D0 - 0x3050)
class AProjectile_10304101 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	class UConfig_103041*                         AbilityConfig;                                     // 0x3050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3058[0x178];                                   // 0x3058(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10304101">();
	}
	static class AProjectile_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10304101>();
	}
};
static_assert(alignof(AProjectile_10304101) == 0x000010, "Wrong alignment on AProjectile_10304101");
static_assert(sizeof(AProjectile_10304101) == 0x0031D0, "Wrong size on AProjectile_10304101");
static_assert(offsetof(AProjectile_10304101, AbilityConfig) == 0x003050, "Member 'AProjectile_10304101::AbilityConfig' has a wrong offset!");

// Class Hero_1030.NotTreatFallAbility_10304101
// 0x0008 (0x12C0 - 0x12B8)
class UNotTreatFallAbility_10304101 : public UMarvelNotTreatFallAbility
{
public:
	class UConfig_103041*                         AbilityConfig;                                     // 0x12B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotTreatFallAbility_10304101">();
	}
	static class UNotTreatFallAbility_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotTreatFallAbility_10304101>();
	}
};
static_assert(alignof(UNotTreatFallAbility_10304101) == 0x000008, "Wrong alignment on UNotTreatFallAbility_10304101");
static_assert(sizeof(UNotTreatFallAbility_10304101) == 0x0012C0, "Wrong size on UNotTreatFallAbility_10304101");
static_assert(offsetof(UNotTreatFallAbility_10304101, AbilityConfig) == 0x0012B8, "Member 'UNotTreatFallAbility_10304101::AbilityConfig' has a wrong offset!");

// Class Hero_1030.Summoned_10304101
// 0x0010 (0x08A0 - 0x0890)
class ASummoned_10304101 : public AMarvelSummonerBase
{
public:
	class UMeshHiddenComponent*                   HiddenComponent;                                   // 0x0890(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_898[0x8];                                      // 0x0898(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10304101">();
	}
	static class ASummoned_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10304101>();
	}
};
static_assert(alignof(ASummoned_10304101) == 0x000010, "Wrong alignment on ASummoned_10304101");
static_assert(sizeof(ASummoned_10304101) == 0x0008A0, "Wrong size on ASummoned_10304101");
static_assert(offsetof(ASummoned_10304101, HiddenComponent) == 0x000890, "Member 'ASummoned_10304101::HiddenComponent' has a wrong offset!");

// Class Hero_1030.SummonedComp_10304101
// 0x0020 (0x0CC0 - 0x0CA0)
class USummonedComp_10304101 final : public UMarvelSummonedComponent
{
public:
	uint8                                         Pad_CA0[0x20];                                     // 0x0CA0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10304101">();
	}
	static class USummonedComp_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10304101>();
	}
};
static_assert(alignof(USummonedComp_10304101) == 0x000010, "Wrong alignment on USummonedComp_10304101");
static_assert(sizeof(USummonedComp_10304101) == 0x000CC0, "Wrong size on USummonedComp_10304101");

// Class Hero_1030.Scope_10304102
// 0x0010 (0x1710 - 0x1700)
class AScope_10304102 final : public AMarvelAbilityTargetActor_Scope
{
public:
	uint8                                         Pad_1700[0x10];                                    // 0x1700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void OnCharacterDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10304102">();
	}
	static class AScope_10304102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10304102>();
	}
};
static_assert(alignof(AScope_10304102) == 0x000010, "Wrong alignment on AScope_10304102");
static_assert(sizeof(AScope_10304102) == 0x001710, "Wrong size on AScope_10304102");

// Class Hero_1030.ScopeManager_10304102
// 0x0050 (0x0080 - 0x0030)
class UScopeManager_10304102 final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector DoCondition(class AActor* InActor, const struct FVector& Delta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScopeManager_10304102">();
	}
	static class UScopeManager_10304102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScopeManager_10304102>();
	}
};
static_assert(alignof(UScopeManager_10304102) == 0x000008, "Wrong alignment on UScopeManager_10304102");
static_assert(sizeof(UScopeManager_10304102) == 0x000080, "Wrong size on UScopeManager_10304102");

// Class Hero_1030.Cue_Buff_10304101
// 0x00A0 (0x10D8 - 0x1038)
class ACue_Buff_10304101 final : public AMarvelCueNotify_Buff
{
public:
	class UFXSystemAsset*                         LineEffectPartOne;                                 // 0x1038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         LineEffectPartTwo;                                 // 0x1040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFxMaterialsCurve                      ColorMaterial;                                     // 0x1048(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFxMaterialsCurve                      GoldColorMaterial;                                 // 0x1080(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         LightDuration;                                     // 0x10B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10BC[0x4];                                     // 0x10BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x10C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C8[0x10];                                    // 0x10C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10304101">();
	}
	static class ACue_Buff_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10304101>();
	}
};
static_assert(alignof(ACue_Buff_10304101) == 0x000008, "Wrong alignment on ACue_Buff_10304101");
static_assert(sizeof(ACue_Buff_10304101) == 0x0010D8, "Wrong size on ACue_Buff_10304101");
static_assert(offsetof(ACue_Buff_10304101, LineEffectPartOne) == 0x001038, "Member 'ACue_Buff_10304101::LineEffectPartOne' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, LineEffectPartTwo) == 0x001040, "Member 'ACue_Buff_10304101::LineEffectPartTwo' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, ColorMaterial) == 0x001048, "Member 'ACue_Buff_10304101::ColorMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, GoldColorMaterial) == 0x001080, "Member 'ACue_Buff_10304101::GoldColorMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, LightDuration) == 0x0010B8, "Member 'ACue_Buff_10304101::LightDuration' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, OwnerCharacter) == 0x0010C0, "Member 'ACue_Buff_10304101::OwnerCharacter' has a wrong offset!");

// Class Hero_1030.Cue_Summoner_Loop_10304101
// 0x0018 (0x0EA8 - 0x0E90)
class ACue_Summoner_Loop_10304101 final : public AMarvelCueNotify_Summoned
{
public:
	class AMarvelSummonerBase*                    OwnerSummoner;                                     // 0x0E90(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwnerInstigator;                                   // 0x0E98(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Anka;                                           // 0x0EA0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnOwnerSummonerDeath(class AActor* InSource, class AActor* InSourceAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10304101">();
	}
	static class ACue_Summoner_Loop_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10304101>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10304101) == 0x000008, "Wrong alignment on ACue_Summoner_Loop_10304101");
static_assert(sizeof(ACue_Summoner_Loop_10304101) == 0x000EA8, "Wrong size on ACue_Summoner_Loop_10304101");
static_assert(offsetof(ACue_Summoner_Loop_10304101, OwnerSummoner) == 0x000E90, "Member 'ACue_Summoner_Loop_10304101::OwnerSummoner' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10304101, OwnerInstigator) == 0x000E98, "Member 'ACue_Summoner_Loop_10304101::OwnerInstigator' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10304101, NS_Anka) == 0x000EA0, "Member 'ACue_Summoner_Loop_10304101::NS_Anka' has a wrong offset!");

// Class Hero_1030.Config_103051
// 0x0BC8 (0x0C60 - 0x0098)
class UConfig_103051 final : public UMarvelAbilityConfig
{
public:
	struct FDashAbilityInfo                       DashInfo;                                          // 0x0098(0x0BA8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bEnableOffsetZ;                                    // 0x0C40(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C41[0x3];                                      // 0x0C41(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashOffsetZ;                                       // 0x0C44(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDashDistance;                                   // 0x0C48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFlyDistance;                                    // 0x0C4C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableLaunchV;                                      // 0x0C50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableRecoverA;                                     // 0x0C54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndMontageWhenDashFinish;                         // 0x0C58(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C59[0x7];                                      // 0x0C59(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103051">();
	}
	static class UConfig_103051* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103051>();
	}
};
static_assert(alignof(UConfig_103051) == 0x000008, "Wrong alignment on UConfig_103051");
static_assert(sizeof(UConfig_103051) == 0x000C60, "Wrong size on UConfig_103051");
static_assert(offsetof(UConfig_103051, DashInfo) == 0x000098, "Member 'UConfig_103051::DashInfo' has a wrong offset!");
static_assert(offsetof(UConfig_103051, bEnableOffsetZ) == 0x000C40, "Member 'UConfig_103051::bEnableOffsetZ' has a wrong offset!");
static_assert(offsetof(UConfig_103051, DashOffsetZ) == 0x000C44, "Member 'UConfig_103051::DashOffsetZ' has a wrong offset!");
static_assert(offsetof(UConfig_103051, MaxDashDistance) == 0x000C48, "Member 'UConfig_103051::MaxDashDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103051, MaxFlyDistance) == 0x000C4C, "Member 'UConfig_103051::MaxFlyDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103051, CableLaunchV) == 0x000C50, "Member 'UConfig_103051::CableLaunchV' has a wrong offset!");
static_assert(offsetof(UConfig_103051, CableRecoverA) == 0x000C54, "Member 'UConfig_103051::CableRecoverA' has a wrong offset!");
static_assert(offsetof(UConfig_103051, bEndMontageWhenDashFinish) == 0x000C58, "Member 'UConfig_103051::bEndMontageWhenDashFinish' has a wrong offset!");

// Class Hero_1030.Ability_103051
// 0x01D8 (0x2760 - 0x2588)
class UAbility_103051 : public UAbility_108
{
public:
	class UConfig_103051*                         AbilityConfig;                                     // 0x2588(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitMovementModeChange*    MoveModeTask;                                      // 0x2590(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2598[0x1C8];                                   // 0x2598(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDashFinish(EDashStopReason Reason);
	void OnOwnerLanding(EMovementMode Mode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103051">();
	}
	static class UAbility_103051* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103051>();
	}
};
static_assert(alignof(UAbility_103051) == 0x000008, "Wrong alignment on UAbility_103051");
static_assert(sizeof(UAbility_103051) == 0x002760, "Wrong size on UAbility_103051");
static_assert(offsetof(UAbility_103051, AbilityConfig) == 0x002588, "Member 'UAbility_103051::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103051, MoveModeTask) == 0x002590, "Member 'UAbility_103051::MoveModeTask' has a wrong offset!");

// Class Hero_1030.Projectile_10305101
// 0x0000 (0x3050 - 0x3050)
class AProjectile_10305101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10305101">();
	}
	static class AProjectile_10305101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10305101>();
	}
};
static_assert(alignof(AProjectile_10305101) == 0x000010, "Wrong alignment on AProjectile_10305101");
static_assert(sizeof(AProjectile_10305101) == 0x003050, "Wrong size on AProjectile_10305101");

// Class Hero_1030.Cue_Projectile_Loop_10305101
// 0x0120 (0x0ED0 - 0x0DB0)
class ACue_Projectile_Loop_10305101 final : public AMarvelCueNotify_Projectile
{
public:
	class FName                                   CableAttachedSocket;                               // 0x0DB0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayFromHit;                                      // 0x0DBC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayFromDistance;                                 // 0x0DC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartParticleScale;                                // 0x0DC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0DC8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MinNumOfSegments;                                  // 0x0E30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E34[0x4];                                      // 0x0E34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ControlPointCurve;                                 // 0x0E38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoonKnightCableComponent*              CableComponent;                                    // 0x0E40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   HookComponent;                                     // 0x0E48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0E50(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AProjectile_10305101*                   OwnerProjectile;                                   // 0x0E58(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelGameplayAbility*                 OwningAbility;                                     // 0x0E60(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E68[0x68];                                     // 0x0E68(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGenericGameplayTagUpdate(const struct FGameplayTag& InTag, int32 Count);
	void PostCableUpdate(float DeltaSeconds);
	void PreCableUpdate(float DeltaSeconds);
	void SetCableVisibility(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10305101">();
	}
	static class ACue_Projectile_Loop_10305101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10305101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10305101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10305101");
static_assert(sizeof(ACue_Projectile_Loop_10305101) == 0x000ED0, "Wrong size on ACue_Projectile_Loop_10305101");
static_assert(offsetof(ACue_Projectile_Loop_10305101, CableAttachedSocket) == 0x000DB0, "Member 'ACue_Projectile_Loop_10305101::CableAttachedSocket' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, DelayFromHit) == 0x000DBC, "Member 'ACue_Projectile_Loop_10305101::DelayFromHit' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, DelayFromDistance) == 0x000DC0, "Member 'ACue_Projectile_Loop_10305101::DelayFromDistance' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, StartParticleScale) == 0x000DC4, "Member 'ACue_Projectile_Loop_10305101::StartParticleScale' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, TagContainer) == 0x000DC8, "Member 'ACue_Projectile_Loop_10305101::TagContainer' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, MinNumOfSegments) == 0x000E30, "Member 'ACue_Projectile_Loop_10305101::MinNumOfSegments' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, ControlPointCurve) == 0x000E38, "Member 'ACue_Projectile_Loop_10305101::ControlPointCurve' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, CableComponent) == 0x000E40, "Member 'ACue_Projectile_Loop_10305101::CableComponent' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, HookComponent) == 0x000E48, "Member 'ACue_Projectile_Loop_10305101::HookComponent' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, OwnerCharacter) == 0x000E50, "Member 'ACue_Projectile_Loop_10305101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, OwnerProjectile) == 0x000E58, "Member 'ACue_Projectile_Loop_10305101::OwnerProjectile' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, OwningAbility) == 0x000E60, "Member 'ACue_Projectile_Loop_10305101::OwningAbility' has a wrong offset!");

// Class Hero_1030.MoonKnightCableComponent
// 0x0000 (0x0BB0 - 0x0BB0)
class UMoonKnightCableComponent final : public UMarvelCableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightCableComponent">();
	}
	static class UMoonKnightCableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonKnightCableComponent>();
	}
};
static_assert(alignof(UMoonKnightCableComponent) == 0x000010, "Wrong alignment on UMoonKnightCableComponent");
static_assert(sizeof(UMoonKnightCableComponent) == 0x000BB0, "Wrong size on UMoonKnightCableComponent");

// Class Hero_1030.Config_103052
// 0x0020 (0x1120 - 0x1100)
class UConfig_103052 final : public UConfig_AeroBase
{
public:
	float                                         DefaultGlidingV;                                   // 0x10F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CueTag;                                            // 0x10FC(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CloakOneTag;                                       // 0x1108(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CloakTwoTag;                                       // 0x1114(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103052">();
	}
	static class UConfig_103052* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103052>();
	}
};
static_assert(alignof(UConfig_103052) == 0x000010, "Wrong alignment on UConfig_103052");
static_assert(sizeof(UConfig_103052) == 0x001120, "Wrong size on UConfig_103052");
static_assert(offsetof(UConfig_103052, DefaultGlidingV) == 0x0010F8, "Member 'UConfig_103052::DefaultGlidingV' has a wrong offset!");
static_assert(offsetof(UConfig_103052, CueTag) == 0x0010FC, "Member 'UConfig_103052::CueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103052, CloakOneTag) == 0x001108, "Member 'UConfig_103052::CloakOneTag' has a wrong offset!");
static_assert(offsetof(UConfig_103052, CloakTwoTag) == 0x001114, "Member 'UConfig_103052::CloakTwoTag' has a wrong offset!");

// Class Hero_1030.Ability_103052
// 0x0130 (0x5D30 - 0x5C00)
class UAbility_103052 : public UMarvelAeroBaseAbility
{
public:
	class UConfig_103052*                         AbilityConfig;                                     // 0x5C00(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputTask;                                         // 0x5C08(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                                      // 0x5C10(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C18[0x118];                                   // 0x5C18(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanActivateForUI();
	void LeaveGlide(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103052">();
	}
	static class UAbility_103052* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103052>();
	}
};
static_assert(alignof(UAbility_103052) == 0x000010, "Wrong alignment on UAbility_103052");
static_assert(sizeof(UAbility_103052) == 0x005D30, "Wrong size on UAbility_103052");
static_assert(offsetof(UAbility_103052, AbilityConfig) == 0x005C00, "Member 'UAbility_103052::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103052, InputTask) == 0x005C08, "Member 'UAbility_103052::InputTask' has a wrong offset!");
static_assert(offsetof(UAbility_103052, TimelineTask) == 0x005C10, "Member 'UAbility_103052::TimelineTask' has a wrong offset!");

// Class Hero_1030.Ability_103053
// 0x0038 (0x25B8 - 0x2580)
class UAbility_103053 : public UMarvelGameplayAbility
{
public:
	class UAbility_103052*                        Ability_Glide;                                     // 0x2580(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelGameplayAbility*                 Ability_DoubleJump;                                // 0x2588(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x2590(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103052*                         GlideConfig;                                       // 0x2598(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputTask;                                         // 0x25A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A8[0x10];                                    // 0x25A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103053">();
	}
	static class UAbility_103053* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103053>();
	}
};
static_assert(alignof(UAbility_103053) == 0x000008, "Wrong alignment on UAbility_103053");
static_assert(sizeof(UAbility_103053) == 0x0025B8, "Wrong size on UAbility_103053");
static_assert(offsetof(UAbility_103053, Ability_Glide) == 0x002580, "Member 'UAbility_103053::Ability_Glide' has a wrong offset!");
static_assert(offsetof(UAbility_103053, Ability_DoubleJump) == 0x002588, "Member 'UAbility_103053::Ability_DoubleJump' has a wrong offset!");
static_assert(offsetof(UAbility_103053, OwnerCharacter) == 0x002590, "Member 'UAbility_103053::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_103053, GlideConfig) == 0x002598, "Member 'UAbility_103053::GlideConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103053, InputTask) == 0x0025A0, "Member 'UAbility_103053::InputTask' has a wrong offset!");

// Class Hero_1030.Config_103061
// 0x0020 (0x00B8 - 0x0098)
class UConfig_103061 : public UMarvelAbilityConfig
{
public:
	int32                                         ProjectileID;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileNum;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileDelay;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileInterval;                                // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageScopeID_HitPoint;                            // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageScopeID_Summoner;                            // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnergyForbidBuffID;                                // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103061">();
	}
	static class UConfig_103061* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103061>();
	}
};
static_assert(alignof(UConfig_103061) == 0x000008, "Wrong alignment on UConfig_103061");
static_assert(sizeof(UConfig_103061) == 0x0000B8, "Wrong size on UConfig_103061");
static_assert(offsetof(UConfig_103061, ProjectileID) == 0x000098, "Member 'UConfig_103061::ProjectileID' has a wrong offset!");
static_assert(offsetof(UConfig_103061, ProjectileNum) == 0x00009C, "Member 'UConfig_103061::ProjectileNum' has a wrong offset!");
static_assert(offsetof(UConfig_103061, ProjectileDelay) == 0x0000A0, "Member 'UConfig_103061::ProjectileDelay' has a wrong offset!");
static_assert(offsetof(UConfig_103061, ProjectileInterval) == 0x0000A4, "Member 'UConfig_103061::ProjectileInterval' has a wrong offset!");
static_assert(offsetof(UConfig_103061, DamageScopeID_HitPoint) == 0x0000A8, "Member 'UConfig_103061::DamageScopeID_HitPoint' has a wrong offset!");
static_assert(offsetof(UConfig_103061, DamageScopeID_Summoner) == 0x0000AC, "Member 'UConfig_103061::DamageScopeID_Summoner' has a wrong offset!");
static_assert(offsetof(UConfig_103061, EnergyForbidBuffID) == 0x0000B0, "Member 'UConfig_103061::EnergyForbidBuffID' has a wrong offset!");

// Class Hero_1030.Ability_103061
// 0x0008 (0x2590 - 0x2588)
class UAbility_103061 : public UAbility_108
{
public:
	class AMarvelAbilityTargetActor_Projectile*   CurrentProjectile;                                 // 0x2588(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103061">();
	}
	static class UAbility_103061* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103061>();
	}
};
static_assert(alignof(UAbility_103061) == 0x000008, "Wrong alignment on UAbility_103061");
static_assert(sizeof(UAbility_103061) == 0x002590, "Wrong size on UAbility_103061");
static_assert(offsetof(UAbility_103061, CurrentProjectile) == 0x002588, "Member 'UAbility_103061::CurrentProjectile' has a wrong offset!");

// Class Hero_1030.ProjectileMovementComponent_Parabola
// 0x0010 (0x2000 - 0x1FF0)
class UProjectileMovementComponent_Parabola final : public UMarvelProjectileComponent
{
public:
	struct FVector                                ParabolaEndPoint;                                  // 0x1FE8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileMovementComponent_Parabola">();
	}
	static class UProjectileMovementComponent_Parabola* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileMovementComponent_Parabola>();
	}
};
static_assert(alignof(UProjectileMovementComponent_Parabola) == 0x000010, "Wrong alignment on UProjectileMovementComponent_Parabola");
static_assert(sizeof(UProjectileMovementComponent_Parabola) == 0x002000, "Wrong size on UProjectileMovementComponent_Parabola");
static_assert(offsetof(UProjectileMovementComponent_Parabola, ParabolaEndPoint) == 0x001FE8, "Member 'UProjectileMovementComponent_Parabola::ParabolaEndPoint' has a wrong offset!");

// Class Hero_1030.Projectile_10306101
// 0x00C0 (0x3110 - 0x3050)
class AProjectile_10306101 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	int32                                         ProjectileIndex;                                   // 0x3050(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3054[0x4];                                     // 0x3054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EndPoint;                                          // 0x3058(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             ProjectileTransform;                               // 0x3070(0x0060)(Net, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SummonerLocation;                                  // 0x30D0(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30E8[0x28];                                    // 0x30E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProjectileEndPoint(const struct FVector& InLocation);
	void SetProjectileIndex(const int32 InValue);
	void SetProjectileTransform(const struct FTransform& InTransform);
	void SetSummonerLocation(const struct FVector& InLocation);

	struct FVector GetSummonerLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10306101">();
	}
	static class AProjectile_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10306101>();
	}
};
static_assert(alignof(AProjectile_10306101) == 0x000010, "Wrong alignment on AProjectile_10306101");
static_assert(sizeof(AProjectile_10306101) == 0x003110, "Wrong size on AProjectile_10306101");
static_assert(offsetof(AProjectile_10306101, ProjectileIndex) == 0x003050, "Member 'AProjectile_10306101::ProjectileIndex' has a wrong offset!");
static_assert(offsetof(AProjectile_10306101, EndPoint) == 0x003058, "Member 'AProjectile_10306101::EndPoint' has a wrong offset!");
static_assert(offsetof(AProjectile_10306101, ProjectileTransform) == 0x003070, "Member 'AProjectile_10306101::ProjectileTransform' has a wrong offset!");
static_assert(offsetof(AProjectile_10306101, SummonerLocation) == 0x0030D0, "Member 'AProjectile_10306101::SummonerLocation' has a wrong offset!");

// Class Hero_1030.Summoned_10306101
// 0x01F0 (0x0A80 - 0x0890)
class ASummoned_10306101 : public AMarvelSummonerBase
{
public:
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0890(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103061*                         AbilityConfig;                                     // 0x0898(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A0[0x1A0];                                    // 0x08A0(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProjectileNum;                                     // 0x0A40(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonRightOffset;                                   // 0x0A44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonUpOffset;                                      // 0x0A48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonScaleOverride;                                 // 0x0A4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkyHeight;                                         // 0x0A50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonRadius;                                        // 0x0A54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ProjectileStartOffset;                             // 0x0A58(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndPointRadius;                                    // 0x0A70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndPointAngle;                                     // 0x0A74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A78[0x8];                                      // 0x0A78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTransform CalcMoonTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10306101">();
	}
	static class ASummoned_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10306101>();
	}
};
static_assert(alignof(ASummoned_10306101) == 0x000010, "Wrong alignment on ASummoned_10306101");
static_assert(sizeof(ASummoned_10306101) == 0x000A80, "Wrong size on ASummoned_10306101");
static_assert(offsetof(ASummoned_10306101, OwnerCharacter) == 0x000890, "Member 'ASummoned_10306101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, AbilityConfig) == 0x000898, "Member 'ASummoned_10306101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, ProjectileNum) == 0x000A40, "Member 'ASummoned_10306101::ProjectileNum' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonRightOffset) == 0x000A44, "Member 'ASummoned_10306101::MoonRightOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonUpOffset) == 0x000A48, "Member 'ASummoned_10306101::MoonUpOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonScaleOverride) == 0x000A4C, "Member 'ASummoned_10306101::MoonScaleOverride' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, SkyHeight) == 0x000A50, "Member 'ASummoned_10306101::SkyHeight' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonRadius) == 0x000A54, "Member 'ASummoned_10306101::MoonRadius' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, ProjectileStartOffset) == 0x000A58, "Member 'ASummoned_10306101::ProjectileStartOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, EndPointRadius) == 0x000A70, "Member 'ASummoned_10306101::EndPointRadius' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, EndPointAngle) == 0x000A74, "Member 'ASummoned_10306101::EndPointAngle' has a wrong offset!");

// Class Hero_1030.Cue_Ability_Loop_10306102
// 0x0008 (0x0E58 - 0x0E50)
class ACue_Ability_Loop_10306102 : public AMarvelCueNotify_Ability
{
public:
	class USkeletalMeshComponent*                 AnkaWeaponMesh;                                    // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10306102">();
	}
	static class ACue_Ability_Loop_10306102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10306102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10306102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10306102");
static_assert(sizeof(ACue_Ability_Loop_10306102) == 0x000E58, "Wrong size on ACue_Ability_Loop_10306102");
static_assert(offsetof(ACue_Ability_Loop_10306102, AnkaWeaponMesh) == 0x000E50, "Member 'ACue_Ability_Loop_10306102::AnkaWeaponMesh' has a wrong offset!");

// Class Hero_1030.Cue_Summoned_Loop_10306101
// 0x0018 (0x0EA8 - 0x0E90)
class ACue_Summoned_Loop_10306101 : public AMarvelCueNotify_Summoned
{
public:
	class ASummoned_10306101*                     OwnerSummoner;                                     // 0x0E90(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Moon;                                              // 0x0E98(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     SkyFX;                                             // 0x0EA0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoned_Loop_10306101">();
	}
	static class ACue_Summoned_Loop_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoned_Loop_10306101>();
	}
};
static_assert(alignof(ACue_Summoned_Loop_10306101) == 0x000008, "Wrong alignment on ACue_Summoned_Loop_10306101");
static_assert(sizeof(ACue_Summoned_Loop_10306101) == 0x000EA8, "Wrong size on ACue_Summoned_Loop_10306101");
static_assert(offsetof(ACue_Summoned_Loop_10306101, OwnerSummoner) == 0x000E90, "Member 'ACue_Summoned_Loop_10306101::OwnerSummoner' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10306101, Moon) == 0x000E98, "Member 'ACue_Summoned_Loop_10306101::Moon' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10306101, SkyFX) == 0x000EA0, "Member 'ACue_Summoned_Loop_10306101::SkyFX' has a wrong offset!");

// Class Hero_1030.Cue_TraceActor_10306101
// 0x0020 (0x0D20 - 0x0D00)
class ACue_TraceActor_10306101 final : public AMarvelCueNotify_TraceActor
{
public:
	struct FVector                                DecalSize;                                         // 0x0D00(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComponent;                                    // 0x0D18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_TraceActor_10306101">();
	}
	static class ACue_TraceActor_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_TraceActor_10306101>();
	}
};
static_assert(alignof(ACue_TraceActor_10306101) == 0x000008, "Wrong alignment on ACue_TraceActor_10306101");
static_assert(sizeof(ACue_TraceActor_10306101) == 0x000D20, "Wrong size on ACue_TraceActor_10306101");
static_assert(offsetof(ACue_TraceActor_10306101, DecalSize) == 0x000D00, "Member 'ACue_TraceActor_10306101::DecalSize' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10306101, DecalComponent) == 0x000D18, "Member 'ACue_TraceActor_10306101::DecalComponent' has a wrong offset!");

// Class Hero_1030.Cue_Projectile_HitImpact_10306101
// 0x0000 (0x04D0 - 0x04D0)
class UCue_Projectile_HitImpact_10306101 final : public UMarvelCueNotify_HitImpact
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_HitImpact_10306101">();
	}
	static class UCue_Projectile_HitImpact_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Projectile_HitImpact_10306101>();
	}
};
static_assert(alignof(UCue_Projectile_HitImpact_10306101) == 0x000008, "Wrong alignment on UCue_Projectile_HitImpact_10306101");
static_assert(sizeof(UCue_Projectile_HitImpact_10306101) == 0x0004D0, "Wrong size on UCue_Projectile_HitImpact_10306101");

// Class Hero_1030.Config_103071
// 0x0000 (0x00C0 - 0x00C0)
class UConfig_103071 final : public UMarvelAbilityConfig_DoubleJump
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103071">();
	}
	static class UConfig_103071* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103071>();
	}
};
static_assert(alignof(UConfig_103071) == 0x000008, "Wrong alignment on UConfig_103071");
static_assert(sizeof(UConfig_103071) == 0x0000C0, "Wrong size on UConfig_103071");

// Class Hero_1030.Ability_103071
// 0x0000 (0x2678 - 0x2678)
class UAbility_103071 : public UMarvelAbility_DoubleJump
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103071">();
	}
	static class UAbility_103071* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103071>();
	}
};
static_assert(alignof(UAbility_103071) == 0x000008, "Wrong alignment on UAbility_103071");
static_assert(sizeof(UAbility_103071) == 0x002678, "Wrong size on UAbility_103071");

// Class Hero_1030.EpicMomentAction_1030
// 0x0000 (0x0120 - 0x0120)
class UEpicMomentAction_1030 final : public UEpicMomentBaseAction
{
public:
	void OnSummonerBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Summoned, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnSummonerEnd(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1030">();
	}
	static class UEpicMomentAction_1030* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1030>();
	}
};
static_assert(alignof(UEpicMomentAction_1030) == 0x000008, "Wrong alignment on UEpicMomentAction_1030");
static_assert(sizeof(UEpicMomentAction_1030) == 0x000120, "Wrong size on UEpicMomentAction_1030");

// Class Hero_1030.MoonKnightAnimInstance
// 0x00E0 (0x09F0 - 0x0910)
class UMoonKnightAnimInstance final : public UMarvelAnimInstance
{
public:
	class UAnimSequence*                          FallingAnimAsset;                                  // 0x0910(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLayeredBoneBlendExternalSetting       PelvisBlendSettings;                               // 0x0918(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   PelvisModifyCurveName_103051;                      // 0x0928(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MeleeAbilityTag;                                   // 0x0934(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PevisLoc;                                          // 0x0940(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StartVelocity;                                     // 0x0958(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDoubleJumpingForAnim;                            // 0x0970(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseAO;                                      // 0x0971(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedModifyBone;                                   // 0x0972(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_973[0x1];                                      // 0x0973(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PelvisModifyCurveValue_103051;                     // 0x0974(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_978[0x78];                                     // 0x0978(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGenericGameplayTagUpdate(const struct FGameplayTag& InTag, int32 Count);

	void GetLinkedAeroAnimInstances(TArray<class UAnimInstance*>* OutLinkedInstances) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightAnimInstance">();
	}
	static class UMoonKnightAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonKnightAnimInstance>();
	}
};
static_assert(alignof(UMoonKnightAnimInstance) == 0x000010, "Wrong alignment on UMoonKnightAnimInstance");
static_assert(sizeof(UMoonKnightAnimInstance) == 0x0009F0, "Wrong size on UMoonKnightAnimInstance");
static_assert(offsetof(UMoonKnightAnimInstance, FallingAnimAsset) == 0x000910, "Member 'UMoonKnightAnimInstance::FallingAnimAsset' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PelvisBlendSettings) == 0x000918, "Member 'UMoonKnightAnimInstance::PelvisBlendSettings' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PelvisModifyCurveName_103051) == 0x000928, "Member 'UMoonKnightAnimInstance::PelvisModifyCurveName_103051' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, MeleeAbilityTag) == 0x000934, "Member 'UMoonKnightAnimInstance::MeleeAbilityTag' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PevisLoc) == 0x000940, "Member 'UMoonKnightAnimInstance::PevisLoc' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, StartVelocity) == 0x000958, "Member 'UMoonKnightAnimInstance::StartVelocity' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, IsDoubleJumpingForAnim) == 0x000970, "Member 'UMoonKnightAnimInstance::IsDoubleJumpingForAnim' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, bShouldUseAO) == 0x000971, "Member 'UMoonKnightAnimInstance::bShouldUseAO' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, bNeedModifyBone) == 0x000972, "Member 'UMoonKnightAnimInstance::bNeedModifyBone' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PelvisModifyCurveValue_103051) == 0x000974, "Member 'UMoonKnightAnimInstance::PelvisModifyCurveValue_103051' has a wrong offset!");

// Class Hero_1030.MoonKnightCharacter
// 0x0010 (0x1820 - 0x1810)
class AMoonKnightCharacter : public AMarvelBaseCharacter
{
public:
	class UMoonKnightMoveLogicBaseComponent*      MoonKnightMoveLogic;                               // 0x1810(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1818[0x8];                                     // 0x1818(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightCharacter">();
	}
	static class AMoonKnightCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoonKnightCharacter>();
	}
};
static_assert(alignof(AMoonKnightCharacter) == 0x000010, "Wrong alignment on AMoonKnightCharacter");
static_assert(sizeof(AMoonKnightCharacter) == 0x001820, "Wrong size on AMoonKnightCharacter");
static_assert(offsetof(AMoonKnightCharacter, MoonKnightMoveLogic) == 0x001810, "Member 'AMoonKnightCharacter::MoonKnightMoveLogic' has a wrong offset!");

// Class Hero_1030.MoonKnightChildActor
// 0x0078 (0x0AD8 - 0x0A60)
class AMoonKnightChildActor : public AMarvelCharacterChildActor
{
public:
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0A60(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MoonMesh;                                          // 0x0A68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A70[0x30];                                     // 0x0A70(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResetCloakDelay;                                   // 0x0AA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA4[0x4];                                      // 0x0AA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NormalCloakSlot;                                   // 0x0AA8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 GlideCloakSlot;                                    // 0x0AB8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 ExtraMoonSkinIDs;                                  // 0x0AC8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void OnOwnerReborn(class AActor* Target, const struct FCharacterRebornParam& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightChildActor">();
	}
	static class AMoonKnightChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoonKnightChildActor>();
	}
};
static_assert(alignof(AMoonKnightChildActor) == 0x000008, "Wrong alignment on AMoonKnightChildActor");
static_assert(sizeof(AMoonKnightChildActor) == 0x000AD8, "Wrong size on AMoonKnightChildActor");
static_assert(offsetof(AMoonKnightChildActor, OwnerCharacter) == 0x000A60, "Member 'AMoonKnightChildActor::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, MoonMesh) == 0x000A68, "Member 'AMoonKnightChildActor::MoonMesh' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, ResetCloakDelay) == 0x000AA0, "Member 'AMoonKnightChildActor::ResetCloakDelay' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, NormalCloakSlot) == 0x000AA8, "Member 'AMoonKnightChildActor::NormalCloakSlot' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, GlideCloakSlot) == 0x000AB8, "Member 'AMoonKnightChildActor::GlideCloakSlot' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, ExtraMoonSkinIDs) == 0x000AC8, "Member 'AMoonKnightChildActor::ExtraMoonSkinIDs' has a wrong offset!");

// Class Hero_1030.MoonKnightMoveLogicBaseComponent
// 0x0008 (0x03F8 - 0x03F0)
class UMoonKnightMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockASDInputMovment(uint8 BlockInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightMoveLogicBaseComponent">();
	}
	static class UMoonKnightMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonKnightMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UMoonKnightMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UMoonKnightMoveLogicBaseComponent");
static_assert(sizeof(UMoonKnightMoveLogicBaseComponent) == 0x0003F8, "Wrong size on UMoonKnightMoveLogicBaseComponent");

// Class Hero_1030.MoonKnightMovementComponent
// 0x0000 (0x1B60 - 0x1B60)
class UMoonKnightMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightMovementComponent">();
	}
	static class UMoonKnightMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonKnightMovementComponent>();
	}
};
static_assert(alignof(UMoonKnightMovementComponent) == 0x000010, "Wrong alignment on UMoonKnightMovementComponent");
static_assert(sizeof(UMoonKnightMovementComponent) == 0x001B60, "Wrong size on UMoonKnightMovementComponent");

}

