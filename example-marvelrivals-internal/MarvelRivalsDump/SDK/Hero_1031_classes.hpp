#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1031

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Engine_structs.hpp"
#include "Hero_1031_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1031.Config_103111
// 0x0030 (0x00C8 - 0x0098)
class UConfig_103111 final : public UMarvelAbilityConfig
{
public:
	float                                         EnterDuration;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedCurve;                                        // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CameraTurnCurve;                                   // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitSkatingTime;                                   // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopSkateInBattleState;                           // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnterSkatingSpeedThreshold;                        // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitSkatingSpeedThreshold;                         // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZVelocity;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103111">();
	}
	static class UConfig_103111* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103111>();
	}
};
static_assert(alignof(UConfig_103111) == 0x000008, "Wrong alignment on UConfig_103111");
static_assert(sizeof(UConfig_103111) == 0x0000C8, "Wrong size on UConfig_103111");
static_assert(offsetof(UConfig_103111, EnterDuration) == 0x000098, "Member 'UConfig_103111::EnterDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103111, SpeedCurve) == 0x0000A0, "Member 'UConfig_103111::SpeedCurve' has a wrong offset!");
static_assert(offsetof(UConfig_103111, CameraTurnCurve) == 0x0000A8, "Member 'UConfig_103111::CameraTurnCurve' has a wrong offset!");
static_assert(offsetof(UConfig_103111, ExitSkatingTime) == 0x0000B0, "Member 'UConfig_103111::ExitSkatingTime' has a wrong offset!");
static_assert(offsetof(UConfig_103111, bStopSkateInBattleState) == 0x0000B4, "Member 'UConfig_103111::bStopSkateInBattleState' has a wrong offset!");
static_assert(offsetof(UConfig_103111, EnterSkatingSpeedThreshold) == 0x0000B8, "Member 'UConfig_103111::EnterSkatingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UConfig_103111, ExitSkatingSpeedThreshold) == 0x0000BC, "Member 'UConfig_103111::ExitSkatingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UConfig_103111, JumpZVelocity) == 0x0000C0, "Member 'UConfig_103111::JumpZVelocity' has a wrong offset!");

// Class Hero_1031.Ability_103111
// 0x0090 (0x2610 - 0x2580)
class UAbility_103111 : public UMarvelGameplayAbility
{
public:
	class UConfig_103111*                         Config;                                            // 0x2580(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMarvelBaseCharacter*                   Owner;                                             // 0x2588(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelCharacterMovementComponent*      Movement;                                          // 0x2590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelMoveLogicBaseComponent*          MoveLogic;                                         // 0x2598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WalkingToSkatingTime;                              // 0x25A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InSkatingTime;                                     // 0x25A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           SkatingToWalkingTimerHandle;                       // 0x25A8(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CachedWalkSpeed;                                   // 0x25C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CachedJumpZVelocity;                               // 0x25C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CachedTurnScale;                                   // 0x25C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           TagSkating;                                        // 0x25CC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           TagSkateEnd;                                       // 0x25D8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESkatingState                                 SkatingState;                                      // 0x25E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInFallingWhileSkating;                            // 0x25E5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNeedEnterSkateQuickly;                            // 0x25E6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOnPressFwdKey;                                    // 0x25E7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFirstSkate;                                     // 0x25E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25E9[0x7];                                     // 0x25E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilitySystemCom*                Abs;                                               // 0x25F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelAttributeSet*                    AttributeSet;                                      // 0x25F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           SkatingCueTag;                                     // 0x2600(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260C[0x4];                                     // 0x260C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckVelocityForSkate();
	void OnPressFwdKey(float TimeWaited);
	void OnReleaseFwdKey(float TimeWaited);
	void OnStopSkating(float TimeWaited);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103111">();
	}
	static class UAbility_103111* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103111>();
	}
};
static_assert(alignof(UAbility_103111) == 0x000008, "Wrong alignment on UAbility_103111");
static_assert(sizeof(UAbility_103111) == 0x002610, "Wrong size on UAbility_103111");
static_assert(offsetof(UAbility_103111, Config) == 0x002580, "Member 'UAbility_103111::Config' has a wrong offset!");
static_assert(offsetof(UAbility_103111, Owner) == 0x002588, "Member 'UAbility_103111::Owner' has a wrong offset!");
static_assert(offsetof(UAbility_103111, Movement) == 0x002590, "Member 'UAbility_103111::Movement' has a wrong offset!");
static_assert(offsetof(UAbility_103111, MoveLogic) == 0x002598, "Member 'UAbility_103111::MoveLogic' has a wrong offset!");
static_assert(offsetof(UAbility_103111, WalkingToSkatingTime) == 0x0025A0, "Member 'UAbility_103111::WalkingToSkatingTime' has a wrong offset!");
static_assert(offsetof(UAbility_103111, InSkatingTime) == 0x0025A4, "Member 'UAbility_103111::InSkatingTime' has a wrong offset!");
static_assert(offsetof(UAbility_103111, SkatingToWalkingTimerHandle) == 0x0025A8, "Member 'UAbility_103111::SkatingToWalkingTimerHandle' has a wrong offset!");
static_assert(offsetof(UAbility_103111, CachedWalkSpeed) == 0x0025C0, "Member 'UAbility_103111::CachedWalkSpeed' has a wrong offset!");
static_assert(offsetof(UAbility_103111, CachedJumpZVelocity) == 0x0025C4, "Member 'UAbility_103111::CachedJumpZVelocity' has a wrong offset!");
static_assert(offsetof(UAbility_103111, CachedTurnScale) == 0x0025C8, "Member 'UAbility_103111::CachedTurnScale' has a wrong offset!");
static_assert(offsetof(UAbility_103111, TagSkating) == 0x0025CC, "Member 'UAbility_103111::TagSkating' has a wrong offset!");
static_assert(offsetof(UAbility_103111, TagSkateEnd) == 0x0025D8, "Member 'UAbility_103111::TagSkateEnd' has a wrong offset!");
static_assert(offsetof(UAbility_103111, SkatingState) == 0x0025E4, "Member 'UAbility_103111::SkatingState' has a wrong offset!");
static_assert(offsetof(UAbility_103111, bInFallingWhileSkating) == 0x0025E5, "Member 'UAbility_103111::bInFallingWhileSkating' has a wrong offset!");
static_assert(offsetof(UAbility_103111, bNeedEnterSkateQuickly) == 0x0025E6, "Member 'UAbility_103111::bNeedEnterSkateQuickly' has a wrong offset!");
static_assert(offsetof(UAbility_103111, bOnPressFwdKey) == 0x0025E7, "Member 'UAbility_103111::bOnPressFwdKey' has a wrong offset!");
static_assert(offsetof(UAbility_103111, bIsFirstSkate) == 0x0025E8, "Member 'UAbility_103111::bIsFirstSkate' has a wrong offset!");
static_assert(offsetof(UAbility_103111, Abs) == 0x0025F0, "Member 'UAbility_103111::Abs' has a wrong offset!");
static_assert(offsetof(UAbility_103111, AttributeSet) == 0x0025F8, "Member 'UAbility_103111::AttributeSet' has a wrong offset!");
static_assert(offsetof(UAbility_103111, SkatingCueTag) == 0x002600, "Member 'UAbility_103111::SkatingCueTag' has a wrong offset!");

// Class Hero_1031.Cue_Instant_HitImpact_10313101
// 0x0008 (0x0508 - 0x0500)
class UCue_Instant_HitImpact_10313101 : public UMarvelCueNotify_InstantHitImpact
{
public:
	int32                                         HitAllyAudioID;                                    // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitOtherAudioID;                                   // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Instant_HitImpact_10313101">();
	}
	static class UCue_Instant_HitImpact_10313101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Instant_HitImpact_10313101>();
	}
};
static_assert(alignof(UCue_Instant_HitImpact_10313101) == 0x000008, "Wrong alignment on UCue_Instant_HitImpact_10313101");
static_assert(sizeof(UCue_Instant_HitImpact_10313101) == 0x000508, "Wrong size on UCue_Instant_HitImpact_10313101");
static_assert(offsetof(UCue_Instant_HitImpact_10313101, HitAllyAudioID) == 0x000500, "Member 'UCue_Instant_HitImpact_10313101::HitAllyAudioID' has a wrong offset!");
static_assert(offsetof(UCue_Instant_HitImpact_10313101, HitOtherAudioID) == 0x000504, "Member 'UCue_Instant_HitImpact_10313101::HitOtherAudioID' has a wrong offset!");

// Class Hero_1031.Cue_Ability_Loop_10315101
// 0x0048 (0x0E98 - 0x0E50)
class ACue_Ability_Loop_10315101 : public AMarvelCueNotify_Ability
{
public:
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x0E50(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     RayFxComp;                                         // 0x0E58(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         RayFx;                                             // 0x0E60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RayLocSocketName;                                  // 0x0E68(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetLength;                                      // 0x0E74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerExecRate;                                     // 0x0E78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E7C[0x4];                                      // 0x0E7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x0E80(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdateRayFx();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10315101">();
	}
	static class ACue_Ability_Loop_10315101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10315101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10315101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10315101");
static_assert(sizeof(ACue_Ability_Loop_10315101) == 0x000E98, "Wrong size on ACue_Ability_Loop_10315101");
static_assert(offsetof(ACue_Ability_Loop_10315101, OwnerChar) == 0x000E50, "Member 'ACue_Ability_Loop_10315101::OwnerChar' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, RayFxComp) == 0x000E58, "Member 'ACue_Ability_Loop_10315101::RayFxComp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, RayFx) == 0x000E60, "Member 'ACue_Ability_Loop_10315101::RayFx' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, RayLocSocketName) == 0x000E68, "Member 'ACue_Ability_Loop_10315101::RayLocSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, OffsetLength) == 0x000E74, "Member 'ACue_Ability_Loop_10315101::OffsetLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, TimerExecRate) == 0x000E78, "Member 'ACue_Ability_Loop_10315101::TimerExecRate' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10315101, LoopTimerHandle) == 0x000E80, "Member 'ACue_Ability_Loop_10315101::LoopTimerHandle' has a wrong offset!");

// Class Hero_1031.Cue_Buff_10315102
// 0x0380 (0x13B8 - 0x1038)
class ACue_Buff_10315102 : public AMarvelCueNotify_Buff
{
public:
	class FName                                   SwitchParamName;                                   // 0x1038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1044[0x4];                                     // 0x1044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UCurveFloat*>         ParamCurves;                                       // 0x1048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   DirParamName;                                      // 0x1098(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A4[0x4];                                     // 0x10A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DirCoefficient;                                    // 0x10A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultParamValue;                                 // 0x10C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoundsTopParmName;                                 // 0x10C4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoundsBottomParmName;                              // 0x10D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10DC[0x4];                                     // 0x10DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UMeshComponent>>       HandleClasses;                                     // 0x10E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bNeedDisappearEffect;                              // 0x1130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1131[0x3];                                     // 0x1131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           BlockUpdateTag;                                    // 0x1134(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomAutoDestroyDelay;                            // 0x1140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisappearCurveTime;                                // 0x1144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         IceThornFx;                                        // 0x1148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IceThornFxAttachSocket;                            // 0x1150(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IceThornFxDirParam;                                // 0x115C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeInterval;                                      // 0x1168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_116C[0x4];                                     // 0x116C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueParameters                 CacheCueParam;                                     // 0x1170(0x01B8)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ACharacter*                             OwnerChar;                                         // 0x1328(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CueBeginTime;                                      // 0x1330(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChargeTime;                                        // 0x1334(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     IceThornComp;                                      // 0x1338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuffTotalTime;                                     // 0x1340(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1344[0x4];                                     // 0x1344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x1348(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 CachedMeshComps;                                   // 0x1360(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FMeshOverlayMaterialHandle             TargetMaterialHandle;                              // 0x1370(0x001C)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_138C[0x2C];                                    // 0x138C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CacheAndHandleTargetMaterial();
	void HandleIceThornFx(bool bReset);
	void HandleMaterialDirParam(bool bReset);
	void HandleMaterialFloatParam(float InChargeTime);
	void HandleUVParam();
	void ListenTargetSculptChanged(bool bListen);
	void OnSculptChanged(int32 SculptID);
	void OnTargetMaterialChanged();
	void ResetTargetMaterial();
	void SwitchMaterial(bool bIsSwitch);
	void UpdateMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10315102">();
	}
	static class ACue_Buff_10315102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10315102>();
	}
};
static_assert(alignof(ACue_Buff_10315102) == 0x000008, "Wrong alignment on ACue_Buff_10315102");
static_assert(sizeof(ACue_Buff_10315102) == 0x0013B8, "Wrong size on ACue_Buff_10315102");
static_assert(offsetof(ACue_Buff_10315102, SwitchParamName) == 0x001038, "Member 'ACue_Buff_10315102::SwitchParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, ParamCurves) == 0x001048, "Member 'ACue_Buff_10315102::ParamCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, DirParamName) == 0x001098, "Member 'ACue_Buff_10315102::DirParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, DirCoefficient) == 0x0010A8, "Member 'ACue_Buff_10315102::DirCoefficient' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, DefaultParamValue) == 0x0010C0, "Member 'ACue_Buff_10315102::DefaultParamValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, BoundsTopParmName) == 0x0010C4, "Member 'ACue_Buff_10315102::BoundsTopParmName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, BoundsBottomParmName) == 0x0010D0, "Member 'ACue_Buff_10315102::BoundsBottomParmName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, HandleClasses) == 0x0010E0, "Member 'ACue_Buff_10315102::HandleClasses' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, bNeedDisappearEffect) == 0x001130, "Member 'ACue_Buff_10315102::bNeedDisappearEffect' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, BlockUpdateTag) == 0x001134, "Member 'ACue_Buff_10315102::BlockUpdateTag' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, CustomAutoDestroyDelay) == 0x001140, "Member 'ACue_Buff_10315102::CustomAutoDestroyDelay' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, DisappearCurveTime) == 0x001144, "Member 'ACue_Buff_10315102::DisappearCurveTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, IceThornFx) == 0x001148, "Member 'ACue_Buff_10315102::IceThornFx' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, IceThornFxAttachSocket) == 0x001150, "Member 'ACue_Buff_10315102::IceThornFxAttachSocket' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, IceThornFxDirParam) == 0x00115C, "Member 'ACue_Buff_10315102::IceThornFxDirParam' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, TimeInterval) == 0x001168, "Member 'ACue_Buff_10315102::TimeInterval' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, CacheCueParam) == 0x001170, "Member 'ACue_Buff_10315102::CacheCueParam' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, OwnerChar) == 0x001328, "Member 'ACue_Buff_10315102::OwnerChar' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, CueBeginTime) == 0x001330, "Member 'ACue_Buff_10315102::CueBeginTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, ChargeTime) == 0x001334, "Member 'ACue_Buff_10315102::ChargeTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, IceThornComp) == 0x001338, "Member 'ACue_Buff_10315102::IceThornComp' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, BuffTotalTime) == 0x001340, "Member 'ACue_Buff_10315102::BuffTotalTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, LoopTimerHandle) == 0x001348, "Member 'ACue_Buff_10315102::LoopTimerHandle' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, CachedMeshComps) == 0x001360, "Member 'ACue_Buff_10315102::CachedMeshComps' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10315102, TargetMaterialHandle) == 0x001370, "Member 'ACue_Buff_10315102::TargetMaterialHandle' has a wrong offset!");

// Class Hero_1031.Cue_Buff_10316101
// 0x0078 (0x10B0 - 0x1038)
class ACue_Buff_10316101 : public AMarvelCueNotify_Buff
{
public:
	class FName                                   SwitchParamName;                                   // 0x1038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialParamName;                                 // 0x1044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultParamValue;                                 // 0x1050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1054[0x4];                                     // 0x1054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ParamCurve;                                        // 0x1058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeInterval;                                      // 0x1060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1064[0x4];                                     // 0x1064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x1068(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChargeTime;                                        // 0x1070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1074[0x4];                                     // 0x1074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x1078(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMeshOverlayMaterialHandle             TargetMaterialHandle;                              // 0x1090(0x001C)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10AC[0x4];                                     // 0x10AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMaterial(float InChargeTime);
	bool IsViewingTarget(class AActor* Target);
	void SwitchMaterial(bool bIsSwitch);
	void UpdateMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10316101">();
	}
	static class ACue_Buff_10316101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10316101>();
	}
};
static_assert(alignof(ACue_Buff_10316101) == 0x000008, "Wrong alignment on ACue_Buff_10316101");
static_assert(sizeof(ACue_Buff_10316101) == 0x0010B0, "Wrong size on ACue_Buff_10316101");
static_assert(offsetof(ACue_Buff_10316101, SwitchParamName) == 0x001038, "Member 'ACue_Buff_10316101::SwitchParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, MaterialParamName) == 0x001044, "Member 'ACue_Buff_10316101::MaterialParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, DefaultParamValue) == 0x001050, "Member 'ACue_Buff_10316101::DefaultParamValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, ParamCurve) == 0x001058, "Member 'ACue_Buff_10316101::ParamCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, TimeInterval) == 0x001060, "Member 'ACue_Buff_10316101::TimeInterval' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, OwnerChar) == 0x001068, "Member 'ACue_Buff_10316101::OwnerChar' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, ChargeTime) == 0x001070, "Member 'ACue_Buff_10316101::ChargeTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, LoopTimerHandle) == 0x001078, "Member 'ACue_Buff_10316101::LoopTimerHandle' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10316101, TargetMaterialHandle) == 0x001090, "Member 'ACue_Buff_10316101::TargetMaterialHandle' has a wrong offset!");

// Class Hero_1031.Scope_10314201
// 0x0020 (0x1720 - 0x1700)
class AScope_10314201 final : public AMarvelAbilityTargetActor_Scope
{
public:
	bool                                          bHasCachedHitRes;                                  // 0x1700(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1701[0x7];                                     // 0x1701(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     CachedHitResults;                                  // 0x1708(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1718[0x8];                                     // 0x1718(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10314201">();
	}
	static class AScope_10314201* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10314201>();
	}
};
static_assert(alignof(AScope_10314201) == 0x000010, "Wrong alignment on AScope_10314201");
static_assert(sizeof(AScope_10314201) == 0x001720, "Wrong size on AScope_10314201");
static_assert(offsetof(AScope_10314201, bHasCachedHitRes) == 0x001700, "Member 'AScope_10314201::bHasCachedHitRes' has a wrong offset!");
static_assert(offsetof(AScope_10314201, CachedHitResults) == 0x001708, "Member 'AScope_10314201::CachedHitResults' has a wrong offset!");

// Class Hero_1031.TraceComponent_10314201
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10314201 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10314201">();
	}
	static class UTraceComponent_10314201* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10314201>();
	}
};
static_assert(alignof(UTraceComponent_10314201) == 0x000010, "Wrong alignment on UTraceComponent_10314201");
static_assert(sizeof(UTraceComponent_10314201) == 0x001710, "Wrong size on UTraceComponent_10314201");

// Class Hero_1031.Cue_Scope_Loop_10314201
// 0x0078 (0x0DE8 - 0x0D70)
class ACue_Scope_Loop_10314201 : public AMarvelCueNotify_Scope
{
public:
	class UFXSystemAsset*                         LaserFX;                                           // 0x0D70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FXStartSocketName;                                 // 0x0D78(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartOuterLength;                                  // 0x0D84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FXLengthParam;                                     // 0x0D88(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LunaLaserAudioID;                                  // 0x0D94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             IgnoreClasses;                                     // 0x0D98(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AScope_10314201*                        OwnerScope;                                        // 0x0DA8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0DB0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FXStart;                                           // 0x0DB8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FXEnd;                                             // 0x0DD0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleLaserFX();
	void OnScopeTraceHitRes(const TArray<struct FHitResult>& HitResults);
	void SpawnLaserFX(const struct FVector& InFXStart, const struct FVector& InFXEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10314201">();
	}
	static class ACue_Scope_Loop_10314201* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10314201>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10314201) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10314201");
static_assert(sizeof(ACue_Scope_Loop_10314201) == 0x000DE8, "Wrong size on ACue_Scope_Loop_10314201");
static_assert(offsetof(ACue_Scope_Loop_10314201, LaserFX) == 0x000D70, "Member 'ACue_Scope_Loop_10314201::LaserFX' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, FXStartSocketName) == 0x000D78, "Member 'ACue_Scope_Loop_10314201::FXStartSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, StartOuterLength) == 0x000D84, "Member 'ACue_Scope_Loop_10314201::StartOuterLength' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, FXLengthParam) == 0x000D88, "Member 'ACue_Scope_Loop_10314201::FXLengthParam' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, LunaLaserAudioID) == 0x000D94, "Member 'ACue_Scope_Loop_10314201::LunaLaserAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, IgnoreClasses) == 0x000D98, "Member 'ACue_Scope_Loop_10314201::IgnoreClasses' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, OwnerScope) == 0x000DA8, "Member 'ACue_Scope_Loop_10314201::OwnerScope' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, OwnerCharacter) == 0x000DB0, "Member 'ACue_Scope_Loop_10314201::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, FXStart) == 0x000DB8, "Member 'ACue_Scope_Loop_10314201::FXStart' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10314201, FXEnd) == 0x000DD0, "Member 'ACue_Scope_Loop_10314201::FXEnd' has a wrong offset!");

// Class Hero_1031.Config_103161
// 0x0010 (0x1160 - 0x1150)
class UConfig_103161 final : public USelectAbilityConfigBase
{
public:
	int32                                         DefendAbilityID;                                   // 0x1150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1154[0xC];                                     // 0x1154(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103161">();
	}
	static class UConfig_103161* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103161>();
	}
};
static_assert(alignof(UConfig_103161) == 0x000010, "Wrong alignment on UConfig_103161");
static_assert(sizeof(UConfig_103161) == 0x001160, "Wrong size on UConfig_103161");
static_assert(offsetof(UConfig_103161, DefendAbilityID) == 0x001150, "Member 'UConfig_103161::DefendAbilityID' has a wrong offset!");

// Class Hero_1031.Ability_103161
// 0x0018 (0x2610 - 0x25F8)
class UAbility_103161 : public UMarvelAbility_SelectTarget
{
public:
	class UAbility_103162*                        DefendAbility;                                     // 0x25F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103161*                         Config;                                            // 0x2600(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ActiveTarget;                                      // 0x2608(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UAbility_103162* GetDefendAbility();
	class AActor* GetTarget();
	bool SetDefendTarget(class AActor* TargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103161">();
	}
	static class UAbility_103161* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103161>();
	}
};
static_assert(alignof(UAbility_103161) == 0x000008, "Wrong alignment on UAbility_103161");
static_assert(sizeof(UAbility_103161) == 0x002610, "Wrong size on UAbility_103161");
static_assert(offsetof(UAbility_103161, DefendAbility) == 0x0025F8, "Member 'UAbility_103161::DefendAbility' has a wrong offset!");
static_assert(offsetof(UAbility_103161, Config) == 0x002600, "Member 'UAbility_103161::Config' has a wrong offset!");
static_assert(offsetof(UAbility_103161, ActiveTarget) == 0x002608, "Member 'UAbility_103161::ActiveTarget' has a wrong offset!");

// Class Hero_1031.Config_103162
// 0x10C8 (0x1160 - 0x0098)
class UConfig_103162 final : public UMarvelAbilityConfig
{
public:
	int32                                         DefendBuffID;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveBuffWhenLoseVision;                         // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RemoveBuffTime;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSelectTaskParam                       SelectParam;                                       // 0x00B0(0x10A0)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         CheckRate;                                         // 0x1150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1154[0xC];                                     // 0x1154(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103162">();
	}
	static class UConfig_103162* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103162>();
	}
};
static_assert(alignof(UConfig_103162) == 0x000010, "Wrong alignment on UConfig_103162");
static_assert(sizeof(UConfig_103162) == 0x001160, "Wrong size on UConfig_103162");
static_assert(offsetof(UConfig_103162, DefendBuffID) == 0x000098, "Member 'UConfig_103162::DefendBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103162, bRemoveBuffWhenLoseVision) == 0x00009C, "Member 'UConfig_103162::bRemoveBuffWhenLoseVision' has a wrong offset!");
static_assert(offsetof(UConfig_103162, RemoveBuffTime) == 0x0000A0, "Member 'UConfig_103162::RemoveBuffTime' has a wrong offset!");
static_assert(offsetof(UConfig_103162, SelectParam) == 0x0000B0, "Member 'UConfig_103162::SelectParam' has a wrong offset!");
static_assert(offsetof(UConfig_103162, CheckRate) == 0x001150, "Member 'UConfig_103162::CheckRate' has a wrong offset!");

// Class Hero_1031.Ability_103162
// 0x1000 (0x3580 - 0x2580)
class UAbility_103162 : public UMarvelGameplayAbility
{
public:
	class AActor*                                 DefendTarget;                                      // 0x2580(0x0008)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTargetChanged;                                   // 0x2588(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UConfig_103162*                         Config;                                            // 0x2598(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMarvelAbilityTraceContext             VisibleCheckContext;                               // 0x25A0(0x0F90)(BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UAbility_103161*                        SelectAbility;                                     // 0x3530(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           OutOfSightTimer;                                   // 0x3538(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilitySystemComponent*                OwnerASC;                                          // 0x3550(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwningChar;                                        // 0x3558(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_SelectTarget*        SelectTask;                                        // 0x3560(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x3568(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeDefendTarget(class AActor* NewTarget);
	void ClearDefendState();
	class ACharacter* GetOwningChar();
	bool IsTargetCanBeSelected(const class AActor* TargetActor);
	void LoopCheck();
	void OnDefendTargetChanged__DelegateSignature(class AActor* TargetActor);
	void OnRep_DefendTarget();
	void SetDefendTarget(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103162">();
	}
	static class UAbility_103162* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103162>();
	}
};
static_assert(alignof(UAbility_103162) == 0x000010, "Wrong alignment on UAbility_103162");
static_assert(sizeof(UAbility_103162) == 0x003580, "Wrong size on UAbility_103162");
static_assert(offsetof(UAbility_103162, DefendTarget) == 0x002580, "Member 'UAbility_103162::DefendTarget' has a wrong offset!");
static_assert(offsetof(UAbility_103162, OnTargetChanged) == 0x002588, "Member 'UAbility_103162::OnTargetChanged' has a wrong offset!");
static_assert(offsetof(UAbility_103162, Config) == 0x002598, "Member 'UAbility_103162::Config' has a wrong offset!");
static_assert(offsetof(UAbility_103162, VisibleCheckContext) == 0x0025A0, "Member 'UAbility_103162::VisibleCheckContext' has a wrong offset!");
static_assert(offsetof(UAbility_103162, SelectAbility) == 0x003530, "Member 'UAbility_103162::SelectAbility' has a wrong offset!");
static_assert(offsetof(UAbility_103162, OutOfSightTimer) == 0x003538, "Member 'UAbility_103162::OutOfSightTimer' has a wrong offset!");
static_assert(offsetof(UAbility_103162, OwnerASC) == 0x003550, "Member 'UAbility_103162::OwnerASC' has a wrong offset!");
static_assert(offsetof(UAbility_103162, OwningChar) == 0x003558, "Member 'UAbility_103162::OwningChar' has a wrong offset!");
static_assert(offsetof(UAbility_103162, SelectTask) == 0x003560, "Member 'UAbility_103162::SelectTask' has a wrong offset!");
static_assert(offsetof(UAbility_103162, LoopTimerHandle) == 0x003568, "Member 'UAbility_103162::LoopTimerHandle' has a wrong offset!");

// Class Hero_1031.DefendTreatAbility
// 0x0050 (0x1148 - 0x10F8)
class UDefendTreatAbility : public UMarvelEffectGameplayAbility
{
public:
	float                                         TreatPercentFromOther;                             // 0x10F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraTreatPercent;                                 // 0x10FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTreatVal;                                       // 0x1100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatSpan;                                          // 0x1104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TreatBuffID;                                       // 0x1108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenLog;                                          // 0x110C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110D[0x3];                                     // 0x110D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelBaseGameplayAbility*             DefendSourceAbility;                               // 0x1110(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   DefendSource;                                      // 0x1118(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   DefendTarget;                                      // 0x1120(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTreatVal;                                     // 0x1128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112C[0x4];                                     // 0x112C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CleanTimerHandle;                                  // 0x1130(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnApplyTreatToOther(class AActor* Source, class AActor* InTarget, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnTimeSliceArrive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefendTreatAbility">();
	}
	static class UDefendTreatAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefendTreatAbility>();
	}
};
static_assert(alignof(UDefendTreatAbility) == 0x000008, "Wrong alignment on UDefendTreatAbility");
static_assert(sizeof(UDefendTreatAbility) == 0x001148, "Wrong size on UDefendTreatAbility");
static_assert(offsetof(UDefendTreatAbility, TreatPercentFromOther) == 0x0010F8, "Member 'UDefendTreatAbility::TreatPercentFromOther' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, ExtraTreatPercent) == 0x0010FC, "Member 'UDefendTreatAbility::ExtraTreatPercent' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, MaxTreatVal) == 0x001100, "Member 'UDefendTreatAbility::MaxTreatVal' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, StatSpan) == 0x001104, "Member 'UDefendTreatAbility::StatSpan' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, TreatBuffID) == 0x001108, "Member 'UDefendTreatAbility::TreatBuffID' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, bOpenLog) == 0x00110C, "Member 'UDefendTreatAbility::bOpenLog' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, DefendSourceAbility) == 0x001110, "Member 'UDefendTreatAbility::DefendSourceAbility' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, DefendSource) == 0x001118, "Member 'UDefendTreatAbility::DefendSource' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, DefendTarget) == 0x001120, "Member 'UDefendTreatAbility::DefendTarget' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, TotalTreatVal) == 0x001128, "Member 'UDefendTreatAbility::TotalTreatVal' has a wrong offset!");
static_assert(offsetof(UDefendTreatAbility, CleanTimerHandle) == 0x001130, "Member 'UDefendTreatAbility::CleanTimerHandle' has a wrong offset!");

// Class Hero_1031.CueDataProcessor_AttachJeff_103192
// 0x0000 (0x00C0 - 0x00C0)
class UCueDataProcessor_AttachJeff_103192 final : public UCueDataProcessor_AttachCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueDataProcessor_AttachJeff_103192">();
	}
	static class UCueDataProcessor_AttachJeff_103192* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCueDataProcessor_AttachJeff_103192>();
	}
};
static_assert(alignof(UCueDataProcessor_AttachJeff_103192) == 0x000008, "Wrong alignment on UCueDataProcessor_AttachJeff_103192");
static_assert(sizeof(UCueDataProcessor_AttachJeff_103192) == 0x0000C0, "Wrong size on UCueDataProcessor_AttachJeff_103192");

// Class Hero_1031.CueNotify_103192
// 0x00B0 (0x10E8 - 0x1038)
class ACueNotify_103192 : public AMarvelCueNotify_Buff
{
public:
	struct FPortableMaterialSlotName              JeffMaterialSlotName;                              // 0x1038(0x0018)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialParamName;                                 // 0x1050(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105C[0x4];                                     // 0x105C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DivingTags;                                        // 0x1060(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C8[0x20];                                    // 0x10C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnJeffTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueNotify_103192">();
	}
	static class ACueNotify_103192* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueNotify_103192>();
	}
};
static_assert(alignof(ACueNotify_103192) == 0x000008, "Wrong alignment on ACueNotify_103192");
static_assert(sizeof(ACueNotify_103192) == 0x0010E8, "Wrong size on ACueNotify_103192");
static_assert(offsetof(ACueNotify_103192, JeffMaterialSlotName) == 0x001038, "Member 'ACueNotify_103192::JeffMaterialSlotName' has a wrong offset!");
static_assert(offsetof(ACueNotify_103192, MaterialParamName) == 0x001050, "Member 'ACueNotify_103192::MaterialParamName' has a wrong offset!");
static_assert(offsetof(ACueNotify_103192, DivingTags) == 0x001060, "Member 'ACueNotify_103192::DivingTags' has a wrong offset!");

// Class Hero_1031.TraceComponent_10319301
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10319301 : public UMarvelAgentTraceComponent
{
public:
	class UCurveFloat*                            Curve_Radius;                                      // 0x1708(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10319301">();
	}
	static class UTraceComponent_10319301* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10319301>();
	}
};
static_assert(alignof(UTraceComponent_10319301) == 0x000010, "Wrong alignment on UTraceComponent_10319301");
static_assert(sizeof(UTraceComponent_10319301) == 0x001710, "Wrong size on UTraceComponent_10319301");
static_assert(offsetof(UTraceComponent_10319301, Curve_Radius) == 0x001708, "Member 'UTraceComponent_10319301::Curve_Radius' has a wrong offset!");

// Class Hero_1031.EpicMomentAction_1031
// 0x0050 (0x01C0 - 0x0170)
class UEpicMomentAction_1031 : public UEpicMomentAction_Treat
{
public:
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    IceConfig;                                         // 0x0180(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    IceInterruptConfig;                                // 0x018C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    IceUltimateConfig;                                 // 0x0198(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 IceInterruptAbilities;                             // 0x01A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         IceBuffID;                                         // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QArmorBuffID;                                      // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnActorAbilityCancel(class AActor* Source, int32 AbilityID, const class FString& SessionID, class UMarvelGameplayAbility* SourceAbility);
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1031">();
	}
	static class UEpicMomentAction_1031* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1031>();
	}
};
static_assert(alignof(UEpicMomentAction_1031) == 0x000008, "Wrong alignment on UEpicMomentAction_1031");
static_assert(sizeof(UEpicMomentAction_1031) == 0x0001C0, "Wrong size on UEpicMomentAction_1031");
static_assert(offsetof(UEpicMomentAction_1031, IceConfig) == 0x000180, "Member 'UEpicMomentAction_1031::IceConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1031, IceInterruptConfig) == 0x00018C, "Member 'UEpicMomentAction_1031::IceInterruptConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1031, IceUltimateConfig) == 0x000198, "Member 'UEpicMomentAction_1031::IceUltimateConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1031, IceInterruptAbilities) == 0x0001A8, "Member 'UEpicMomentAction_1031::IceInterruptAbilities' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1031, IceBuffID) == 0x0001B8, "Member 'UEpicMomentAction_1031::IceBuffID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1031, QArmorBuffID) == 0x0001BC, "Member 'UEpicMomentAction_1031::QArmorBuffID' has a wrong offset!");

// Class Hero_1031.LunaSnowAnimInstance
// 0x0040 (0x0950 - 0x0910)
class ULunaSnowAnimInstance : public UMarvelAnimInstance
{
public:
	float                                         SmoothAccRotateSpeed;                              // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_914[0x4];                                      // 0x0914(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SmoothAcceleration;                                // 0x0918(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMovingOrTurnInPlace;                            // 0x0930(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSkating;                                        // 0x0931(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSkateEnding;                                    // 0x0932(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDeath;                                          // 0x0933(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SkatingState;                                      // 0x0934(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_938[0x18];                                     // 0x0938(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeGroundMotionTo103141(bool IsOn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LunaSnowAnimInstance">();
	}
	static class ULunaSnowAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULunaSnowAnimInstance>();
	}
};
static_assert(alignof(ULunaSnowAnimInstance) == 0x000010, "Wrong alignment on ULunaSnowAnimInstance");
static_assert(sizeof(ULunaSnowAnimInstance) == 0x000950, "Wrong size on ULunaSnowAnimInstance");
static_assert(offsetof(ULunaSnowAnimInstance, SmoothAccRotateSpeed) == 0x000910, "Member 'ULunaSnowAnimInstance::SmoothAccRotateSpeed' has a wrong offset!");
static_assert(offsetof(ULunaSnowAnimInstance, SmoothAcceleration) == 0x000918, "Member 'ULunaSnowAnimInstance::SmoothAcceleration' has a wrong offset!");
static_assert(offsetof(ULunaSnowAnimInstance, bIsMovingOrTurnInPlace) == 0x000930, "Member 'ULunaSnowAnimInstance::bIsMovingOrTurnInPlace' has a wrong offset!");
static_assert(offsetof(ULunaSnowAnimInstance, bIsSkating) == 0x000931, "Member 'ULunaSnowAnimInstance::bIsSkating' has a wrong offset!");
static_assert(offsetof(ULunaSnowAnimInstance, bIsSkateEnding) == 0x000932, "Member 'ULunaSnowAnimInstance::bIsSkateEnding' has a wrong offset!");
static_assert(offsetof(ULunaSnowAnimInstance, bIsDeath) == 0x000933, "Member 'ULunaSnowAnimInstance::bIsDeath' has a wrong offset!");
static_assert(offsetof(ULunaSnowAnimInstance, SkatingState) == 0x000934, "Member 'ULunaSnowAnimInstance::SkatingState' has a wrong offset!");

// Class Hero_1031.LunaSnowCharacter
// 0x0010 (0x1820 - 0x1810)
class ALunaSnowCharacter : public AMarvelBaseCharacter
{
public:
	class ULunaSnowMoveLogicBaseComponent*        LunaSnowMoveLogic;                                 // 0x1810(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1818[0x8];                                     // 0x1818(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LunaSnowCharacter">();
	}
	static class ALunaSnowCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALunaSnowCharacter>();
	}
};
static_assert(alignof(ALunaSnowCharacter) == 0x000010, "Wrong alignment on ALunaSnowCharacter");
static_assert(sizeof(ALunaSnowCharacter) == 0x001820, "Wrong size on ALunaSnowCharacter");
static_assert(offsetof(ALunaSnowCharacter, LunaSnowMoveLogic) == 0x001810, "Member 'ALunaSnowCharacter::LunaSnowMoveLogic' has a wrong offset!");

// Class Hero_1031.LunaSnowMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class ULunaSnowMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LunaSnowMoveLogicBaseComponent">();
	}
	static class ULunaSnowMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULunaSnowMoveLogicBaseComponent>();
	}
};
static_assert(alignof(ULunaSnowMoveLogicBaseComponent) == 0x000008, "Wrong alignment on ULunaSnowMoveLogicBaseComponent");
static_assert(sizeof(ULunaSnowMoveLogicBaseComponent) == 0x0003F0, "Wrong size on ULunaSnowMoveLogicBaseComponent");

// Class Hero_1031.LunaSnowMovementComponent
// 0x0000 (0x1B60 - 0x1B60)
class ULunaSnowMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LunaSnowMovementComponent">();
	}
	static class ULunaSnowMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULunaSnowMovementComponent>();
	}
};
static_assert(alignof(ULunaSnowMovementComponent) == 0x000010, "Wrong alignment on ULunaSnowMovementComponent");
static_assert(sizeof(ULunaSnowMovementComponent) == 0x001B60, "Wrong size on ULunaSnowMovementComponent");

// Class Hero_1031.TabData_1031
// 0x0000 (0x0050 - 0x0050)
class UTabData_1031 final : public UHeroTabDataBase
{
public:
	void OnActorTakeHealth(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnBuffAddEvent(class UAbilitySystemComponent* Source, class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& EffectSpecStackHandle, const struct FActiveGameplayEffectHandle& EffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1031">();
	}
	static class UTabData_1031* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1031>();
	}
};
static_assert(alignof(UTabData_1031) == 0x000008, "Wrong alignment on UTabData_1031");
static_assert(sizeof(UTabData_1031) == 0x000050, "Wrong size on UTabData_1031");

}

