#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MarvelAI

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "AIModule_structs.hpp"


namespace SDK
{

// Enum MarvelAI.EAITeamAction
// NumValues: 0x0007
enum class EAITeamAction : uint8
{
	NoAction                                 = 0,
	AvoidFight                               = 1,
	Sneak                                    = 2,
	RunAway                                  = 3,
	Counter                                  = 4,
	Chase                                    = 5,
	EAITeamAction_MAX                        = 6,
};

// Enum MarvelAI.AIAbilityCheckTarget
// NumValues: 0x0004
enum class EAIAbilityCheckTarget : uint8
{
	Self                                     = 0,
	EnemyTarget                              = 1,
	TeammateTarget                           = 2,
	AIAbilityCheckTarget_MAX                 = 3,
};

// Enum MarvelAI.EAbilityEffectPriority
// NumValues: 0x0008
enum class EAbilityEffectPriority : uint8
{
	Damage                                   = 0,
	Defend                                   = 1,
	Heal                                     = 2,
	Movement                                 = 3,
	Summons                                  = 4,
	BuffEffect                               = 5,
	AbilityType_Highest                      = 6,
	EAbilityEffectPriority_MAX               = 7,
};

// Enum MarvelAI.EOperationType
// NumValues: 0x0005
enum class EOperationType : uint8
{
	Normal                                   = 0,
	Holding                                  = 1,
	Continuous                               = 2,
	Trigger                                  = 3,
	EOperationType_MAX                       = 4,
};

// Enum MarvelAI.EAbilityEffectRangeType
// NumValues: 0x0003
enum class EAbilityEffectRangeType : uint8
{
	Single                                   = 0,
	AOE                                      = 1,
	EAbilityEffectRangeType_MAX              = 2,
};

// Enum MarvelAI.ETargetType
// NumValues: 0x0008
enum class MarvelAI::ETargetType : uint8
{
	Enemy                                    = 0,
	Teammate                                 = 1,
	Self                                     = 2,
	Area                                     = 3,
	Custom                                   = 4,
	TeammateIncludeMe                        = 5,
	None                                     = 255,
	ETargetType_MAX                          = 256,
};

// Enum MarvelAI.ETargetPositionAreaType
// NumValues: 0x0005
enum class ETargetPositionAreaType : uint8
{
	Point                                    = 0,
	Sphere                                   = 1,
	Box                                      = 2,
	Custom                                   = 255,
	ETargetPositionAreaType_MAX              = 256,
};

// Enum MarvelAI.ETargetPositionType
// NumValues: 0x0004
enum class ETargetPositionType : uint8
{
	Release                                  = 0,
	Usage                                    = 1,
	Focus                                    = 2,
	ETargetPositionType_MAX                  = 3,
};

// Enum MarvelAI.EAIActivationAbilityStage
// NumValues: 0x0008
enum class EAIActivationAbilityStage : uint8
{
	None                                     = 0,
	PreWait                                  = 1,
	Press                                    = 2,
	AfterWait                                = 3,
	Canceling                                = 253,
	Canceled                                 = 254,
	Done                                     = 255,
	EAIActivationAbilityStage_MAX            = 256,
};

// Enum MarvelAI.EBattleAreaType
// NumValues: 0x0005
enum class EBattleAreaType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Defend                                   = 2,
	Sniper                                   = 3,
	EBattleAreaType_MAX                      = 4,
};

// Enum MarvelAI.EFireLineSenseType
// NumValues: 0x0003
enum class EFireLineSenseType : uint8
{
	Sight                                    = 0,
	Damage                                   = 1,
	EFireLineSenseType_MAX                   = 2,
};

// Enum MarvelAI.EFireLineSenseState
// NumValues: 0x0004
enum class EFireLineSenseState : uint8
{
	Identifying                              = 0,
	Found                                    = 1,
	TryAvoid                                 = 2,
	EFireLineSenseState_MAX                  = 3,
};

// Enum MarvelAI.EAIDistanceSMTarget
// NumValues: 0x0003
enum class EAIDistanceSMTarget : uint8
{
	ToSelf                                   = 0,
	ToBBKey                                  = 1,
	EAIDistanceSMTarget_MAX                  = 2,
};

// Enum MarvelAI.EAbilityTargetType
// NumValues: 0x0004
enum class EAbilityTargetType : uint32
{
	Node                                     = 0,
	Character                                = 1,
	Summoned                                 = 2,
	EAbilityTargetType_MAX                   = 3,
};

// Enum MarvelAI.EAIIntentionType
// NumValues: 0x0006
enum class EAIIntentionType : uint32
{
	Default                                  = 0,
	Self                                     = 1,
	Enemy                                    = 2,
	Teammate                                 = 3,
	Custom                                   = 4,
	EAIIntentionType_MAX                     = 5,
};

// Enum MarvelAI.EResponseState
// NumValues: 0x0004
enum class EResponseState : uint8
{
	Default                                  = 0,
	TimeOut                                  = 1,
	NoReply                                  = 2,
	EResponseState_MAX                       = 3,
};

// Enum MarvelAI.EStrategyType
// NumValues: 0x0004
enum class EStrategyType : uint32
{
	SuppressArea                             = 0,
	RetreatArea                              = 1,
	HotArea                                  = 2,
	EStrategyType_MAX                        = 3,
};

// Enum MarvelAI.EGroupState
// NumValues: 0x0003
enum class EGroupState : uint32
{
	Red                                      = 0,
	Blue                                     = 1,
	EGroupState_MAX                          = 2,
};

// Enum MarvelAI.EAIDistanceLimit
// NumValues: 0x0005
enum class EAIDistanceLimit : uint8
{
	None                                     = 0,
	Approach                                 = 1,
	KeepDistance                             = 2,
	StayAway                                 = 3,
	EAIDistanceLimit_MAX                     = 4,
};

// Enum MarvelAI.EAIFireLimit
// NumValues: 0x0003
enum class EAIFireLimit : uint8
{
	FreeFire                                 = 0,
	StopFire                                 = 1,
	EAIFireLimit_MAX                         = 2,
};

// Enum MarvelAI.EAIMoveTargetLimit
// NumValues: 0x0003
enum class EAIMoveTargetLimit : uint8
{
	NoLimit                                  = 0,
	GoFrontier                               = 1,
	EAIMoveTargetLimit_MAX                   = 2,
};

// Enum MarvelAI.EDiffOperator
// NumValues: 0x0005
enum class EDiffOperator : uint32
{
	Addition                                 = 0,
	Subtraction                              = 1,
	Multiplication                           = 2,
	Division                                 = 3,
	EDiffOperator_MAX                        = 4,
};

// Enum MarvelAI.ECheckOption
// NumValues: 0x0003
enum class ECheckOption : uint8
{
	CampScore                                = 0,
	CampState                                = 1,
	ECheckOption_MAX                         = 2,
};

// Enum MarvelAI.ETargetCampState
// NumValues: 0x0004
enum class ETargetCampState : uint8
{
	Neutral                                  = 0,
	AllyControl                              = 1,
	EnemyControl                             = 2,
	ETargetCampState_MAX                     = 3,
};

// Enum MarvelAI.EPayloadState
// NumValues: 0x0006
enum class EPayloadState : uint8
{
	Neutral                                  = 1,
	AttackerForward                          = 2,
	AttackerStop                             = 4,
	DefenderBackward                         = 8,
	DefenderStop                             = 16,
	EPayloadState_MAX                        = 17,
};

// Enum MarvelAI.EActionCategory
// NumValues: 0x0007
enum class EActionCategory : uint8
{
	None                                     = 0,
	Any                                      = 1,
	Normal                                   = 2,
	Suppress                                 = 3,
	PartialDefense                           = 4,
	AllDefense                               = 5,
	EActionCategory_MAX                      = 6,
};

// Enum MarvelAI.ECalculateType
// NumValues: 0x0003
enum class ECalculateType : uint8
{
	Number                                   = 0,
	Health                                   = 1,
	ECalculateType_MAX                       = 2,
};

// Enum MarvelAI.EPropertyValueType
// NumValues: 0x0003
enum class EPropertyValueType : uint8
{
	CurrentValue                             = 0,
	MaxValue                                 = 1,
	EPropertyValueType_MAX                   = 2,
};

// Enum MarvelAI.EFrontierState
// NumValues: 0x0009
enum class EFrontierState : uint8
{
	None                                     = 1,
	Enemy                                    = 2,
	Ally                                     = 4,
	Both                                     = 8,
	Forward                                  = 16,
	Backward                                 = 32,
	Stop                                     = 64,
	Contesting                               = 128,
	EFrontierState_MAX                       = 129,
};

// Enum MarvelAI.EAITargetType
// NumValues: 0x0007
enum class EAITargetType : uint8
{
	AllysInView                              = 0,
	EnemiesInView                            = 1,
	AliveEnemies                             = 2,
	AliveAllys                               = 3,
	DangerAroundEnemies                      = 4,
	DangerAroundAllys                        = 5,
	EAITargetType_MAX                        = 6,
};

// Enum MarvelAI.EAICommunicateType
// NumValues: 0x0005
enum class EAICommunicateType : uint8
{
	None                                     = 0,
	Quick                                    = 1,
	Message                                  = 2,
	Null                                     = 3,
	EAICommunicateType_MAX                   = 4,
};

// Enum MarvelAI.EAIGameEvent
// NumValues: 0x000A
enum class EAIGameEvent : uint8
{
	None                                     = 0,
	GameBegin                                = 1,
	GameEnd                                  = 2,
	Death                                    = 3,
	AllyAllDeath                             = 4,
	EnemyAllDeath                            = 5,
	BeHeal                                   = 6,
	EnergyFull                               = 7,
	PoorHealth                               = 8,
	EAIGameEvent_MAX                         = 9,
};

// Enum MarvelAI.EBT_GameModeTag
// NumValues: 0x0005
enum class EBT_GameModeTag : uint8
{
	Control                                  = 0,
	Escort                                   = 1,
	Hybrid                                   = 2,
	Other                                    = 3,
	EBT_MAX                                  = 4,
};

// Enum MarvelAI.EPinEnum
// NumValues: 0x0005
enum class EPinEnum : uint8
{
	Attack                                   = 0,
	NeedHeal                                 = 1,
	UltimateCharge                           = 2,
	FallBack                                 = 3,
	EPinEnum_MAX                             = 4,
};

// Enum MarvelAI.EAIAbilityCounterTarget
// NumValues: 0x000A
enum class EAIAbilityCounterTarget : uint8
{
	None                                     = 0,
	Execute                                  = 1,
	User                                     = 2,
	Summoned                                 = 3,
	Projectile                               = 4,
	Scope                                    = 5,
	Target                                   = 6,
	CustomLogic                              = 254,
	Unknown                                  = 255,
	EAIAbilityCounterTarget_MAX              = 256,
};

// Enum MarvelAI.EFlowTemplate
// NumValues: 0x0005
enum class EFlowTemplate : uint8
{
	Button                                   = 0,
	Button_Delay_Button                      = 1,
	Button_CButton                           = 2,
	Custom                                   = 3,
	EFlowTemplate_MAX                        = 4,
};

// Enum MarvelAI.EAbilityCheckType
// NumValues: 0x0004
enum class EAbilityCheckType : uint8
{
	All                                      = 0,
	Base                                     = 1,
	Skip                                     = 2,
	EAbilityCheckType_MAX                    = 3,
};

// Enum MarvelAI.EAIScoreArea
// NumValues: 0x0004
enum class EAIScoreArea : uint8
{
	BasePlus                                 = 0,
	Multiple                                 = 1,
	ExtraPlus                                = 2,
	EAIScoreArea_MAX                         = 3,
};

// Enum MarvelAI.EDestructionState
// NumValues: 0x0004
enum class EDestructionState : uint8
{
	None                                     = 0,
	Unbroken                                 = 1,
	Broken                                   = 2,
	EDestructionState_MAX                    = 3,
};

// Enum MarvelAI.EAITrainingType
// NumValues: 0x0006
enum class EAITrainingType : uint8
{
	Fly                                      = 0,
	Land                                     = 1,
	Jump                                     = 2,
	Patrol                                   = 3,
	Battle                                   = 4,
	EAITrainingType_MAX                      = 5,
};

// Enum MarvelAI.EDefendStandPointHeroType
// NumValues: 0x0008
enum class EDefendStandPointHeroType : uint8
{
	None                                     = 0,
	Tank_Near                                = 1,
	Tank_Far                                 = 2,
	Damage_Near                              = 3,
	Damage_Far                               = 4,
	Support_Near                             = 5,
	Support_Far                              = 6,
	EDefendStandPointHeroType_MAX            = 7,
};

// Enum MarvelAI.EAIJumpAbilityStrength
// NumValues: 0x0004
enum class EAIJumpAbilityStrength : uint8
{
	JumpNormal                               = 0,
	JumpHigh                                 = 1,
	JumpVeryHigh                             = 2,
	EAIJumpAbilityStrength_MAX               = 3,
};

// Enum MarvelAI.EAssaultProgress
// NumValues: 0x0004
enum class EAssaultProgress : uint8
{
	A_Before                                 = 0,
	A_Attacking                              = 1,
	A_Done                                   = 2,
	A_MAX                                    = 3,
};

// Enum MarvelAI.EAssaultStage
// NumValues: 0x0003
enum class EAssaultStage : uint8
{
	A_Point                                  = 0,
	B_Point                                  = 1,
	EAssaultStage_MAX                        = 2,
};

// Enum MarvelAI.EEscortProgress
// NumValues: 0x0005
enum class EEscortProgress : uint8
{
	Ready                                    = 0,
	Go_1                                     = 1,
	Go_2                                     = 2,
	Go_3                                     = 3,
	EEscortProgress_MAX                      = 4,
};

// Enum MarvelAI.EAIDifficultyMode
// NumValues: 0x0005
enum class EAIDifficultyMode : uint8
{
	None                                     = 0,
	Static                                   = 1,
	DynamicWeaken                            = 2,
	DynamicStrengthen                        = 3,
	EAIDifficultyMode_MAX                    = 4,
};

// Enum MarvelAI.EAIHeroType
// NumValues: 0x0003
enum class EAIHeroType : uint8
{
	Normal                                   = 0,
	Sniper                                   = 1,
	EAIHeroType_MAX                          = 2,
};

// Enum MarvelAI.EAIAbilityResource
// NumValues: 0x0004
enum class EAIAbilityResource : uint8
{
	None                                     = 0,
	Move                                     = 1,
	Focus                                    = 2,
	EAIAbilityResource_MAX                   = 3,
};

// Enum MarvelAI.EAIMoveType
// NumValues: 0x0004
enum class EAIMoveType : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	BattleMove                               = 2,
	EAIMoveType_MAX                          = 3,
};

// Enum MarvelAI.EAIBattleMoveType
// NumValues: 0x0005
enum class EAIBattleMoveType : uint8
{
	Default                                  = 0,
	Straight                                 = 1,
	Ground                                   = 2,
	Fly                                      = 3,
	EAIBattleMoveType_MAX                    = 4,
};

// Enum MarvelAI.EAIResourceConflictBehavior
// NumValues: 0x0005
enum class EAIResourceConflictBehavior : uint8
{
	Disable                                  = 0,
	Wait                                     = 1,
	Rerun                                    = 2,
	Ignore                                   = 3,
	EAIResourceConflictBehavior_MAX          = 4,
};

// Enum MarvelAI.EMarvelStandPointShareType
// NumValues: 0x0004
enum class EMarvelStandPointShareType : uint8
{
	Default                                  = 0,
	Share                                    = 1,
	SelfOnly                                 = 2,
	EMarvelStandPointShareType_MAX           = 3,
};

// Enum MarvelAI.EMarvelHealthBarType
// NumValues: 0x0007
enum class EMarvelHealthBarType : uint8
{
	None                                     = 0,
	Health                                   = 1,
	Armor                                    = 2,
	Shield                                   = 4,
	SpareHealth                              = 8,
	All                                      = 7,
	EMarvelHealthBarType_MAX                 = 9,
};

// Enum MarvelAI.EAIFilterSide
// NumValues: 0x0007
enum class EAIFilterSide : uint8
{
	Neutral                                  = 0,
	Enemy                                    = 1,
	Teammate                                 = 2,
	AnySide                                  = 3,
	Anywhere                                 = 4,
	Unknown                                  = 255,
	EAIFilterSide_MAX                        = 256,
};

// Enum MarvelAI.EMarvelArithmeticOperation
// NumValues: 0x0007
enum class EMarvelArithmeticOperation : uint8
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	Less                                     = 2,
	LessOrEqual                              = 3,
	Greater                                  = 4,
	GreaterOrEqual                           = 5,
	EMarvelArithmeticOperation_MAX           = 6,
};

// Enum MarvelAI.EAICharacterSide
// NumValues: 0x0004
enum class EAICharacterSide : uint8
{
	All                                      = 0,
	Ally                                     = 1,
	Enemy                                    = 2,
	EAICharacterSide_MAX                     = 3,
};

// Enum MarvelAI.EAICharacterLifeStatus
// NumValues: 0x0004
enum class EAICharacterLifeStatus : uint8
{
	All                                      = 0,
	Alive                                    = 1,
	Dead                                     = 2,
	EAICharacterLifeStatus_MAX               = 3,
};

// Enum MarvelAI.EAbilitySenseNotify
// NumValues: 0x0004
enum class EAbilitySenseNotify : uint8
{
	None                                     = 0,
	Activate                                 = 1,
	End                                      = 2,
	EAbilitySenseNotify_MAX                  = 3,
};

// Enum MarvelAI.EFilterGroup
// NumValues: 0x0003
enum class EFilterGroup : uint8
{
	Ally                                     = 1,
	Enemy                                    = 2,
	EFilterGroup_MAX                         = 3,
};

// Enum MarvelAI.EFilterRole
// NumValues: 0x0004
enum class EFilterRole : uint8
{
	Tank                                     = 1,
	Damage                                   = 2,
	Support                                  = 4,
	EFilterRole_MAX                          = 5,
};

// Enum MarvelAI.ESurviveState
// NumValues: 0x0003
enum class ESurviveState : uint8
{
	Alive                                    = 1,
	Dead                                     = 2,
	ESurviveState_MAX                        = 3,
};

// Enum MarvelAI.EAIChangeHeroReason
// NumValues: 0x0004
enum class EAIChangeHeroReason : uint8
{
	Default                                  = 0,
	BadLineup                                = 1,
	BadPerformance                           = 2,
	EAIChangeHeroReason_MAX                  = 3,
};

// Enum MarvelAI.EAIAnthropomorphic
// NumValues: 0x0004
enum class EAIAnthropomorphic : uint8
{
	None                                     = 0,
	PlayerTeam                               = 1,
	All                                      = 2,
	EAIAnthropomorphic_MAX                   = 3,
};

// Enum MarvelAI.EStandPointType
// NumValues: 0x0005
enum class EStandPointType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Defend                                   = 2,
	Sniper                                   = 3,
	EStandPointType_MAX                      = 4,
};

// Enum MarvelAI.EAIStandPointTeamType
// NumValues: 0x0005
enum class EAIStandPointTeamType : uint8
{
	None                                     = 0,
	Attack                                   = 1,
	Defend                                   = 2,
	Both                                     = 3,
	EAIStandPointTeamType_MAX                = 4,
};

// Enum MarvelAI.EShelterHeightLevel
// NumValues: 0x0003
enum class EShelterHeightLevel : uint8
{
	Normal                                   = 0,
	High                                     = 1,
	EShelterHeightLevel_MAX                  = 2,
};

// Enum MarvelAI.EWayPointMark
// NumValues: 0x0003
enum class EWayPointMark : uint8
{
	Normal                                   = 0,
	Raid                                     = 1,
	EWayPointMark_MAX                        = 2,
};

// ScriptStruct MarvelAI.TacticsTaskParam
// 0x00B0 (0x00B0 - 0x0000)
struct FTacticsTaskParam final
{
public:
	int32                                         TaskIndex;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            TaskOwner;                                         // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TaskTags;                                          // 0x0010(0x0068)(NativeAccessSpecifierPublic)
	int64                                         AbilityID;                                         // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AbilityUsage;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIIntentionType                              Intention;                                         // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x1C];                                      // 0x008C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAIAbilitySelectCheckBase>  OverrideSelectCheckClass;                          // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTacticsTaskParam) == 0x000008, "Wrong alignment on FTacticsTaskParam");
static_assert(sizeof(FTacticsTaskParam) == 0x0000B0, "Wrong size on FTacticsTaskParam");
static_assert(offsetof(FTacticsTaskParam, TaskIndex) == 0x000000, "Member 'FTacticsTaskParam::TaskIndex' has a wrong offset!");
static_assert(offsetof(FTacticsTaskParam, TaskOwner) == 0x000008, "Member 'FTacticsTaskParam::TaskOwner' has a wrong offset!");
static_assert(offsetof(FTacticsTaskParam, TaskTags) == 0x000010, "Member 'FTacticsTaskParam::TaskTags' has a wrong offset!");
static_assert(offsetof(FTacticsTaskParam, AbilityID) == 0x000078, "Member 'FTacticsTaskParam::AbilityID' has a wrong offset!");
static_assert(offsetof(FTacticsTaskParam, AbilityUsage) == 0x000080, "Member 'FTacticsTaskParam::AbilityUsage' has a wrong offset!");
static_assert(offsetof(FTacticsTaskParam, Intention) == 0x000088, "Member 'FTacticsTaskParam::Intention' has a wrong offset!");
static_assert(offsetof(FTacticsTaskParam, OverrideSelectCheckClass) == 0x0000A8, "Member 'FTacticsTaskParam::OverrideSelectCheckClass' has a wrong offset!");

// ScriptStruct MarvelAI.TargetRoleFactor
// 0x00A0 (0x00A0 - 0x0000)
struct FTargetRoleFactor final
{
public:
	TMap<EHeroRole, float>                        RoleFactor;                                        // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, float>                            SummonerFactor;                                    // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetRoleFactor) == 0x000008, "Wrong alignment on FTargetRoleFactor");
static_assert(sizeof(FTargetRoleFactor) == 0x0000A0, "Wrong size on FTargetRoleFactor");
static_assert(offsetof(FTargetRoleFactor, RoleFactor) == 0x000000, "Member 'FTargetRoleFactor::RoleFactor' has a wrong offset!");
static_assert(offsetof(FTargetRoleFactor, SummonerFactor) == 0x000050, "Member 'FTargetRoleFactor::SummonerFactor' has a wrong offset!");

// ScriptStruct MarvelAI.AITargetFactorConfig
// 0x0060 (0x0060 - 0x0000)
struct FAITargetFactorConfig final
{
public:
	TMap<EHeroRole, struct FTargetRoleFactor>     TargetRoleFactorData;                              // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         TargetFactorNotInView;                             // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetFactorForDamageSource;                       // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetFactorForImportantUnit;                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAITargetFactorConfig) == 0x000008, "Wrong alignment on FAITargetFactorConfig");
static_assert(sizeof(FAITargetFactorConfig) == 0x000060, "Wrong size on FAITargetFactorConfig");
static_assert(offsetof(FAITargetFactorConfig, TargetRoleFactorData) == 0x000000, "Member 'FAITargetFactorConfig::TargetRoleFactorData' has a wrong offset!");
static_assert(offsetof(FAITargetFactorConfig, TargetFactorNotInView) == 0x000050, "Member 'FAITargetFactorConfig::TargetFactorNotInView' has a wrong offset!");
static_assert(offsetof(FAITargetFactorConfig, TargetFactorForDamageSource) == 0x000054, "Member 'FAITargetFactorConfig::TargetFactorForDamageSource' has a wrong offset!");
static_assert(offsetof(FAITargetFactorConfig, TargetFactorForImportantUnit) == 0x000058, "Member 'FAITargetFactorConfig::TargetFactorForImportantUnit' has a wrong offset!");

// ScriptStruct MarvelAI.AIEventArgs
// 0x0028 (0x0028 - 0x0000)
struct FAIEventArgs final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeModifierHandle               ModifierParameterHandle;                           // 0x0010(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIEventArgs) == 0x000008, "Wrong alignment on FAIEventArgs");
static_assert(sizeof(FAIEventArgs) == 0x000028, "Wrong size on FAIEventArgs");
static_assert(offsetof(FAIEventArgs, Instigator) == 0x000000, "Member 'FAIEventArgs::Instigator' has a wrong offset!");
static_assert(offsetof(FAIEventArgs, Target) == 0x000008, "Member 'FAIEventArgs::Target' has a wrong offset!");
static_assert(offsetof(FAIEventArgs, ModifierParameterHandle) == 0x000010, "Member 'FAIEventArgs::ModifierParameterHandle' has a wrong offset!");

// ScriptStruct MarvelAI.AbilityTacticsRequest
// 0x00B8 (0x00B8 - 0x0000)
struct FAbilityTacticsRequest final
{
public:
	class UAbilityTacticsTask*                    TaskObject;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTacticsTaskParam                      RequestParam;                                      // 0x0008(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityTacticsRequest) == 0x000008, "Wrong alignment on FAbilityTacticsRequest");
static_assert(sizeof(FAbilityTacticsRequest) == 0x0000B8, "Wrong size on FAbilityTacticsRequest");
static_assert(offsetof(FAbilityTacticsRequest, TaskObject) == 0x000000, "Member 'FAbilityTacticsRequest::TaskObject' has a wrong offset!");
static_assert(offsetof(FAbilityTacticsRequest, RequestParam) == 0x000008, "Member 'FAbilityTacticsRequest::RequestParam' has a wrong offset!");

// ScriptStruct MarvelAI.Range_FloatValue
// 0x0008 (0x0008 - 0x0000)
struct FRange_FloatValue final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRange_FloatValue) == 0x000004, "Wrong alignment on FRange_FloatValue");
static_assert(sizeof(FRange_FloatValue) == 0x000008, "Wrong size on FRange_FloatValue");
static_assert(offsetof(FRange_FloatValue, Min) == 0x000000, "Member 'FRange_FloatValue::Min' has a wrong offset!");
static_assert(offsetof(FRange_FloatValue, Max) == 0x000004, "Member 'FRange_FloatValue::Max' has a wrong offset!");

// ScriptStruct MarvelAI.AILabProtoWeaponClipData
// 0x001C (0x001C - 0x0000)
struct FAILabProtoWeaponClipData final
{
public:
	int32                                         Weapon1;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weapon2;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weapon3;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillEnergy;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillEnergy2;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillEnergy3;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateAbility;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILabProtoWeaponClipData) == 0x000004, "Wrong alignment on FAILabProtoWeaponClipData");
static_assert(sizeof(FAILabProtoWeaponClipData) == 0x00001C, "Wrong size on FAILabProtoWeaponClipData");
static_assert(offsetof(FAILabProtoWeaponClipData, Weapon1) == 0x000000, "Member 'FAILabProtoWeaponClipData::Weapon1' has a wrong offset!");
static_assert(offsetof(FAILabProtoWeaponClipData, Weapon2) == 0x000004, "Member 'FAILabProtoWeaponClipData::Weapon2' has a wrong offset!");
static_assert(offsetof(FAILabProtoWeaponClipData, Weapon3) == 0x000008, "Member 'FAILabProtoWeaponClipData::Weapon3' has a wrong offset!");
static_assert(offsetof(FAILabProtoWeaponClipData, SkillEnergy) == 0x00000C, "Member 'FAILabProtoWeaponClipData::SkillEnergy' has a wrong offset!");
static_assert(offsetof(FAILabProtoWeaponClipData, SkillEnergy2) == 0x000010, "Member 'FAILabProtoWeaponClipData::SkillEnergy2' has a wrong offset!");
static_assert(offsetof(FAILabProtoWeaponClipData, SkillEnergy3) == 0x000014, "Member 'FAILabProtoWeaponClipData::SkillEnergy3' has a wrong offset!");
static_assert(offsetof(FAILabProtoWeaponClipData, UltimateAbility) == 0x000018, "Member 'FAILabProtoWeaponClipData::UltimateAbility' has a wrong offset!");

// ScriptStruct MarvelAI.AIAbilityButtonActivationConfig
// 0x0090 (0x0090 - 0x0000)
struct FAIAbilityButtonActivationConfig final
{
public:
	EAbilityInputBinds                            Button;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRange_FloatValue                      ButtonPressTime;                                   // 0x0004(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UAIAbilityActivationLogic>> PressLogicList;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIAbilityExitStageLogic>   PressCheckLogic;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHavePreWait;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRange_FloatValue                      PreWaitTime;                                       // 0x002C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UAIAbilityActivationLogic>> PreWaitLogicList;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIAbilityExitStageLogic>   PreWaitCheckLogic;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHaveAfterWait;                                    // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRange_FloatValue                      AfterWaitTime;                                     // 0x0054(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UAIAbilityActivationLogic>> AfterWaitLogicList;                                // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIAbilityExitStageLogic>   AfterWaitCheckLogic;                               // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopButton;                                       // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoopNum;                                           // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopTime;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAIAbilityExitStageLogic>   LoopCheckLogic;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAbilityButtonActivationConfig) == 0x000008, "Wrong alignment on FAIAbilityButtonActivationConfig");
static_assert(sizeof(FAIAbilityButtonActivationConfig) == 0x000090, "Wrong size on FAIAbilityButtonActivationConfig");
static_assert(offsetof(FAIAbilityButtonActivationConfig, Button) == 0x000000, "Member 'FAIAbilityButtonActivationConfig::Button' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, ButtonPressTime) == 0x000004, "Member 'FAIAbilityButtonActivationConfig::ButtonPressTime' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, PressLogicList) == 0x000010, "Member 'FAIAbilityButtonActivationConfig::PressLogicList' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, PressCheckLogic) == 0x000020, "Member 'FAIAbilityButtonActivationConfig::PressCheckLogic' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, bHavePreWait) == 0x000028, "Member 'FAIAbilityButtonActivationConfig::bHavePreWait' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, PreWaitTime) == 0x00002C, "Member 'FAIAbilityButtonActivationConfig::PreWaitTime' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, PreWaitLogicList) == 0x000038, "Member 'FAIAbilityButtonActivationConfig::PreWaitLogicList' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, PreWaitCheckLogic) == 0x000048, "Member 'FAIAbilityButtonActivationConfig::PreWaitCheckLogic' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, bHaveAfterWait) == 0x000050, "Member 'FAIAbilityButtonActivationConfig::bHaveAfterWait' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, AfterWaitTime) == 0x000054, "Member 'FAIAbilityButtonActivationConfig::AfterWaitTime' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, AfterWaitLogicList) == 0x000060, "Member 'FAIAbilityButtonActivationConfig::AfterWaitLogicList' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, AfterWaitCheckLogic) == 0x000070, "Member 'FAIAbilityButtonActivationConfig::AfterWaitCheckLogic' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, bLoopButton) == 0x000078, "Member 'FAIAbilityButtonActivationConfig::bLoopButton' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, LoopNum) == 0x00007C, "Member 'FAIAbilityButtonActivationConfig::LoopNum' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, LoopTime) == 0x000080, "Member 'FAIAbilityButtonActivationConfig::LoopTime' has a wrong offset!");
static_assert(offsetof(FAIAbilityButtonActivationConfig, LoopCheckLogic) == 0x000088, "Member 'FAIAbilityButtonActivationConfig::LoopCheckLogic' has a wrong offset!");

// ScriptStruct MarvelAI.AbilityList
// 0x00A0 (0x00A0 - 0x0000)
struct FAbilityList final
{
public:
	TSet<class UMarvelGameplayAbility*>           Ability;                                           // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TSet<int32>                                   AbilityID;                                         // 0x0050(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityList) == 0x000008, "Wrong alignment on FAbilityList");
static_assert(sizeof(FAbilityList) == 0x0000A0, "Wrong size on FAbilityList");
static_assert(offsetof(FAbilityList, Ability) == 0x000000, "Member 'FAbilityList::Ability' has a wrong offset!");
static_assert(offsetof(FAbilityList, AbilityID) == 0x000050, "Member 'FAbilityList::AbilityID' has a wrong offset!");

// ScriptStruct MarvelAI.MarvelAITarget
// 0x0060 (0x0060 - 0x0000)
struct FMarvelAITarget final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetActorOffset;                                 // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MissOffset;                                        // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseLocation;                                // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomValue;                                       // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsValidRandomValue;                               // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNoTarget;                                       // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMarvelAITarget) == 0x000008, "Wrong alignment on FMarvelAITarget");
static_assert(sizeof(FMarvelAITarget) == 0x000060, "Wrong size on FMarvelAITarget");
static_assert(offsetof(FMarvelAITarget, TargetActor) == 0x000000, "Member 'FMarvelAITarget::TargetActor' has a wrong offset!");
static_assert(offsetof(FMarvelAITarget, TargetLocation) == 0x000008, "Member 'FMarvelAITarget::TargetLocation' has a wrong offset!");
static_assert(offsetof(FMarvelAITarget, TargetActorOffset) == 0x000020, "Member 'FMarvelAITarget::TargetActorOffset' has a wrong offset!");
static_assert(offsetof(FMarvelAITarget, MissOffset) == 0x000038, "Member 'FMarvelAITarget::MissOffset' has a wrong offset!");
static_assert(offsetof(FMarvelAITarget, bShouldUseLocation) == 0x000050, "Member 'FMarvelAITarget::bShouldUseLocation' has a wrong offset!");
static_assert(offsetof(FMarvelAITarget, RandomValue) == 0x000054, "Member 'FMarvelAITarget::RandomValue' has a wrong offset!");
static_assert(offsetof(FMarvelAITarget, bIsValidRandomValue) == 0x000058, "Member 'FMarvelAITarget::bIsValidRandomValue' has a wrong offset!");
static_assert(offsetof(FMarvelAITarget, bIsNoTarget) == 0x000059, "Member 'FMarvelAITarget::bIsNoTarget' has a wrong offset!");

// ScriptStruct MarvelAI.AbilityTargetArea
// 0x0050 (0x0050 - 0x0000)
struct FAbilityTargetArea final
{
public:
	struct FVector                                CenterPosition;                                    // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetPositionAreaType                       TargetPositionType;                                // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereRadius;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxLength;                                         // 0x0020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               BoxRotation;                                       // 0x0038(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityTargetArea) == 0x000008, "Wrong alignment on FAbilityTargetArea");
static_assert(sizeof(FAbilityTargetArea) == 0x000050, "Wrong size on FAbilityTargetArea");
static_assert(offsetof(FAbilityTargetArea, CenterPosition) == 0x000000, "Member 'FAbilityTargetArea::CenterPosition' has a wrong offset!");
static_assert(offsetof(FAbilityTargetArea, TargetPositionType) == 0x000018, "Member 'FAbilityTargetArea::TargetPositionType' has a wrong offset!");
static_assert(offsetof(FAbilityTargetArea, SphereRadius) == 0x00001C, "Member 'FAbilityTargetArea::SphereRadius' has a wrong offset!");
static_assert(offsetof(FAbilityTargetArea, BoxLength) == 0x000020, "Member 'FAbilityTargetArea::BoxLength' has a wrong offset!");
static_assert(offsetof(FAbilityTargetArea, BoxRotation) == 0x000038, "Member 'FAbilityTargetArea::BoxRotation' has a wrong offset!");

// ScriptStruct MarvelAI.AbilityUsagePointData
// 0x0070 (0x0070 - 0x0000)
struct FAbilityUsagePointData final
{
public:
	int32                                         AbilityUsageID;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableReleasePosition : 1;                        // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSetFocusToUsagePosition : 1;                      // 0x0004(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FocusPositionIndex;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityTargetArea                     ReleasePosition;                                   // 0x0010(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FAbilityTargetArea>             UsagePositions;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityUsagePointData) == 0x000008, "Wrong alignment on FAbilityUsagePointData");
static_assert(sizeof(FAbilityUsagePointData) == 0x000070, "Wrong size on FAbilityUsagePointData");
static_assert(offsetof(FAbilityUsagePointData, AbilityUsageID) == 0x000000, "Member 'FAbilityUsagePointData::AbilityUsageID' has a wrong offset!");
static_assert(offsetof(FAbilityUsagePointData, FocusPositionIndex) == 0x000008, "Member 'FAbilityUsagePointData::FocusPositionIndex' has a wrong offset!");
static_assert(offsetof(FAbilityUsagePointData, ReleasePosition) == 0x000010, "Member 'FAbilityUsagePointData::ReleasePosition' has a wrong offset!");
static_assert(offsetof(FAbilityUsagePointData, UsagePositions) == 0x000060, "Member 'FAbilityUsagePointData::UsagePositions' has a wrong offset!");

// ScriptStruct MarvelAI.AIAbilityUsage
// 0x00E8 (0x00E8 - 0x0000)
struct FAIAbilityUsage final
{
public:
	int32                                         UsageID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAITarget                        UsageTarget;                                       // 0x0008(0x0060)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAbilityUsagePointData                 UsagePointData;                                    // 0x0068(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	MarvelAI::ETargetType                         TargetType;                                        // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UsageScore;                                        // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsedByAILab;                                       // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAbilityUsage) == 0x000008, "Wrong alignment on FAIAbilityUsage");
static_assert(sizeof(FAIAbilityUsage) == 0x0000E8, "Wrong size on FAIAbilityUsage");
static_assert(offsetof(FAIAbilityUsage, UsageID) == 0x000000, "Member 'FAIAbilityUsage::UsageID' has a wrong offset!");
static_assert(offsetof(FAIAbilityUsage, UsageTarget) == 0x000008, "Member 'FAIAbilityUsage::UsageTarget' has a wrong offset!");
static_assert(offsetof(FAIAbilityUsage, UsagePointData) == 0x000068, "Member 'FAIAbilityUsage::UsagePointData' has a wrong offset!");
static_assert(offsetof(FAIAbilityUsage, TargetType) == 0x0000D8, "Member 'FAIAbilityUsage::TargetType' has a wrong offset!");
static_assert(offsetof(FAIAbilityUsage, UsageScore) == 0x0000DC, "Member 'FAIAbilityUsage::UsageScore' has a wrong offset!");
static_assert(offsetof(FAIAbilityUsage, UsedByAILab) == 0x0000E0, "Member 'FAIAbilityUsage::UsedByAILab' has a wrong offset!");

// ScriptStruct MarvelAI.AbilityUsagePointCollection
// 0x0010 (0x0010 - 0x0000)
struct FAbilityUsagePointCollection final
{
public:
	TArray<class AAbilityUsageStandPoint*>        ListOfValidPointForUsage;                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityUsagePointCollection) == 0x000008, "Wrong alignment on FAbilityUsagePointCollection");
static_assert(sizeof(FAbilityUsagePointCollection) == 0x000010, "Wrong size on FAbilityUsagePointCollection");
static_assert(offsetof(FAbilityUsagePointCollection, ListOfValidPointForUsage) == 0x000000, "Member 'FAbilityUsagePointCollection::ListOfValidPointForUsage' has a wrong offset!");

// ScriptStruct MarvelAI.AbilityUsagePriorityConfig
// 0x0058 (0x0058 - 0x0000)
struct FAbilityUsagePriorityConfig final
{
public:
	int32                                         BasicPriorityScore;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, int32>              TagToPriority;                                     // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityUsagePriorityConfig) == 0x000008, "Wrong alignment on FAbilityUsagePriorityConfig");
static_assert(sizeof(FAbilityUsagePriorityConfig) == 0x000058, "Wrong size on FAbilityUsagePriorityConfig");
static_assert(offsetof(FAbilityUsagePriorityConfig, BasicPriorityScore) == 0x000000, "Member 'FAbilityUsagePriorityConfig::BasicPriorityScore' has a wrong offset!");
static_assert(offsetof(FAbilityUsagePriorityConfig, TagToPriority) == 0x000008, "Member 'FAbilityUsagePriorityConfig::TagToPriority' has a wrong offset!");

// ScriptStruct MarvelAI.AIAbilityResourcePriorityPair
// 0x0008 (0x0008 - 0x0000)
struct FAIAbilityResourcePriorityPair final
{
public:
	int32                                         UsageID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAbilityResourcePriorityPair) == 0x000004, "Wrong alignment on FAIAbilityResourcePriorityPair");
static_assert(sizeof(FAIAbilityResourcePriorityPair) == 0x000008, "Wrong size on FAIAbilityResourcePriorityPair");
static_assert(offsetof(FAIAbilityResourcePriorityPair, UsageID) == 0x000000, "Member 'FAIAbilityResourcePriorityPair::UsageID' has a wrong offset!");
static_assert(offsetof(FAIAbilityResourcePriorityPair, Priority) == 0x000004, "Member 'FAIAbilityResourcePriorityPair::Priority' has a wrong offset!");

// ScriptStruct MarvelAI.AIAbilityResourceQueue
// 0x0018 (0x0018 - 0x0000)
struct FAIAbilityResourceQueue final
{
public:
	TArray<struct FAIAbilityResourcePriorityPair> ResourceQueue;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EAIAbilityResource                            RequestResource;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAbilityResourceQueue) == 0x000008, "Wrong alignment on FAIAbilityResourceQueue");
static_assert(sizeof(FAIAbilityResourceQueue) == 0x000018, "Wrong size on FAIAbilityResourceQueue");
static_assert(offsetof(FAIAbilityResourceQueue, ResourceQueue) == 0x000000, "Member 'FAIAbilityResourceQueue::ResourceQueue' has a wrong offset!");
static_assert(offsetof(FAIAbilityResourceQueue, RequestResource) == 0x000010, "Member 'FAIAbilityResourceQueue::RequestResource' has a wrong offset!");

// ScriptStruct MarvelAI.AutoAbilityGroup
// 0x0018 (0x0018 - 0x0000)
struct FAutoAbilityGroup final
{
public:
	class AMarvelBaseCharacter*                   Character;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GroupTag;                                          // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAutoAbilityGroup) == 0x000008, "Wrong alignment on FAutoAbilityGroup");
static_assert(sizeof(FAutoAbilityGroup) == 0x000018, "Wrong size on FAutoAbilityGroup");
static_assert(offsetof(FAutoAbilityGroup, Character) == 0x000000, "Member 'FAutoAbilityGroup::Character' has a wrong offset!");
static_assert(offsetof(FAutoAbilityGroup, GroupTag) == 0x000008, "Member 'FAutoAbilityGroup::GroupTag' has a wrong offset!");

// ScriptStruct MarvelAI.AIChangeHeroDebugInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FAIChangeHeroDebugInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIChangeHeroDebugInfo) == 0x000004, "Wrong alignment on FAIChangeHeroDebugInfo");
static_assert(sizeof(FAIChangeHeroDebugInfo) == 0x000010, "Wrong size on FAIChangeHeroDebugInfo");

// ScriptStruct MarvelAI.AIHitModifyDebugInfo
// 0x0001 (0x0001 - 0x0000)
struct FAIHitModifyDebugInfo final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIHitModifyDebugInfo) == 0x000001, "Wrong alignment on FAIHitModifyDebugInfo");
static_assert(sizeof(FAIHitModifyDebugInfo) == 0x000001, "Wrong size on FAIHitModifyDebugInfo");

// ScriptStruct MarvelAI.MyStruct1
// 0x0001 (0x0001 - 0x0000)
struct FMyStruct1
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMyStruct1) == 0x000001, "Wrong alignment on FMyStruct1");
static_assert(sizeof(FMyStruct1) == 0x000001, "Wrong size on FMyStruct1");

// ScriptStruct MarvelAI.MyStruct2
// 0x0000 (0x0001 - 0x0001)
struct FMyStruct2 : public FMyStruct1
{
};
static_assert(alignof(FMyStruct2) == 0x000001, "Wrong alignment on FMyStruct2");
static_assert(sizeof(FMyStruct2) == 0x000001, "Wrong size on FMyStruct2");

// ScriptStruct MarvelAI.MyStruct3
// 0x0000 (0x0001 - 0x0001)
struct FMyStruct3 : public FMyStruct2
{
};
static_assert(alignof(FMyStruct3) == 0x000001, "Wrong alignment on FMyStruct3");
static_assert(sizeof(FMyStruct3) == 0x000001, "Wrong size on FMyStruct3");

// ScriptStruct MarvelAI.MyStruct4
// 0x0000 (0x0001 - 0x0001)
struct FMyStruct4 final : public FMyStruct3
{
};
static_assert(alignof(FMyStruct4) == 0x000001, "Wrong alignment on FMyStruct4");
static_assert(sizeof(FMyStruct4) == 0x000001, "Wrong size on FMyStruct4");

// ScriptStruct MarvelAI.MyStruct5
// 0x0000 (0x0001 - 0x0001)
struct FMyStruct5 final : public FMyStruct3
{
};
static_assert(alignof(FMyStruct5) == 0x000001, "Wrong alignment on FMyStruct5");
static_assert(sizeof(FMyStruct5) == 0x000001, "Wrong size on FMyStruct5");

// ScriptStruct MarvelAI.HitRateModifyAsset
// 0x0010 (0x0010 - 0x0000)
struct FHitRateModifyAsset final
{
public:
	TArray<class UAIHitRateModify*>               AIHitRateModify;                                   // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHitRateModifyAsset) == 0x000008, "Wrong alignment on FHitRateModifyAsset");
static_assert(sizeof(FHitRateModifyAsset) == 0x000010, "Wrong size on FHitRateModifyAsset");
static_assert(offsetof(FHitRateModifyAsset, AIHitRateModify) == 0x000000, "Member 'FHitRateModifyAsset::AIHitRateModify' has a wrong offset!");

// ScriptStruct MarvelAI.AbilityCDCache
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FAbilityCDCache final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityCDCache) == 0x000008, "Wrong alignment on FAbilityCDCache");
static_assert(sizeof(FAbilityCDCache) == 0x000050, "Wrong size on FAbilityCDCache");

// ScriptStruct MarvelAI.AIImpressionBase
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FAIImpressionBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIImpressionBase) == 0x000008, "Wrong alignment on FAIImpressionBase");
static_assert(sizeof(FAIImpressionBase) == 0x000008, "Wrong size on FAIImpressionBase");

// ScriptStruct MarvelAI.AIImpressionAbilityData
// 0x0010 (0x0018 - 0x0008)
struct FAIImpressionAbilityData final : public FAIImpressionBase
{
public:
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelGameplayAbility*                 Ability;                                           // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIImpressionAbilityData) == 0x000008, "Wrong alignment on FAIImpressionAbilityData");
static_assert(sizeof(FAIImpressionAbilityData) == 0x000018, "Wrong size on FAIImpressionAbilityData");
static_assert(offsetof(FAIImpressionAbilityData, Instigator) == 0x000008, "Member 'FAIImpressionAbilityData::Instigator' has a wrong offset!");
static_assert(offsetof(FAIImpressionAbilityData, Ability) == 0x000010, "Member 'FAIImpressionAbilityData::Ability' has a wrong offset!");

// ScriptStruct MarvelAI.AIImpressionSummonedData
// 0x0010 (0x0018 - 0x0008)
struct FAIImpressionSummonedData final : public FAIImpressionBase
{
public:
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelSummonedComponent*               Summoned;                                          // 0x0010(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIImpressionSummonedData) == 0x000008, "Wrong alignment on FAIImpressionSummonedData");
static_assert(sizeof(FAIImpressionSummonedData) == 0x000018, "Wrong size on FAIImpressionSummonedData");
static_assert(offsetof(FAIImpressionSummonedData, Instigator) == 0x000008, "Member 'FAIImpressionSummonedData::Instigator' has a wrong offset!");
static_assert(offsetof(FAIImpressionSummonedData, Summoned) == 0x000010, "Member 'FAIImpressionSummonedData::Summoned' has a wrong offset!");

// ScriptStruct MarvelAI.AIImpressionProjectileData
// 0x0010 (0x0018 - 0x0008)
struct FAIImpressionProjectileData final : public FAIImpressionBase
{
public:
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelAbilityTargetActor_Projectile*   Projectile;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIImpressionProjectileData) == 0x000008, "Wrong alignment on FAIImpressionProjectileData");
static_assert(sizeof(FAIImpressionProjectileData) == 0x000018, "Wrong size on FAIImpressionProjectileData");
static_assert(offsetof(FAIImpressionProjectileData, Instigator) == 0x000008, "Member 'FAIImpressionProjectileData::Instigator' has a wrong offset!");
static_assert(offsetof(FAIImpressionProjectileData, Projectile) == 0x000010, "Member 'FAIImpressionProjectileData::Projectile' has a wrong offset!");

// ScriptStruct MarvelAI.AIImpressionScopeData
// 0x0010 (0x0018 - 0x0008)
struct FAIImpressionScopeData final : public FAIImpressionBase
{
public:
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelAbilityTargetActor_Scope*        Scope;                                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIImpressionScopeData) == 0x000008, "Wrong alignment on FAIImpressionScopeData");
static_assert(sizeof(FAIImpressionScopeData) == 0x000018, "Wrong size on FAIImpressionScopeData");
static_assert(offsetof(FAIImpressionScopeData, Instigator) == 0x000008, "Member 'FAIImpressionScopeData::Instigator' has a wrong offset!");
static_assert(offsetof(FAIImpressionScopeData, Scope) == 0x000010, "Member 'FAIImpressionScopeData::Scope' has a wrong offset!");

// ScriptStruct MarvelAI.AIImpressionGamePlayTagData
// 0x0050 (0x0058 - 0x0008)
struct FAIImpressionGamePlayTagData final : public FAIImpressionBase
{
public:
	TSet<class AActor*>                           TagOwner;                                          // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIImpressionGamePlayTagData) == 0x000008, "Wrong alignment on FAIImpressionGamePlayTagData");
static_assert(sizeof(FAIImpressionGamePlayTagData) == 0x000058, "Wrong size on FAIImpressionGamePlayTagData");
static_assert(offsetof(FAIImpressionGamePlayTagData, TagOwner) == 0x000008, "Member 'FAIImpressionGamePlayTagData::TagOwner' has a wrong offset!");

// ScriptStruct MarvelAI.AIImpressionAgentTraceData
// 0x0010 (0x0010 - 0x0000)
struct FAIImpressionAgentTraceData final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAgentTraceComponent*             TraceComponent;                                    // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIImpressionAgentTraceData) == 0x000008, "Wrong alignment on FAIImpressionAgentTraceData");
static_assert(sizeof(FAIImpressionAgentTraceData) == 0x000010, "Wrong size on FAIImpressionAgentTraceData");
static_assert(offsetof(FAIImpressionAgentTraceData, Instigator) == 0x000000, "Member 'FAIImpressionAgentTraceData::Instigator' has a wrong offset!");
static_assert(offsetof(FAIImpressionAgentTraceData, TraceComponent) == 0x000008, "Member 'FAIImpressionAgentTraceData::TraceComponent' has a wrong offset!");

// ScriptStruct MarvelAI.AIImpressionFireLine
// 0x0018 (0x0018 - 0x0000)
struct FAIImpressionFireLine final
{
public:
	class AMarvelBaseCharacter*                   Target;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFireLineSenseType                            FireLineSenseType;                                 // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFireLineSenseState                           FireLineSenseState;                                // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SenseStateTime;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIImpressionFireLine) == 0x000008, "Wrong alignment on FAIImpressionFireLine");
static_assert(sizeof(FAIImpressionFireLine) == 0x000018, "Wrong size on FAIImpressionFireLine");
static_assert(offsetof(FAIImpressionFireLine, Target) == 0x000000, "Member 'FAIImpressionFireLine::Target' has a wrong offset!");
static_assert(offsetof(FAIImpressionFireLine, FireLineSenseType) == 0x000008, "Member 'FAIImpressionFireLine::FireLineSenseType' has a wrong offset!");
static_assert(offsetof(FAIImpressionFireLine, FireLineSenseState) == 0x000009, "Member 'FAIImpressionFireLine::FireLineSenseState' has a wrong offset!");
static_assert(offsetof(FAIImpressionFireLine, SenseStateTime) == 0x00000C, "Member 'FAIImpressionFireLine::SenseStateTime' has a wrong offset!");
static_assert(offsetof(FAIImpressionFireLine, Priority) == 0x000010, "Member 'FAIImpressionFireLine::Priority' has a wrong offset!");

// ScriptStruct MarvelAI.AIImpressionData
// 0x0230 (0x0230 - 0x0000)
struct FAIImpressionData final
{
public:
	TSet<struct FAIImpressionAbilityData>         AbilityData;                                       // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSet<struct FAIImpressionSummonedData>        SummonedData;                                      // 0x0050(0x0050)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<struct FAIImpressionProjectileData>      ProjectileData;                                    // 0x00A0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSet<struct FAIImpressionScopeData>           ScopeData;                                         // 0x00F0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSet<struct FAIImpressionAgentTraceData>      AgentTraceData;                                    // 0x0140(0x0050)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<struct FAIImpressionFireLine>            FireLineData;                                      // 0x0190(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FAIImpressionGamePlayTagData> GamePlayTagData;                                   // 0x01E0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAIImpressionData) == 0x000008, "Wrong alignment on FAIImpressionData");
static_assert(sizeof(FAIImpressionData) == 0x000230, "Wrong size on FAIImpressionData");
static_assert(offsetof(FAIImpressionData, AbilityData) == 0x000000, "Member 'FAIImpressionData::AbilityData' has a wrong offset!");
static_assert(offsetof(FAIImpressionData, SummonedData) == 0x000050, "Member 'FAIImpressionData::SummonedData' has a wrong offset!");
static_assert(offsetof(FAIImpressionData, ProjectileData) == 0x0000A0, "Member 'FAIImpressionData::ProjectileData' has a wrong offset!");
static_assert(offsetof(FAIImpressionData, ScopeData) == 0x0000F0, "Member 'FAIImpressionData::ScopeData' has a wrong offset!");
static_assert(offsetof(FAIImpressionData, AgentTraceData) == 0x000140, "Member 'FAIImpressionData::AgentTraceData' has a wrong offset!");
static_assert(offsetof(FAIImpressionData, FireLineData) == 0x000190, "Member 'FAIImpressionData::FireLineData' has a wrong offset!");
static_assert(offsetof(FAIImpressionData, GamePlayTagData) == 0x0001E0, "Member 'FAIImpressionData::GamePlayTagData' has a wrong offset!");

// ScriptStruct MarvelAI.AbilityDangerous
// 0x000C (0x000C - 0x0000)
struct FAbilityDangerous final
{
public:
	int32                                         AbilityID;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DangerousTargetRadius;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForgetAge;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityDangerous) == 0x000004, "Wrong alignment on FAbilityDangerous");
static_assert(sizeof(FAbilityDangerous) == 0x00000C, "Wrong size on FAbilityDangerous");
static_assert(offsetof(FAbilityDangerous, AbilityID) == 0x000000, "Member 'FAbilityDangerous::AbilityID' has a wrong offset!");
static_assert(offsetof(FAbilityDangerous, DangerousTargetRadius) == 0x000004, "Member 'FAbilityDangerous::DangerousTargetRadius' has a wrong offset!");
static_assert(offsetof(FAbilityDangerous, ForgetAge) == 0x000008, "Member 'FAbilityDangerous::ForgetAge' has a wrong offset!");

// ScriptStruct MarvelAI.AISenseDangerousTargetConfig
// 0x0010 (0x0010 - 0x0000)
struct FAISenseDangerousTargetConfig final
{
public:
	TArray<struct FAbilityDangerous>              DangerousTarget;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISenseDangerousTargetConfig) == 0x000008, "Wrong alignment on FAISenseDangerousTargetConfig");
static_assert(sizeof(FAISenseDangerousTargetConfig) == 0x000010, "Wrong size on FAISenseDangerousTargetConfig");
static_assert(offsetof(FAISenseDangerousTargetConfig, DangerousTarget) == 0x000000, "Member 'FAISenseDangerousTargetConfig::DangerousTarget' has a wrong offset!");

// ScriptStruct MarvelAI.AIServerTargetType
// 0x0018 (0x0018 - 0x0000)
struct FAIServerTargetType final
{
public:
	EAbilityTargetType                            TargetType;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         OwnerID;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetUID;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIServerTargetType) == 0x000008, "Wrong alignment on FAIServerTargetType");
static_assert(sizeof(FAIServerTargetType) == 0x000018, "Wrong size on FAIServerTargetType");
static_assert(offsetof(FAIServerTargetType, TargetType) == 0x000000, "Member 'FAIServerTargetType::TargetType' has a wrong offset!");
static_assert(offsetof(FAIServerTargetType, OwnerID) == 0x000008, "Member 'FAIServerTargetType::OwnerID' has a wrong offset!");
static_assert(offsetof(FAIServerTargetType, TargetUID) == 0x000010, "Member 'FAIServerTargetType::TargetUID' has a wrong offset!");

// ScriptStruct MarvelAI.AIServerTargetProtocol
// 0x0020 (0x0020 - 0x0000)
struct FAIServerTargetProtocol final
{
public:
	TArray<struct FAIServerTargetType>            AllyTarget;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAIServerTargetType>            EnemyTarget;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIServerTargetProtocol) == 0x000008, "Wrong alignment on FAIServerTargetProtocol");
static_assert(sizeof(FAIServerTargetProtocol) == 0x000020, "Wrong size on FAIServerTargetProtocol");
static_assert(offsetof(FAIServerTargetProtocol, AllyTarget) == 0x000000, "Member 'FAIServerTargetProtocol::AllyTarget' has a wrong offset!");
static_assert(offsetof(FAIServerTargetProtocol, EnemyTarget) == 0x000010, "Member 'FAIServerTargetProtocol::EnemyTarget' has a wrong offset!");

// ScriptStruct MarvelAI.AIServerIntentionProtocol
// 0x0004 (0x0004 - 0x0000)
struct FAIServerIntentionProtocol final
{
public:
	EAIIntentionType                              Intention;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIServerIntentionProtocol) == 0x000004, "Wrong alignment on FAIServerIntentionProtocol");
static_assert(sizeof(FAIServerIntentionProtocol) == 0x000004, "Wrong size on FAIServerIntentionProtocol");
static_assert(offsetof(FAIServerIntentionProtocol, Intention) == 0x000000, "Member 'FAIServerIntentionProtocol::Intention' has a wrong offset!");

// ScriptStruct MarvelAI.AIServerAbilityProtocol
// 0x0030 (0x0030 - 0x0000)
struct FAIServerAbilityProtocol final
{
public:
	int32                                         AbilityID;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIIntentionType                              Intention;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIServerTargetProtocol                Target;                                            // 0x0008(0x0020)(NativeAccessSpecifierPublic)
	int32                                         AbilityUsageID;                                    // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIServerAbilityProtocol) == 0x000008, "Wrong alignment on FAIServerAbilityProtocol");
static_assert(sizeof(FAIServerAbilityProtocol) == 0x000030, "Wrong size on FAIServerAbilityProtocol");
static_assert(offsetof(FAIServerAbilityProtocol, AbilityID) == 0x000000, "Member 'FAIServerAbilityProtocol::AbilityID' has a wrong offset!");
static_assert(offsetof(FAIServerAbilityProtocol, Intention) == 0x000004, "Member 'FAIServerAbilityProtocol::Intention' has a wrong offset!");
static_assert(offsetof(FAIServerAbilityProtocol, Target) == 0x000008, "Member 'FAIServerAbilityProtocol::Target' has a wrong offset!");
static_assert(offsetof(FAIServerAbilityProtocol, AbilityUsageID) == 0x000028, "Member 'FAIServerAbilityProtocol::AbilityUsageID' has a wrong offset!");

// ScriptStruct MarvelAI.AIServerResponseProtocol
// 0x0020 (0x0020 - 0x0000)
struct FAIServerResponseProtocol final
{
public:
	int32                                         UID;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIServerAbilityProtocol>       Ability;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DynamicDifficultyFactor[0x2];                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIServerResponseProtocol) == 0x000008, "Wrong alignment on FAIServerResponseProtocol");
static_assert(sizeof(FAIServerResponseProtocol) == 0x000020, "Wrong size on FAIServerResponseProtocol");
static_assert(offsetof(FAIServerResponseProtocol, UID) == 0x000000, "Member 'FAIServerResponseProtocol::UID' has a wrong offset!");
static_assert(offsetof(FAIServerResponseProtocol, Ability) == 0x000008, "Member 'FAIServerResponseProtocol::Ability' has a wrong offset!");
static_assert(offsetof(FAIServerResponseProtocol, DynamicDifficultyFactor) == 0x000018, "Member 'FAIServerResponseProtocol::DynamicDifficultyFactor' has a wrong offset!");

// ScriptStruct MarvelAI.AIServerControlProtocol
// 0x0068 (0x0068 - 0x0000)
struct FAIServerControlProtocol final
{
public:
	int32                                         RequestID;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AILabTeam;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AIDifficulty[0x2];                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FAIServerResponseProtocol> Control;                                           // 0x0010(0x0050)(NativeAccessSpecifierPublic)
	float                                         DynamicDifficultyFactor[0x2];                      // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIServerControlProtocol) == 0x000008, "Wrong alignment on FAIServerControlProtocol");
static_assert(sizeof(FAIServerControlProtocol) == 0x000068, "Wrong size on FAIServerControlProtocol");
static_assert(offsetof(FAIServerControlProtocol, RequestID) == 0x000000, "Member 'FAIServerControlProtocol::RequestID' has a wrong offset!");
static_assert(offsetof(FAIServerControlProtocol, AILabTeam) == 0x000004, "Member 'FAIServerControlProtocol::AILabTeam' has a wrong offset!");
static_assert(offsetof(FAIServerControlProtocol, AIDifficulty) == 0x000008, "Member 'FAIServerControlProtocol::AIDifficulty' has a wrong offset!");
static_assert(offsetof(FAIServerControlProtocol, Control) == 0x000010, "Member 'FAIServerControlProtocol::Control' has a wrong offset!");
static_assert(offsetof(FAIServerControlProtocol, DynamicDifficultyFactor) == 0x000060, "Member 'FAIServerControlProtocol::DynamicDifficultyFactor' has a wrong offset!");

// ScriptStruct MarvelAI.AIServerRequestID
// 0x0004 (0x0004 - 0x0000)
struct FAIServerRequestID final
{
public:
	int32                                         RequestUID;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIServerRequestID) == 0x000004, "Wrong alignment on FAIServerRequestID");
static_assert(sizeof(FAIServerRequestID) == 0x000004, "Wrong size on FAIServerRequestID");
static_assert(offsetof(FAIServerRequestID, RequestUID) == 0x000000, "Member 'FAIServerRequestID::RequestUID' has a wrong offset!");

// ScriptStruct MarvelAI.AIServerResponseCode
// 0x0001 (0x0001 - 0x0000)
struct FAIServerResponseCode final
{
public:
	EResponseState                                ResponseCode;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIServerResponseCode) == 0x000001, "Wrong alignment on FAIServerResponseCode");
static_assert(sizeof(FAIServerResponseCode) == 0x000001, "Wrong size on FAIServerResponseCode");
static_assert(offsetof(FAIServerResponseCode, ResponseCode) == 0x000000, "Member 'FAIServerResponseCode::ResponseCode' has a wrong offset!");

// ScriptStruct MarvelAI.AILabProtoBattleRecordData
// 0x001C (0x001C - 0x0000)
struct FAILabProtoBattleRecordData final
{
public:
	int32                                         KillCount;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeathCount;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssistCount;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitRate;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Injured;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Heal;                                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILabProtoBattleRecordData) == 0x000004, "Wrong alignment on FAILabProtoBattleRecordData");
static_assert(sizeof(FAILabProtoBattleRecordData) == 0x00001C, "Wrong size on FAILabProtoBattleRecordData");
static_assert(offsetof(FAILabProtoBattleRecordData, KillCount) == 0x000000, "Member 'FAILabProtoBattleRecordData::KillCount' has a wrong offset!");
static_assert(offsetof(FAILabProtoBattleRecordData, DeathCount) == 0x000004, "Member 'FAILabProtoBattleRecordData::DeathCount' has a wrong offset!");
static_assert(offsetof(FAILabProtoBattleRecordData, AssistCount) == 0x000008, "Member 'FAILabProtoBattleRecordData::AssistCount' has a wrong offset!");
static_assert(offsetof(FAILabProtoBattleRecordData, HitRate) == 0x00000C, "Member 'FAILabProtoBattleRecordData::HitRate' has a wrong offset!");
static_assert(offsetof(FAILabProtoBattleRecordData, Damage) == 0x000010, "Member 'FAILabProtoBattleRecordData::Damage' has a wrong offset!");
static_assert(offsetof(FAILabProtoBattleRecordData, Injured) == 0x000014, "Member 'FAILabProtoBattleRecordData::Injured' has a wrong offset!");
static_assert(offsetof(FAILabProtoBattleRecordData, Heal) == 0x000018, "Member 'FAILabProtoBattleRecordData::Heal' has a wrong offset!");

// ScriptStruct MarvelAI.AILabProtoBuffData
// 0x0008 (0x0008 - 0x0000)
struct FAILabProtoBuffData final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILabProtoBuffData) == 0x000004, "Wrong alignment on FAILabProtoBuffData");
static_assert(sizeof(FAILabProtoBuffData) == 0x000008, "Wrong size on FAILabProtoBuffData");
static_assert(offsetof(FAILabProtoBuffData, ID) == 0x000000, "Member 'FAILabProtoBuffData::ID' has a wrong offset!");
static_assert(offsetof(FAILabProtoBuffData, Duration) == 0x000004, "Member 'FAILabProtoBuffData::Duration' has a wrong offset!");

// ScriptStruct MarvelAI.AILabProtoAbilityData
// 0x00A0 (0x00A0 - 0x0000)
struct FAILabProtoAbilityData final
{
public:
	TSet<int32>                                   ActivatedAbility;                                  // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSet<int32>                                   CoolDownAbility;                                   // 0x0050(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILabProtoAbilityData) == 0x000008, "Wrong alignment on FAILabProtoAbilityData");
static_assert(sizeof(FAILabProtoAbilityData) == 0x0000A0, "Wrong size on FAILabProtoAbilityData");
static_assert(offsetof(FAILabProtoAbilityData, ActivatedAbility) == 0x000000, "Member 'FAILabProtoAbilityData::ActivatedAbility' has a wrong offset!");
static_assert(offsetof(FAILabProtoAbilityData, CoolDownAbility) == 0x000050, "Member 'FAILabProtoAbilityData::CoolDownAbility' has a wrong offset!");

// ScriptStruct MarvelAI.AILabProtoEnvironmentData
// 0x0040 (0x0040 - 0x0000)
struct FAILabProtoEnvironmentData final
{
public:
	TArray<int32>                                 AllyInViewCharacterUID;                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 EnemyInViewCharacterUID;                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 AllyJustDisappearedCharacterUID;                   // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 EnemyJustDisappearedCharacterUID;                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILabProtoEnvironmentData) == 0x000008, "Wrong alignment on FAILabProtoEnvironmentData");
static_assert(sizeof(FAILabProtoEnvironmentData) == 0x000040, "Wrong size on FAILabProtoEnvironmentData");
static_assert(offsetof(FAILabProtoEnvironmentData, AllyInViewCharacterUID) == 0x000000, "Member 'FAILabProtoEnvironmentData::AllyInViewCharacterUID' has a wrong offset!");
static_assert(offsetof(FAILabProtoEnvironmentData, EnemyInViewCharacterUID) == 0x000010, "Member 'FAILabProtoEnvironmentData::EnemyInViewCharacterUID' has a wrong offset!");
static_assert(offsetof(FAILabProtoEnvironmentData, AllyJustDisappearedCharacterUID) == 0x000020, "Member 'FAILabProtoEnvironmentData::AllyJustDisappearedCharacterUID' has a wrong offset!");
static_assert(offsetof(FAILabProtoEnvironmentData, EnemyJustDisappearedCharacterUID) == 0x000030, "Member 'FAILabProtoEnvironmentData::EnemyJustDisappearedCharacterUID' has a wrong offset!");

// ScriptStruct MarvelAI.AILabProtoCharacterData
// 0x01B0 (0x01B0 - 0x0000)
struct FAILabProtoCharacterData final
{
public:
	int32                                         UID;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRobot;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MoveMode;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SculptID;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDeath;                                           // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Other;                                             // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rotation;                                          // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleSide;                                        // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAILabProtoBuffData>            BuffData;                                          // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAILabProtoAbilityData                 AbilityUsageData;                                  // 0x0080(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAILabProtoEnvironmentData             EnvironmentData;                                   // 0x0120(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAILabProtoWeaponClipData              WeaponClip;                                        // 0x0160(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FAILabProtoBattleRecordData            BattleRecordBoard;                                 // 0x017C(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CurrentAmmoTypes;                                  // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AllyTargetUID;                                     // 0x01A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyTargetUID;                                    // 0x01AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILabProtoCharacterData) == 0x000008, "Wrong alignment on FAILabProtoCharacterData");
static_assert(sizeof(FAILabProtoCharacterData) == 0x0001B0, "Wrong size on FAILabProtoCharacterData");
static_assert(offsetof(FAILabProtoCharacterData, UID) == 0x000000, "Member 'FAILabProtoCharacterData::UID' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, ID) == 0x000004, "Member 'FAILabProtoCharacterData::ID' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, IsRobot) == 0x000008, "Member 'FAILabProtoCharacterData::IsRobot' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, MoveMode) == 0x00000C, "Member 'FAILabProtoCharacterData::MoveMode' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, SculptID) == 0x000010, "Member 'FAILabProtoCharacterData::SculptID' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, IsDeath) == 0x000014, "Member 'FAILabProtoCharacterData::IsDeath' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, Health) == 0x000018, "Member 'FAILabProtoCharacterData::Health' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, Other) == 0x00001C, "Member 'FAILabProtoCharacterData::Other' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, Location) == 0x000020, "Member 'FAILabProtoCharacterData::Location' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, Velocity) == 0x000038, "Member 'FAILabProtoCharacterData::Velocity' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, Rotation) == 0x000050, "Member 'FAILabProtoCharacterData::Rotation' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, BattleSide) == 0x000068, "Member 'FAILabProtoCharacterData::BattleSide' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, BuffData) == 0x000070, "Member 'FAILabProtoCharacterData::BuffData' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, AbilityUsageData) == 0x000080, "Member 'FAILabProtoCharacterData::AbilityUsageData' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, EnvironmentData) == 0x000120, "Member 'FAILabProtoCharacterData::EnvironmentData' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, WeaponClip) == 0x000160, "Member 'FAILabProtoCharacterData::WeaponClip' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, BattleRecordBoard) == 0x00017C, "Member 'FAILabProtoCharacterData::BattleRecordBoard' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, CurrentAmmoTypes) == 0x000198, "Member 'FAILabProtoCharacterData::CurrentAmmoTypes' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, AllyTargetUID) == 0x0001A8, "Member 'FAILabProtoCharacterData::AllyTargetUID' has a wrong offset!");
static_assert(offsetof(FAILabProtoCharacterData, EnemyTargetUID) == 0x0001AC, "Member 'FAILabProtoCharacterData::EnemyTargetUID' has a wrong offset!");

// ScriptStruct MarvelAI.AILabProtoSummonedData
// 0x0038 (0x0038 - 0x0000)
struct FAILabProtoSummonedData final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UID;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwnerID;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleSide;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAILabProtoSummonedData) == 0x000008, "Wrong alignment on FAILabProtoSummonedData");
static_assert(sizeof(FAILabProtoSummonedData) == 0x000038, "Wrong size on FAILabProtoSummonedData");
static_assert(offsetof(FAILabProtoSummonedData, ID) == 0x000000, "Member 'FAILabProtoSummonedData::ID' has a wrong offset!");
static_assert(offsetof(FAILabProtoSummonedData, UID) == 0x000004, "Member 'FAILabProtoSummonedData::UID' has a wrong offset!");
static_assert(offsetof(FAILabProtoSummonedData, OwnerID) == 0x000008, "Member 'FAILabProtoSummonedData::OwnerID' has a wrong offset!");
static_assert(offsetof(FAILabProtoSummonedData, BattleSide) == 0x00000C, "Member 'FAILabProtoSummonedData::BattleSide' has a wrong offset!");
static_assert(offsetof(FAILabProtoSummonedData, Health) == 0x000010, "Member 'FAILabProtoSummonedData::Health' has a wrong offset!");
static_assert(offsetof(FAILabProtoSummonedData, Location) == 0x000018, "Member 'FAILabProtoSummonedData::Location' has a wrong offset!");
static_assert(offsetof(FAILabProtoSummonedData, Duration) == 0x000030, "Member 'FAILabProtoSummonedData::Duration' has a wrong offset!");

// ScriptStruct MarvelAI.AILabProtoBarrierData
// 0x0030 (0x0030 - 0x0000)
struct FAILabProtoBarrierData final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSmash;                                          // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPickUp;                                         // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonerWeaponType;                                // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAILabProtoBarrierData) == 0x000008, "Wrong alignment on FAILabProtoBarrierData");
static_assert(sizeof(FAILabProtoBarrierData) == 0x000030, "Wrong size on FAILabProtoBarrierData");
static_assert(offsetof(FAILabProtoBarrierData, ID) == 0x000000, "Member 'FAILabProtoBarrierData::ID' has a wrong offset!");
static_assert(offsetof(FAILabProtoBarrierData, Location) == 0x000008, "Member 'FAILabProtoBarrierData::Location' has a wrong offset!");
static_assert(offsetof(FAILabProtoBarrierData, bIsSmash) == 0x000020, "Member 'FAILabProtoBarrierData::bIsSmash' has a wrong offset!");
static_assert(offsetof(FAILabProtoBarrierData, bIsPickUp) == 0x000021, "Member 'FAILabProtoBarrierData::bIsPickUp' has a wrong offset!");
static_assert(offsetof(FAILabProtoBarrierData, Health) == 0x000024, "Member 'FAILabProtoBarrierData::Health' has a wrong offset!");
static_assert(offsetof(FAILabProtoBarrierData, SummonerWeaponType) == 0x000028, "Member 'FAILabProtoBarrierData::SummonerWeaponType' has a wrong offset!");

// ScriptStruct MarvelAI.AILabProtoSceneData
// 0x0030 (0x0030 - 0x0000)
struct FAILabProtoSceneData final
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAILabProtoBarrierData>         BarrierData;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAILabProtoSummonedData>        SummonedData;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILabProtoSceneData) == 0x000008, "Wrong alignment on FAILabProtoSceneData");
static_assert(sizeof(FAILabProtoSceneData) == 0x000030, "Wrong size on FAILabProtoSceneData");
static_assert(offsetof(FAILabProtoSceneData, MapName) == 0x000000, "Member 'FAILabProtoSceneData::MapName' has a wrong offset!");
static_assert(offsetof(FAILabProtoSceneData, BarrierData) == 0x000010, "Member 'FAILabProtoSceneData::BarrierData' has a wrong offset!");
static_assert(offsetof(FAILabProtoSceneData, SummonedData) == 0x000020, "Member 'FAILabProtoSceneData::SummonedData' has a wrong offset!");

// ScriptStruct MarvelAI.AILabProtoTickData
// 0x0090 (0x0090 - 0x0000)
struct FAILabProtoTickData final
{
public:
	int64                                         Timestamp;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BattleID;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapID;                                             // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinnerSide;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGameOver;                                        // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAILabProtoCharacterData>       CharacterData;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAILabProtoSceneData                   SceneData;                                         // 0x0050(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<float>                                 LevelParams;                                       // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILabProtoTickData) == 0x000008, "Wrong alignment on FAILabProtoTickData");
static_assert(sizeof(FAILabProtoTickData) == 0x000090, "Wrong size on FAILabProtoTickData");
static_assert(offsetof(FAILabProtoTickData, Timestamp) == 0x000000, "Member 'FAILabProtoTickData::Timestamp' has a wrong offset!");
static_assert(offsetof(FAILabProtoTickData, BattleID) == 0x000008, "Member 'FAILabProtoTickData::BattleID' has a wrong offset!");
static_assert(offsetof(FAILabProtoTickData, MapID) == 0x000018, "Member 'FAILabProtoTickData::MapID' has a wrong offset!");
static_assert(offsetof(FAILabProtoTickData, GameMode) == 0x000028, "Member 'FAILabProtoTickData::GameMode' has a wrong offset!");
static_assert(offsetof(FAILabProtoTickData, WinnerSide) == 0x000038, "Member 'FAILabProtoTickData::WinnerSide' has a wrong offset!");
static_assert(offsetof(FAILabProtoTickData, IsGameOver) == 0x00003C, "Member 'FAILabProtoTickData::IsGameOver' has a wrong offset!");
static_assert(offsetof(FAILabProtoTickData, CharacterData) == 0x000040, "Member 'FAILabProtoTickData::CharacterData' has a wrong offset!");
static_assert(offsetof(FAILabProtoTickData, SceneData) == 0x000050, "Member 'FAILabProtoTickData::SceneData' has a wrong offset!");
static_assert(offsetof(FAILabProtoTickData, LevelParams) == 0x000080, "Member 'FAILabProtoTickData::LevelParams' has a wrong offset!");

// ScriptStruct MarvelAI.RequestParamData
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FRequestParamData final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRequestParamData) == 0x000004, "Wrong alignment on FRequestParamData");
static_assert(sizeof(FRequestParamData) == 0x000004, "Wrong size on FRequestParamData");

// ScriptStruct MarvelAI.AIServerRequestProtocol
// 0x00B0 (0x00B0 - 0x0000)
struct FAIServerRequestProtocol final
{
public:
	int64                                         RequestID;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAIServerRequestID>             RequestAI;                                         // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAILabProtoTickData                    TickData;                                          // 0x0018(0x0090)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIServerRequestProtocol) == 0x000008, "Wrong alignment on FAIServerRequestProtocol");
static_assert(sizeof(FAIServerRequestProtocol) == 0x0000B0, "Wrong size on FAIServerRequestProtocol");
static_assert(offsetof(FAIServerRequestProtocol, RequestID) == 0x000000, "Member 'FAIServerRequestProtocol::RequestID' has a wrong offset!");
static_assert(offsetof(FAIServerRequestProtocol, RequestAI) == 0x000008, "Member 'FAIServerRequestProtocol::RequestAI' has a wrong offset!");
static_assert(offsetof(FAIServerRequestProtocol, TickData) == 0x000018, "Member 'FAIServerRequestProtocol::TickData' has a wrong offset!");

// ScriptStruct MarvelAI.RequestMessageData
// 0x0028 (0x0028 - 0x0000)
struct FRequestMessageData final
{
public:
	class UObject*                                RequestObject;                                     // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RequestUID;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRequestParamData                      RequestParam;                                      // 0x0010(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x14];                                      // 0x0014(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRequestMessageData) == 0x000008, "Wrong alignment on FRequestMessageData");
static_assert(sizeof(FRequestMessageData) == 0x000028, "Wrong size on FRequestMessageData");
static_assert(offsetof(FRequestMessageData, RequestObject) == 0x000000, "Member 'FRequestMessageData::RequestObject' has a wrong offset!");
static_assert(offsetof(FRequestMessageData, RequestUID) == 0x000008, "Member 'FRequestMessageData::RequestUID' has a wrong offset!");
static_assert(offsetof(FRequestMessageData, RequestParam) == 0x000010, "Member 'FRequestMessageData::RequestParam' has a wrong offset!");

// ScriptStruct MarvelAI.StrategyArea
// 0x0090 (0x0090 - 0x0000)
struct FStrategyArea final
{
public:
	struct FBlackboardKeySelector                 OutSuppressArea;                                   // 0x0000(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 OutRetreatArea;                                    // 0x0030(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 OutHotArea;                                        // 0x0060(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStrategyArea) == 0x000008, "Wrong alignment on FStrategyArea");
static_assert(sizeof(FStrategyArea) == 0x000090, "Wrong size on FStrategyArea");
static_assert(offsetof(FStrategyArea, OutSuppressArea) == 0x000000, "Member 'FStrategyArea::OutSuppressArea' has a wrong offset!");
static_assert(offsetof(FStrategyArea, OutRetreatArea) == 0x000030, "Member 'FStrategyArea::OutRetreatArea' has a wrong offset!");
static_assert(offsetof(FStrategyArea, OutHotArea) == 0x000060, "Member 'FStrategyArea::OutHotArea' has a wrong offset!");

// ScriptStruct MarvelAI.TargetChangeConfig
// 0x0050 (0x0050 - 0x0000)
struct FTargetChangeConfig final
{
public:
	TMap<float, float>                            TargetChangeProbabilities;                         // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetChangeConfig) == 0x000008, "Wrong alignment on FTargetChangeConfig");
static_assert(sizeof(FTargetChangeConfig) == 0x000050, "Wrong size on FTargetChangeConfig");
static_assert(offsetof(FTargetChangeConfig, TargetChangeProbabilities) == 0x000000, "Member 'FTargetChangeConfig::TargetChangeProbabilities' has a wrong offset!");

// ScriptStruct MarvelAI.RequiredAIDataForAutoAbility
// 0x0038 (0x0038 - 0x0000)
struct FRequiredAIDataForAutoAbility final
{
public:
	class AMarvelAIController*                    AIController;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TeammateTarget;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TeammateIncludeMeTarget;                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EnemyTarget;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIIntentionType                              Intention;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x14];                                      // 0x0024(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRequiredAIDataForAutoAbility) == 0x000008, "Wrong alignment on FRequiredAIDataForAutoAbility");
static_assert(sizeof(FRequiredAIDataForAutoAbility) == 0x000038, "Wrong size on FRequiredAIDataForAutoAbility");
static_assert(offsetof(FRequiredAIDataForAutoAbility, AIController) == 0x000000, "Member 'FRequiredAIDataForAutoAbility::AIController' has a wrong offset!");
static_assert(offsetof(FRequiredAIDataForAutoAbility, TeammateTarget) == 0x000008, "Member 'FRequiredAIDataForAutoAbility::TeammateTarget' has a wrong offset!");
static_assert(offsetof(FRequiredAIDataForAutoAbility, TeammateIncludeMeTarget) == 0x000010, "Member 'FRequiredAIDataForAutoAbility::TeammateIncludeMeTarget' has a wrong offset!");
static_assert(offsetof(FRequiredAIDataForAutoAbility, EnemyTarget) == 0x000018, "Member 'FRequiredAIDataForAutoAbility::EnemyTarget' has a wrong offset!");
static_assert(offsetof(FRequiredAIDataForAutoAbility, Intention) == 0x000020, "Member 'FRequiredAIDataForAutoAbility::Intention' has a wrong offset!");

// ScriptStruct MarvelAI.CheckFrontCharacterData
// 0x0001 (0x0001 - 0x0000)
struct FCheckFrontCharacterData final
{
public:
	bool                                          bIsRunning;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCheckFrontCharacterData) == 0x000001, "Wrong alignment on FCheckFrontCharacterData");
static_assert(sizeof(FCheckFrontCharacterData) == 0x000001, "Wrong size on FCheckFrontCharacterData");
static_assert(offsetof(FCheckFrontCharacterData, bIsRunning) == 0x000000, "Member 'FCheckFrontCharacterData::bIsRunning' has a wrong offset!");

// ScriptStruct MarvelAI.CoupleActorStruct
// 0x0068 (0x0068 - 0x0000)
struct FCoupleActorStruct final
{
public:
	struct FBlackboardKeySelector                 SourceActor;                                       // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 TargetActor;                                       // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
	float                                         MultipleNum;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoupleActorStruct) == 0x000008, "Wrong alignment on FCoupleActorStruct");
static_assert(sizeof(FCoupleActorStruct) == 0x000068, "Wrong size on FCoupleActorStruct");
static_assert(offsetof(FCoupleActorStruct, SourceActor) == 0x000000, "Member 'FCoupleActorStruct::SourceActor' has a wrong offset!");
static_assert(offsetof(FCoupleActorStruct, TargetActor) == 0x000030, "Member 'FCoupleActorStruct::TargetActor' has a wrong offset!");
static_assert(offsetof(FCoupleActorStruct, MultipleNum) == 0x000060, "Member 'FCoupleActorStruct::MultipleNum' has a wrong offset!");

// ScriptStruct MarvelAI.SideScoreConfig
// 0x0014 (0x0014 - 0x0000)
struct FSideScoreConfig final
{
public:
	EAIFilterSide                                 Side;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            Score;                                             // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSideScoreConfig) == 0x000004, "Wrong alignment on FSideScoreConfig");
static_assert(sizeof(FSideScoreConfig) == 0x000014, "Wrong size on FSideScoreConfig");
static_assert(offsetof(FSideScoreConfig, Side) == 0x000000, "Member 'FSideScoreConfig::Side' has a wrong offset!");
static_assert(offsetof(FSideScoreConfig, Score) == 0x000004, "Member 'FSideScoreConfig::Score' has a wrong offset!");

// ScriptStruct MarvelAI.CampStateConfig
// 0x0001 (0x0001 - 0x0000)
struct FCampStateConfig final
{
public:
	EAIFilterSide                                 State;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampStateConfig) == 0x000001, "Wrong alignment on FCampStateConfig");
static_assert(sizeof(FCampStateConfig) == 0x000001, "Wrong size on FCampStateConfig");
static_assert(offsetof(FCampStateConfig, State) == 0x000000, "Member 'FCampStateConfig::State' has a wrong offset!");

// ScriptStruct MarvelAI.ActionRequirement
// 0x0010 (0x0010 - 0x0000)
struct FActionRequirement final
{
public:
	TArray<class UActionRequirementBase*>         Requirement;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActionRequirement) == 0x000008, "Wrong alignment on FActionRequirement");
static_assert(sizeof(FActionRequirement) == 0x000010, "Wrong size on FActionRequirement");
static_assert(offsetof(FActionRequirement, Requirement) == 0x000000, "Member 'FActionRequirement::Requirement' has a wrong offset!");

// ScriptStruct MarvelAI.ActionRequirementNode
// 0x0030 (0x0030 - 0x0000)
struct FActionRequirementNode final
{
public:
	EActionCategory                               AIAction;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionCategory                               DefaultAction;                                     // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActionRequirement>             ActiveRequirement;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FActionRequirement>             DeActiveRequirement;                               // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bAborts;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionRequirementNode) == 0x000008, "Wrong alignment on FActionRequirementNode");
static_assert(sizeof(FActionRequirementNode) == 0x000030, "Wrong size on FActionRequirementNode");
static_assert(offsetof(FActionRequirementNode, AIAction) == 0x000000, "Member 'FActionRequirementNode::AIAction' has a wrong offset!");
static_assert(offsetof(FActionRequirementNode, DefaultAction) == 0x000001, "Member 'FActionRequirementNode::DefaultAction' has a wrong offset!");
static_assert(offsetof(FActionRequirementNode, ActiveRequirement) == 0x000008, "Member 'FActionRequirementNode::ActiveRequirement' has a wrong offset!");
static_assert(offsetof(FActionRequirementNode, DeActiveRequirement) == 0x000018, "Member 'FActionRequirementNode::DeActiveRequirement' has a wrong offset!");
static_assert(offsetof(FActionRequirementNode, bAborts) == 0x000028, "Member 'FActionRequirementNode::bAborts' has a wrong offset!");

// ScriptStruct MarvelAI.AIStateMachine
// 0x0070 (0x0070 - 0x0000)
struct FAIStateMachine final
{
public:
	class UActionRequirementAsset*                ActionTableAsset;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x60];                                       // 0x0008(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	EActionCategory                               CurrentAction;                                     // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EActionCategory                               DefaultAction;                                     // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIStateMachine) == 0x000008, "Wrong alignment on FAIStateMachine");
static_assert(sizeof(FAIStateMachine) == 0x000070, "Wrong size on FAIStateMachine");
static_assert(offsetof(FAIStateMachine, ActionTableAsset) == 0x000000, "Member 'FAIStateMachine::ActionTableAsset' has a wrong offset!");
static_assert(offsetof(FAIStateMachine, CurrentAction) == 0x000068, "Member 'FAIStateMachine::CurrentAction' has a wrong offset!");
static_assert(offsetof(FAIStateMachine, DefaultAction) == 0x000069, "Member 'FAIStateMachine::DefaultAction' has a wrong offset!");

// ScriptStruct MarvelAI.AroundCharacterCheckStruct
// 0x0038 (0x0038 - 0x0000)
struct FAroundCharacterCheckStruct final
{
public:
	struct FBlackboardKeySelector                 FocusActor;                                        // 0x0000(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAroundCharacterCheckStruct) == 0x000008, "Wrong alignment on FAroundCharacterCheckStruct");
static_assert(sizeof(FAroundCharacterCheckStruct) == 0x000038, "Wrong size on FAroundCharacterCheckStruct");
static_assert(offsetof(FAroundCharacterCheckStruct, FocusActor) == 0x000000, "Member 'FAroundCharacterCheckStruct::FocusActor' has a wrong offset!");
static_assert(offsetof(FAroundCharacterCheckStruct, Radius) == 0x000030, "Member 'FAroundCharacterCheckStruct::Radius' has a wrong offset!");

// ScriptStruct MarvelAI.AICommunicateEx
// 0x0070 (0x0070 - 0x0000)
struct FAICommunicateEx final
{
public:
	EAICommunicateType                            Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EHeroRole, int32>                        IDMap;                                             // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         Widget;                                            // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            Delay;                                             // 0x005C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAICommunicateEx) == 0x000008, "Wrong alignment on FAICommunicateEx");
static_assert(sizeof(FAICommunicateEx) == 0x000070, "Wrong size on FAICommunicateEx");
static_assert(offsetof(FAICommunicateEx, Type) == 0x000000, "Member 'FAICommunicateEx::Type' has a wrong offset!");
static_assert(offsetof(FAICommunicateEx, ID) == 0x000004, "Member 'FAICommunicateEx::ID' has a wrong offset!");
static_assert(offsetof(FAICommunicateEx, IDMap) == 0x000008, "Member 'FAICommunicateEx::IDMap' has a wrong offset!");
static_assert(offsetof(FAICommunicateEx, Widget) == 0x000058, "Member 'FAICommunicateEx::Widget' has a wrong offset!");
static_assert(offsetof(FAICommunicateEx, Delay) == 0x00005C, "Member 'FAICommunicateEx::Delay' has a wrong offset!");

// ScriptStruct MarvelAI.AICommunicateList
// 0x0018 (0x0018 - 0x0000)
struct FAICommunicateList final
{
public:
	TArray<struct FAICommunicateEx>               Communicates;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProbabilityAttenuation;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAICommunicateList) == 0x000008, "Wrong alignment on FAICommunicateList");
static_assert(sizeof(FAICommunicateList) == 0x000018, "Wrong size on FAICommunicateList");
static_assert(offsetof(FAICommunicateList, Communicates) == 0x000000, "Member 'FAICommunicateList::Communicates' has a wrong offset!");
static_assert(offsetof(FAICommunicateList, Probability) == 0x000010, "Member 'FAICommunicateList::Probability' has a wrong offset!");
static_assert(offsetof(FAICommunicateList, ProbabilityAttenuation) == 0x000014, "Member 'FAICommunicateList::ProbabilityAttenuation' has a wrong offset!");

// ScriptStruct MarvelAI.AICommunicateData
// 0x0050 (0x0050 - 0x0000)
struct FAICommunicateData final
{
public:
	TMap<EAIGameEvent, struct FAICommunicateList> AICommunicate;                                     // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAICommunicateData) == 0x000008, "Wrong alignment on FAICommunicateData");
static_assert(sizeof(FAICommunicateData) == 0x000050, "Wrong size on FAICommunicateData");
static_assert(offsetof(FAICommunicateData, AICommunicate) == 0x000000, "Member 'FAICommunicateData::AICommunicate' has a wrong offset!");

// ScriptStruct MarvelAI.AICommunicateRow
// 0x0018 (0x0038 - 0x0020)
struct FAICommunicateRow final : public FTableRowBase
{
public:
	class FText                                   AICommunicate;                                     // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAICommunicateRow) == 0x000008, "Wrong alignment on FAICommunicateRow");
static_assert(sizeof(FAICommunicateRow) == 0x000038, "Wrong size on FAICommunicateRow");
static_assert(offsetof(FAICommunicateRow, AICommunicate) == 0x000020, "Member 'FAICommunicateRow::AICommunicate' has a wrong offset!");

// ScriptStruct MarvelAI.MapPoint
// 0x0050 (0x0050 - 0x0000)
struct FMapPoint final
{
public:
	TMap<int32, float>                            Distance;                                          // 0x0000(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FMapPoint) == 0x000008, "Wrong alignment on FMapPoint");
static_assert(sizeof(FMapPoint) == 0x000050, "Wrong size on FMapPoint");
static_assert(offsetof(FMapPoint, Distance) == 0x000000, "Member 'FMapPoint::Distance' has a wrong offset!");

// ScriptStruct MarvelAI.StrategyAreaBBkeyOutput
// 0x0090 (0x0090 - 0x0000)
struct FStrategyAreaBBkeyOutput final
{
public:
	struct FBlackboardKeySelector                 SuppressArea;                                      // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 RetreatArea;                                       // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 HotArea;                                           // 0x0060(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStrategyAreaBBkeyOutput) == 0x000008, "Wrong alignment on FStrategyAreaBBkeyOutput");
static_assert(sizeof(FStrategyAreaBBkeyOutput) == 0x000090, "Wrong size on FStrategyAreaBBkeyOutput");
static_assert(offsetof(FStrategyAreaBBkeyOutput, SuppressArea) == 0x000000, "Member 'FStrategyAreaBBkeyOutput::SuppressArea' has a wrong offset!");
static_assert(offsetof(FStrategyAreaBBkeyOutput, RetreatArea) == 0x000030, "Member 'FStrategyAreaBBkeyOutput::RetreatArea' has a wrong offset!");
static_assert(offsetof(FStrategyAreaBBkeyOutput, HotArea) == 0x000060, "Member 'FStrategyAreaBBkeyOutput::HotArea' has a wrong offset!");

// ScriptStruct MarvelAI.PinPointInfo
// 0x0010 (0x0010 - 0x0000)
struct FPinPointInfo final
{
public:
	struct FGameplayTag                           SignalTag;                                         // 0x0000(0x000C)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CommID;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPinPointInfo) == 0x000004, "Wrong alignment on FPinPointInfo");
static_assert(sizeof(FPinPointInfo) == 0x000010, "Wrong size on FPinPointInfo");
static_assert(offsetof(FPinPointInfo, SignalTag) == 0x000000, "Member 'FPinPointInfo::SignalTag' has a wrong offset!");
static_assert(offsetof(FPinPointInfo, CommID) == 0x00000C, "Member 'FPinPointInfo::CommID' has a wrong offset!");

// ScriptStruct MarvelAI.BTEmoteConfig
// 0x0018 (0x0018 - 0x0000)
struct FBTEmoteConfig final
{
public:
	int64                                         EmoteID;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EmoteDesc;                                         // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBTEmoteConfig) == 0x000008, "Wrong alignment on FBTEmoteConfig");
static_assert(sizeof(FBTEmoteConfig) == 0x000018, "Wrong size on FBTEmoteConfig");
static_assert(offsetof(FBTEmoteConfig, EmoteID) == 0x000000, "Member 'FBTEmoteConfig::EmoteID' has a wrong offset!");
static_assert(offsetof(FBTEmoteConfig, Weight) == 0x000008, "Member 'FBTEmoteConfig::Weight' has a wrong offset!");
static_assert(offsetof(FBTEmoteConfig, EmoteDesc) == 0x00000C, "Member 'FBTEmoteConfig::EmoteDesc' has a wrong offset!");

// ScriptStruct MarvelAI.BTHeroEmoteConfig
// 0x0020 (0x0020 - 0x0000)
struct FBTHeroEmoteConfig final
{
public:
	class FString                                 HeroEmoteConfigDesc;                               // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBTEmoteConfig>                 EmoteProbArray;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBTHeroEmoteConfig) == 0x000008, "Wrong alignment on FBTHeroEmoteConfig");
static_assert(sizeof(FBTHeroEmoteConfig) == 0x000020, "Wrong size on FBTHeroEmoteConfig");
static_assert(offsetof(FBTHeroEmoteConfig, HeroEmoteConfigDesc) == 0x000000, "Member 'FBTHeroEmoteConfig::HeroEmoteConfigDesc' has a wrong offset!");
static_assert(offsetof(FBTHeroEmoteConfig, EmoteProbArray) == 0x000010, "Member 'FBTHeroEmoteConfig::EmoteProbArray' has a wrong offset!");

// ScriptStruct MarvelAI.AbilityTargetDistance
// 0x000C (0x000C - 0x0000)
struct FAbilityTargetDistance final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SenseDistance;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidDistance;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityTargetDistance) == 0x000004, "Wrong alignment on FAbilityTargetDistance");
static_assert(sizeof(FAbilityTargetDistance) == 0x00000C, "Wrong size on FAbilityTargetDistance");
static_assert(offsetof(FAbilityTargetDistance, ID) == 0x000000, "Member 'FAbilityTargetDistance::ID' has a wrong offset!");
static_assert(offsetof(FAbilityTargetDistance, SenseDistance) == 0x000004, "Member 'FAbilityTargetDistance::SenseDistance' has a wrong offset!");
static_assert(offsetof(FAbilityTargetDistance, AvoidDistance) == 0x000008, "Member 'FAbilityTargetDistance::AvoidDistance' has a wrong offset!");

// ScriptStruct MarvelAI.EvadeParameter
// 0x0030 (0x0030 - 0x0000)
struct FEvadeParameter final
{
public:
	TArray<struct FAbilityTargetDistance>         Summoner;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAbilityTargetDistance>         Hero;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAbilityTargetDistance>         Projectile;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEvadeParameter) == 0x000008, "Wrong alignment on FEvadeParameter");
static_assert(sizeof(FEvadeParameter) == 0x000030, "Wrong size on FEvadeParameter");
static_assert(offsetof(FEvadeParameter, Summoner) == 0x000000, "Member 'FEvadeParameter::Summoner' has a wrong offset!");
static_assert(offsetof(FEvadeParameter, Hero) == 0x000010, "Member 'FEvadeParameter::Hero' has a wrong offset!");
static_assert(offsetof(FEvadeParameter, Projectile) == 0x000020, "Member 'FEvadeParameter::Projectile' has a wrong offset!");

// ScriptStruct MarvelAI.EnvQueryProjectileInfo
// 0x0008 (0x0008 - 0x0000)
struct FEnvQueryProjectileInfo final
{
public:
	int32                                         ProjectileID;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectRadius;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvQueryProjectileInfo) == 0x000004, "Wrong alignment on FEnvQueryProjectileInfo");
static_assert(sizeof(FEnvQueryProjectileInfo) == 0x000008, "Wrong size on FEnvQueryProjectileInfo");
static_assert(offsetof(FEnvQueryProjectileInfo, ProjectileID) == 0x000000, "Member 'FEnvQueryProjectileInfo::ProjectileID' has a wrong offset!");
static_assert(offsetof(FEnvQueryProjectileInfo, EffectRadius) == 0x000004, "Member 'FEnvQueryProjectileInfo::EffectRadius' has a wrong offset!");

// ScriptStruct MarvelAI.EQSTargetConfig
// 0x0018 (0x0018 - 0x0000)
struct FEQSTargetConfig final
{
public:
	TSubclassOf<class UEnvQueryContext>           TargetContext;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DistScoreCurve;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleFactor;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEQSTargetConfig) == 0x000008, "Wrong alignment on FEQSTargetConfig");
static_assert(sizeof(FEQSTargetConfig) == 0x000018, "Wrong size on FEQSTargetConfig");
static_assert(offsetof(FEQSTargetConfig, TargetContext) == 0x000000, "Member 'FEQSTargetConfig::TargetContext' has a wrong offset!");
static_assert(offsetof(FEQSTargetConfig, DistScoreCurve) == 0x000008, "Member 'FEQSTargetConfig::DistScoreCurve' has a wrong offset!");
static_assert(offsetof(FEQSTargetConfig, ScaleFactor) == 0x000010, "Member 'FEQSTargetConfig::ScaleFactor' has a wrong offset!");

// ScriptStruct MarvelAI.AIAbilityCounterConfig
// 0x0010 (0x0010 - 0x0000)
struct FAIAbilityCounterConfig final
{
public:
	int32                                         AbilityID;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIAbilityCounterTarget                       CheckTarget;                                       // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckTime;                                  // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeLimit;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedInSight;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAbilityCounterConfig) == 0x000004, "Wrong alignment on FAIAbilityCounterConfig");
static_assert(sizeof(FAIAbilityCounterConfig) == 0x000010, "Wrong size on FAIAbilityCounterConfig");
static_assert(offsetof(FAIAbilityCounterConfig, AbilityID) == 0x000000, "Member 'FAIAbilityCounterConfig::AbilityID' has a wrong offset!");
static_assert(offsetof(FAIAbilityCounterConfig, CheckTarget) == 0x000004, "Member 'FAIAbilityCounterConfig::CheckTarget' has a wrong offset!");
static_assert(offsetof(FAIAbilityCounterConfig, bShouldCheckTime) == 0x000005, "Member 'FAIAbilityCounterConfig::bShouldCheckTime' has a wrong offset!");
static_assert(offsetof(FAIAbilityCounterConfig, TimeLimit) == 0x000008, "Member 'FAIAbilityCounterConfig::TimeLimit' has a wrong offset!");
static_assert(offsetof(FAIAbilityCounterConfig, bNeedInSight) == 0x00000C, "Member 'FAIAbilityCounterConfig::bNeedInSight' has a wrong offset!");

// ScriptStruct MarvelAI.MarvelAIAbilityCounterTable
// 0x0028 (0x0048 - 0x0020)
struct FMarvelAIAbilityCounterTable final : public FTableRowBase
{
public:
	class FString                                 Description;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIFilterSide                                 FilterSide;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIAbilityCounterConfig>        CounterConfigList;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarvelAIAbilityCounterTable) == 0x000008, "Wrong alignment on FMarvelAIAbilityCounterTable");
static_assert(sizeof(FMarvelAIAbilityCounterTable) == 0x000048, "Wrong size on FMarvelAIAbilityCounterTable");
static_assert(offsetof(FMarvelAIAbilityCounterTable, Description) == 0x000020, "Member 'FMarvelAIAbilityCounterTable::Description' has a wrong offset!");
static_assert(offsetof(FMarvelAIAbilityCounterTable, FilterSide) == 0x000030, "Member 'FMarvelAIAbilityCounterTable::FilterSide' has a wrong offset!");
static_assert(offsetof(FMarvelAIAbilityCounterTable, CounterConfigList) == 0x000038, "Member 'FMarvelAIAbilityCounterTable::CounterConfigList' has a wrong offset!");

// ScriptStruct MarvelAI.AIAbilityActivateConfig
// 0x00B8 (0x00B8 - 0x0000)
struct FAIAbilityActivateConfig final
{
public:
	int32                                         UsageID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayAbility>           AbilityParentClass;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityInputBinds                            AbilityInputBind;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    AbilityBindFilter;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredicateDistance;                                 // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTryHeadShoot;                               // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTryFootShoot;                               // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadShotChance;                                    // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ActivationOwnedAITags;                             // 0x0030(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         ResourceList;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAIMoveControlLogic>        MoveControlLogic;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAISelectTargetLogicBase>   FocusControlLogic;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIResourceConflictBehavior                   ConflictBehavior;                                  // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectilePredicateShootPos;                      // 0x00B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectilePredicateMinDistance;                    // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAbilityActivateConfig) == 0x000008, "Wrong alignment on FAIAbilityActivateConfig");
static_assert(sizeof(FAIAbilityActivateConfig) == 0x0000B8, "Wrong size on FAIAbilityActivateConfig");
static_assert(offsetof(FAIAbilityActivateConfig, UsageID) == 0x000000, "Member 'FAIAbilityActivateConfig::UsageID' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, AbilityParentClass) == 0x000008, "Member 'FAIAbilityActivateConfig::AbilityParentClass' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, AbilityInputBind) == 0x000010, "Member 'FAIAbilityActivateConfig::AbilityInputBind' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, AbilityBindFilter) == 0x000018, "Member 'FAIAbilityActivateConfig::AbilityBindFilter' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, PredicateDistance) == 0x000020, "Member 'FAIAbilityActivateConfig::PredicateDistance' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, bShouldTryHeadShoot) == 0x000024, "Member 'FAIAbilityActivateConfig::bShouldTryHeadShoot' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, bShouldTryFootShoot) == 0x000025, "Member 'FAIAbilityActivateConfig::bShouldTryFootShoot' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, HeadShotChance) == 0x000028, "Member 'FAIAbilityActivateConfig::HeadShotChance' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, ActivationOwnedAITags) == 0x000030, "Member 'FAIAbilityActivateConfig::ActivationOwnedAITags' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, ResourceList) == 0x000098, "Member 'FAIAbilityActivateConfig::ResourceList' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, MoveControlLogic) == 0x0000A0, "Member 'FAIAbilityActivateConfig::MoveControlLogic' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, FocusControlLogic) == 0x0000A8, "Member 'FAIAbilityActivateConfig::FocusControlLogic' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, ConflictBehavior) == 0x0000B0, "Member 'FAIAbilityActivateConfig::ConflictBehavior' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, bProjectilePredicateShootPos) == 0x0000B1, "Member 'FAIAbilityActivateConfig::bProjectilePredicateShootPos' has a wrong offset!");
static_assert(offsetof(FAIAbilityActivateConfig, ProjectilePredicateMinDistance) == 0x0000B4, "Member 'FAIAbilityActivateConfig::ProjectilePredicateMinDistance' has a wrong offset!");

// ScriptStruct MarvelAI.LowHealthConfig
// 0x0008 (0x0008 - 0x0000)
struct FLowHealthConfig final
{
public:
	float                                         LowHealth;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfLowHealth;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLowHealthConfig) == 0x000004, "Wrong alignment on FLowHealthConfig");
static_assert(sizeof(FLowHealthConfig) == 0x000008, "Wrong size on FLowHealthConfig");
static_assert(offsetof(FLowHealthConfig, LowHealth) == 0x000000, "Member 'FLowHealthConfig::LowHealth' has a wrong offset!");
static_assert(offsetof(FLowHealthConfig, NumOfLowHealth) == 0x000004, "Member 'FLowHealthConfig::NumOfLowHealth' has a wrong offset!");

// ScriptStruct MarvelAI.AIAbilityConditionConfig
// 0x0064 (0x0064 - 0x0000)
struct FAIAbilityConditionConfig final
{
public:
	float                                         CheckCooldownSeconds;                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRange_FloatValue                      ActivateDistance;                                  // 0x0004(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ActiveHeight;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToUse;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUseWhenTakingDamage;                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInt32Range                            NumOfEnemiesInView;                                // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            NumOfTeammatesInView;                              // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            NearbyDeaths;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	MarvelAI::ETargetType                         TargetType;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRange_FloatValue                      TargetHealth;                                      // 0x004C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNeedCheckTeamHealth;                              // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroupHealth;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLowHealthConfig                       LowHealth;                                         // 0x005C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAbilityConditionConfig) == 0x000004, "Wrong alignment on FAIAbilityConditionConfig");
static_assert(sizeof(FAIAbilityConditionConfig) == 0x000064, "Wrong size on FAIAbilityConditionConfig");
static_assert(offsetof(FAIAbilityConditionConfig, CheckCooldownSeconds) == 0x000000, "Member 'FAIAbilityConditionConfig::CheckCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, ActivateDistance) == 0x000004, "Member 'FAIAbilityConditionConfig::ActivateDistance' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, ActiveHeight) == 0x00000C, "Member 'FAIAbilityConditionConfig::ActiveHeight' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, ChanceToUse) == 0x000010, "Member 'FAIAbilityConditionConfig::ChanceToUse' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, bOnlyUseWhenTakingDamage) == 0x000014, "Member 'FAIAbilityConditionConfig::bOnlyUseWhenTakingDamage' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, NumOfEnemiesInView) == 0x000018, "Member 'FAIAbilityConditionConfig::NumOfEnemiesInView' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, NumOfTeammatesInView) == 0x000028, "Member 'FAIAbilityConditionConfig::NumOfTeammatesInView' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, NearbyDeaths) == 0x000038, "Member 'FAIAbilityConditionConfig::NearbyDeaths' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, TargetType) == 0x000048, "Member 'FAIAbilityConditionConfig::TargetType' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, bIsVisible) == 0x000049, "Member 'FAIAbilityConditionConfig::bIsVisible' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, TargetHealth) == 0x00004C, "Member 'FAIAbilityConditionConfig::TargetHealth' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, bNeedCheckTeamHealth) == 0x000054, "Member 'FAIAbilityConditionConfig::bNeedCheckTeamHealth' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, GroupHealth) == 0x000058, "Member 'FAIAbilityConditionConfig::GroupHealth' has a wrong offset!");
static_assert(offsetof(FAIAbilityConditionConfig, LowHealth) == 0x00005C, "Member 'FAIAbilityConditionConfig::LowHealth' has a wrong offset!");

// ScriptStruct MarvelAI.AIAbilityPriorityConfig
// 0x0060 (0x0060 - 0x0000)
struct FAIAbilityPriorityConfig final
{
public:
	EAbilityEffectPriority                        EffectPriority;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityUsagePriorityConfig            UsagePriorityConfig;                               // 0x0008(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAbilityPriorityConfig) == 0x000008, "Wrong alignment on FAIAbilityPriorityConfig");
static_assert(sizeof(FAIAbilityPriorityConfig) == 0x000060, "Wrong size on FAIAbilityPriorityConfig");
static_assert(offsetof(FAIAbilityPriorityConfig, EffectPriority) == 0x000000, "Member 'FAIAbilityPriorityConfig::EffectPriority' has a wrong offset!");
static_assert(offsetof(FAIAbilityPriorityConfig, UsagePriorityConfig) == 0x000008, "Member 'FAIAbilityPriorityConfig::UsagePriorityConfig' has a wrong offset!");

// ScriptStruct MarvelAI.ComboConfig
// 0x0008 (0x0008 - 0x0000)
struct FComboConfig final
{
public:
	int32                                         ComboUsageID;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ComboValidDuration;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComboConfig) == 0x000004, "Wrong alignment on FComboConfig");
static_assert(sizeof(FComboConfig) == 0x000008, "Wrong size on FComboConfig");
static_assert(offsetof(FComboConfig, ComboUsageID) == 0x000000, "Member 'FComboConfig::ComboUsageID' has a wrong offset!");
static_assert(offsetof(FComboConfig, ComboValidDuration) == 0x000004, "Member 'FComboConfig::ComboValidDuration' has a wrong offset!");

// ScriptStruct MarvelAI.AIAbilityUsageTag
// 0x0068 (0x0068 - 0x0000)
struct FAIAbilityUsageTag final
{
public:
	struct FGameplayTagContainer                  AbilityUsageTag;                                   // 0x0000(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAbilityUsageTag) == 0x000008, "Wrong alignment on FAIAbilityUsageTag");
static_assert(sizeof(FAIAbilityUsageTag) == 0x000068, "Wrong size on FAIAbilityUsageTag");
static_assert(offsetof(FAIAbilityUsageTag, AbilityUsageTag) == 0x000000, "Member 'FAIAbilityUsageTag::AbilityUsageTag' has a wrong offset!");

// ScriptStruct MarvelAI.AIHitRateTagContainer
// 0x0068 (0x0068 - 0x0000)
struct FAIHitRateTagContainer final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIHitRateTagContainer) == 0x000008, "Wrong alignment on FAIHitRateTagContainer");
static_assert(sizeof(FAIHitRateTagContainer) == 0x000068, "Wrong size on FAIHitRateTagContainer");
static_assert(offsetof(FAIHitRateTagContainer, TagContainer) == 0x000000, "Member 'FAIHitRateTagContainer::TagContainer' has a wrong offset!");

// ScriptStruct MarvelAI.MarvelAIAutoAbilityTable
// 0x0248 (0x0268 - 0x0020)
struct FMarvelAIAutoAbilityTable final : public FTableRowBase
{
public:
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAbilityUsageTag                     AbilityUsageTag;                                   // 0x0030(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAIHitRateTagContainer                 HitRateTagContainer;                               // 0x0098(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         ChanceToHit;                                       // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAbilityActivateConfig               ActivateConfig;                                    // 0x0108(0x00B8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAIAbilityConditionConfig              ConditionConfig;                                   // 0x01C0(0x0064)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PriorityScore;                                     // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FComboConfig                           ComboConfig;                                       // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EAbilityCheckType                             AbilityCheckType;                                  // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIAbilityButtonActivationConfig> ButtonConfig;                                      // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasCancelButton;                                  // 0x0248(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityInputBinds                            CancelButton;                                      // 0x0249(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24A[0x6];                                      // 0x024A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAIAbilityFlowCheckLogicBase> FlowCheckLogic;                                    // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIAbilityUsageAsset*                   UsageAsset;                                        // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIServerIntentionProtocol             Intention;                                         // 0x0260(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMarvelAIAutoAbilityTable) == 0x000008, "Wrong alignment on FMarvelAIAutoAbilityTable");
static_assert(sizeof(FMarvelAIAutoAbilityTable) == 0x000268, "Wrong size on FMarvelAIAutoAbilityTable");
static_assert(offsetof(FMarvelAIAutoAbilityTable, AbilityUsageTag) == 0x000030, "Member 'FMarvelAIAutoAbilityTable::AbilityUsageTag' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, HitRateTagContainer) == 0x000098, "Member 'FMarvelAIAutoAbilityTable::HitRateTagContainer' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, ChanceToHit) == 0x000100, "Member 'FMarvelAIAutoAbilityTable::ChanceToHit' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, ActivateConfig) == 0x000108, "Member 'FMarvelAIAutoAbilityTable::ActivateConfig' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, ConditionConfig) == 0x0001C0, "Member 'FMarvelAIAutoAbilityTable::ConditionConfig' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, PriorityScore) == 0x000224, "Member 'FMarvelAIAutoAbilityTable::PriorityScore' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, ComboConfig) == 0x000228, "Member 'FMarvelAIAutoAbilityTable::ComboConfig' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, AbilityCheckType) == 0x000230, "Member 'FMarvelAIAutoAbilityTable::AbilityCheckType' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, ButtonConfig) == 0x000238, "Member 'FMarvelAIAutoAbilityTable::ButtonConfig' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, bHasCancelButton) == 0x000248, "Member 'FMarvelAIAutoAbilityTable::bHasCancelButton' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, CancelButton) == 0x000249, "Member 'FMarvelAIAutoAbilityTable::CancelButton' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, FlowCheckLogic) == 0x000250, "Member 'FMarvelAIAutoAbilityTable::FlowCheckLogic' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, UsageAsset) == 0x000258, "Member 'FMarvelAIAutoAbilityTable::UsageAsset' has a wrong offset!");
static_assert(offsetof(FMarvelAIAutoAbilityTable, Intention) == 0x000260, "Member 'FMarvelAIAutoAbilityTable::Intention' has a wrong offset!");

// ScriptStruct MarvelAI.AIRolePriority
// 0x0008 (0x0008 - 0x0000)
struct FAIRolePriority final
{
public:
	EHeroRole                                     AIRole;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RoleNum;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIRolePriority) == 0x000004, "Wrong alignment on FAIRolePriority");
static_assert(sizeof(FAIRolePriority) == 0x000008, "Wrong size on FAIRolePriority");
static_assert(offsetof(FAIRolePriority, AIRole) == 0x000000, "Member 'FAIRolePriority::AIRole' has a wrong offset!");
static_assert(offsetof(FAIRolePriority, RoleNum) == 0x000004, "Member 'FAIRolePriority::RoleNum' has a wrong offset!");

// ScriptStruct MarvelAI.Range_Int32Value
// 0x0008 (0x0008 - 0x0000)
struct FRange_Int32Value final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRange_Int32Value) == 0x000004, "Wrong alignment on FRange_Int32Value");
static_assert(sizeof(FRange_Int32Value) == 0x000008, "Wrong size on FRange_Int32Value");
static_assert(offsetof(FRange_Int32Value, Min) == 0x000000, "Member 'FRange_Int32Value::Min' has a wrong offset!");
static_assert(offsetof(FRange_Int32Value, Max) == 0x000004, "Member 'FRange_Int32Value::Max' has a wrong offset!");

// ScriptStruct MarvelAI.AIAggressiveLevelConfig
// 0x0050 (0x0050 - 0x0000)
struct FAIAggressiveLevelConfig final
{
public:
	TMap<int32, int32>                            BuffIDToAggressiveLevel;                           // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAggressiveLevelConfig) == 0x000008, "Wrong alignment on FAIAggressiveLevelConfig");
static_assert(sizeof(FAIAggressiveLevelConfig) == 0x000050, "Wrong size on FAIAggressiveLevelConfig");
static_assert(offsetof(FAIAggressiveLevelConfig, BuffIDToAggressiveLevel) == 0x000000, "Member 'FAIAggressiveLevelConfig::BuffIDToAggressiveLevel' has a wrong offset!");

// ScriptStruct MarvelAI.HealthPackDistToChance
// 0x0008 (0x0008 - 0x0000)
struct FHealthPackDistToChance final
{
public:
	float                                         DistToHealthPack;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chance;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHealthPackDistToChance) == 0x000004, "Wrong alignment on FHealthPackDistToChance");
static_assert(sizeof(FHealthPackDistToChance) == 0x000008, "Wrong size on FHealthPackDistToChance");
static_assert(offsetof(FHealthPackDistToChance, DistToHealthPack) == 0x000000, "Member 'FHealthPackDistToChance::DistToHealthPack' has a wrong offset!");
static_assert(offsetof(FHealthPackDistToChance, Chance) == 0x000004, "Member 'FHealthPackDistToChance::Chance' has a wrong offset!");

// ScriptStruct MarvelAI.GoHealthPackConfigEntry
// 0x0018 (0x0018 - 0x0000)
struct FGoHealthPackConfigEntry final
{
public:
	float                                         HealthProportion;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHealthPackDistToChance>        DistToChance;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGoHealthPackConfigEntry) == 0x000008, "Wrong alignment on FGoHealthPackConfigEntry");
static_assert(sizeof(FGoHealthPackConfigEntry) == 0x000018, "Wrong size on FGoHealthPackConfigEntry");
static_assert(offsetof(FGoHealthPackConfigEntry, HealthProportion) == 0x000000, "Member 'FGoHealthPackConfigEntry::HealthProportion' has a wrong offset!");
static_assert(offsetof(FGoHealthPackConfigEntry, DistToChance) == 0x000008, "Member 'FGoHealthPackConfigEntry::DistToChance' has a wrong offset!");

// ScriptStruct MarvelAI.NavLinkMoveConfigEntry
// 0x0010 (0x0010 - 0x0000)
struct FNavLinkMoveConfigEntry final
{
public:
	TArray<class UNavLinkMoveMethod*>             MoveMethodList;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavLinkMoveConfigEntry) == 0x000008, "Wrong alignment on FNavLinkMoveConfigEntry");
static_assert(sizeof(FNavLinkMoveConfigEntry) == 0x000010, "Wrong size on FNavLinkMoveConfigEntry");
static_assert(offsetof(FNavLinkMoveConfigEntry, MoveMethodList) == 0x000000, "Member 'FNavLinkMoveConfigEntry::MoveMethodList' has a wrong offset!");

// ScriptStruct MarvelAI.AIHeroNavigationConfig
// 0x0018 (0x0018 - 0x0000)
struct FAIHeroNavigationConfig final
{
public:
	struct FNavLinkMoveConfigEntry                NavLinkMoveConfig;                                 // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     OverrideNavFilerClass;                             // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIHeroNavigationConfig) == 0x000008, "Wrong alignment on FAIHeroNavigationConfig");
static_assert(sizeof(FAIHeroNavigationConfig) == 0x000018, "Wrong size on FAIHeroNavigationConfig");
static_assert(offsetof(FAIHeroNavigationConfig, NavLinkMoveConfig) == 0x000000, "Member 'FAIHeroNavigationConfig::NavLinkMoveConfig' has a wrong offset!");
static_assert(offsetof(FAIHeroNavigationConfig, OverrideNavFilerClass) == 0x000010, "Member 'FAIHeroNavigationConfig::OverrideNavFilerClass' has a wrong offset!");

// ScriptStruct MarvelAI.AIDifficultyConfig
// 0x0008 (0x0008 - 0x0000)
struct FAIDifficultyConfig final
{
public:
	EAIDifficultyMode                             DifficultyMode;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DifficultyLevel;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDifficultyConfig) == 0x000004, "Wrong alignment on FAIDifficultyConfig");
static_assert(sizeof(FAIDifficultyConfig) == 0x000008, "Wrong size on FAIDifficultyConfig");
static_assert(offsetof(FAIDifficultyConfig, DifficultyMode) == 0x000000, "Member 'FAIDifficultyConfig::DifficultyMode' has a wrong offset!");
static_assert(offsetof(FAIDifficultyConfig, DifficultyLevel) == 0x000004, "Member 'FAIDifficultyConfig::DifficultyLevel' has a wrong offset!");

// ScriptStruct MarvelAI.GameplayProgress
// 0x000C (0x000C - 0x0000)
struct FGameplayProgress final
{
public:
	uint8                                         StageProgress;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRange_FloatValue                      SubProgressRange;                                  // 0x0004(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayProgress) == 0x000004, "Wrong alignment on FGameplayProgress");
static_assert(sizeof(FGameplayProgress) == 0x00000C, "Wrong size on FGameplayProgress");
static_assert(offsetof(FGameplayProgress, StageProgress) == 0x000000, "Member 'FGameplayProgress::StageProgress' has a wrong offset!");
static_assert(offsetof(FGameplayProgress, SubProgressRange) == 0x000004, "Member 'FGameplayProgress::SubProgressRange' has a wrong offset!");

// ScriptStruct MarvelAI.AbilityCheckInfo
// 0x0008 (0x0008 - 0x0000)
struct FAbilityCheckInfo final
{
public:
	float                                         SenseDistance;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidDistance;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityCheckInfo) == 0x000004, "Wrong alignment on FAbilityCheckInfo");
static_assert(sizeof(FAbilityCheckInfo) == 0x000008, "Wrong size on FAbilityCheckInfo");
static_assert(offsetof(FAbilityCheckInfo, SenseDistance) == 0x000000, "Member 'FAbilityCheckInfo::SenseDistance' has a wrong offset!");
static_assert(offsetof(FAbilityCheckInfo, AvoidDistance) == 0x000004, "Member 'FAbilityCheckInfo::AvoidDistance' has a wrong offset!");

// ScriptStruct MarvelAI.AIAbilityCheckInfo
// 0x0190 (0x0190 - 0x0000)
struct FAIAbilityCheckInfo final
{
public:
	TMap<int32, struct FAbilityCheckInfo>         HeroCheckInfos;                                    // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, struct FAbilityCheckInfo>         SummonerCheckInfos;                                // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, struct FAbilityCheckInfo>         ProjectileCheckInfos;                              // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, struct FAbilityCheckInfo>         ScopeCheckInfos;                                   // 0x00F0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FAbilityCheckInfo> TagCheckInfos;                                     // 0x0140(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAbilityCheckInfo) == 0x000008, "Wrong alignment on FAIAbilityCheckInfo");
static_assert(sizeof(FAIAbilityCheckInfo) == 0x000190, "Wrong size on FAIAbilityCheckInfo");
static_assert(offsetof(FAIAbilityCheckInfo, HeroCheckInfos) == 0x000000, "Member 'FAIAbilityCheckInfo::HeroCheckInfos' has a wrong offset!");
static_assert(offsetof(FAIAbilityCheckInfo, SummonerCheckInfos) == 0x000050, "Member 'FAIAbilityCheckInfo::SummonerCheckInfos' has a wrong offset!");
static_assert(offsetof(FAIAbilityCheckInfo, ProjectileCheckInfos) == 0x0000A0, "Member 'FAIAbilityCheckInfo::ProjectileCheckInfos' has a wrong offset!");
static_assert(offsetof(FAIAbilityCheckInfo, ScopeCheckInfos) == 0x0000F0, "Member 'FAIAbilityCheckInfo::ScopeCheckInfos' has a wrong offset!");
static_assert(offsetof(FAIAbilityCheckInfo, TagCheckInfos) == 0x000140, "Member 'FAIAbilityCheckInfo::TagCheckInfos' has a wrong offset!");

// ScriptStruct MarvelAI.AbilityCheckConfig
// 0x0198 (0x0198 - 0x0000)
struct FAbilityCheckConfig final
{
public:
	struct FAIAbilityCheckInfo                    LocalAbilityCheckInfo;                             // 0x0000(0x0190)(Edit, NativeAccessSpecifierPublic)
	class UAbilityCheckInfoAsset*                 GlobalAsset;                                       // 0x0190(0x0008)(Edit, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityCheckConfig) == 0x000008, "Wrong alignment on FAbilityCheckConfig");
static_assert(sizeof(FAbilityCheckConfig) == 0x000198, "Wrong size on FAbilityCheckConfig");
static_assert(offsetof(FAbilityCheckConfig, LocalAbilityCheckInfo) == 0x000000, "Member 'FAbilityCheckConfig::LocalAbilityCheckInfo' has a wrong offset!");
static_assert(offsetof(FAbilityCheckConfig, GlobalAsset) == 0x000190, "Member 'FAbilityCheckConfig::GlobalAsset' has a wrong offset!");

// ScriptStruct MarvelAI.AITagMatchParameter
// 0x0070 (0x0070 - 0x0000)
struct FAITagMatchParameter final
{
public:
	EGameplayContainerMatchType                   TagsToMatch;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0008(0x0068)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAITagMatchParameter) == 0x000008, "Wrong alignment on FAITagMatchParameter");
static_assert(sizeof(FAITagMatchParameter) == 0x000070, "Wrong size on FAITagMatchParameter");
static_assert(offsetof(FAITagMatchParameter, TagsToMatch) == 0x000000, "Member 'FAITagMatchParameter::TagsToMatch' has a wrong offset!");
static_assert(offsetof(FAITagMatchParameter, GameplayTags) == 0x000008, "Member 'FAITagMatchParameter::GameplayTags' has a wrong offset!");

// ScriptStruct MarvelAI.AIInputInfo
// 0x0010 (0x0010 - 0x0000)
struct FAIInputInfo final
{
public:
	bool                                          JustWait;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityInputBinds                            Key;                                               // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoRelease;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPress;                                           // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIInputInfo) == 0x000004, "Wrong alignment on FAIInputInfo");
static_assert(sizeof(FAIInputInfo) == 0x000010, "Wrong size on FAIInputInfo");
static_assert(offsetof(FAIInputInfo, JustWait) == 0x000000, "Member 'FAIInputInfo::JustWait' has a wrong offset!");
static_assert(offsetof(FAIInputInfo, Key) == 0x000001, "Member 'FAIInputInfo::Key' has a wrong offset!");
static_assert(offsetof(FAIInputInfo, AbilityID) == 0x000004, "Member 'FAIInputInfo::AbilityID' has a wrong offset!");
static_assert(offsetof(FAIInputInfo, AutoRelease) == 0x000008, "Member 'FAIInputInfo::AutoRelease' has a wrong offset!");
static_assert(offsetof(FAIInputInfo, IsPress) == 0x000009, "Member 'FAIInputInfo::IsPress' has a wrong offset!");
static_assert(offsetof(FAIInputInfo, Duration) == 0x00000C, "Member 'FAIInputInfo::Duration' has a wrong offset!");

// ScriptStruct MarvelAI.AIDifficultyAttributeConfig
// 0x0050 (0x0050 - 0x0000)
struct FAIDifficultyAttributeConfig final
{
public:
	TMap<EHeroRole, float>                        ValueMap;                                          // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDifficultyAttributeConfig) == 0x000008, "Wrong alignment on FAIDifficultyAttributeConfig");
static_assert(sizeof(FAIDifficultyAttributeConfig) == 0x000050, "Wrong size on FAIDifficultyAttributeConfig");
static_assert(offsetof(FAIDifficultyAttributeConfig, ValueMap) == 0x000000, "Member 'FAIDifficultyAttributeConfig::ValueMap' has a wrong offset!");

// ScriptStruct MarvelAI.AILowHealthMarkConfig
// 0x000C (0x000C - 0x0000)
struct FAILowHealthMarkConfig final
{
public:
	float                                         HealthThreshold;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowHealthMarkDuration;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowHealthMarkCooldown;                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILowHealthMarkConfig) == 0x000004, "Wrong alignment on FAILowHealthMarkConfig");
static_assert(sizeof(FAILowHealthMarkConfig) == 0x00000C, "Wrong size on FAILowHealthMarkConfig");
static_assert(offsetof(FAILowHealthMarkConfig, HealthThreshold) == 0x000000, "Member 'FAILowHealthMarkConfig::HealthThreshold' has a wrong offset!");
static_assert(offsetof(FAILowHealthMarkConfig, LowHealthMarkDuration) == 0x000004, "Member 'FAILowHealthMarkConfig::LowHealthMarkDuration' has a wrong offset!");
static_assert(offsetof(FAILowHealthMarkConfig, LowHealthMarkCooldown) == 0x000008, "Member 'FAILowHealthMarkConfig::LowHealthMarkCooldown' has a wrong offset!");

// ScriptStruct MarvelAI.MarvelAIDifficultyTable
// 0x01F8 (0x0218 - 0x0020)
struct FMarvelAIDifficultyTable final : public FTableRowBase
{
public:
	EAIDifficultyMode                             DifficultyMode;                                    // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DifficultyLevel;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForbiddenSkillLevel;                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDifficultyAttributeConfig           ApplyDamageRatio;                                  // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAIDifficultyAttributeConfig           TakingDamageRatio;                                 // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAIDifficultyAttributeConfig           ApplyTreatRatio;                                   // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAIDifficultyAttributeConfig           TakingTreatRatio;                                  // 0x0120(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAIDifficultyAttributeConfig           MaxHealthRatio;                                    // 0x0170(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MoveWaitTime;                                      // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomJumpInterval;                                // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeToJump;                                      // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRefreshInterval;                               // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveCloseRadiusRatio;                              // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAILowHealthMarkConfig                 LowHealthMarkConfig;                               // 0x01D4(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UAIDifficultyExtendAsset*               ExtendAsset;                                       // 0x01E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIDynamicDifficultyAsset*              DynamicDifficultyAsset;                            // 0x01E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSelected;                                        // 0x01F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AILevelText;                                       // 0x01F8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         AILABRequestFrequency;                             // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMarvelAIDifficultyTable) == 0x000008, "Wrong alignment on FMarvelAIDifficultyTable");
static_assert(sizeof(FMarvelAIDifficultyTable) == 0x000218, "Wrong size on FMarvelAIDifficultyTable");
static_assert(offsetof(FMarvelAIDifficultyTable, DifficultyMode) == 0x000020, "Member 'FMarvelAIDifficultyTable::DifficultyMode' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, DifficultyLevel) == 0x000024, "Member 'FMarvelAIDifficultyTable::DifficultyLevel' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, ForbiddenSkillLevel) == 0x000028, "Member 'FMarvelAIDifficultyTable::ForbiddenSkillLevel' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, ApplyDamageRatio) == 0x000030, "Member 'FMarvelAIDifficultyTable::ApplyDamageRatio' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, TakingDamageRatio) == 0x000080, "Member 'FMarvelAIDifficultyTable::TakingDamageRatio' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, ApplyTreatRatio) == 0x0000D0, "Member 'FMarvelAIDifficultyTable::ApplyTreatRatio' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, TakingTreatRatio) == 0x000120, "Member 'FMarvelAIDifficultyTable::TakingTreatRatio' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, MaxHealthRatio) == 0x000170, "Member 'FMarvelAIDifficultyTable::MaxHealthRatio' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, MoveWaitTime) == 0x0001C0, "Member 'FMarvelAIDifficultyTable::MoveWaitTime' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, RandomJumpInterval) == 0x0001C4, "Member 'FMarvelAIDifficultyTable::RandomJumpInterval' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, ChangeToJump) == 0x0001C8, "Member 'FMarvelAIDifficultyTable::ChangeToJump' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, MoveRefreshInterval) == 0x0001CC, "Member 'FMarvelAIDifficultyTable::MoveRefreshInterval' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, MoveCloseRadiusRatio) == 0x0001D0, "Member 'FMarvelAIDifficultyTable::MoveCloseRadiusRatio' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, LowHealthMarkConfig) == 0x0001D4, "Member 'FMarvelAIDifficultyTable::LowHealthMarkConfig' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, ExtendAsset) == 0x0001E0, "Member 'FMarvelAIDifficultyTable::ExtendAsset' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, DynamicDifficultyAsset) == 0x0001E8, "Member 'FMarvelAIDifficultyTable::DynamicDifficultyAsset' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, IsSelected) == 0x0001F0, "Member 'FMarvelAIDifficultyTable::IsSelected' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, AILevelText) == 0x0001F8, "Member 'FMarvelAIDifficultyTable::AILevelText' has a wrong offset!");
static_assert(offsetof(FMarvelAIDifficultyTable, AILABRequestFrequency) == 0x000210, "Member 'FMarvelAIDifficultyTable::AILABRequestFrequency' has a wrong offset!");

// ScriptStruct MarvelAI.AIChangeHeroConfig
// 0x0040 (0x0040 - 0x0000)
struct FAIChangeHeroConfig final
{
public:
	class UCurveFloat*                            EnergyCurve;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            KillDeathCurve;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeHeroCD;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeathThreshold;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAIRolePriority>                RolePriorityList;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BuildBondPossibility;                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRange_FloatValue                      PreselectTimeRange;                                // 0x002C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRange_FloatValue                      UpdateDelayRange;                                  // 0x0034(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIChangeHeroConfig) == 0x000008, "Wrong alignment on FAIChangeHeroConfig");
static_assert(sizeof(FAIChangeHeroConfig) == 0x000040, "Wrong size on FAIChangeHeroConfig");
static_assert(offsetof(FAIChangeHeroConfig, EnergyCurve) == 0x000000, "Member 'FAIChangeHeroConfig::EnergyCurve' has a wrong offset!");
static_assert(offsetof(FAIChangeHeroConfig, KillDeathCurve) == 0x000008, "Member 'FAIChangeHeroConfig::KillDeathCurve' has a wrong offset!");
static_assert(offsetof(FAIChangeHeroConfig, ChangeHeroCD) == 0x000010, "Member 'FAIChangeHeroConfig::ChangeHeroCD' has a wrong offset!");
static_assert(offsetof(FAIChangeHeroConfig, DeathThreshold) == 0x000014, "Member 'FAIChangeHeroConfig::DeathThreshold' has a wrong offset!");
static_assert(offsetof(FAIChangeHeroConfig, RolePriorityList) == 0x000018, "Member 'FAIChangeHeroConfig::RolePriorityList' has a wrong offset!");
static_assert(offsetof(FAIChangeHeroConfig, BuildBondPossibility) == 0x000028, "Member 'FAIChangeHeroConfig::BuildBondPossibility' has a wrong offset!");
static_assert(offsetof(FAIChangeHeroConfig, PreselectTimeRange) == 0x00002C, "Member 'FAIChangeHeroConfig::PreselectTimeRange' has a wrong offset!");
static_assert(offsetof(FAIChangeHeroConfig, UpdateDelayRange) == 0x000034, "Member 'FAIChangeHeroConfig::UpdateDelayRange' has a wrong offset!");

// ScriptStruct MarvelAI.AIGameModeConfig
// 0x0080 (0x0080 - 0x0000)
struct FAIGameModeConfig final
{
public:
	bool                                          UseDefaultAvailableHero;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   HeroIDs;                                           // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          UseDefaultLineupPriority;                          // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIRolePriority>                RolePriorityList;                                  // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          GameModeDefaultBTree;                              // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultRequestServerIndex;                         // 0x0078(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowAIChangeHero;                                 // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIGameModeConfig) == 0x000008, "Wrong alignment on FAIGameModeConfig");
static_assert(sizeof(FAIGameModeConfig) == 0x000080, "Wrong size on FAIGameModeConfig");
static_assert(offsetof(FAIGameModeConfig, UseDefaultAvailableHero) == 0x000000, "Member 'FAIGameModeConfig::UseDefaultAvailableHero' has a wrong offset!");
static_assert(offsetof(FAIGameModeConfig, HeroIDs) == 0x000008, "Member 'FAIGameModeConfig::HeroIDs' has a wrong offset!");
static_assert(offsetof(FAIGameModeConfig, UseDefaultLineupPriority) == 0x000058, "Member 'FAIGameModeConfig::UseDefaultLineupPriority' has a wrong offset!");
static_assert(offsetof(FAIGameModeConfig, RolePriorityList) == 0x000060, "Member 'FAIGameModeConfig::RolePriorityList' has a wrong offset!");
static_assert(offsetof(FAIGameModeConfig, GameModeDefaultBTree) == 0x000070, "Member 'FAIGameModeConfig::GameModeDefaultBTree' has a wrong offset!");
static_assert(offsetof(FAIGameModeConfig, DefaultRequestServerIndex) == 0x000078, "Member 'FAIGameModeConfig::DefaultRequestServerIndex' has a wrong offset!");
static_assert(offsetof(FAIGameModeConfig, AllowAIChangeHero) == 0x00007C, "Member 'FAIGameModeConfig::AllowAIChangeHero' has a wrong offset!");

// ScriptStruct MarvelAI.LevelStaticActorCache
// 0x0010 (0x0010 - 0x0000)
struct FLevelStaticActorCache final
{
public:
	TArray<class AActor*>                         LevelStaticActors;                                 // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelStaticActorCache) == 0x000008, "Wrong alignment on FLevelStaticActorCache");
static_assert(sizeof(FLevelStaticActorCache) == 0x000010, "Wrong size on FLevelStaticActorCache");
static_assert(offsetof(FLevelStaticActorCache, LevelStaticActors) == 0x000000, "Member 'FLevelStaticActorCache::LevelStaticActors' has a wrong offset!");

// ScriptStruct MarvelAI.DangerousTargetAbilityEvent
// 0x0018 (0x0018 - 0x0000)
struct FDangerousTargetAbilityEvent final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       Ability;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilitySenseNotify                           Notify;                                            // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDangerousTargetAbilityEvent) == 0x000008, "Wrong alignment on FDangerousTargetAbilityEvent");
static_assert(sizeof(FDangerousTargetAbilityEvent) == 0x000018, "Wrong size on FDangerousTargetAbilityEvent");
static_assert(offsetof(FDangerousTargetAbilityEvent, Source) == 0x000000, "Member 'FDangerousTargetAbilityEvent::Source' has a wrong offset!");
static_assert(offsetof(FDangerousTargetAbilityEvent, Ability) == 0x000008, "Member 'FDangerousTargetAbilityEvent::Ability' has a wrong offset!");
static_assert(offsetof(FDangerousTargetAbilityEvent, Notify) == 0x000010, "Member 'FDangerousTargetAbilityEvent::Notify' has a wrong offset!");

// ScriptStruct MarvelAI.MarvelAITeamEvent
// 0x0050 (0x0050 - 0x0000)
struct FMarvelAITeamEvent final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Broadcaster;                                       // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 Target;                                            // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarvelAITeamEvent) == 0x000008, "Wrong alignment on FMarvelAITeamEvent");
static_assert(sizeof(FMarvelAITeamEvent) == 0x000050, "Wrong size on FMarvelAITeamEvent");
static_assert(offsetof(FMarvelAITeamEvent, Broadcaster) == 0x000040, "Member 'FMarvelAITeamEvent::Broadcaster' has a wrong offset!");
static_assert(offsetof(FMarvelAITeamEvent, Target) == 0x000048, "Member 'FMarvelAITeamEvent::Target' has a wrong offset!");

// ScriptStruct MarvelAI.MarvelAISprayTable
// 0x0020 (0x0040 - 0x0020)
struct FMarvelAISprayTable final : public FTableRowBase
{
public:
	int32                                         SprayID;                                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SprayDesc;                                         // 0x0024(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SprayWeight;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              SprayValidTime;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarvelAISprayTable) == 0x000008, "Wrong alignment on FMarvelAISprayTable");
static_assert(sizeof(FMarvelAISprayTable) == 0x000040, "Wrong size on FMarvelAISprayTable");
static_assert(offsetof(FMarvelAISprayTable, SprayID) == 0x000020, "Member 'FMarvelAISprayTable::SprayID' has a wrong offset!");
static_assert(offsetof(FMarvelAISprayTable, SprayDesc) == 0x000024, "Member 'FMarvelAISprayTable::SprayDesc' has a wrong offset!");
static_assert(offsetof(FMarvelAISprayTable, SprayWeight) == 0x000030, "Member 'FMarvelAISprayTable::SprayWeight' has a wrong offset!");
static_assert(offsetof(FMarvelAISprayTable, SprayValidTime) == 0x000038, "Member 'FMarvelAISprayTable::SprayValidTime' has a wrong offset!");

// ScriptStruct MarvelAI.MarvelAIStandPointGroupTable
// 0x0048 (0x0068 - 0x0020)
struct FMarvelAIStandPointGroupTable final : public FTableRowBase
{
public:
	int32                                         GroupId;                                           // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LevelName;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Desc;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           StandPointNames;                                   // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EAssaultProgress                              AssaultProgress;                                   // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEscortProgress                               EscortProgress;                                    // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRange_FloatValue                      SubProgressRange;                                  // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMarvelAIStandPointGroupTable) == 0x000008, "Wrong alignment on FMarvelAIStandPointGroupTable");
static_assert(sizeof(FMarvelAIStandPointGroupTable) == 0x000068, "Wrong size on FMarvelAIStandPointGroupTable");
static_assert(offsetof(FMarvelAIStandPointGroupTable, GroupId) == 0x000020, "Member 'FMarvelAIStandPointGroupTable::GroupId' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointGroupTable, LevelName) == 0x000028, "Member 'FMarvelAIStandPointGroupTable::LevelName' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointGroupTable, Desc) == 0x000038, "Member 'FMarvelAIStandPointGroupTable::Desc' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointGroupTable, StandPointNames) == 0x000048, "Member 'FMarvelAIStandPointGroupTable::StandPointNames' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointGroupTable, AssaultProgress) == 0x000058, "Member 'FMarvelAIStandPointGroupTable::AssaultProgress' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointGroupTable, EscortProgress) == 0x000059, "Member 'FMarvelAIStandPointGroupTable::EscortProgress' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointGroupTable, SubProgressRange) == 0x00005C, "Member 'FMarvelAIStandPointGroupTable::SubProgressRange' has a wrong offset!");

// ScriptStruct MarvelAI.MarvelAIStandPointTable
// 0x0050 (0x0070 - 0x0020)
struct FMarvelAIStandPointTable final : public FTableRowBase
{
public:
	class FString                                 Desc;                                              // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelName;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeroID;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMarvelStandPointShareType                    ShareType;                                         // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BattleAreaName;                                    // 0x0048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEscortProgress                               EscortProgress;                                    // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRange_FloatValue                      SubProgressRange;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           StandPointNames;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarvelAIStandPointTable) == 0x000008, "Wrong alignment on FMarvelAIStandPointTable");
static_assert(sizeof(FMarvelAIStandPointTable) == 0x000070, "Wrong size on FMarvelAIStandPointTable");
static_assert(offsetof(FMarvelAIStandPointTable, Desc) == 0x000020, "Member 'FMarvelAIStandPointTable::Desc' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointTable, LevelName) == 0x000030, "Member 'FMarvelAIStandPointTable::LevelName' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointTable, HeroID) == 0x000040, "Member 'FMarvelAIStandPointTable::HeroID' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointTable, ShareType) == 0x000044, "Member 'FMarvelAIStandPointTable::ShareType' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointTable, BattleAreaName) == 0x000048, "Member 'FMarvelAIStandPointTable::BattleAreaName' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointTable, EscortProgress) == 0x000054, "Member 'FMarvelAIStandPointTable::EscortProgress' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointTable, SubProgressRange) == 0x000058, "Member 'FMarvelAIStandPointTable::SubProgressRange' has a wrong offset!");
static_assert(offsetof(FMarvelAIStandPointTable, StandPointNames) == 0x000060, "Member 'FMarvelAIStandPointTable::StandPointNames' has a wrong offset!");

// ScriptStruct MarvelAI.MarvelAITeamInfo
// 0x0240 (0x0240 - 0x0000)
struct alignas(0x08) FMarvelAITeamInfo final
{
public:
	uint8                                         Pad_0[0x240];                                      // 0x0000(0x0240)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMarvelAITeamInfo) == 0x000008, "Wrong alignment on FMarvelAITeamInfo");
static_assert(sizeof(FMarvelAITeamInfo) == 0x000240, "Wrong size on FMarvelAITeamInfo");

// ScriptStruct MarvelAI.AIDamageSourceInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAIDamageSourceInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDamageSourceInfo) == 0x000008, "Wrong alignment on FAIDamageSourceInfo");
static_assert(sizeof(FAIDamageSourceInfo) == 0x000018, "Wrong size on FAIDamageSourceInfo");

// ScriptStruct MarvelAI.MarvelFloatRange
// 0x0010 (0x0010 - 0x0000)
struct FMarvelFloatRange final
{
public:
	struct FFloatRange                            Range;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarvelFloatRange) == 0x000004, "Wrong alignment on FMarvelFloatRange");
static_assert(sizeof(FMarvelFloatRange) == 0x000010, "Wrong size on FMarvelFloatRange");
static_assert(offsetof(FMarvelFloatRange, Range) == 0x000000, "Member 'FMarvelFloatRange::Range' has a wrong offset!");

// ScriptStruct MarvelAI.GameplayAITag
// 0x000C (0x000C - 0x0000)
struct FGameplayAITag final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAITag) == 0x000004, "Wrong alignment on FGameplayAITag");
static_assert(sizeof(FGameplayAITag) == 0x00000C, "Wrong size on FGameplayAITag");
static_assert(offsetof(FGameplayAITag, GameplayTag) == 0x000000, "Member 'FGameplayAITag::GameplayTag' has a wrong offset!");

// ScriptStruct MarvelAI.AIHeroTag
// 0x0068 (0x0068 - 0x0000)
struct FAIHeroTag final
{
public:
	struct FGameplayTagContainer                  AIHeroTag;                                         // 0x0000(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIHeroTag) == 0x000008, "Wrong alignment on FAIHeroTag");
static_assert(sizeof(FAIHeroTag) == 0x000068, "Wrong size on FAIHeroTag");
static_assert(offsetof(FAIHeroTag, AIHeroTag) == 0x000000, "Member 'FAIHeroTag::AIHeroTag' has a wrong offset!");

// ScriptStruct MarvelAI.AIMoveTypeTag
// 0x0068 (0x0068 - 0x0000)
struct FAIMoveTypeTag final
{
public:
	struct FGameplayTagContainer                  MoveTypeTag;                                       // 0x0000(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIMoveTypeTag) == 0x000008, "Wrong alignment on FAIMoveTypeTag");
static_assert(sizeof(FAIMoveTypeTag) == 0x000068, "Wrong size on FAIMoveTypeTag");
static_assert(offsetof(FAIMoveTypeTag, MoveTypeTag) == 0x000000, "Member 'FAIMoveTypeTag::MoveTypeTag' has a wrong offset!");

// ScriptStruct MarvelAI.AIAgility
// 0x0020 (0x0020 - 0x0000)
struct FAIAgility final
{
public:
	struct FMarvelFloatRange                      Slow;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMarvelFloatRange                      MistakeRate;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAgility) == 0x000004, "Wrong alignment on FAIAgility");
static_assert(sizeof(FAIAgility) == 0x000020, "Wrong size on FAIAgility");
static_assert(offsetof(FAIAgility, Slow) == 0x000000, "Member 'FAIAgility::Slow' has a wrong offset!");
static_assert(offsetof(FAIAgility, MistakeRate) == 0x000010, "Member 'FAIAgility::MistakeRate' has a wrong offset!");

// ScriptStruct MarvelAI.HeroTagMatch
// 0x0070 (0x0070 - 0x0000)
struct FHeroTagMatch final
{
public:
	struct FAIHeroTag                             AIHeroTag;                                         // 0x0000(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EGameplayContainerMatchType                   TagMatchType;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeroTagMatch) == 0x000008, "Wrong alignment on FHeroTagMatch");
static_assert(sizeof(FHeroTagMatch) == 0x000070, "Wrong size on FHeroTagMatch");
static_assert(offsetof(FHeroTagMatch, AIHeroTag) == 0x000000, "Member 'FHeroTagMatch::AIHeroTag' has a wrong offset!");
static_assert(offsetof(FHeroTagMatch, TagMatchType) == 0x000068, "Member 'FHeroTagMatch::TagMatchType' has a wrong offset!");

// ScriptStruct MarvelAI.HeroFilter
// 0x0080 (0x0080 - 0x0000)
struct FHeroFilter final
{
public:
	int32                                         Group;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Role;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SurviveState;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHeroTagMatch                          HeroTagMatch;                                      // 0x0010(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeroFilter) == 0x000008, "Wrong alignment on FHeroFilter");
static_assert(sizeof(FHeroFilter) == 0x000080, "Wrong size on FHeroFilter");
static_assert(offsetof(FHeroFilter, Group) == 0x000000, "Member 'FHeroFilter::Group' has a wrong offset!");
static_assert(offsetof(FHeroFilter, Role) == 0x000004, "Member 'FHeroFilter::Role' has a wrong offset!");
static_assert(offsetof(FHeroFilter, SurviveState) == 0x000008, "Member 'FHeroFilter::SurviveState' has a wrong offset!");
static_assert(offsetof(FHeroFilter, HeroTagMatch) == 0x000010, "Member 'FHeroFilter::HeroTagMatch' has a wrong offset!");

// ScriptStruct MarvelAI.AISpawnParam
// 0x00A8 (0x00A8 - 0x0000)
struct FAISpawnParam final
{
public:
	int32                                         UID;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeroID;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleSide                                   BattleSide;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AIName;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIDifficultyMode                             DifficultyMode;                                    // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DifficultyLevel;                                   // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RebornLocation;                                    // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotation;                                     // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RebornRotation;                                    // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RebornTime;                                        // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0090(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTrainingTarget;                                  // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWoodPile;                                        // 0x0099(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkinID;                                            // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecordUID;                                         // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePreciseReachLogic;                              // 0x00A4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISpawnParam) == 0x000008, "Wrong alignment on FAISpawnParam");
static_assert(sizeof(FAISpawnParam) == 0x0000A8, "Wrong size on FAISpawnParam");
static_assert(offsetof(FAISpawnParam, UID) == 0x000000, "Member 'FAISpawnParam::UID' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, HeroID) == 0x000004, "Member 'FAISpawnParam::HeroID' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, BattleSide) == 0x000008, "Member 'FAISpawnParam::BattleSide' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, AIName) == 0x000010, "Member 'FAISpawnParam::AIName' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, DifficultyMode) == 0x000020, "Member 'FAISpawnParam::DifficultyMode' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, DifficultyLevel) == 0x000024, "Member 'FAISpawnParam::DifficultyLevel' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, SpawnLocation) == 0x000028, "Member 'FAISpawnParam::SpawnLocation' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, RebornLocation) == 0x000040, "Member 'FAISpawnParam::RebornLocation' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, SpawnRotation) == 0x000058, "Member 'FAISpawnParam::SpawnRotation' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, RebornRotation) == 0x000070, "Member 'FAISpawnParam::RebornRotation' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, RebornTime) == 0x000088, "Member 'FAISpawnParam::RebornTime' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, BehaviorTree) == 0x000090, "Member 'FAISpawnParam::BehaviorTree' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, IsTrainingTarget) == 0x000098, "Member 'FAISpawnParam::IsTrainingTarget' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, IsWoodPile) == 0x000099, "Member 'FAISpawnParam::IsWoodPile' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, SkinID) == 0x00009C, "Member 'FAISpawnParam::SkinID' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, RecordUID) == 0x0000A0, "Member 'FAISpawnParam::RecordUID' has a wrong offset!");
static_assert(offsetof(FAISpawnParam, UsePreciseReachLogic) == 0x0000A4, "Member 'FAISpawnParam::UsePreciseReachLogic' has a wrong offset!");

// ScriptStruct MarvelAI.MarvelHeroAutoAITable
// 0x0010 (0x0030 - 0x0020)
struct FMarvelHeroAutoAITable final : public FTableRowBase
{
public:
	int32                                         HeroID;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarvelHeroAutoAITable) == 0x000008, "Wrong alignment on FMarvelHeroAutoAITable");
static_assert(sizeof(FMarvelHeroAutoAITable) == 0x000030, "Wrong size on FMarvelHeroAutoAITable");
static_assert(offsetof(FMarvelHeroAutoAITable, HeroID) == 0x000020, "Member 'FMarvelHeroAutoAITable::HeroID' has a wrong offset!");
static_assert(offsetof(FMarvelHeroAutoAITable, BehaviorTree) == 0x000028, "Member 'FMarvelHeroAutoAITable::BehaviorTree' has a wrong offset!");

// ScriptStruct MarvelAI.AIBattleConfig
// 0x0004 (0x0004 - 0x0000)
struct FAIBattleConfig final
{
public:
	float                                         KeepDistanceInBattle;                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIBattleConfig) == 0x000004, "Wrong alignment on FAIBattleConfig");
static_assert(sizeof(FAIBattleConfig) == 0x000004, "Wrong size on FAIBattleConfig");
static_assert(offsetof(FAIBattleConfig, KeepDistanceInBattle) == 0x000000, "Member 'FAIBattleConfig::KeepDistanceInBattle' has a wrong offset!");

// ScriptStruct MarvelAI.MarvelHeroBehaviorTreeTable
// 0x00F0 (0x0110 - 0x0020)
struct FMarvelHeroBehaviorTreeTable final : public FTableRowBase
{
public:
	int32                                         HeroID;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIHeroTag                             AIHeroType;                                        // 0x0028(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         NormalJumpAbilityID;                               // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            HeroSculptDataRemap;                               // 0x0098(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAIBattleConfig                        BattleConfig;                                      // 0x00E8(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIHeroNavigationConfig                NavigationConfig;                                  // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bSelectable;                                       // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMarvelHeroBehaviorTreeTable) == 0x000008, "Wrong alignment on FMarvelHeroBehaviorTreeTable");
static_assert(sizeof(FMarvelHeroBehaviorTreeTable) == 0x000110, "Wrong size on FMarvelHeroBehaviorTreeTable");
static_assert(offsetof(FMarvelHeroBehaviorTreeTable, HeroID) == 0x000020, "Member 'FMarvelHeroBehaviorTreeTable::HeroID' has a wrong offset!");
static_assert(offsetof(FMarvelHeroBehaviorTreeTable, AIHeroType) == 0x000028, "Member 'FMarvelHeroBehaviorTreeTable::AIHeroType' has a wrong offset!");
static_assert(offsetof(FMarvelHeroBehaviorTreeTable, NormalJumpAbilityID) == 0x000090, "Member 'FMarvelHeroBehaviorTreeTable::NormalJumpAbilityID' has a wrong offset!");
static_assert(offsetof(FMarvelHeroBehaviorTreeTable, HeroSculptDataRemap) == 0x000098, "Member 'FMarvelHeroBehaviorTreeTable::HeroSculptDataRemap' has a wrong offset!");
static_assert(offsetof(FMarvelHeroBehaviorTreeTable, BattleConfig) == 0x0000E8, "Member 'FMarvelHeroBehaviorTreeTable::BattleConfig' has a wrong offset!");
static_assert(offsetof(FMarvelHeroBehaviorTreeTable, NavigationConfig) == 0x0000F0, "Member 'FMarvelHeroBehaviorTreeTable::NavigationConfig' has a wrong offset!");
static_assert(offsetof(FMarvelHeroBehaviorTreeTable, bSelectable) == 0x000108, "Member 'FMarvelHeroBehaviorTreeTable::bSelectable' has a wrong offset!");

// ScriptStruct MarvelAI.HeightToNavArea
// 0x0010 (0x0010 - 0x0000)
struct FHeightToNavArea final
{
public:
	float                                         Height;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavArea>                   NavAreaClass;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeightToNavArea) == 0x000008, "Wrong alignment on FHeightToNavArea");
static_assert(sizeof(FHeightToNavArea) == 0x000010, "Wrong size on FHeightToNavArea");
static_assert(offsetof(FHeightToNavArea, Height) == 0x000000, "Member 'FHeightToNavArea::Height' has a wrong offset!");
static_assert(offsetof(FHeightToNavArea, NavAreaClass) == 0x000008, "Member 'FHeightToNavArea::NavAreaClass' has a wrong offset!");

// ScriptStruct MarvelAI.WallAttachCheckConfig
// 0x0020 (0x0020 - 0x0000)
struct FWallAttachCheckConfig final
{
public:
	float                                         MinHeightForWallAttach;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAllowedHorizontalDist;                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaycastDistInterval;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffsetForBasePoints;                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalDistFactor;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowedDistRangeFactor;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowedDotDiffValue;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDrawDebug;                                  // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldOverrideWithRecastConfig;                   // 0x001D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWallAttachCheckConfig) == 0x000004, "Wrong alignment on FWallAttachCheckConfig");
static_assert(sizeof(FWallAttachCheckConfig) == 0x000020, "Wrong size on FWallAttachCheckConfig");
static_assert(offsetof(FWallAttachCheckConfig, MinHeightForWallAttach) == 0x000000, "Member 'FWallAttachCheckConfig::MinHeightForWallAttach' has a wrong offset!");
static_assert(offsetof(FWallAttachCheckConfig, MaxAllowedHorizontalDist) == 0x000004, "Member 'FWallAttachCheckConfig::MaxAllowedHorizontalDist' has a wrong offset!");
static_assert(offsetof(FWallAttachCheckConfig, RaycastDistInterval) == 0x000008, "Member 'FWallAttachCheckConfig::RaycastDistInterval' has a wrong offset!");
static_assert(offsetof(FWallAttachCheckConfig, HeightOffsetForBasePoints) == 0x00000C, "Member 'FWallAttachCheckConfig::HeightOffsetForBasePoints' has a wrong offset!");
static_assert(offsetof(FWallAttachCheckConfig, HorizontalDistFactor) == 0x000010, "Member 'FWallAttachCheckConfig::HorizontalDistFactor' has a wrong offset!");
static_assert(offsetof(FWallAttachCheckConfig, AllowedDistRangeFactor) == 0x000014, "Member 'FWallAttachCheckConfig::AllowedDistRangeFactor' has a wrong offset!");
static_assert(offsetof(FWallAttachCheckConfig, AllowedDotDiffValue) == 0x000018, "Member 'FWallAttachCheckConfig::AllowedDotDiffValue' has a wrong offset!");
static_assert(offsetof(FWallAttachCheckConfig, bEnableDrawDebug) == 0x00001C, "Member 'FWallAttachCheckConfig::bEnableDrawDebug' has a wrong offset!");
static_assert(offsetof(FWallAttachCheckConfig, bShouldOverrideWithRecastConfig) == 0x00001D, "Member 'FWallAttachCheckConfig::bShouldOverrideWithRecastConfig' has a wrong offset!");

// ScriptStruct MarvelAI.PathSelectorData
// 0x0050 (0x0050 - 0x0000)
struct FPathSelectorData final
{
public:
	TMap<TSoftObjectPtr<class AActor>, TSoftObjectPtr<class AStartWayPoint>> TargetToPathStart;                                 // 0x0000(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPathSelectorData) == 0x000008, "Wrong alignment on FPathSelectorData");
static_assert(sizeof(FPathSelectorData) == 0x000050, "Wrong size on FPathSelectorData");
static_assert(offsetof(FPathSelectorData, TargetToPathStart) == 0x000000, "Member 'FPathSelectorData::TargetToPathStart' has a wrong offset!");

// ScriptStruct MarvelAI.TileRef
// 0x0008 (0x0008 - 0x0000)
struct FTileRef final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTileRef) == 0x000004, "Wrong alignment on FTileRef");
static_assert(sizeof(FTileRef) == 0x000008, "Wrong size on FTileRef");
static_assert(offsetof(FTileRef, X) == 0x000000, "Member 'FTileRef::X' has a wrong offset!");
static_assert(offsetof(FTileRef, Y) == 0x000004, "Member 'FTileRef::Y' has a wrong offset!");

// ScriptStruct MarvelAI.TileDebugDrawConfig
// 0x0008 (0x0008 - 0x0000)
struct FTileDebugDrawConfig final
{
public:
	uint8                                         bDrawEdgeData : 1;                                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawEdgeLine : 1;                                 // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawEdgeSamplePoints : 1;                         // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawEdgeBackDir : 1;                              // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawEdgeBound : 1;                                // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawEdgeIndexInTile : 1;                          // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawPendingLinks : 1;                             // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDebugForLinkCheck : 1;                        // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x1];                                        // 0x0001(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         DrawDebugDepthPriority;                            // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDebugLifeTime;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTileDebugDrawConfig) == 0x000004, "Wrong alignment on FTileDebugDrawConfig");
static_assert(sizeof(FTileDebugDrawConfig) == 0x000008, "Wrong size on FTileDebugDrawConfig");
static_assert(offsetof(FTileDebugDrawConfig, DrawDebugDepthPriority) == 0x000002, "Member 'FTileDebugDrawConfig::DrawDebugDepthPriority' has a wrong offset!");
static_assert(offsetof(FTileDebugDrawConfig, DrawDebugLifeTime) == 0x000004, "Member 'FTileDebugDrawConfig::DrawDebugLifeTime' has a wrong offset!");

// ScriptStruct MarvelAI.DebugEdge
// 0x0048 (0x0048 - 0x0000)
struct FDebugEdge final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AnotherPoint;                                      // 0x0030(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugEdge) == 0x000008, "Wrong alignment on FDebugEdge");
static_assert(sizeof(FDebugEdge) == 0x000048, "Wrong size on FDebugEdge");
static_assert(offsetof(FDebugEdge, StartLocation) == 0x000000, "Member 'FDebugEdge::StartLocation' has a wrong offset!");
static_assert(offsetof(FDebugEdge, EndLocation) == 0x000018, "Member 'FDebugEdge::EndLocation' has a wrong offset!");
static_assert(offsetof(FDebugEdge, AnotherPoint) == 0x000030, "Member 'FDebugEdge::AnotherPoint' has a wrong offset!");

// ScriptStruct MarvelAI.EdgeRef
// 0x000C (0x000C - 0x0000)
struct FEdgeRef final
{
public:
	struct FTileRef                               TileRef;                                           // 0x0000(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        EdgeIndex;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FEdgeRef) == 0x000004, "Wrong alignment on FEdgeRef");
static_assert(sizeof(FEdgeRef) == 0x00000C, "Wrong size on FEdgeRef");
static_assert(offsetof(FEdgeRef, TileRef) == 0x000000, "Member 'FEdgeRef::TileRef' has a wrong offset!");
static_assert(offsetof(FEdgeRef, EdgeIndex) == 0x000008, "Member 'FEdgeRef::EdgeIndex' has a wrong offset!");

// ScriptStruct MarvelAI.NavLinkList
// 0x0010 (0x0010 - 0x0000)
struct FNavLinkList final
{
public:
	TArray<class ANavLinkProxy*>                  LinkListData;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavLinkList) == 0x000008, "Wrong alignment on FNavLinkList");
static_assert(sizeof(FNavLinkList) == 0x000010, "Wrong size on FNavLinkList");
static_assert(offsetof(FNavLinkList, LinkListData) == 0x000000, "Member 'FNavLinkList::LinkListData' has a wrong offset!");

// ScriptStruct MarvelAI.TileData
// 0x00D0 (0x00D0 - 0x0000)
struct FTileData final
{
public:
	struct FTileRef                               MyTileRef;                                         // 0x0000(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBox                                   MyBound;                                           // 0x0008(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNavLinkList                           InnerTileLinks;                                    // 0x0050(0x0010)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FTileRef, struct FNavLinkList>    CrossTileLinks;                                    // 0x0060(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTileData) == 0x000008, "Wrong alignment on FTileData");
static_assert(sizeof(FTileData) == 0x0000D0, "Wrong size on FTileData");
static_assert(offsetof(FTileData, MyTileRef) == 0x000000, "Member 'FTileData::MyTileRef' has a wrong offset!");
static_assert(offsetof(FTileData, MyBound) == 0x000008, "Member 'FTileData::MyBound' has a wrong offset!");
static_assert(offsetof(FTileData, InnerTileLinks) == 0x000050, "Member 'FTileData::InnerTileLinks' has a wrong offset!");
static_assert(offsetof(FTileData, CrossTileLinks) == 0x000060, "Member 'FTileData::CrossTileLinks' has a wrong offset!");

// ScriptStruct MarvelAI.NavLinkGenerateConfig
// 0x0038 (0x0038 - 0x0000)
struct FNavLinkGenerateConfig final
{
public:
	struct FRange_FloatValue                      DropHeight;                                        // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRange_FloatValue                      JumpDistance_Horizontal;                           // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EdgeSampleDistance;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustBackDistForRealLink;                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalTraceExtraOffset;                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalTraceExtraOffset;                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockUpEffectRadius;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinKnockUpLinkHeight;                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentRadius;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentHeight;                                       // 0x002C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavLinkGenerateConfig) == 0x000004, "Wrong alignment on FNavLinkGenerateConfig");
static_assert(sizeof(FNavLinkGenerateConfig) == 0x000038, "Wrong size on FNavLinkGenerateConfig");
static_assert(offsetof(FNavLinkGenerateConfig, DropHeight) == 0x000000, "Member 'FNavLinkGenerateConfig::DropHeight' has a wrong offset!");
static_assert(offsetof(FNavLinkGenerateConfig, JumpDistance_Horizontal) == 0x000008, "Member 'FNavLinkGenerateConfig::JumpDistance_Horizontal' has a wrong offset!");
static_assert(offsetof(FNavLinkGenerateConfig, EdgeSampleDistance) == 0x000010, "Member 'FNavLinkGenerateConfig::EdgeSampleDistance' has a wrong offset!");
static_assert(offsetof(FNavLinkGenerateConfig, AdjustBackDistForRealLink) == 0x000014, "Member 'FNavLinkGenerateConfig::AdjustBackDistForRealLink' has a wrong offset!");
static_assert(offsetof(FNavLinkGenerateConfig, HorizontalTraceExtraOffset) == 0x000018, "Member 'FNavLinkGenerateConfig::HorizontalTraceExtraOffset' has a wrong offset!");
static_assert(offsetof(FNavLinkGenerateConfig, VerticalTraceExtraOffset) == 0x00001C, "Member 'FNavLinkGenerateConfig::VerticalTraceExtraOffset' has a wrong offset!");
static_assert(offsetof(FNavLinkGenerateConfig, KnockUpEffectRadius) == 0x000020, "Member 'FNavLinkGenerateConfig::KnockUpEffectRadius' has a wrong offset!");
static_assert(offsetof(FNavLinkGenerateConfig, MinKnockUpLinkHeight) == 0x000024, "Member 'FNavLinkGenerateConfig::MinKnockUpLinkHeight' has a wrong offset!");
static_assert(offsetof(FNavLinkGenerateConfig, AgentRadius) == 0x000028, "Member 'FNavLinkGenerateConfig::AgentRadius' has a wrong offset!");
static_assert(offsetof(FNavLinkGenerateConfig, AgentHeight) == 0x00002C, "Member 'FNavLinkGenerateConfig::AgentHeight' has a wrong offset!");

// ScriptStruct MarvelAI.StrategyPointGenerateConfig
// 0x0010 (0x0010 - 0x0000)
struct FStrategyPointGenerateConfig final
{
public:
	float                                         MaxHorizontalDistanceToShelter;                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxShelterHeight;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredMinHeightAsShelter;                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleDistanceAlongZAxis;                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStrategyPointGenerateConfig) == 0x000004, "Wrong alignment on FStrategyPointGenerateConfig");
static_assert(sizeof(FStrategyPointGenerateConfig) == 0x000010, "Wrong size on FStrategyPointGenerateConfig");
static_assert(offsetof(FStrategyPointGenerateConfig, MaxHorizontalDistanceToShelter) == 0x000000, "Member 'FStrategyPointGenerateConfig::MaxHorizontalDistanceToShelter' has a wrong offset!");
static_assert(offsetof(FStrategyPointGenerateConfig, MaxShelterHeight) == 0x000004, "Member 'FStrategyPointGenerateConfig::MaxShelterHeight' has a wrong offset!");
static_assert(offsetof(FStrategyPointGenerateConfig, RequiredMinHeightAsShelter) == 0x000008, "Member 'FStrategyPointGenerateConfig::RequiredMinHeightAsShelter' has a wrong offset!");
static_assert(offsetof(FStrategyPointGenerateConfig, SampleDistanceAlongZAxis) == 0x00000C, "Member 'FStrategyPointGenerateConfig::SampleDistanceAlongZAxis' has a wrong offset!");

// ScriptStruct MarvelAI.QA_AIHeroConfig
// 0x0001 (0x0001 - 0x0000)
struct FQA_AIHeroConfig final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQA_AIHeroConfig) == 0x000001, "Wrong alignment on FQA_AIHeroConfig");
static_assert(sizeof(FQA_AIHeroConfig) == 0x000001, "Wrong size on FQA_AIHeroConfig");

// ScriptStruct MarvelAI.AIScoreModuleStruct
// 0x0018 (0x0018 - 0x0000)
struct FAIScoreModuleStruct final
{
public:
	class UAIScoreModule*                         ScoreModule;                                       // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAIScoreModuleCondition*>        Conditions;                                        // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIScoreModuleStruct) == 0x000008, "Wrong alignment on FAIScoreModuleStruct");
static_assert(sizeof(FAIScoreModuleStruct) == 0x000018, "Wrong size on FAIScoreModuleStruct");
static_assert(offsetof(FAIScoreModuleStruct, ScoreModule) == 0x000000, "Member 'FAIScoreModuleStruct::ScoreModule' has a wrong offset!");
static_assert(offsetof(FAIScoreModuleStruct, Conditions) == 0x000008, "Member 'FAIScoreModuleStruct::Conditions' has a wrong offset!");

// ScriptStruct MarvelAI.ShelterPathFindConfig
// 0x0040 (0x0040 - 0x0000)
struct FShelterPathFindConfig final
{
public:
	bool                                          bFailedIfCanNotFindInterPoints;                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConsideredPointMaxRange;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleSampleDist;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptableRadius;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleCheckOffsetAsAgentHeight;                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleCheckHeightOffset_Fixed;                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalRangeRadius;                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceCheckRange;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            NextNodeFindRange;                                 // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IterationNumLimit;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebugDraw;                                  // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawFullGraph;                                    // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvisibleCostFactor;                               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawDebugDuration;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShelterPathFindConfig) == 0x000004, "Wrong alignment on FShelterPathFindConfig");
static_assert(sizeof(FShelterPathFindConfig) == 0x000040, "Wrong size on FShelterPathFindConfig");
static_assert(offsetof(FShelterPathFindConfig, bFailedIfCanNotFindInterPoints) == 0x000000, "Member 'FShelterPathFindConfig::bFailedIfCanNotFindInterPoints' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, ConsideredPointMaxRange) == 0x000004, "Member 'FShelterPathFindConfig::ConsideredPointMaxRange' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, VisibleSampleDist) == 0x000008, "Member 'FShelterPathFindConfig::VisibleSampleDist' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, AcceptableRadius) == 0x00000C, "Member 'FShelterPathFindConfig::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, VisibleCheckOffsetAsAgentHeight) == 0x000010, "Member 'FShelterPathFindConfig::VisibleCheckOffsetAsAgentHeight' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, VisibleCheckHeightOffset_Fixed) == 0x000014, "Member 'FShelterPathFindConfig::VisibleCheckHeightOffset_Fixed' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, AdditionalRangeRadius) == 0x000018, "Member 'FShelterPathFindConfig::AdditionalRangeRadius' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, TraceCheckRange) == 0x00001C, "Member 'FShelterPathFindConfig::TraceCheckRange' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, NextNodeFindRange) == 0x000020, "Member 'FShelterPathFindConfig::NextNodeFindRange' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, IterationNumLimit) == 0x000030, "Member 'FShelterPathFindConfig::IterationNumLimit' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, bEnableDebugDraw) == 0x000034, "Member 'FShelterPathFindConfig::bEnableDebugDraw' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, bDrawFullGraph) == 0x000035, "Member 'FShelterPathFindConfig::bDrawFullGraph' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, InvisibleCostFactor) == 0x000038, "Member 'FShelterPathFindConfig::InvisibleCostFactor' has a wrong offset!");
static_assert(offsetof(FShelterPathFindConfig, DrawDebugDuration) == 0x00003C, "Member 'FShelterPathFindConfig::DrawDebugDuration' has a wrong offset!");

// ScriptStruct MarvelAI.SteeringWithWeight
// 0x0010 (0x0010 - 0x0000)
struct FSteeringWithWeight final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USteeringBehavior*                      SteeringBehavior;                                  // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSteeringWithWeight) == 0x000008, "Wrong alignment on FSteeringWithWeight");
static_assert(sizeof(FSteeringWithWeight) == 0x000010, "Wrong size on FSteeringWithWeight");
static_assert(offsetof(FSteeringWithWeight, Weight) == 0x000000, "Member 'FSteeringWithWeight::Weight' has a wrong offset!");
static_assert(offsetof(FSteeringWithWeight, SteeringBehavior) == 0x000008, "Member 'FSteeringWithWeight::SteeringBehavior' has a wrong offset!");

// ScriptStruct MarvelAI.ShelterInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FShelterInstanceData final
{
public:
	float                                         HeightValue;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShelterInstanceData) == 0x000004, "Wrong alignment on FShelterInstanceData");
static_assert(sizeof(FShelterInstanceData) == 0x000008, "Wrong size on FShelterInstanceData");
static_assert(offsetof(FShelterInstanceData, HeightValue) == 0x000000, "Member 'FShelterInstanceData::HeightValue' has a wrong offset!");

// ScriptStruct MarvelAI.NavDistToScore
// 0x0008 (0x0008 - 0x0000)
struct FNavDistToScore final
{
public:
	float                                         NavDist;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavDistToScore) == 0x000004, "Wrong alignment on FNavDistToScore");
static_assert(sizeof(FNavDistToScore) == 0x000008, "Wrong size on FNavDistToScore");
static_assert(offsetof(FNavDistToScore, NavDist) == 0x000000, "Member 'FNavDistToScore::NavDist' has a wrong offset!");
static_assert(offsetof(FNavDistToScore, Score) == 0x000004, "Member 'FNavDistToScore::Score' has a wrong offset!");

// ScriptStruct MarvelAI.PathFindTestCase
// 0x0050 (0x0050 - 0x0000)
struct FPathFindTestCase final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHavePath;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ResultPathPoints;                                  // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CachedPathLength;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathFindTestCase) == 0x000008, "Wrong alignment on FPathFindTestCase");
static_assert(sizeof(FPathFindTestCase) == 0x000050, "Wrong size on FPathFindTestCase");
static_assert(offsetof(FPathFindTestCase, StartLocation) == 0x000000, "Member 'FPathFindTestCase::StartLocation' has a wrong offset!");
static_assert(offsetof(FPathFindTestCase, TargetLocation) == 0x000018, "Member 'FPathFindTestCase::TargetLocation' has a wrong offset!");
static_assert(offsetof(FPathFindTestCase, bShouldHavePath) == 0x000030, "Member 'FPathFindTestCase::bShouldHavePath' has a wrong offset!");
static_assert(offsetof(FPathFindTestCase, ResultPathPoints) == 0x000038, "Member 'FPathFindTestCase::ResultPathPoints' has a wrong offset!");
static_assert(offsetof(FPathFindTestCase, CachedPathLength) == 0x000048, "Member 'FPathFindTestCase::CachedPathLength' has a wrong offset!");

// ScriptStruct MarvelAI.PathTestCaseCategory
// 0x0030 (0x0030 - 0x0000)
struct FPathTestCaseCategory final
{
public:
	struct FFloatRange                            NavDistRange;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CategoryName;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CaseList;                                          // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPathTestCaseCategory) == 0x000008, "Wrong alignment on FPathTestCaseCategory");
static_assert(sizeof(FPathTestCaseCategory) == 0x000030, "Wrong size on FPathTestCaseCategory");
static_assert(offsetof(FPathTestCaseCategory, NavDistRange) == 0x000000, "Member 'FPathTestCaseCategory::NavDistRange' has a wrong offset!");
static_assert(offsetof(FPathTestCaseCategory, CategoryName) == 0x000010, "Member 'FPathTestCaseCategory::CategoryName' has a wrong offset!");
static_assert(offsetof(FPathTestCaseCategory, CaseList) == 0x000020, "Member 'FPathTestCaseCategory::CaseList' has a wrong offset!");

// ScriptStruct MarvelAI.WayPointPathWeight
// 0x0008 (0x0008 - 0x0000)
struct FWayPointPathWeight final
{
public:
	EWayPointMark                                 Mark;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWayPointPathWeight) == 0x000004, "Wrong alignment on FWayPointPathWeight");
static_assert(sizeof(FWayPointPathWeight) == 0x000008, "Wrong size on FWayPointPathWeight");
static_assert(offsetof(FWayPointPathWeight, Mark) == 0x000000, "Member 'FWayPointPathWeight::Mark' has a wrong offset!");
static_assert(offsetof(FWayPointPathWeight, Weight) == 0x000004, "Member 'FWayPointPathWeight::Weight' has a wrong offset!");

// ScriptStruct MarvelAI.WayPointPathConfig
// 0x0010 (0x0010 - 0x0000)
struct FWayPointPathConfig final
{
public:
	TArray<struct FWayPointPathWeight>            WayPointPathWeights;                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWayPointPathConfig) == 0x000008, "Wrong alignment on FWayPointPathConfig");
static_assert(sizeof(FWayPointPathConfig) == 0x000010, "Wrong size on FWayPointPathConfig");
static_assert(offsetof(FWayPointPathConfig, WayPointPathWeights) == 0x000000, "Member 'FWayPointPathConfig::WayPointPathWeights' has a wrong offset!");

// ScriptStruct MarvelAI.WayPointToWeight
// 0x0038 (0x0038 - 0x0000)
struct FWayPointToWeight final
{
public:
	TWeakObjectPtr<class AWayPoint>               WayPoint;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafeFactor;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawSafeFactor;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FComponentReference>            FlyAreas;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWayPointToWeight) == 0x000008, "Wrong alignment on FWayPointToWeight");
static_assert(sizeof(FWayPointToWeight) == 0x000038, "Wrong size on FWayPointToWeight");
static_assert(offsetof(FWayPointToWeight, WayPoint) == 0x000000, "Member 'FWayPointToWeight::WayPoint' has a wrong offset!");
static_assert(offsetof(FWayPointToWeight, Weight) == 0x000008, "Member 'FWayPointToWeight::Weight' has a wrong offset!");
static_assert(offsetof(FWayPointToWeight, SafeFactor) == 0x00000C, "Member 'FWayPointToWeight::SafeFactor' has a wrong offset!");
static_assert(offsetof(FWayPointToWeight, RawSafeFactor) == 0x000010, "Member 'FWayPointToWeight::RawSafeFactor' has a wrong offset!");
static_assert(offsetof(FWayPointToWeight, FlyAreas) == 0x000018, "Member 'FWayPointToWeight::FlyAreas' has a wrong offset!");

// ScriptStruct MarvelAI.WayPointPath
// 0x0048 (0x0048 - 0x0000)
struct FWayPointPath final
{
public:
	EWayPointMark                                 WayPointMark;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         WayPoints;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         WayPointIndex;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        SubPathPoints;                                     // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         SubPathIndex;                                      // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RingStartIndex;                                    // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasRing;                                           // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0xF];                                       // 0x0039(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWayPointPath) == 0x000008, "Wrong alignment on FWayPointPath");
static_assert(sizeof(FWayPointPath) == 0x000048, "Wrong size on FWayPointPath");
static_assert(offsetof(FWayPointPath, WayPointMark) == 0x000000, "Member 'FWayPointPath::WayPointMark' has a wrong offset!");
static_assert(offsetof(FWayPointPath, WayPoints) == 0x000008, "Member 'FWayPointPath::WayPoints' has a wrong offset!");
static_assert(offsetof(FWayPointPath, WayPointIndex) == 0x000018, "Member 'FWayPointPath::WayPointIndex' has a wrong offset!");
static_assert(offsetof(FWayPointPath, SubPathPoints) == 0x000020, "Member 'FWayPointPath::SubPathPoints' has a wrong offset!");
static_assert(offsetof(FWayPointPath, SubPathIndex) == 0x000030, "Member 'FWayPointPath::SubPathIndex' has a wrong offset!");
static_assert(offsetof(FWayPointPath, RingStartIndex) == 0x000034, "Member 'FWayPointPath::RingStartIndex' has a wrong offset!");
static_assert(offsetof(FWayPointPath, HasRing) == 0x000038, "Member 'FWayPointPath::HasRing' has a wrong offset!");

}

