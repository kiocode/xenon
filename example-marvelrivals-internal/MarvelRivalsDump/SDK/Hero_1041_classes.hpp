#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1041

#include "Basic.hpp"

#include "Hero_1041_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1041.Config_104101
// 0x0008 (0x00A0 - 0x0098)
class UConfig_104101 : public UMarvelAbilityConfig
{
public:
	EAutoAddAmmoTime                              AutoAddAmmoTime;                                   // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoAddAmmoAmount;                                 // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104101">();
	}
	static class UConfig_104101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104101>();
	}
};
static_assert(alignof(UConfig_104101) == 0x000008, "Wrong alignment on UConfig_104101");
static_assert(sizeof(UConfig_104101) == 0x0000A0, "Wrong size on UConfig_104101");
static_assert(offsetof(UConfig_104101, AutoAddAmmoTime) == 0x000098, "Member 'UConfig_104101::AutoAddAmmoTime' has a wrong offset!");
static_assert(offsetof(UConfig_104101, AutoAddAmmoAmount) == 0x00009C, "Member 'UConfig_104101::AutoAddAmmoAmount' has a wrong offset!");

// Class Hero_1041.AnimNotify_WS_WeaponQuickReload
// 0x0010 (0x0080 - 0x0070)
class UAnimNotify_WS_WeaponQuickReload final : public UAnimNotify_TriggerWeaponEvent
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponMaterialUpdateDuration;                      // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WS_WeaponQuickReload">();
	}
	static class UAnimNotify_WS_WeaponQuickReload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WS_WeaponQuickReload>();
	}
};
static_assert(alignof(UAnimNotify_WS_WeaponQuickReload) == 0x000008, "Wrong alignment on UAnimNotify_WS_WeaponQuickReload");
static_assert(sizeof(UAnimNotify_WS_WeaponQuickReload) == 0x000080, "Wrong size on UAnimNotify_WS_WeaponQuickReload");
static_assert(offsetof(UAnimNotify_WS_WeaponQuickReload, WeaponMaterialUpdateDuration) == 0x000078, "Member 'UAnimNotify_WS_WeaponQuickReload::WeaponMaterialUpdateDuration' has a wrong offset!");

// Class Hero_1041.Cue_Weapon_Loop_104121
// 0x0008 (0x10B0 - 0x10A8)
class ACue_Weapon_Loop_104121 : public AMarvelCueNotify_Weapon_Loop
{
public:
	int32                                         PassiveAbilityID;                                  // 0x10A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10AC[0x4];                                     // 0x10AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPassiveAmmoAdd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Weapon_Loop_104121">();
	}
	static class ACue_Weapon_Loop_104121* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Weapon_Loop_104121>();
	}
};
static_assert(alignof(ACue_Weapon_Loop_104121) == 0x000008, "Wrong alignment on ACue_Weapon_Loop_104121");
static_assert(sizeof(ACue_Weapon_Loop_104121) == 0x0010B0, "Wrong size on ACue_Weapon_Loop_104121");
static_assert(offsetof(ACue_Weapon_Loop_104121, PassiveAbilityID) == 0x0010A8, "Member 'ACue_Weapon_Loop_104121::PassiveAbilityID' has a wrong offset!");

// Class Hero_1041.Config_104131
// 0x0040 (0x0110 - 0x00D0)
class UConfig_104131 : public UMarvelAbilityConfig_LongPressTrigger
{
public:
	int32                                         SubTargetsMaxCount;                                // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetDistance;                                    // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DashEndLocationOffset;                             // 0x00D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileRecycleDelay;                            // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleOffsetLimit;                                  // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DizzyBuffTag;                                      // 0x00F8(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraInterp*                          PullingCameraInterp;                               // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104131">();
	}
	static class UConfig_104131* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104131>();
	}
};
static_assert(alignof(UConfig_104131) == 0x000008, "Wrong alignment on UConfig_104131");
static_assert(sizeof(UConfig_104131) == 0x000110, "Wrong size on UConfig_104131");
static_assert(offsetof(UConfig_104131, SubTargetsMaxCount) == 0x0000D0, "Member 'UConfig_104131::SubTargetsMaxCount' has a wrong offset!");
static_assert(offsetof(UConfig_104131, OffsetDistance) == 0x0000D4, "Member 'UConfig_104131::OffsetDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104131, DashEndLocationOffset) == 0x0000D8, "Member 'UConfig_104131::DashEndLocationOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104131, ProjectileRecycleDelay) == 0x0000F0, "Member 'UConfig_104131::ProjectileRecycleDelay' has a wrong offset!");
static_assert(offsetof(UConfig_104131, AngleOffsetLimit) == 0x0000F4, "Member 'UConfig_104131::AngleOffsetLimit' has a wrong offset!");
static_assert(offsetof(UConfig_104131, DizzyBuffTag) == 0x0000F8, "Member 'UConfig_104131::DizzyBuffTag' has a wrong offset!");
static_assert(offsetof(UConfig_104131, EndDistance) == 0x000104, "Member 'UConfig_104131::EndDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104131, PullingCameraInterp) == 0x000108, "Member 'UConfig_104131::PullingCameraInterp' has a wrong offset!");

// Class Hero_1041.Ability_104131
// 0x01D0 (0x2768 - 0x2598)
class UAbility_104131 : public UMarvelAbility_LongPressTrigger
{
public:
	class AMarvelAbilityTargetActor_Projectile*   BackWardProjectile;                                // 0x2598(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             MainProjectileHitResult;                           // 0x25A0(0x0170)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRotator                               MissileRotator104131;                              // 0x2710(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  MainTarget;                                        // 0x2728(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          SubTargets;                                        // 0x2730(0x0010)(Net, ZeroConstructor, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         DragBuffId;                                        // 0x2740(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DizzyBuffId;                                       // 0x2744(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitGameplayTagRemoved*    WaitBuffRemoveTask;                                // 0x2748(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_104131*                         Config_104131;                                     // 0x2750(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAbility104131PullBackDispatcher;                 // 0x2758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddSubTarget(class AActor* Target);
	void ApplyDragBuff();
	class ACharacter* GetMainTarget();
	struct FRotator GetMissileRotator104131();
	TArray<TWeakObjectPtr<class AActor>> GetSubTargets();
	bool IsAbilityHit();
	bool IsMainTarget(const class AActor* CheckTarget);
	bool IsSubTarget(const class AActor* CheckTarget);
	void K2_EnterEndSection();
	void OnMainTargetDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnMainTargetHit();
	void OnRep_SubTargets();
	void OnTargetDizzyBuffRemoved();
	void OnWinterSoldierPortal(const struct FVector& LastPosition, const struct FVector& NewPosition);
	void RemoveSubTarget(class AActor* Target);
	void ResetSubTarget();
	void SetMainTarget(class AActor* Target);
	void SetMissileRotator104131();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104131">();
	}
	static class UAbility_104131* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104131>();
	}
};
static_assert(alignof(UAbility_104131) == 0x000008, "Wrong alignment on UAbility_104131");
static_assert(sizeof(UAbility_104131) == 0x002768, "Wrong size on UAbility_104131");
static_assert(offsetof(UAbility_104131, BackWardProjectile) == 0x002598, "Member 'UAbility_104131::BackWardProjectile' has a wrong offset!");
static_assert(offsetof(UAbility_104131, MainProjectileHitResult) == 0x0025A0, "Member 'UAbility_104131::MainProjectileHitResult' has a wrong offset!");
static_assert(offsetof(UAbility_104131, MissileRotator104131) == 0x002710, "Member 'UAbility_104131::MissileRotator104131' has a wrong offset!");
static_assert(offsetof(UAbility_104131, MainTarget) == 0x002728, "Member 'UAbility_104131::MainTarget' has a wrong offset!");
static_assert(offsetof(UAbility_104131, SubTargets) == 0x002730, "Member 'UAbility_104131::SubTargets' has a wrong offset!");
static_assert(offsetof(UAbility_104131, DragBuffId) == 0x002740, "Member 'UAbility_104131::DragBuffId' has a wrong offset!");
static_assert(offsetof(UAbility_104131, DizzyBuffId) == 0x002744, "Member 'UAbility_104131::DizzyBuffId' has a wrong offset!");
static_assert(offsetof(UAbility_104131, WaitBuffRemoveTask) == 0x002748, "Member 'UAbility_104131::WaitBuffRemoveTask' has a wrong offset!");
static_assert(offsetof(UAbility_104131, Config_104131) == 0x002750, "Member 'UAbility_104131::Config_104131' has a wrong offset!");
static_assert(offsetof(UAbility_104131, OnAbility104131PullBackDispatcher) == 0x002758, "Member 'UAbility_104131::OnAbility104131PullBackDispatcher' has a wrong offset!");

// Class Hero_1041.DragAbility_104131
// 0x0050 (0x1D38 - 0x1CE8)
class UDragAbility_104131 : public UMarvelDragAbility
{
public:
	class ACharacter*                             DraggingCharacter;                                 // 0x1CE8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceOffset;                                    // 0x1CF0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CF4[0x4];                                     // 0x1CF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashEndLocationOffset;                             // 0x1CF8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawOffsetLimit;                                    // 0x1D10(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D14[0x4];                                     // 0x1D14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               OriginRotator;                                     // 0x1D18(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         OriginYaw;                                         // 0x1D30(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D34[0x4];                                     // 0x1D34(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCurrentLimitedYaw();
	struct FVector GetCurrentTargetLocation();
	float GetCurrentYaw();
	void OnActorHitDuringDash(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragAbility_104131">();
	}
	static class UDragAbility_104131* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragAbility_104131>();
	}
};
static_assert(alignof(UDragAbility_104131) == 0x000008, "Wrong alignment on UDragAbility_104131");
static_assert(sizeof(UDragAbility_104131) == 0x001D38, "Wrong size on UDragAbility_104131");
static_assert(offsetof(UDragAbility_104131, DraggingCharacter) == 0x001CE8, "Member 'UDragAbility_104131::DraggingCharacter' has a wrong offset!");
static_assert(offsetof(UDragAbility_104131, DistanceOffset) == 0x001CF0, "Member 'UDragAbility_104131::DistanceOffset' has a wrong offset!");
static_assert(offsetof(UDragAbility_104131, DashEndLocationOffset) == 0x001CF8, "Member 'UDragAbility_104131::DashEndLocationOffset' has a wrong offset!");
static_assert(offsetof(UDragAbility_104131, YawOffsetLimit) == 0x001D10, "Member 'UDragAbility_104131::YawOffsetLimit' has a wrong offset!");
static_assert(offsetof(UDragAbility_104131, OriginRotator) == 0x001D18, "Member 'UDragAbility_104131::OriginRotator' has a wrong offset!");
static_assert(offsetof(UDragAbility_104131, OriginYaw) == 0x001D30, "Member 'UDragAbility_104131::OriginYaw' has a wrong offset!");

// Class Hero_1041.Cue_Projectile_Loop_10413101
// 0x02D8 (0x1088 - 0x0DB0)
class ACue_Projectile_Loop_10413101 final : public AMarvelCueNotify_Projectile
{
public:
	class UStaticMeshComponent*                   PrickleVineMeshComp;                               // 0x0DB0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCableComponent*                  SubCableComp01;                                    // 0x0DB8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCableComponent*                  SubCableComp02;                                    // 0x0DC0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCableComponent*                  SubCableComp03;                                    // 0x0DC8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCableComponent*                  SubCableComp04;                                    // 0x0DD0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCableComponent*                  SubCableComp05;                                    // 0x0DD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMarvelCableComponent*>          Cables;                                            // 0x0DE0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HookComp01;                                        // 0x0DF0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HookComp02;                                        // 0x0DF8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HookComp03;                                        // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HookComp04;                                        // 0x0E08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HookComp05;                                        // 0x0E10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         Hooks;                                             // 0x0E18(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 RiotMeshComp;                                      // 0x0E28(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      RiotSpeedLineFXComponent;                          // 0x0E30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayDeactivateSpeedlineFXTime;                    // 0x0E38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3C[0x4];                                      // 0x0E3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedlineFXDissolveCurve;                          // 0x0E40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrickleVineGrowTime;                               // 0x0E48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrickleVineDissolveTime;                           // 0x0E4C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrickleVineMeshLength;                             // 0x0E50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E54[0x4];                                      // 0x0E54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               PrickleVineMeshRotation;                           // 0x0E58(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         PrickleVineCurveWhenGrowing;                       // 0x0E70(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         PrickleVineCurveWhenDissolving;                    // 0x0EC0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FName                                   PrickleVineAttachSocketName;                       // 0x0F10(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1C[0x4];                                      // 0x0F1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   HideMaterialIndex;                                 // 0x0F20(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         SubCableLengthOffset;                              // 0x0F70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubCableEachSegmentLength;                         // 0x0F74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RiotRelativeRotator;                               // 0x0F78(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PrickleVineScaleDistanceCurve;                     // 0x0F90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SubCableMaterial;                                  // 0x0F98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubCableLength;                                    // 0x0FA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubCableNumSegments;                               // 0x0FA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubCableSolverIterations;                          // 0x0FA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubCableWidth;                                     // 0x0FAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         CharacterDragFX;                                   // 0x0FB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UFXSystemComponent*>        DragTargetFXComps;                                 // 0x0FB8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         PrickleVineRandRoll;                               // 0x1008(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrickleVineGrowRange;                              // 0x100C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrickleVineGrowDelta;                              // 0x1010(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrickleVineGrowLastDelta;                          // 0x1014(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackVelocity;                                      // 0x1018(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasSetDissolveTime;                               // 0x101C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasEndAgentTask;                                  // 0x101D(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAbilityHit;                                     // 0x101E(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101F[0x1];                                     // 0x101F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x1020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelAbilityTargetActor_Projectile*   OwnerProjectile;                                   // 0x1028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbility_104131*                        OwnerAbility;                                      // 0x1030(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelAbilityTargetActor_Projectile*   BackWardProjectile;                                // 0x1038(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               OriginRotator;                                     // 0x1040(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bStopUpdatePrickles;                               // 0x1058(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1059[0x3];                                     // 0x1059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AbilityActivateTag;                                // 0x105C(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           HideAllPrickleVineTimer;                           // 0x1068(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedlineFXDissolveTimeCounter;                    // 0x1080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1084[0x4];                                     // 0x1084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideAllPrickleVineComponents();
	void HideAllSubPrickles();
	bool ShouldSetParameterWhenDissolving(class FName ParameterName);
	bool ShouldSetParameterWhenGrowing(class FName ParameterName);
	bool ShouldUpdateSubPrickles();
	void UpdatePrickleVineFX();
	void UpdateSubPrickles();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10413101">();
	}
	static class ACue_Projectile_Loop_10413101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10413101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10413101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10413101");
static_assert(sizeof(ACue_Projectile_Loop_10413101) == 0x001088, "Wrong size on ACue_Projectile_Loop_10413101");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineMeshComp) == 0x000DB0, "Member 'ACue_Projectile_Loop_10413101::PrickleVineMeshComp' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableComp01) == 0x000DB8, "Member 'ACue_Projectile_Loop_10413101::SubCableComp01' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableComp02) == 0x000DC0, "Member 'ACue_Projectile_Loop_10413101::SubCableComp02' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableComp03) == 0x000DC8, "Member 'ACue_Projectile_Loop_10413101::SubCableComp03' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableComp04) == 0x000DD0, "Member 'ACue_Projectile_Loop_10413101::SubCableComp04' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableComp05) == 0x000DD8, "Member 'ACue_Projectile_Loop_10413101::SubCableComp05' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, Cables) == 0x000DE0, "Member 'ACue_Projectile_Loop_10413101::Cables' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HookComp01) == 0x000DF0, "Member 'ACue_Projectile_Loop_10413101::HookComp01' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HookComp02) == 0x000DF8, "Member 'ACue_Projectile_Loop_10413101::HookComp02' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HookComp03) == 0x000E00, "Member 'ACue_Projectile_Loop_10413101::HookComp03' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HookComp04) == 0x000E08, "Member 'ACue_Projectile_Loop_10413101::HookComp04' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HookComp05) == 0x000E10, "Member 'ACue_Projectile_Loop_10413101::HookComp05' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, Hooks) == 0x000E18, "Member 'ACue_Projectile_Loop_10413101::Hooks' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, RiotMeshComp) == 0x000E28, "Member 'ACue_Projectile_Loop_10413101::RiotMeshComp' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, RiotSpeedLineFXComponent) == 0x000E30, "Member 'ACue_Projectile_Loop_10413101::RiotSpeedLineFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, DelayDeactivateSpeedlineFXTime) == 0x000E38, "Member 'ACue_Projectile_Loop_10413101::DelayDeactivateSpeedlineFXTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SpeedlineFXDissolveCurve) == 0x000E40, "Member 'ACue_Projectile_Loop_10413101::SpeedlineFXDissolveCurve' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineGrowTime) == 0x000E48, "Member 'ACue_Projectile_Loop_10413101::PrickleVineGrowTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineDissolveTime) == 0x000E4C, "Member 'ACue_Projectile_Loop_10413101::PrickleVineDissolveTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineMeshLength) == 0x000E50, "Member 'ACue_Projectile_Loop_10413101::PrickleVineMeshLength' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineMeshRotation) == 0x000E58, "Member 'ACue_Projectile_Loop_10413101::PrickleVineMeshRotation' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineCurveWhenGrowing) == 0x000E70, "Member 'ACue_Projectile_Loop_10413101::PrickleVineCurveWhenGrowing' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineCurveWhenDissolving) == 0x000EC0, "Member 'ACue_Projectile_Loop_10413101::PrickleVineCurveWhenDissolving' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineAttachSocketName) == 0x000F10, "Member 'ACue_Projectile_Loop_10413101::PrickleVineAttachSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HideMaterialIndex) == 0x000F20, "Member 'ACue_Projectile_Loop_10413101::HideMaterialIndex' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableLengthOffset) == 0x000F70, "Member 'ACue_Projectile_Loop_10413101::SubCableLengthOffset' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableEachSegmentLength) == 0x000F74, "Member 'ACue_Projectile_Loop_10413101::SubCableEachSegmentLength' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, RiotRelativeRotator) == 0x000F78, "Member 'ACue_Projectile_Loop_10413101::RiotRelativeRotator' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineScaleDistanceCurve) == 0x000F90, "Member 'ACue_Projectile_Loop_10413101::PrickleVineScaleDistanceCurve' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableMaterial) == 0x000F98, "Member 'ACue_Projectile_Loop_10413101::SubCableMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableLength) == 0x000FA0, "Member 'ACue_Projectile_Loop_10413101::SubCableLength' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableNumSegments) == 0x000FA4, "Member 'ACue_Projectile_Loop_10413101::SubCableNumSegments' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableSolverIterations) == 0x000FA8, "Member 'ACue_Projectile_Loop_10413101::SubCableSolverIterations' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SubCableWidth) == 0x000FAC, "Member 'ACue_Projectile_Loop_10413101::SubCableWidth' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, CharacterDragFX) == 0x000FB0, "Member 'ACue_Projectile_Loop_10413101::CharacterDragFX' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, DragTargetFXComps) == 0x000FB8, "Member 'ACue_Projectile_Loop_10413101::DragTargetFXComps' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineRandRoll) == 0x001008, "Member 'ACue_Projectile_Loop_10413101::PrickleVineRandRoll' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineGrowRange) == 0x00100C, "Member 'ACue_Projectile_Loop_10413101::PrickleVineGrowRange' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineGrowDelta) == 0x001010, "Member 'ACue_Projectile_Loop_10413101::PrickleVineGrowDelta' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, PrickleVineGrowLastDelta) == 0x001014, "Member 'ACue_Projectile_Loop_10413101::PrickleVineGrowLastDelta' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, BackVelocity) == 0x001018, "Member 'ACue_Projectile_Loop_10413101::BackVelocity' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, bHasSetDissolveTime) == 0x00101C, "Member 'ACue_Projectile_Loop_10413101::bHasSetDissolveTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, bHasEndAgentTask) == 0x00101D, "Member 'ACue_Projectile_Loop_10413101::bHasEndAgentTask' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, bIsAbilityHit) == 0x00101E, "Member 'ACue_Projectile_Loop_10413101::bIsAbilityHit' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, OwnerCharacter) == 0x001020, "Member 'ACue_Projectile_Loop_10413101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, OwnerProjectile) == 0x001028, "Member 'ACue_Projectile_Loop_10413101::OwnerProjectile' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, OwnerAbility) == 0x001030, "Member 'ACue_Projectile_Loop_10413101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, BackWardProjectile) == 0x001038, "Member 'ACue_Projectile_Loop_10413101::BackWardProjectile' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, OriginRotator) == 0x001040, "Member 'ACue_Projectile_Loop_10413101::OriginRotator' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, bStopUpdatePrickles) == 0x001058, "Member 'ACue_Projectile_Loop_10413101::bStopUpdatePrickles' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, AbilityActivateTag) == 0x00105C, "Member 'ACue_Projectile_Loop_10413101::AbilityActivateTag' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, HideAllPrickleVineTimer) == 0x001068, "Member 'ACue_Projectile_Loop_10413101::HideAllPrickleVineTimer' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10413101, SpeedlineFXDissolveTimeCounter) == 0x001080, "Member 'ACue_Projectile_Loop_10413101::SpeedlineFXDissolveTimeCounter' has a wrong offset!");

// Class Hero_1041.Cue_Ability_Loop_10413101
// 0x0068 (0x0EB8 - 0x0E50)
class ACue_Ability_Loop_10413101 final : public AMarvelCueNotify_Ability
{
public:
	class AMarvelBaseCharacter*                   OwningCharacter;                                   // 0x0E50(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbility_104131*                        OwningAbility;                                     // 0x0E58(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraInterp*                          PullBackCameraInterp;                              // 0x0E60(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FSpringArmControlHandler> SpringArmHandlers;                                 // 0x0E68(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void OnAbilityStartPullBack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10413101">();
	}
	static class ACue_Ability_Loop_10413101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10413101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10413101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10413101");
static_assert(sizeof(ACue_Ability_Loop_10413101) == 0x000EB8, "Wrong size on ACue_Ability_Loop_10413101");
static_assert(offsetof(ACue_Ability_Loop_10413101, OwningCharacter) == 0x000E50, "Member 'ACue_Ability_Loop_10413101::OwningCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10413101, OwningAbility) == 0x000E58, "Member 'ACue_Ability_Loop_10413101::OwningAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10413101, PullBackCameraInterp) == 0x000E60, "Member 'ACue_Ability_Loop_10413101::PullBackCameraInterp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10413101, SpringArmHandlers) == 0x000E68, "Member 'ACue_Ability_Loop_10413101::SpringArmHandlers' has a wrong offset!");

// Class Hero_1041.UIController_104131
// 0x0018 (0x0C78 - 0x0C60)
class UUIController_104131 : public UUIC_Ability
{
public:
	float                                         GatherWarningTime;                                 // 0x0C60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullDuration;                                      // 0x0C64(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPlayWarningAnim;                               // 0x0C68(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C69[0x7];                                      // 0x0C69(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget_AbilityDuration*                DurationWidget;                                    // 0x0C70(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayWarningAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIController_104131">();
	}
	static class UUIController_104131* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIController_104131>();
	}
};
static_assert(alignof(UUIController_104131) == 0x000008, "Wrong alignment on UUIController_104131");
static_assert(sizeof(UUIController_104131) == 0x000C78, "Wrong size on UUIController_104131");
static_assert(offsetof(UUIController_104131, GatherWarningTime) == 0x000C60, "Member 'UUIController_104131::GatherWarningTime' has a wrong offset!");
static_assert(offsetof(UUIController_104131, FullDuration) == 0x000C64, "Member 'UUIController_104131::FullDuration' has a wrong offset!");
static_assert(offsetof(UUIController_104131, bHasPlayWarningAnim) == 0x000C68, "Member 'UUIController_104131::bHasPlayWarningAnim' has a wrong offset!");
static_assert(offsetof(UUIController_104131, DurationWidget) == 0x000C70, "Member 'UUIController_104131::DurationWidget' has a wrong offset!");

// Class Hero_1041.Config_104141
// 0x1120 (0x11B8 - 0x0098)
class UConfig_104141 final : public UMarvelAbilityConfig
{
public:
	bool                                          bNewCollideDown;                                   // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelApplyPinnedMotionConfig         NewCollideDownConfig;                              // 0x00A0(0x0230)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         GrabScopeID;                                       // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GrabCollideTag;                                    // 0x02D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrabBuffID_CollideKonckDown;                       // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DashScopeID;                                       // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashDistance;                                      // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDashAbilityInfo                       DashInfo;                                          // 0x02F0(0x0BA8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DashStopIfHasAnyTags;                              // 0x0E98(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector                                DashTraceOffset;                                   // 0x0F00(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MajorTargetBuffID;                                 // 0x0F18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1C[0x4];                                      // 0x0F1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelGameplayTagRequirements         MajorTargetRequirements;                           // 0x0F20(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         MinorTargetBuffID;                                 // 0x0FF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF4[0x4];                                      // 0x0FF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelGameplayTagRequirements         MinorTargetRequirements;                           // 0x0FF8(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector                                PinnedTargetOffset;                                // 0x10C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  PinnedTargetGrantedTags;                           // 0x10E0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  PinnedSourceGrantedTags;                           // 0x1148(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EMovementMode                                 PinnedTargetMovementMode;                          // 0x11B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B1[0x7];                                     // 0x11B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104141">();
	}
	static class UConfig_104141* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104141>();
	}
};
static_assert(alignof(UConfig_104141) == 0x000008, "Wrong alignment on UConfig_104141");
static_assert(sizeof(UConfig_104141) == 0x0011B8, "Wrong size on UConfig_104141");
static_assert(offsetof(UConfig_104141, bNewCollideDown) == 0x000098, "Member 'UConfig_104141::bNewCollideDown' has a wrong offset!");
static_assert(offsetof(UConfig_104141, NewCollideDownConfig) == 0x0000A0, "Member 'UConfig_104141::NewCollideDownConfig' has a wrong offset!");
static_assert(offsetof(UConfig_104141, GrabScopeID) == 0x0002D0, "Member 'UConfig_104141::GrabScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_104141, GrabCollideTag) == 0x0002D4, "Member 'UConfig_104141::GrabCollideTag' has a wrong offset!");
static_assert(offsetof(UConfig_104141, GrabBuffID_CollideKonckDown) == 0x0002E0, "Member 'UConfig_104141::GrabBuffID_CollideKonckDown' has a wrong offset!");
static_assert(offsetof(UConfig_104141, DashScopeID) == 0x0002E4, "Member 'UConfig_104141::DashScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_104141, DashDistance) == 0x0002E8, "Member 'UConfig_104141::DashDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104141, DashInfo) == 0x0002F0, "Member 'UConfig_104141::DashInfo' has a wrong offset!");
static_assert(offsetof(UConfig_104141, DashStopIfHasAnyTags) == 0x000E98, "Member 'UConfig_104141::DashStopIfHasAnyTags' has a wrong offset!");
static_assert(offsetof(UConfig_104141, DashTraceOffset) == 0x000F00, "Member 'UConfig_104141::DashTraceOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104141, MajorTargetBuffID) == 0x000F18, "Member 'UConfig_104141::MajorTargetBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104141, MajorTargetRequirements) == 0x000F20, "Member 'UConfig_104141::MajorTargetRequirements' has a wrong offset!");
static_assert(offsetof(UConfig_104141, MinorTargetBuffID) == 0x000FF0, "Member 'UConfig_104141::MinorTargetBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104141, MinorTargetRequirements) == 0x000FF8, "Member 'UConfig_104141::MinorTargetRequirements' has a wrong offset!");
static_assert(offsetof(UConfig_104141, PinnedTargetOffset) == 0x0010C8, "Member 'UConfig_104141::PinnedTargetOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104141, PinnedTargetGrantedTags) == 0x0010E0, "Member 'UConfig_104141::PinnedTargetGrantedTags' has a wrong offset!");
static_assert(offsetof(UConfig_104141, PinnedSourceGrantedTags) == 0x001148, "Member 'UConfig_104141::PinnedSourceGrantedTags' has a wrong offset!");
static_assert(offsetof(UConfig_104141, PinnedTargetMovementMode) == 0x0011B0, "Member 'UConfig_104141::PinnedTargetMovementMode' has a wrong offset!");

// Class Hero_1041.MarvelDragAbility_10414102
// 0x0028 (0x1D10 - 0x1CE8)
class UMarvelDragAbility_10414102 : public UMarvelDragAbility
{
public:
	class UMarvelAbilityTask_Dash*                DashTask;                                          // 0x1CE8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ReplicatedTargetLocation;                          // 0x1CF0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_NetworkSyncPointWithPayload* NetSyncTask;                                       // 0x1D08(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyDash(const struct FVector& DragTargetLocation);
	void OnDashFinish(EDashStopReason Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelDragAbility_10414102">();
	}
	static class UMarvelDragAbility_10414102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelDragAbility_10414102>();
	}
};
static_assert(alignof(UMarvelDragAbility_10414102) == 0x000008, "Wrong alignment on UMarvelDragAbility_10414102");
static_assert(sizeof(UMarvelDragAbility_10414102) == 0x001D10, "Wrong size on UMarvelDragAbility_10414102");
static_assert(offsetof(UMarvelDragAbility_10414102, DashTask) == 0x001CE8, "Member 'UMarvelDragAbility_10414102::DashTask' has a wrong offset!");
static_assert(offsetof(UMarvelDragAbility_10414102, ReplicatedTargetLocation) == 0x001CF0, "Member 'UMarvelDragAbility_10414102::ReplicatedTargetLocation' has a wrong offset!");
static_assert(offsetof(UMarvelDragAbility_10414102, NetSyncTask) == 0x001D08, "Member 'UMarvelDragAbility_10414102::NetSyncTask' has a wrong offset!");

// Class Hero_1041.TraceComponent_10414101
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10414101 final : public UMarvelAgentTraceComponent
{
public:
	class UConfig_104141*                         MyConfig;                                          // 0x1708(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10414101">();
	}
	static class UTraceComponent_10414101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10414101>();
	}
};
static_assert(alignof(UTraceComponent_10414101) == 0x000010, "Wrong alignment on UTraceComponent_10414101");
static_assert(sizeof(UTraceComponent_10414101) == 0x001710, "Wrong size on UTraceComponent_10414101");
static_assert(offsetof(UTraceComponent_10414101, MyConfig) == 0x001708, "Member 'UTraceComponent_10414101::MyConfig' has a wrong offset!");

// Class Hero_1041.EffectiveComponent_10414101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10414101 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10414101">();
	}
	static class UEffectiveComponent_10414101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10414101>();
	}
};
static_assert(alignof(UEffectiveComponent_10414101) == 0x000010, "Wrong alignment on UEffectiveComponent_10414101");
static_assert(sizeof(UEffectiveComponent_10414101) == 0x001C00, "Wrong size on UEffectiveComponent_10414101");

// Class Hero_1041.EffectiveComponent_10414102
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10414102 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10414102">();
	}
	static class UEffectiveComponent_10414102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10414102>();
	}
};
static_assert(alignof(UEffectiveComponent_10414102) == 0x000010, "Wrong alignment on UEffectiveComponent_10414102");
static_assert(sizeof(UEffectiveComponent_10414102) == 0x001C00, "Wrong size on UEffectiveComponent_10414102");

// Class Hero_1041.Ability_104141
// 0x0310 (0x2890 - 0x2580)
class UAbility_104141 : public UMarvelGameplayAbility
{
public:
	float                                         HasDashDistance;                                   // 0x2580(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityState_104141                          AbilityState;                                      // 0x2584(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2585[0x3];                                     // 0x2585(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashSourceLocation;                                // 0x2588(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DashTargetLocation;                                // 0x25A0(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDashStageHit;                                  // 0x25B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B9[0x3];                                     // 0x25B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  DashMajorTarget;                                   // 0x25BC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C4[0x4];                                     // 0x25C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         DashMinorTargets;                                  // 0x25C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UMarvelAgentTraceComponent*             DashTraceComponent;                                // 0x25D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         ApplyEffectToDashTargetsKey;                       // 0x25E0(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         DashMajorTargetPredictionKey;                      // 0x2680(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         WaitServerConfirmKey;                              // 0x2720(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C0[0x8];                                     // 0x27C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_104141*                         MyConfig;                                          // 0x27C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_ApplyPinnedMotion*   ApplyPinnedMotionTask;                             // 0x27D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D8[0x50];                                    // 0x27D8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_WaitTargetDataInDuration* WaitMajorTargetTask;                               // 0x2828(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitServerConfirm*   WaitServerConfirmTask;                             // 0x2830(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMontageEnded;                                     // 0x2838(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnablePin;                                        // 0x2839(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_283A[0x6];                                     // 0x283A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TWeakObjectPtr<class AActor>>            MoveIgnoreActors;                                  // 0x2840(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void OnAbilityStart();
	void OnAfterDashing(bool bAbilityEnd);
	void OnCharacterDashDistance(float InDistance);
	void OnClientReceivePinTaskReject();
	void OnHitMajorTarget(class AActor* Causer, class AActor* HitActor, struct FHitResult& Hit, bool bIsNetAuthority);
	void OnHitMinorTarget(class AActor* Causer, class AActor* HitActor, const struct FHitResult& Hit, bool bIsNetAuthority);
	void OnPinnedActorGameTagUpdate(const struct FGameplayTag& Tag, bool TagExists);
	void OnPinnedActorHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnPinnedActorLost();
	void OnPinnedTaskFinish(EDashStopReason Reason);
	void OnServerReceiveMajorTarget(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnServerWaitMajorTargetTimeout();
	void OnStartDashing();
	void OnStartPunching();
	void SetAbilityState(EAbilityState_104141 NewAbilityState);

	bool GetDashMajorTarget(class AActor** OutTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104141">();
	}
	static class UAbility_104141* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104141>();
	}
};
static_assert(alignof(UAbility_104141) == 0x000008, "Wrong alignment on UAbility_104141");
static_assert(sizeof(UAbility_104141) == 0x002890, "Wrong size on UAbility_104141");
static_assert(offsetof(UAbility_104141, HasDashDistance) == 0x002580, "Member 'UAbility_104141::HasDashDistance' has a wrong offset!");
static_assert(offsetof(UAbility_104141, AbilityState) == 0x002584, "Member 'UAbility_104141::AbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashSourceLocation) == 0x002588, "Member 'UAbility_104141::DashSourceLocation' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashTargetLocation) == 0x0025A0, "Member 'UAbility_104141::DashTargetLocation' has a wrong offset!");
static_assert(offsetof(UAbility_104141, bHasDashStageHit) == 0x0025B8, "Member 'UAbility_104141::bHasDashStageHit' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashMajorTarget) == 0x0025BC, "Member 'UAbility_104141::DashMajorTarget' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashMinorTargets) == 0x0025C8, "Member 'UAbility_104141::DashMinorTargets' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashTraceComponent) == 0x0025D8, "Member 'UAbility_104141::DashTraceComponent' has a wrong offset!");
static_assert(offsetof(UAbility_104141, ApplyEffectToDashTargetsKey) == 0x0025E0, "Member 'UAbility_104141::ApplyEffectToDashTargetsKey' has a wrong offset!");
static_assert(offsetof(UAbility_104141, DashMajorTargetPredictionKey) == 0x002680, "Member 'UAbility_104141::DashMajorTargetPredictionKey' has a wrong offset!");
static_assert(offsetof(UAbility_104141, WaitServerConfirmKey) == 0x002720, "Member 'UAbility_104141::WaitServerConfirmKey' has a wrong offset!");
static_assert(offsetof(UAbility_104141, MyConfig) == 0x0027C8, "Member 'UAbility_104141::MyConfig' has a wrong offset!");
static_assert(offsetof(UAbility_104141, ApplyPinnedMotionTask) == 0x0027D0, "Member 'UAbility_104141::ApplyPinnedMotionTask' has a wrong offset!");
static_assert(offsetof(UAbility_104141, WaitMajorTargetTask) == 0x002828, "Member 'UAbility_104141::WaitMajorTargetTask' has a wrong offset!");
static_assert(offsetof(UAbility_104141, WaitServerConfirmTask) == 0x002830, "Member 'UAbility_104141::WaitServerConfirmTask' has a wrong offset!");
static_assert(offsetof(UAbility_104141, bMontageEnded) == 0x002838, "Member 'UAbility_104141::bMontageEnded' has a wrong offset!");
static_assert(offsetof(UAbility_104141, bEnablePin) == 0x002839, "Member 'UAbility_104141::bEnablePin' has a wrong offset!");
static_assert(offsetof(UAbility_104141, MoveIgnoreActors) == 0x002840, "Member 'UAbility_104141::MoveIgnoreActors' has a wrong offset!");

// Class Hero_1041.DashOnCharacterHitFilter_104141
// 0x0008 (0x0038 - 0x0030)
class UDashOnCharacterHitFilter_104141 final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DashOnCharacterHitFilter_104141">();
	}
	static class UDashOnCharacterHitFilter_104141* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDashOnCharacterHitFilter_104141>();
	}
};
static_assert(alignof(UDashOnCharacterHitFilter_104141) == 0x000008, "Wrong alignment on UDashOnCharacterHitFilter_104141");
static_assert(sizeof(UDashOnCharacterHitFilter_104141) == 0x000038, "Wrong size on UDashOnCharacterHitFilter_104141");

// Class Hero_1041.BuffAbility_10415101
// 0x0058 (0x1150 - 0x10F8)
class UBuffAbility_10415101 : public UMarvelEffectGameplayAbility
{
public:
	class UCurveFloat*                            SlowdownCurve;                                     // 0x10F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedBase;                                         // 0x1100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowDownTimeCNT;                                   // 0x1104(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     SpeedAttribute;                                    // 0x1108(0x0040)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTimeCurveValue;                                // 0x1148(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114C[0x4];                                     // 0x114C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetChangeSlowDownValue(float DeltaTime);
	float GetCurveValue(float DeltaTime);
	void SetCurrentBuffSlowDownValue(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffAbility_10415101">();
	}
	static class UBuffAbility_10415101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffAbility_10415101>();
	}
};
static_assert(alignof(UBuffAbility_10415101) == 0x000008, "Wrong alignment on UBuffAbility_10415101");
static_assert(sizeof(UBuffAbility_10415101) == 0x001150, "Wrong size on UBuffAbility_10415101");
static_assert(offsetof(UBuffAbility_10415101, SlowdownCurve) == 0x0010F8, "Member 'UBuffAbility_10415101::SlowdownCurve' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10415101, SpeedBase) == 0x001100, "Member 'UBuffAbility_10415101::SpeedBase' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10415101, SlowDownTimeCNT) == 0x001104, "Member 'UBuffAbility_10415101::SlowDownTimeCNT' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10415101, SpeedAttribute) == 0x001108, "Member 'UBuffAbility_10415101::SpeedAttribute' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10415101, LastTimeCurveValue) == 0x001148, "Member 'UBuffAbility_10415101::LastTimeCurveValue' has a wrong offset!");

// Class Hero_1041.TraceComponent_10415101
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10415101 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10415101">();
	}
	static class UTraceComponent_10415101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10415101>();
	}
};
static_assert(alignof(UTraceComponent_10415101) == 0x000010, "Wrong alignment on UTraceComponent_10415101");
static_assert(sizeof(UTraceComponent_10415101) == 0x001710, "Wrong size on UTraceComponent_10415101");

// Class Hero_1041.Cue_Projectile_Loop_10415101
// 0x0018 (0x0DC8 - 0x0DB0)
class ACue_Projectile_Loop_10415101 final : public AMarvelCueNotify_Projectile
{
public:
	class FName                                   SwitchParamName;                                   // 0x0DB0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DBC[0x4];                                      // 0x0DBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      TrajectoryNiagara;                                 // 0x0DC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10415101">();
	}
	static class ACue_Projectile_Loop_10415101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10415101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10415101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10415101");
static_assert(sizeof(ACue_Projectile_Loop_10415101) == 0x000DC8, "Wrong size on ACue_Projectile_Loop_10415101");
static_assert(offsetof(ACue_Projectile_Loop_10415101, SwitchParamName) == 0x000DB0, "Member 'ACue_Projectile_Loop_10415101::SwitchParamName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10415101, TrajectoryNiagara) == 0x000DC0, "Member 'ACue_Projectile_Loop_10415101::TrajectoryNiagara' has a wrong offset!");

// Class Hero_1041.MarvelGameplayEffectDamage_10416101
// 0x0000 (0x16C8 - 0x16C8)
class UMarvelGameplayEffectDamage_10416101 final : public UMarvelGameplayEffectDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelGameplayEffectDamage_10416101">();
	}
	static class UMarvelGameplayEffectDamage_10416101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelGameplayEffectDamage_10416101>();
	}
};
static_assert(alignof(UMarvelGameplayEffectDamage_10416101) == 0x000008, "Wrong alignment on UMarvelGameplayEffectDamage_10416101");
static_assert(sizeof(UMarvelGameplayEffectDamage_10416101) == 0x0016C8, "Wrong size on UMarvelGameplayEffectDamage_10416101");

// Class Hero_1041.Ability_104161_Log
// 0x0030 (0x1128 - 0x10F8)
class UAbility_104161_Log final : public UMarvelEffectGameplayAbility
{
public:
	int32                                         ReleaseCount;                                      // 0x10F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10FC[0x4];                                     // 0x10FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_WaitAbilityActivate*       ActiveTask;                                        // 0x1100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentEnergy;                                     // 0x1108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110C[0x4];                                     // 0x110C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PreviousEnergyRecord;                              // 0x1110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   SourceActor;                                       // 0x1120(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AccumulateCount(class UGameplayAbility* ActivatedAbility);
	void BattleLog();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104161_Log">();
	}
	static class UAbility_104161_Log* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104161_Log>();
	}
};
static_assert(alignof(UAbility_104161_Log) == 0x000008, "Wrong alignment on UAbility_104161_Log");
static_assert(sizeof(UAbility_104161_Log) == 0x001128, "Wrong size on UAbility_104161_Log");
static_assert(offsetof(UAbility_104161_Log, ReleaseCount) == 0x0010F8, "Member 'UAbility_104161_Log::ReleaseCount' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Log, ActiveTask) == 0x001100, "Member 'UAbility_104161_Log::ActiveTask' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Log, CurrentEnergy) == 0x001108, "Member 'UAbility_104161_Log::CurrentEnergy' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Log, PreviousEnergyRecord) == 0x001110, "Member 'UAbility_104161_Log::PreviousEnergyRecord' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Log, SourceActor) == 0x001120, "Member 'UAbility_104161_Log::SourceActor' has a wrong offset!");

// Class Hero_1041.Ability_104161_Delay_CheckKill
// 0x0028 (0x1120 - 0x10F8)
class UAbility_104161_Delay_CheckKill final : public UMarvelEffectGameplayAbility
{
public:
	class AActor*                                 TargetCheckActor;                                  // 0x10F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   SourceActor;                                       // 0x1100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104161*                         Config;                                            // 0x1108(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedCheck;                                        // 0x1110(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1111[0xF];                                     // 0x1111(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ApplySlayDamageToTarget(float Value, class AMarvelBaseCharacter* Source, class AActor* Target, bool bIgnoreDamagePercent, class UMarvelAgentTraceComponent* TraceSource);
	static void CheckTargetStatusAfterDamage(class AMarvelBaseCharacter* Source, class AActor* Target);

	void CheckIfCanKill();
	void OnSourceActorDeath(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnSummonedDeath(class AActor* InActor);
	void OnTargetActorDeath(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104161_Delay_CheckKill">();
	}
	static class UAbility_104161_Delay_CheckKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104161_Delay_CheckKill>();
	}
};
static_assert(alignof(UAbility_104161_Delay_CheckKill) == 0x000008, "Wrong alignment on UAbility_104161_Delay_CheckKill");
static_assert(sizeof(UAbility_104161_Delay_CheckKill) == 0x001120, "Wrong size on UAbility_104161_Delay_CheckKill");
static_assert(offsetof(UAbility_104161_Delay_CheckKill, TargetCheckActor) == 0x0010F8, "Member 'UAbility_104161_Delay_CheckKill::TargetCheckActor' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Delay_CheckKill, SourceActor) == 0x001100, "Member 'UAbility_104161_Delay_CheckKill::SourceActor' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Delay_CheckKill, Config) == 0x001108, "Member 'UAbility_104161_Delay_CheckKill::Config' has a wrong offset!");
static_assert(offsetof(UAbility_104161_Delay_CheckKill, bNeedCheck) == 0x001110, "Member 'UAbility_104161_Delay_CheckKill::bNeedCheck' has a wrong offset!");

// Class Hero_1041.Config_104161
// 0x1178 (0x1210 - 0x0098)
class UConfig_104161 : public UMarvelAbilityConfig
{
public:
	bool                                          bUsePhysicKnockUp;                                 // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhysicForceMove                       PhysicKnockUp;                                     // 0x00A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocityZ;                                      // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindowTime;                                        // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             GroundTraceContext;                                // 0x0100(0x0F90)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         HoverTime;                                         // 0x1090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckAngle;                                  // 0x1094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckDistance;                               // 0x1098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KRatio;                                            // 0x109C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EarlyCheckKillScopeID;                             // 0x10A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckEnemyEarlyKill;                              // 0x10A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A5[0x3];                                     // 0x10A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               SummonedCharacterTagRequirement;                   // 0x10A8(0x0118)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            RefreshAudioIDMap;                                 // 0x11C0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104161">();
	}
	static class UConfig_104161* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104161>();
	}
};
static_assert(alignof(UConfig_104161) == 0x000010, "Wrong alignment on UConfig_104161");
static_assert(sizeof(UConfig_104161) == 0x001210, "Wrong size on UConfig_104161");
static_assert(offsetof(UConfig_104161, bUsePhysicKnockUp) == 0x000098, "Member 'UConfig_104161::bUsePhysicKnockUp' has a wrong offset!");
static_assert(offsetof(UConfig_104161, PhysicKnockUp) == 0x0000A0, "Member 'UConfig_104161::PhysicKnockUp' has a wrong offset!");
static_assert(offsetof(UConfig_104161, MaxAcceleration) == 0x0000F0, "Member 'UConfig_104161::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UConfig_104161, MaxVelocityZ) == 0x0000F4, "Member 'UConfig_104161::MaxVelocityZ' has a wrong offset!");
static_assert(offsetof(UConfig_104161, WindowTime) == 0x0000F8, "Member 'UConfig_104161::WindowTime' has a wrong offset!");
static_assert(offsetof(UConfig_104161, GroundTraceContext) == 0x000100, "Member 'UConfig_104161::GroundTraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_104161, HoverTime) == 0x001090, "Member 'UConfig_104161::HoverTime' has a wrong offset!");
static_assert(offsetof(UConfig_104161, GroundCheckAngle) == 0x001094, "Member 'UConfig_104161::GroundCheckAngle' has a wrong offset!");
static_assert(offsetof(UConfig_104161, GroundCheckDistance) == 0x001098, "Member 'UConfig_104161::GroundCheckDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104161, KRatio) == 0x00109C, "Member 'UConfig_104161::KRatio' has a wrong offset!");
static_assert(offsetof(UConfig_104161, EarlyCheckKillScopeID) == 0x0010A0, "Member 'UConfig_104161::EarlyCheckKillScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_104161, bCheckEnemyEarlyKill) == 0x0010A4, "Member 'UConfig_104161::bCheckEnemyEarlyKill' has a wrong offset!");
static_assert(offsetof(UConfig_104161, SummonedCharacterTagRequirement) == 0x0010A8, "Member 'UConfig_104161::SummonedCharacterTagRequirement' has a wrong offset!");
static_assert(offsetof(UConfig_104161, RefreshAudioIDMap) == 0x0011C0, "Member 'UConfig_104161::RefreshAudioIDMap' has a wrong offset!");

// Class Hero_1041.Ability_104161
// 0x03D8 (0x2958 - 0x2580)
class UAbility_104161 : public UMarvelGameplayAbility
{
public:
	bool                                          bInPhysicKnockUp;                                  // 0x2580(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2581[0x3];                                     // 0x2581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedAcceleration;                                // 0x2584(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UPrimitiveComponent>> BehitComponents;                                   // 0x2588(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UConfig_104161*                         Config;                                            // 0x2598(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   AbilityOwner;                                      // 0x25A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelCharacterMovementComponent*      OwnerMovementComp;                                 // 0x25A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESmashDownState                               SmashState;                                        // 0x25B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterWindowState;                                 // 0x25B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmashDownBegin;                                   // 0x25B2(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterHover;                                       // 0x25B3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B4[0x4];                                     // 0x25B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashDirection;                                     // 0x25B8(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimLocation;                                       // 0x25D0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedGravity;                                     // 0x25E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedAirControl;                                  // 0x25EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandleGravity;                                // 0x25F0(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalScopeLocation;                                // 0x2608(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalScopeNormal;                                  // 0x2620(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         RPCKey;                                            // 0x2638(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         LaunchKey;                                         // 0x26D8(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         ResetKey;                                          // 0x2778(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x2818(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2820[0x18];                                    // 0x2820(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        LastTimeApplyRefreshBuffFrame;                     // 0x2838(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAOParamChanged;                                  // 0x2840(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2850[0x8];                                     // 0x2850(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashImpactPoint;                                   // 0x2858(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<TWeakObjectPtr<class AActor>>            CheckEarlyKillActorSet;                            // 0x2870(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bHasPreDeathCharacter;                             // 0x28C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C1[0x3];                                     // 0x28C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ContinuousKillCount;                               // 0x28C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ContinuousKillCount_Actual;                        // 0x28C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ContinuousRefreshCount;                            // 0x28CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ContinuousRefresh_UniqueID;                        // 0x28D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D4[0x6C];                                    // 0x28D4(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClientEnterHoverLocation;                          // 0x2940(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CheckIfHaveEarlyKillActor();
	struct FVector GetJumpInitialDirection(bool bIsUp);
	struct FVector GetSelectAimDirection(struct FMarvelAbilityTargetFilter& InFilter);
	void JumpStart();
	void K2_BeginHover();
	void K2_EnterWindowState();
	void K2_OnLaunchCharacterCallback();
	void K2_UpdateValidHitForUI(bool bValidHit);
	void LaunchUpEnded();
	void OnEarlyCheckKillCharacterPreDeath(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnRep_ContinuousKillCount();
	void OnRep_ContinuousKillCount_Actual();
	void OnRep_ContinuousRefreshCount();
	void OnServerReceiveLaunchVelocity(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnSlayCountDownTagUpdated(const struct FGameplayTag& TagUpdated, bool bTagExists);
	void ResetGravity();
	void ServerSetClientHoverLocation(const struct FVector& NewLocation);
	void SetHoverGravityScale(bool bSet);
	void TryEnterHover(float DeltaTime, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void TryEnterWindow(float DeltaTime, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void UpdateCheckEarlyKillActors(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104161">();
	}
	static class UAbility_104161* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104161>();
	}
};
static_assert(alignof(UAbility_104161) == 0x000008, "Wrong alignment on UAbility_104161");
static_assert(sizeof(UAbility_104161) == 0x002958, "Wrong size on UAbility_104161");
static_assert(offsetof(UAbility_104161, bInPhysicKnockUp) == 0x002580, "Member 'UAbility_104161::bInPhysicKnockUp' has a wrong offset!");
static_assert(offsetof(UAbility_104161, CachedAcceleration) == 0x002584, "Member 'UAbility_104161::CachedAcceleration' has a wrong offset!");
static_assert(offsetof(UAbility_104161, BehitComponents) == 0x002588, "Member 'UAbility_104161::BehitComponents' has a wrong offset!");
static_assert(offsetof(UAbility_104161, Config) == 0x002598, "Member 'UAbility_104161::Config' has a wrong offset!");
static_assert(offsetof(UAbility_104161, AbilityOwner) == 0x0025A0, "Member 'UAbility_104161::AbilityOwner' has a wrong offset!");
static_assert(offsetof(UAbility_104161, OwnerMovementComp) == 0x0025A8, "Member 'UAbility_104161::OwnerMovementComp' has a wrong offset!");
static_assert(offsetof(UAbility_104161, SmashState) == 0x0025B0, "Member 'UAbility_104161::SmashState' has a wrong offset!");
static_assert(offsetof(UAbility_104161, bEnterWindowState) == 0x0025B1, "Member 'UAbility_104161::bEnterWindowState' has a wrong offset!");
static_assert(offsetof(UAbility_104161, bSmashDownBegin) == 0x0025B2, "Member 'UAbility_104161::bSmashDownBegin' has a wrong offset!");
static_assert(offsetof(UAbility_104161, bEnterHover) == 0x0025B3, "Member 'UAbility_104161::bEnterHover' has a wrong offset!");
static_assert(offsetof(UAbility_104161, DashDirection) == 0x0025B8, "Member 'UAbility_104161::DashDirection' has a wrong offset!");
static_assert(offsetof(UAbility_104161, AimLocation) == 0x0025D0, "Member 'UAbility_104161::AimLocation' has a wrong offset!");
static_assert(offsetof(UAbility_104161, CachedGravity) == 0x0025E8, "Member 'UAbility_104161::CachedGravity' has a wrong offset!");
static_assert(offsetof(UAbility_104161, CachedAirControl) == 0x0025EC, "Member 'UAbility_104161::CachedAirControl' has a wrong offset!");
static_assert(offsetof(UAbility_104161, TimerHandleGravity) == 0x0025F0, "Member 'UAbility_104161::TimerHandleGravity' has a wrong offset!");
static_assert(offsetof(UAbility_104161, FinalScopeLocation) == 0x002608, "Member 'UAbility_104161::FinalScopeLocation' has a wrong offset!");
static_assert(offsetof(UAbility_104161, FinalScopeNormal) == 0x002620, "Member 'UAbility_104161::FinalScopeNormal' has a wrong offset!");
static_assert(offsetof(UAbility_104161, RPCKey) == 0x002638, "Member 'UAbility_104161::RPCKey' has a wrong offset!");
static_assert(offsetof(UAbility_104161, LaunchKey) == 0x0026D8, "Member 'UAbility_104161::LaunchKey' has a wrong offset!");
static_assert(offsetof(UAbility_104161, ResetKey) == 0x002778, "Member 'UAbility_104161::ResetKey' has a wrong offset!");
static_assert(offsetof(UAbility_104161, AbilitySystemComponent) == 0x002818, "Member 'UAbility_104161::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(UAbility_104161, LastTimeApplyRefreshBuffFrame) == 0x002838, "Member 'UAbility_104161::LastTimeApplyRefreshBuffFrame' has a wrong offset!");
static_assert(offsetof(UAbility_104161, OnAOParamChanged) == 0x002840, "Member 'UAbility_104161::OnAOParamChanged' has a wrong offset!");
static_assert(offsetof(UAbility_104161, DashImpactPoint) == 0x002858, "Member 'UAbility_104161::DashImpactPoint' has a wrong offset!");
static_assert(offsetof(UAbility_104161, CheckEarlyKillActorSet) == 0x002870, "Member 'UAbility_104161::CheckEarlyKillActorSet' has a wrong offset!");
static_assert(offsetof(UAbility_104161, bHasPreDeathCharacter) == 0x0028C0, "Member 'UAbility_104161::bHasPreDeathCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_104161, ContinuousKillCount) == 0x0028C4, "Member 'UAbility_104161::ContinuousKillCount' has a wrong offset!");
static_assert(offsetof(UAbility_104161, ContinuousKillCount_Actual) == 0x0028C8, "Member 'UAbility_104161::ContinuousKillCount_Actual' has a wrong offset!");
static_assert(offsetof(UAbility_104161, ContinuousRefreshCount) == 0x0028CC, "Member 'UAbility_104161::ContinuousRefreshCount' has a wrong offset!");
static_assert(offsetof(UAbility_104161, ContinuousRefresh_UniqueID) == 0x0028D0, "Member 'UAbility_104161::ContinuousRefresh_UniqueID' has a wrong offset!");
static_assert(offsetof(UAbility_104161, ClientEnterHoverLocation) == 0x002940, "Member 'UAbility_104161::ClientEnterHoverLocation' has a wrong offset!");

// Class Hero_1041.EffectiveComponent_10416101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10416101 : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10416101">();
	}
	static class UEffectiveComponent_10416101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10416101>();
	}
};
static_assert(alignof(UEffectiveComponent_10416101) == 0x000010, "Wrong alignment on UEffectiveComponent_10416101");
static_assert(sizeof(UEffectiveComponent_10416101) == 0x001C00, "Wrong size on UEffectiveComponent_10416101");

// Class Hero_1041.EffectiveComponent_10416102
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10416102 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10416102">();
	}
	static class UEffectiveComponent_10416102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10416102>();
	}
};
static_assert(alignof(UEffectiveComponent_10416102) == 0x000010, "Wrong alignment on UEffectiveComponent_10416102");
static_assert(sizeof(UEffectiveComponent_10416102) == 0x001C00, "Wrong size on UEffectiveComponent_10416102");

// Class Hero_1041.Cue_Ability_Loop_10416102
// 0x1030 (0x1E80 - 0x0E50)
class ACue_Ability_Loop_10416102 final : public AMarvelCueNotify_Ability
{
public:
	float                                         MaxDistToSmooth;                                   // 0x0E50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpMaxSpeed;                                      // 0x0E54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpMinSpeed;                                      // 0x0E58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateRate;                                        // 0x0E5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFindGroundParam                       GroundParam;                                       // 0x0E60(0x0FD0)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAbility_104161*                        OwnerAbility;                                      // 0x1E30(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104161*                         AbilityConfig;                                     // 0x1E38(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x1E40(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastFXLocation;                                    // 0x1E48(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LastFXRotation;                                    // 0x1E60(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      FieldNiagara;                                      // 0x1E78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10416102">();
	}
	static class ACue_Ability_Loop_10416102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10416102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10416102) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10416102");
static_assert(sizeof(ACue_Ability_Loop_10416102) == 0x001E80, "Wrong size on ACue_Ability_Loop_10416102");
static_assert(offsetof(ACue_Ability_Loop_10416102, MaxDistToSmooth) == 0x000E50, "Member 'ACue_Ability_Loop_10416102::MaxDistToSmooth' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, LerpMaxSpeed) == 0x000E54, "Member 'ACue_Ability_Loop_10416102::LerpMaxSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, LerpMinSpeed) == 0x000E58, "Member 'ACue_Ability_Loop_10416102::LerpMinSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, UpdateRate) == 0x000E5C, "Member 'ACue_Ability_Loop_10416102::UpdateRate' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, GroundParam) == 0x000E60, "Member 'ACue_Ability_Loop_10416102::GroundParam' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, OwnerAbility) == 0x001E30, "Member 'ACue_Ability_Loop_10416102::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, AbilityConfig) == 0x001E38, "Member 'ACue_Ability_Loop_10416102::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, OwnerChar) == 0x001E40, "Member 'ACue_Ability_Loop_10416102::OwnerChar' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, LastFXLocation) == 0x001E48, "Member 'ACue_Ability_Loop_10416102::LastFXLocation' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, LastFXRotation) == 0x001E60, "Member 'ACue_Ability_Loop_10416102::LastFXRotation' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10416102, FieldNiagara) == 0x001E78, "Member 'ACue_Ability_Loop_10416102::FieldNiagara' has a wrong offset!");

// Class Hero_1041.Cue_Scope_Start_10416101
// 0x0018 (0x0380 - 0x0368)
class UCue_Scope_Start_10416101 final : public UMarvelCueNotify_Base
{
public:
	struct FVector                                ImpactNormal;                                      // 0x0368(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Start_10416101">();
	}
	static class UCue_Scope_Start_10416101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Scope_Start_10416101>();
	}
};
static_assert(alignof(UCue_Scope_Start_10416101) == 0x000008, "Wrong alignment on UCue_Scope_Start_10416101");
static_assert(sizeof(UCue_Scope_Start_10416101) == 0x000380, "Wrong size on UCue_Scope_Start_10416101");
static_assert(offsetof(UCue_Scope_Start_10416101, ImpactNormal) == 0x000368, "Member 'UCue_Scope_Start_10416101::ImpactNormal' has a wrong offset!");

// Class Hero_1041.EpicMomentAction_1041
// 0x0010 (0x0130 - 0x0120)
class UEpicMomentAction_1041 : public UEpicMomentBaseAction
{
public:
	struct FEpicMomentNodeInfo                    QKillConfig;                                       // 0x0120(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         QAbilityID;                                        // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1041">();
	}
	static class UEpicMomentAction_1041* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1041>();
	}
};
static_assert(alignof(UEpicMomentAction_1041) == 0x000008, "Wrong alignment on UEpicMomentAction_1041");
static_assert(sizeof(UEpicMomentAction_1041) == 0x000130, "Wrong size on UEpicMomentAction_1041");
static_assert(offsetof(UEpicMomentAction_1041, QKillConfig) == 0x000120, "Member 'UEpicMomentAction_1041::QKillConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1041, QAbilityID) == 0x00012C, "Member 'UEpicMomentAction_1041::QAbilityID' has a wrong offset!");

// Class Hero_1041.WinterSoldierAnimInstance
// 0x0040 (0x0950 - 0x0910)
class UWinterSoldierAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bTestUltimate;                                     // 0x0910(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_911[0x3];                                      // 0x0911(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimReloadConstraintCurveName;                     // 0x0914(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimReloadConstraintBlendAlpha;                    // 0x0920(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReloadAbilityTag;                                  // 0x0924(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimReloadConstraintCurveValue;                    // 0x0930(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseUltimateAOParam;                         // 0x0934(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_935[0x3];                                      // 0x0935(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UltimateAOPitch;                                   // 0x0938(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UltimateAOYaw;                                     // 0x093C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AWinterSoldierCharacter*                WinterSoldierCharacter;                            // 0x0940(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_948[0x8];                                      // 0x0948(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivateAbility(int32 InAbilityId);
	void OnEndAbility(int32 InAbilityId);
	void OnUltimateAOParamChanged(float InUltimateAOPitch, float InUltimateAOYaw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinterSoldierAnimInstance">();
	}
	static class UWinterSoldierAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinterSoldierAnimInstance>();
	}
};
static_assert(alignof(UWinterSoldierAnimInstance) == 0x000010, "Wrong alignment on UWinterSoldierAnimInstance");
static_assert(sizeof(UWinterSoldierAnimInstance) == 0x000950, "Wrong size on UWinterSoldierAnimInstance");
static_assert(offsetof(UWinterSoldierAnimInstance, bTestUltimate) == 0x000910, "Member 'UWinterSoldierAnimInstance::bTestUltimate' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, AnimReloadConstraintCurveName) == 0x000914, "Member 'UWinterSoldierAnimInstance::AnimReloadConstraintCurveName' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, AnimReloadConstraintBlendAlpha) == 0x000920, "Member 'UWinterSoldierAnimInstance::AnimReloadConstraintBlendAlpha' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, ReloadAbilityTag) == 0x000924, "Member 'UWinterSoldierAnimInstance::ReloadAbilityTag' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, AnimReloadConstraintCurveValue) == 0x000930, "Member 'UWinterSoldierAnimInstance::AnimReloadConstraintCurveValue' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, bShouldUseUltimateAOParam) == 0x000934, "Member 'UWinterSoldierAnimInstance::bShouldUseUltimateAOParam' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, UltimateAOPitch) == 0x000938, "Member 'UWinterSoldierAnimInstance::UltimateAOPitch' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, UltimateAOYaw) == 0x00093C, "Member 'UWinterSoldierAnimInstance::UltimateAOYaw' has a wrong offset!");
static_assert(offsetof(UWinterSoldierAnimInstance, WinterSoldierCharacter) == 0x000940, "Member 'UWinterSoldierAnimInstance::WinterSoldierCharacter' has a wrong offset!");

// Class Hero_1041.WinterSoldierCharacter
// 0x0010 (0x1820 - 0x1810)
class AWinterSoldierCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bQuickReloading;                                   // 0x1810(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1811[0x7];                                     // 0x1811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWinterSoldierMoveLogicBaseComponent*   WinterSoldierMoveLogic;                            // 0x1818(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetQuickReloadingState(bool bInState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinterSoldierCharacter">();
	}
	static class AWinterSoldierCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWinterSoldierCharacter>();
	}
};
static_assert(alignof(AWinterSoldierCharacter) == 0x000010, "Wrong alignment on AWinterSoldierCharacter");
static_assert(sizeof(AWinterSoldierCharacter) == 0x001820, "Wrong size on AWinterSoldierCharacter");
static_assert(offsetof(AWinterSoldierCharacter, bQuickReloading) == 0x001810, "Member 'AWinterSoldierCharacter::bQuickReloading' has a wrong offset!");
static_assert(offsetof(AWinterSoldierCharacter, WinterSoldierMoveLogic) == 0x001818, "Member 'AWinterSoldierCharacter::WinterSoldierMoveLogic' has a wrong offset!");

// Class Hero_1041.WinterSoldierChildActor
// 0x0178 (0x0BD8 - 0x0A60)
class AWinterSoldierChildActor final : public AMarvelCharacterChildActor
{
public:
	TSet<int32>                                   OriginArmMaterialSet;                              // 0x0A60(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<int32>                                   UltimateArmMaterialSet;                            // 0x0AB0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<class FName>                             OriginArmMaterialSlotNameSet;                      // 0x0B00(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<class FName>                             UltimateArmMaterialSlotNameSet;                    // 0x0B50(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   OriginArmMaterialSlotNameSuffix;                   // 0x0BA0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UltimateArmMaterialSlotNameSuffix;                 // 0x0BAC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           UpdateArmMaterialTag;                              // 0x0BB8(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC4[0x14];                                     // 0x0BC4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);
	void UpdateArmMaterial(bool bUltimate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinterSoldierChildActor">();
	}
	static class AWinterSoldierChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWinterSoldierChildActor>();
	}
};
static_assert(alignof(AWinterSoldierChildActor) == 0x000008, "Wrong alignment on AWinterSoldierChildActor");
static_assert(sizeof(AWinterSoldierChildActor) == 0x000BD8, "Wrong size on AWinterSoldierChildActor");
static_assert(offsetof(AWinterSoldierChildActor, OriginArmMaterialSet) == 0x000A60, "Member 'AWinterSoldierChildActor::OriginArmMaterialSet' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, UltimateArmMaterialSet) == 0x000AB0, "Member 'AWinterSoldierChildActor::UltimateArmMaterialSet' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, OriginArmMaterialSlotNameSet) == 0x000B00, "Member 'AWinterSoldierChildActor::OriginArmMaterialSlotNameSet' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, UltimateArmMaterialSlotNameSet) == 0x000B50, "Member 'AWinterSoldierChildActor::UltimateArmMaterialSlotNameSet' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, OriginArmMaterialSlotNameSuffix) == 0x000BA0, "Member 'AWinterSoldierChildActor::OriginArmMaterialSlotNameSuffix' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, UltimateArmMaterialSlotNameSuffix) == 0x000BAC, "Member 'AWinterSoldierChildActor::UltimateArmMaterialSlotNameSuffix' has a wrong offset!");
static_assert(offsetof(AWinterSoldierChildActor, UpdateArmMaterialTag) == 0x000BB8, "Member 'AWinterSoldierChildActor::UpdateArmMaterialTag' has a wrong offset!");

// Class Hero_1041.WinterSoldierMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UWinterSoldierMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinterSoldierMoveLogicBaseComponent">();
	}
	static class UWinterSoldierMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinterSoldierMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UWinterSoldierMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UWinterSoldierMoveLogicBaseComponent");
static_assert(sizeof(UWinterSoldierMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UWinterSoldierMoveLogicBaseComponent");

// Class Hero_1041.WinterSoldierMovementComponent
// 0x0010 (0x1B70 - 0x1B60)
class UWinterSoldierMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	class UConfig_104161*                         Config_104161;                                     // 0x1B60(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastSkipSmoothCorrectionTime;                      // 0x1B68(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B6C[0x4];                                     // 0x1B6C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinterSoldierMovementComponent">();
	}
	static class UWinterSoldierMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinterSoldierMovementComponent>();
	}
};
static_assert(alignof(UWinterSoldierMovementComponent) == 0x000010, "Wrong alignment on UWinterSoldierMovementComponent");
static_assert(sizeof(UWinterSoldierMovementComponent) == 0x001B70, "Wrong size on UWinterSoldierMovementComponent");
static_assert(offsetof(UWinterSoldierMovementComponent, Config_104161) == 0x001B60, "Member 'UWinterSoldierMovementComponent::Config_104161' has a wrong offset!");
static_assert(offsetof(UWinterSoldierMovementComponent, LastSkipSmoothCorrectionTime) == 0x001B68, "Member 'UWinterSoldierMovementComponent::LastSkipSmoothCorrectionTime' has a wrong offset!");

}

