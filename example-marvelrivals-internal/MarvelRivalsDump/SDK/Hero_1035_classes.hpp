#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1035

#include "Basic.hpp"

#include "DeclarativeUnreal_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Hero_1035_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1035.Config_103521
// 0x0048 (0x00E0 - 0x0098)
class UConfig_103521 final : public UMarvelAbilityConfig
{
public:
	class FName                                   ActivateTentaclePreName;                           // 0x0098(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScopeId;                                           // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceStartSocketName;                              // 0x00A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceEndSocketName;                                // 0x00B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVenomTentacleInfo>             TentacleInfos;                                     // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceDelayTime;                                    // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceDebugDraw;                                   // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFramingUpdateTentacles;                           // 0x00DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103521">();
	}
	static class UConfig_103521* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103521>();
	}
};
static_assert(alignof(UConfig_103521) == 0x000008, "Wrong alignment on UConfig_103521");
static_assert(sizeof(UConfig_103521) == 0x0000E0, "Wrong size on UConfig_103521");
static_assert(offsetof(UConfig_103521, ActivateTentaclePreName) == 0x000098, "Member 'UConfig_103521::ActivateTentaclePreName' has a wrong offset!");
static_assert(offsetof(UConfig_103521, ScopeId) == 0x0000A4, "Member 'UConfig_103521::ScopeId' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceStartSocketName) == 0x0000A8, "Member 'UConfig_103521::TraceStartSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceEndSocketName) == 0x0000B4, "Member 'UConfig_103521::TraceEndSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceDistance) == 0x0000C0, "Member 'UConfig_103521::TraceDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TentacleInfos) == 0x0000C8, "Member 'UConfig_103521::TentacleInfos' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceDelayTime) == 0x0000D8, "Member 'UConfig_103521::TraceDelayTime' has a wrong offset!");
static_assert(offsetof(UConfig_103521, bTraceDebugDraw) == 0x0000DC, "Member 'UConfig_103521::bTraceDebugDraw' has a wrong offset!");
static_assert(offsetof(UConfig_103521, bFramingUpdateTentacles) == 0x0000DD, "Member 'UConfig_103521::bFramingUpdateTentacles' has a wrong offset!");

// Class Hero_1035.Ability_103521
// 0x0020 (0x25A8 - 0x2588)
class UAbility_103521 : public UAbility_108
{
public:
	class UConfig_103521*                         AbilityConfig;                                     // 0x2588(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_WaitBindInput*       InputLeftTask;                                     // 0x2590(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CurrentIndex;                                      // 0x2598(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	void OnPressLeft(float TimeWaited);
	void OnReleaseLeft(float TimeWaited);
	void OnSpawnSuccess(class AActor* SpawnActor, const struct FGameplayAbilityTargetDataHandle& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103521">();
	}
	static class UAbility_103521* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103521>();
	}
};
static_assert(alignof(UAbility_103521) == 0x000008, "Wrong alignment on UAbility_103521");
static_assert(sizeof(UAbility_103521) == 0x0025A8, "Wrong size on UAbility_103521");
static_assert(offsetof(UAbility_103521, AbilityConfig) == 0x002588, "Member 'UAbility_103521::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103521, InputLeftTask) == 0x002590, "Member 'UAbility_103521::InputLeftTask' has a wrong offset!");
static_assert(offsetof(UAbility_103521, CurrentIndex) == 0x002598, "Member 'UAbility_103521::CurrentIndex' has a wrong offset!");

// Class Hero_1035.TentacleAnimInstance
// 0x0050 (0x0480 - 0x0430)
class UTentacleAnimInstance final : public UAnimInstance
{
public:
	TArray<class UAnimSequence*>                  LoopSequences;                                     // 0x0428(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0438(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneScale;                                         // 0x0450(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0454(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseMT;                                          // 0x0460(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LoopSequence;                                      // 0x0468(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckPause;                                       // 0x0470(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_471[0xF];                                      // 0x0471(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TentacleAnimInstance">();
	}
	static class UTentacleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTentacleAnimInstance>();
	}
};
static_assert(alignof(UTentacleAnimInstance) == 0x000010, "Wrong alignment on UTentacleAnimInstance");
static_assert(sizeof(UTentacleAnimInstance) == 0x000480, "Wrong size on UTentacleAnimInstance");
static_assert(offsetof(UTentacleAnimInstance, LoopSequences) == 0x000428, "Member 'UTentacleAnimInstance::LoopSequences' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, TargetLocation) == 0x000438, "Member 'UTentacleAnimInstance::TargetLocation' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, BoneScale) == 0x000450, "Member 'UTentacleAnimInstance::BoneScale' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, BoneName) == 0x000454, "Member 'UTentacleAnimInstance::BoneName' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, bPauseMT) == 0x000460, "Member 'UTentacleAnimInstance::bPauseMT' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, LoopSequence) == 0x000468, "Member 'UTentacleAnimInstance::LoopSequence' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, bCheckPause) == 0x000470, "Member 'UTentacleAnimInstance::bCheckPause' has a wrong offset!");

// Class Hero_1035.Scope_10352101
// 0x01C0 (0x18C0 - 0x1700)
class AScope_10352101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	int32                                         ScopeIndex;                                        // 0x1700(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1704[0x4];                                     // 0x1704(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ClientTraceResult;                                 // 0x1708(0x0170)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     TracedResults;                                     // 0x1878(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UConfig_103521*                         AbilityConfig;                                     // 0x1888(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1890[0x30];                                    // 0x1890(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeactivateTentacle(int32 TentacleID);
	void ServerSetTraceResult(const struct FHitResult& InTraceResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10352101">();
	}
	static class AScope_10352101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10352101>();
	}
};
static_assert(alignof(AScope_10352101) == 0x000010, "Wrong alignment on AScope_10352101");
static_assert(sizeof(AScope_10352101) == 0x0018C0, "Wrong size on AScope_10352101");
static_assert(offsetof(AScope_10352101, ScopeIndex) == 0x001700, "Member 'AScope_10352101::ScopeIndex' has a wrong offset!");
static_assert(offsetof(AScope_10352101, ClientTraceResult) == 0x001708, "Member 'AScope_10352101::ClientTraceResult' has a wrong offset!");
static_assert(offsetof(AScope_10352101, TracedResults) == 0x001878, "Member 'AScope_10352101::TracedResults' has a wrong offset!");
static_assert(offsetof(AScope_10352101, AbilityConfig) == 0x001888, "Member 'AScope_10352101::AbilityConfig' has a wrong offset!");

// Class Hero_1035.MarvelGameplay_SphereTraceType_10352101
// 0x0000 (0x0030 - 0x0030)
class UMarvelGameplay_SphereTraceType_10352101 final : public UMarvelGameplay_SphereTraceType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelGameplay_SphereTraceType_10352101">();
	}
	static class UMarvelGameplay_SphereTraceType_10352101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelGameplay_SphereTraceType_10352101>();
	}
};
static_assert(alignof(UMarvelGameplay_SphereTraceType_10352101) == 0x000008, "Wrong alignment on UMarvelGameplay_SphereTraceType_10352101");
static_assert(sizeof(UMarvelGameplay_SphereTraceType_10352101) == 0x000030, "Wrong size on UMarvelGameplay_SphereTraceType_10352101");

// Class Hero_1035.TraceComponent_10352101
// 0x0020 (0x1730 - 0x1710)
class UTraceComponent_10352101 final : public UMarvelAgentTraceComponent
{
public:
	uint8                                         Pad_1708[0x28];                                    // 0x1708(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10352101">();
	}
	static class UTraceComponent_10352101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10352101>();
	}
};
static_assert(alignof(UTraceComponent_10352101) == 0x000010, "Wrong alignment on UTraceComponent_10352101");
static_assert(sizeof(UTraceComponent_10352101) == 0x001730, "Wrong size on UTraceComponent_10352101");

// Class Hero_1035.Config_103531
// 0x1C18 (0x1CB0 - 0x0098)
class UConfig_103531 final : public UMarvelAbilityConfig
{
public:
	bool                                          bLandedGroundIsWalkable;                           // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumDegreesBetweenDown;                         // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimalDistanceToGround;                           // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToRestrictGroundNormal;                    // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidAngle;                                        // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FXScopeID;                                         // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BlockTags;                                         // 0x00B8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceAimContext;                                   // 0x0120(0x0F90)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDashAbilityInfo                       DashInfo;                                          // 0x10B0(0x0BA8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DashCueTag;                                        // 0x1C58(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CameraCueTag;                                      // 0x1C64(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           IndicateCueTag;                                    // 0x1C70(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AddCueTag;                                         // 0x1C7C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RemoveCueTag;                                      // 0x1C88(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StartCameraInterpTag;                              // 0x1C94(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EndCameraInterpTag;                                // 0x1CA0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CAC[0x4];                                     // 0x1CAC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103531">();
	}
	static class UConfig_103531* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103531>();
	}
};
static_assert(alignof(UConfig_103531) == 0x000010, "Wrong alignment on UConfig_103531");
static_assert(sizeof(UConfig_103531) == 0x001CB0, "Wrong size on UConfig_103531");
static_assert(offsetof(UConfig_103531, bLandedGroundIsWalkable) == 0x000098, "Member 'UConfig_103531::bLandedGroundIsWalkable' has a wrong offset!");
static_assert(offsetof(UConfig_103531, MaximumDegreesBetweenDown) == 0x00009C, "Member 'UConfig_103531::MaximumDegreesBetweenDown' has a wrong offset!");
static_assert(offsetof(UConfig_103531, MinimalDistanceToGround) == 0x0000A0, "Member 'UConfig_103531::MinimalDistanceToGround' has a wrong offset!");
static_assert(offsetof(UConfig_103531, DistanceToRestrictGroundNormal) == 0x0000A4, "Member 'UConfig_103531::DistanceToRestrictGroundNormal' has a wrong offset!");
static_assert(offsetof(UConfig_103531, ValidAngle) == 0x0000A8, "Member 'UConfig_103531::ValidAngle' has a wrong offset!");
static_assert(offsetof(UConfig_103531, BuffID) == 0x0000AC, "Member 'UConfig_103531::BuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103531, FXScopeID) == 0x0000B0, "Member 'UConfig_103531::FXScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103531, BlockTags) == 0x0000B8, "Member 'UConfig_103531::BlockTags' has a wrong offset!");
static_assert(offsetof(UConfig_103531, TraceAimContext) == 0x000120, "Member 'UConfig_103531::TraceAimContext' has a wrong offset!");
static_assert(offsetof(UConfig_103531, DashInfo) == 0x0010B0, "Member 'UConfig_103531::DashInfo' has a wrong offset!");
static_assert(offsetof(UConfig_103531, DashCueTag) == 0x001C58, "Member 'UConfig_103531::DashCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, CameraCueTag) == 0x001C64, "Member 'UConfig_103531::CameraCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, IndicateCueTag) == 0x001C70, "Member 'UConfig_103531::IndicateCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, AddCueTag) == 0x001C7C, "Member 'UConfig_103531::AddCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, RemoveCueTag) == 0x001C88, "Member 'UConfig_103531::RemoveCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, StartCameraInterpTag) == 0x001C94, "Member 'UConfig_103531::StartCameraInterpTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, EndCameraInterpTag) == 0x001CA0, "Member 'UConfig_103531::EndCameraInterpTag' has a wrong offset!");

// Class Hero_1035.Ability_103531
// 0x0488 (0x2A08 - 0x2580)
class UAbility_103531 : public UMarvelGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             CanActivateDelegate;                               // 0x2580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bIsDashing;                                        // 0x2590(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2591[0x7];                                     // 0x2591(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DashAimLocation;                                   // 0x2598(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DashAimRotation;                                   // 0x25B0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDashStateChanged;                                // 0x25C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UConfig_103531*                         Config;                                            // 0x25D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   MBCOwner;                                          // 0x25E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_Dash*                DashTask;                                          // 0x25E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* PlayMontageTask;                                   // 0x25F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         AddEffectPredictionKey;                            // 0x25F8(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         RemoveEffectPredictionKey;                         // 0x2698(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         CameraInterpPredictionKey;                         // 0x2738(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         RemoveCameraInterpPredictionKey;                   // 0x27D8(0x00A0)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2878[0x190];                                   // 0x2878(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Explode(const struct FHitResult& Hit);
	void OnDashFinish(EDashStopReason Reason);
	void OnRep_IsDashing();
	void PlayMontage(int32 MontageIndex);
	bool TraceGround();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103531">();
	}
	static class UAbility_103531* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103531>();
	}
};
static_assert(alignof(UAbility_103531) == 0x000008, "Wrong alignment on UAbility_103531");
static_assert(sizeof(UAbility_103531) == 0x002A08, "Wrong size on UAbility_103531");
static_assert(offsetof(UAbility_103531, CanActivateDelegate) == 0x002580, "Member 'UAbility_103531::CanActivateDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_103531, bIsDashing) == 0x002590, "Member 'UAbility_103531::bIsDashing' has a wrong offset!");
static_assert(offsetof(UAbility_103531, DashAimLocation) == 0x002598, "Member 'UAbility_103531::DashAimLocation' has a wrong offset!");
static_assert(offsetof(UAbility_103531, DashAimRotation) == 0x0025B0, "Member 'UAbility_103531::DashAimRotation' has a wrong offset!");
static_assert(offsetof(UAbility_103531, OnDashStateChanged) == 0x0025C8, "Member 'UAbility_103531::OnDashStateChanged' has a wrong offset!");
static_assert(offsetof(UAbility_103531, Config) == 0x0025D8, "Member 'UAbility_103531::Config' has a wrong offset!");
static_assert(offsetof(UAbility_103531, MBCOwner) == 0x0025E0, "Member 'UAbility_103531::MBCOwner' has a wrong offset!");
static_assert(offsetof(UAbility_103531, DashTask) == 0x0025E8, "Member 'UAbility_103531::DashTask' has a wrong offset!");
static_assert(offsetof(UAbility_103531, PlayMontageTask) == 0x0025F0, "Member 'UAbility_103531::PlayMontageTask' has a wrong offset!");
static_assert(offsetof(UAbility_103531, AddEffectPredictionKey) == 0x0025F8, "Member 'UAbility_103531::AddEffectPredictionKey' has a wrong offset!");
static_assert(offsetof(UAbility_103531, RemoveEffectPredictionKey) == 0x002698, "Member 'UAbility_103531::RemoveEffectPredictionKey' has a wrong offset!");
static_assert(offsetof(UAbility_103531, CameraInterpPredictionKey) == 0x002738, "Member 'UAbility_103531::CameraInterpPredictionKey' has a wrong offset!");
static_assert(offsetof(UAbility_103531, RemoveCameraInterpPredictionKey) == 0x0027D8, "Member 'UAbility_103531::RemoveCameraInterpPredictionKey' has a wrong offset!");

// Class Hero_1035.Cue_Ability_Loop_10353102
// 0x0030 (0x0E80 - 0x0E50)
class ACue_Ability_Loop_10353102 final : public AMarvelCueNotify_Ability
{
public:
	class UNiagaraComponent*                      NS_Loop;                                           // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityID;                                         // 0x0E58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5C[0x4];                                      // 0x0E5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x0E60(0x0010)(Transient, NativeAccessSpecifierPublic)
	class UAbility_103531*                        Ability;                                           // 0x0E70(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E78[0x8];                                      // 0x0E78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityCanActivateChanged(bool bCanActivate);
	void OnDashStateChanged(bool bIsDashing);
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10353102">();
	}
	static class ACue_Ability_Loop_10353102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10353102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10353102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10353102");
static_assert(sizeof(ACue_Ability_Loop_10353102) == 0x000E80, "Wrong size on ACue_Ability_Loop_10353102");
static_assert(offsetof(ACue_Ability_Loop_10353102, NS_Loop) == 0x000E50, "Member 'ACue_Ability_Loop_10353102::NS_Loop' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10353102, AbilityID) == 0x000E58, "Member 'ACue_Ability_Loop_10353102::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10353102, DeclarePlayerViewSideHolder) == 0x000E60, "Member 'ACue_Ability_Loop_10353102::DeclarePlayerViewSideHolder' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10353102, Ability) == 0x000E70, "Member 'ACue_Ability_Loop_10353102::Ability' has a wrong offset!");

// Class Hero_1035.Config_103541
// 0x1008 (0x10A0 - 0x0098)
class UConfig_103541 final : public UMarvelAbilityConfig
{
public:
	int32                                         ScopeId;                                           // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00A0(0x0F90)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         LinkTime;                                          // 0x1030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x1034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CancelEffectTags;                                  // 0x1038(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103541">();
	}
	static class UConfig_103541* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103541>();
	}
};
static_assert(alignof(UConfig_103541) == 0x000010, "Wrong alignment on UConfig_103541");
static_assert(sizeof(UConfig_103541) == 0x0010A0, "Wrong size on UConfig_103541");
static_assert(offsetof(UConfig_103541, ScopeId) == 0x000098, "Member 'UConfig_103541::ScopeId' has a wrong offset!");
static_assert(offsetof(UConfig_103541, TraceContext) == 0x0000A0, "Member 'UConfig_103541::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103541, LinkTime) == 0x001030, "Member 'UConfig_103541::LinkTime' has a wrong offset!");
static_assert(offsetof(UConfig_103541, Distance) == 0x001034, "Member 'UConfig_103541::Distance' has a wrong offset!");
static_assert(offsetof(UConfig_103541, CancelEffectTags) == 0x001038, "Member 'UConfig_103541::CancelEffectTags' has a wrong offset!");

// Class Hero_1035.Ability_103541
// 0x0040 (0x25C0 - 0x2580)
class UAbility_103541 : public UMarvelGameplayAbility
{
public:
	TArray<struct FHitResult>                     HitResults;                                        // 0x2580(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          TLHasFinished;                                     // 0x2590(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2591[0x3];                                     // 0x2591(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x2594(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2598[0x8];                                     // 0x2598(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           Timer;                                             // 0x25A0(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25B8[0x8];                                     // 0x25B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecordLog();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103541">();
	}
	static class UAbility_103541* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103541>();
	}
};
static_assert(alignof(UAbility_103541) == 0x000008, "Wrong alignment on UAbility_103541");
static_assert(sizeof(UAbility_103541) == 0x0025C0, "Wrong size on UAbility_103541");
static_assert(offsetof(UAbility_103541, HitResults) == 0x002580, "Member 'UAbility_103541::HitResults' has a wrong offset!");
static_assert(offsetof(UAbility_103541, TLHasFinished) == 0x002590, "Member 'UAbility_103541::TLHasFinished' has a wrong offset!");
static_assert(offsetof(UAbility_103541, Duration) == 0x002594, "Member 'UAbility_103541::Duration' has a wrong offset!");
static_assert(offsetof(UAbility_103541, Timer) == 0x0025A0, "Member 'UAbility_103541::Timer' has a wrong offset!");

// Class Hero_1035.EffectiveComponent_10354101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10354101 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10354101">();
	}
	static class UEffectiveComponent_10354101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10354101>();
	}
};
static_assert(alignof(UEffectiveComponent_10354101) == 0x000010, "Wrong alignment on UEffectiveComponent_10354101");
static_assert(sizeof(UEffectiveComponent_10354101) == 0x001C00, "Wrong size on UEffectiveComponent_10354101");

// Class Hero_1035.Cue_Buff_10354101
// 0x0578 (0x15B0 - 0x1038)
class ACue_Buff_10354101 final : public AMarvelCueNotify_Buff
{
public:
	class FName                                   SetLengthName;                                     // 0x1038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaxDistanceName;                                   // 0x1044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x1050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceScale;                                     // 0x1054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceLerpSpeed;                                 // 0x1058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SplitCenterScaleParam;                             // 0x105C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SplitCenterScaleCurve;                             // 0x1068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBoundsScale;                                   // 0x1070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurDistanceBias;                                   // 0x1074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrowAnimName;                                      // 0x1078(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrowNoiseIntensityName;                            // 0x1084(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowAnimMax;                                       // 0x1090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1094[0x4];                                     // 0x1094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            GrowAnimValueCurve;                                // 0x1098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GrowNoiseIntensityCurve;                           // 0x10A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherGrowCurves;                                   // 0x10A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         GrowMinR;                                          // 0x10F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowAnimTime;                                      // 0x10FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MinRName;                                          // 0x1100(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110C[0x4];                                     // 0x110C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RecoveryMinRCurve;                                 // 0x1110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherOutOfRangeCurves;                             // 0x1118(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherExpiredCurves;                                // 0x1168(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherBlockedCurves;                                // 0x11B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ForceRecycleTags;                                  // 0x1208(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         RecoverySpeed;                                     // 0x1270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryAnimValue;                                 // 0x1274(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryAnimTime;                                  // 0x1278(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HasObstacleName;                                   // 0x127C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObstacleSplitName;                                 // 0x1288(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObstacleSplitRateName;                             // 0x1294(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitSpeed;                                        // 0x12A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A4[0x4];                                     // 0x12A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         SplitFXAsset;                                      // 0x12A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         TransientFXAsset;                                  // 0x12B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         TargetTransientFXAsset;                            // 0x12B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpValue;                                         // 0x12C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x12C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfRangeLerpSpeed;                               // 0x12C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDelayTime;                                   // 0x12CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpiredDelayTime;                                  // 0x12D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfRangeDelayTime;                               // 0x12D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockedDelayTime;                                  // 0x12D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTransientFXDistance;                            // 0x12DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SymbioteStateOffset;                               // 0x12E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkeletalMeshName;                                  // 0x12F8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsStartName;                                   // 0x1304(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsEndName;                                     // 0x1310(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetTransientSizeName;                           // 0x131C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         RestrictFX;                                        // 0x1328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RestrictGrowName;                                  // 0x1330(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_133C[0x4];                                     // 0x133C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RestrictGrowCurve;                                 // 0x1340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RestrictScaleName;                                 // 0x1348(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1354[0x4];                                     // 0x1354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RestrictScaleCurve;                                // 0x1358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ExpiredRestrictScaleCurve;                         // 0x1360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestrictFXDelayTime;                               // 0x1368(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_136C[0x4];                                     // 0x136C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         ExpiredHitFX;                                      // 0x1370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBodySizeScale;                                  // 0x1378(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TentacleLoopAudioID;                               // 0x137C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuccessAudioID;                                    // 0x1380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailAudioID;                                       // 0x1384(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RTPCName;                                          // 0x1388(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1394[0x4];                                     // 0x1394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOneShotAudioActor*                     TentacleAudioActor;                                // 0x1398(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TransientFXComponent;                              // 0x13A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TargetTransientFXComponent;                        // 0x13A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      RestrictFXComponent;                               // 0x13B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransientFXCurrentLerpValue;                       // 0x13B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTransientFXCurrentLerpValue;                 // 0x13BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransientDelayRecycleTime;                         // 0x13C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTransientDelayRecycleTime;                   // 0x13C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x13C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestrictRecoveryTime;                              // 0x13CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SplitLocation;                                     // 0x13D0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CacheOwnerLocation;                                // 0x13E8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitPercent;                                      // 0x1400(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1404[0x4];                                     // 0x1404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ObstacleInfo;                                      // 0x1408(0x0170)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1578[0x4];                                     // 0x1578(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x157C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x1580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103541*                         AbilityConfig;                                     // 0x1588(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             OwnerCharacter;                                    // 0x1590(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVenomCharacter*                        InstigatorCharacter;                               // 0x1598(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 TickIntervalsOfEachLOD;                            // 0x15A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void OnInstigatorCharacterEndPlay();
	void OnSymbioteStateChanged(bool InSymbioteState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10354101">();
	}
	static class ACue_Buff_10354101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10354101>();
	}
};
static_assert(alignof(ACue_Buff_10354101) == 0x000008, "Wrong alignment on ACue_Buff_10354101");
static_assert(sizeof(ACue_Buff_10354101) == 0x0015B0, "Wrong size on ACue_Buff_10354101");
static_assert(offsetof(ACue_Buff_10354101, SetLengthName) == 0x001038, "Member 'ACue_Buff_10354101::SetLengthName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MaxDistanceName) == 0x001044, "Member 'ACue_Buff_10354101::MaxDistanceName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MaxDistance) == 0x001050, "Member 'ACue_Buff_10354101::MaxDistance' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, DistanceScale) == 0x001054, "Member 'ACue_Buff_10354101::DistanceScale' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, DistanceLerpSpeed) == 0x001058, "Member 'ACue_Buff_10354101::DistanceLerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitCenterScaleParam) == 0x00105C, "Member 'ACue_Buff_10354101::SplitCenterScaleParam' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitCenterScaleCurve) == 0x001068, "Member 'ACue_Buff_10354101::SplitCenterScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MeshBoundsScale) == 0x001070, "Member 'ACue_Buff_10354101::MeshBoundsScale' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, CurDistanceBias) == 0x001074, "Member 'ACue_Buff_10354101::CurDistanceBias' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimName) == 0x001078, "Member 'ACue_Buff_10354101::GrowAnimName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowNoiseIntensityName) == 0x001084, "Member 'ACue_Buff_10354101::GrowNoiseIntensityName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimMax) == 0x001090, "Member 'ACue_Buff_10354101::GrowAnimMax' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimValueCurve) == 0x001098, "Member 'ACue_Buff_10354101::GrowAnimValueCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowNoiseIntensityCurve) == 0x0010A0, "Member 'ACue_Buff_10354101::GrowNoiseIntensityCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherGrowCurves) == 0x0010A8, "Member 'ACue_Buff_10354101::OtherGrowCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowMinR) == 0x0010F8, "Member 'ACue_Buff_10354101::GrowMinR' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimTime) == 0x0010FC, "Member 'ACue_Buff_10354101::GrowAnimTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MinRName) == 0x001100, "Member 'ACue_Buff_10354101::MinRName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoveryMinRCurve) == 0x001110, "Member 'ACue_Buff_10354101::RecoveryMinRCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherOutOfRangeCurves) == 0x001118, "Member 'ACue_Buff_10354101::OtherOutOfRangeCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherExpiredCurves) == 0x001168, "Member 'ACue_Buff_10354101::OtherExpiredCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherBlockedCurves) == 0x0011B8, "Member 'ACue_Buff_10354101::OtherBlockedCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ForceRecycleTags) == 0x001208, "Member 'ACue_Buff_10354101::ForceRecycleTags' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoverySpeed) == 0x001270, "Member 'ACue_Buff_10354101::RecoverySpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoveryAnimValue) == 0x001274, "Member 'ACue_Buff_10354101::RecoveryAnimValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoveryAnimTime) == 0x001278, "Member 'ACue_Buff_10354101::RecoveryAnimTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, HasObstacleName) == 0x00127C, "Member 'ACue_Buff_10354101::HasObstacleName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ObstacleSplitName) == 0x001288, "Member 'ACue_Buff_10354101::ObstacleSplitName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ObstacleSplitRateName) == 0x001294, "Member 'ACue_Buff_10354101::ObstacleSplitRateName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitSpeed) == 0x0012A0, "Member 'ACue_Buff_10354101::SplitSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitFXAsset) == 0x0012A8, "Member 'ACue_Buff_10354101::SplitFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientFXAsset) == 0x0012B0, "Member 'ACue_Buff_10354101::TransientFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientFXAsset) == 0x0012B8, "Member 'ACue_Buff_10354101::TargetTransientFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, LerpValue) == 0x0012C0, "Member 'ACue_Buff_10354101::LerpValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, LerpSpeed) == 0x0012C4, "Member 'ACue_Buff_10354101::LerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OutOfRangeLerpSpeed) == 0x0012C8, "Member 'ACue_Buff_10354101::OutOfRangeLerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetDelayTime) == 0x0012CC, "Member 'ACue_Buff_10354101::TargetDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ExpiredDelayTime) == 0x0012D0, "Member 'ACue_Buff_10354101::ExpiredDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OutOfRangeDelayTime) == 0x0012D4, "Member 'ACue_Buff_10354101::OutOfRangeDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, BlockedDelayTime) == 0x0012D8, "Member 'ACue_Buff_10354101::BlockedDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MaxTransientFXDistance) == 0x0012DC, "Member 'ACue_Buff_10354101::MaxTransientFXDistance' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SymbioteStateOffset) == 0x0012E0, "Member 'ACue_Buff_10354101::SymbioteStateOffset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SkeletalMeshName) == 0x0012F8, "Member 'ACue_Buff_10354101::SkeletalMeshName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, PointsStartName) == 0x001304, "Member 'ACue_Buff_10354101::PointsStartName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, PointsEndName) == 0x001310, "Member 'ACue_Buff_10354101::PointsEndName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientSizeName) == 0x00131C, "Member 'ACue_Buff_10354101::TargetTransientSizeName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictFX) == 0x001328, "Member 'ACue_Buff_10354101::RestrictFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictGrowName) == 0x001330, "Member 'ACue_Buff_10354101::RestrictGrowName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictGrowCurve) == 0x001340, "Member 'ACue_Buff_10354101::RestrictGrowCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictScaleName) == 0x001348, "Member 'ACue_Buff_10354101::RestrictScaleName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictScaleCurve) == 0x001358, "Member 'ACue_Buff_10354101::RestrictScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ExpiredRestrictScaleCurve) == 0x001360, "Member 'ACue_Buff_10354101::ExpiredRestrictScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictFXDelayTime) == 0x001368, "Member 'ACue_Buff_10354101::RestrictFXDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ExpiredHitFX) == 0x001370, "Member 'ACue_Buff_10354101::ExpiredHitFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MinBodySizeScale) == 0x001378, "Member 'ACue_Buff_10354101::MinBodySizeScale' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TentacleLoopAudioID) == 0x00137C, "Member 'ACue_Buff_10354101::TentacleLoopAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SuccessAudioID) == 0x001380, "Member 'ACue_Buff_10354101::SuccessAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, FailAudioID) == 0x001384, "Member 'ACue_Buff_10354101::FailAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RTPCName) == 0x001388, "Member 'ACue_Buff_10354101::RTPCName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TentacleAudioActor) == 0x001398, "Member 'ACue_Buff_10354101::TentacleAudioActor' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientFXComponent) == 0x0013A0, "Member 'ACue_Buff_10354101::TransientFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientFXComponent) == 0x0013A8, "Member 'ACue_Buff_10354101::TargetTransientFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictFXComponent) == 0x0013B0, "Member 'ACue_Buff_10354101::RestrictFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientFXCurrentLerpValue) == 0x0013B8, "Member 'ACue_Buff_10354101::TransientFXCurrentLerpValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientFXCurrentLerpValue) == 0x0013BC, "Member 'ACue_Buff_10354101::TargetTransientFXCurrentLerpValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientDelayRecycleTime) == 0x0013C0, "Member 'ACue_Buff_10354101::TransientDelayRecycleTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientDelayRecycleTime) == 0x0013C4, "Member 'ACue_Buff_10354101::TargetTransientDelayRecycleTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, CurrentTime) == 0x0013C8, "Member 'ACue_Buff_10354101::CurrentTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictRecoveryTime) == 0x0013CC, "Member 'ACue_Buff_10354101::RestrictRecoveryTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitLocation) == 0x0013D0, "Member 'ACue_Buff_10354101::SplitLocation' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, CacheOwnerLocation) == 0x0013E8, "Member 'ACue_Buff_10354101::CacheOwnerLocation' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitPercent) == 0x001400, "Member 'ACue_Buff_10354101::SplitPercent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ObstacleInfo) == 0x001408, "Member 'ACue_Buff_10354101::ObstacleInfo' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, AbilityID) == 0x00157C, "Member 'ACue_Buff_10354101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MeshComponent) == 0x001580, "Member 'ACue_Buff_10354101::MeshComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, AbilityConfig) == 0x001588, "Member 'ACue_Buff_10354101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OwnerCharacter) == 0x001590, "Member 'ACue_Buff_10354101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, InstigatorCharacter) == 0x001598, "Member 'ACue_Buff_10354101::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TickIntervalsOfEachLOD) == 0x0015A0, "Member 'ACue_Buff_10354101::TickIntervalsOfEachLOD' has a wrong offset!");

// Class Hero_1035.Cue_AbilityLoop_103551
// 0x0258 (0x10A8 - 0x0E50)
class ACue_AbilityLoop_103551 : public AMarvelCueNotify_Ability
{
public:
	TArray<struct FArmEffectParam>                ArmEffectParams;                                   // 0x0E50(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SetLengthName;                                     // 0x0E60(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaxDistanceName;                                   // 0x0E6C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         GrowCurveMap;                                      // 0x0E78(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      CurveValueMap_WhenHit;                             // 0x0EC8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   MinRName;                                          // 0x0F18(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowMinR;                                          // 0x0F24(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         RecycleCurveMap;                                   // 0x0F28(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   HasObstacleName;                                   // 0x0F78(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F84[0x4];                                      // 0x0F84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         TransientFXAsset;                                  // 0x0F88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpValue;                                         // 0x0F90(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x0F94(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTransientFXDistance;                            // 0x0F98(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsStartName;                                   // 0x0F9C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsEndName;                                     // 0x0FA8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB4[0x4];                                      // 0x0FB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         HitFxAsset;                                        // 0x0FB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFxScaleValue;                                   // 0x0FC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFxMaxLength;                                    // 0x0FC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFxRecycleDuration;                              // 0x0FC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FCC[0x4];                                      // 0x0FCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   TentacleMeshComponent;                             // 0x0FD0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0FD8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETentacleState103551                          TentacleState;                                     // 0x0FE0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FE1[0x3];                                      // 0x0FE1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartShootTime;                                    // 0x0FE4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartHandReleaseTime;                              // 0x0FE8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FEC[0x24];                                     // 0x0FEC(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiagaraComponent*>              ArmFXComponentArray;                               // 0x1010(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      TransientFXComponent;                              // 0x1020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      HitEffectComponent;                                // 0x1028(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HitEffectCurrentEndPos;                            // 0x1030(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitEffectRecycleSpeed;                             // 0x1048(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104C[0x4];                                     // 0x104C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      TentacleStateMap;                                  // 0x1050(0x0050)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     TentacleMaterial;                                  // 0x10A0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddArmFXComponent(class UNiagaraComponent* StartComp);
	struct FVector GetTargetLocationEXT();
	void K2_OnRecycle();
	void ResetDefault();
	void SetTargetLocation(const struct FVector& InTargetLocation);
	void SetTentacleMaterialParamValue(class FName InName, float InValue);

	void SetTransientFXLerpValue(class UNiagaraComponent* StartComp, const struct FVector& InTargetLocation, float InLerpValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_AbilityLoop_103551">();
	}
	static class ACue_AbilityLoop_103551* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_AbilityLoop_103551>();
	}
};
static_assert(alignof(ACue_AbilityLoop_103551) == 0x000008, "Wrong alignment on ACue_AbilityLoop_103551");
static_assert(sizeof(ACue_AbilityLoop_103551) == 0x0010A8, "Wrong size on ACue_AbilityLoop_103551");
static_assert(offsetof(ACue_AbilityLoop_103551, ArmEffectParams) == 0x000E50, "Member 'ACue_AbilityLoop_103551::ArmEffectParams' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, SetLengthName) == 0x000E60, "Member 'ACue_AbilityLoop_103551::SetLengthName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, MaxDistanceName) == 0x000E6C, "Member 'ACue_AbilityLoop_103551::MaxDistanceName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, GrowCurveMap) == 0x000E78, "Member 'ACue_AbilityLoop_103551::GrowCurveMap' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, CurveValueMap_WhenHit) == 0x000EC8, "Member 'ACue_AbilityLoop_103551::CurveValueMap_WhenHit' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, MinRName) == 0x000F18, "Member 'ACue_AbilityLoop_103551::MinRName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, GrowMinR) == 0x000F24, "Member 'ACue_AbilityLoop_103551::GrowMinR' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, RecycleCurveMap) == 0x000F28, "Member 'ACue_AbilityLoop_103551::RecycleCurveMap' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HasObstacleName) == 0x000F78, "Member 'ACue_AbilityLoop_103551::HasObstacleName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TransientFXAsset) == 0x000F88, "Member 'ACue_AbilityLoop_103551::TransientFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, LerpValue) == 0x000F90, "Member 'ACue_AbilityLoop_103551::LerpValue' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, LerpSpeed) == 0x000F94, "Member 'ACue_AbilityLoop_103551::LerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, MaxTransientFXDistance) == 0x000F98, "Member 'ACue_AbilityLoop_103551::MaxTransientFXDistance' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, PointsStartName) == 0x000F9C, "Member 'ACue_AbilityLoop_103551::PointsStartName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, PointsEndName) == 0x000FA8, "Member 'ACue_AbilityLoop_103551::PointsEndName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxAsset) == 0x000FB8, "Member 'ACue_AbilityLoop_103551::HitFxAsset' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxScaleValue) == 0x000FC0, "Member 'ACue_AbilityLoop_103551::HitFxScaleValue' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxMaxLength) == 0x000FC4, "Member 'ACue_AbilityLoop_103551::HitFxMaxLength' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxRecycleDuration) == 0x000FC8, "Member 'ACue_AbilityLoop_103551::HitFxRecycleDuration' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleMeshComponent) == 0x000FD0, "Member 'ACue_AbilityLoop_103551::TentacleMeshComponent' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, OwnerCharacter) == 0x000FD8, "Member 'ACue_AbilityLoop_103551::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleState) == 0x000FE0, "Member 'ACue_AbilityLoop_103551::TentacleState' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, StartShootTime) == 0x000FE4, "Member 'ACue_AbilityLoop_103551::StartShootTime' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, StartHandReleaseTime) == 0x000FE8, "Member 'ACue_AbilityLoop_103551::StartHandReleaseTime' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, ArmFXComponentArray) == 0x001010, "Member 'ACue_AbilityLoop_103551::ArmFXComponentArray' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TransientFXComponent) == 0x001020, "Member 'ACue_AbilityLoop_103551::TransientFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitEffectComponent) == 0x001028, "Member 'ACue_AbilityLoop_103551::HitEffectComponent' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitEffectCurrentEndPos) == 0x001030, "Member 'ACue_AbilityLoop_103551::HitEffectCurrentEndPos' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitEffectRecycleSpeed) == 0x001048, "Member 'ACue_AbilityLoop_103551::HitEffectRecycleSpeed' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleStateMap) == 0x001050, "Member 'ACue_AbilityLoop_103551::TentacleStateMap' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleMaterial) == 0x0010A0, "Member 'ACue_AbilityLoop_103551::TentacleMaterial' has a wrong offset!");

// Class Hero_1035.Cue_Buff_10356101
// 0x00D8 (0x1110 - 0x1038)
class ACue_Buff_10356101 final : public AMarvelCueNotify_Buff
{
public:
	class UNiagaraComponent*                      NS_Buff;                                           // 0x1038(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideName;                                          // 0x1040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideSpeed;                                         // 0x104C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x1050(0x0068)(Edit, NativeAccessSpecifierPublic)
	class FName                                   DissolveName;                                      // 0x10B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C4[0x4];                                     // 0x10C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DissolveCurve;                                     // 0x10C8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SymbiontOpenParameterName;                         // 0x10D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SymbiontIntensityParameterName;                    // 0x10DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StartSymbiontCurve;                                // 0x10E8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EndSymbiontCurve;                                  // 0x10F0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         RecycleFXAsset;                                    // 0x10F8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1100[0x10];                                    // 0x1100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10356101">();
	}
	static class ACue_Buff_10356101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10356101>();
	}
};
static_assert(alignof(ACue_Buff_10356101) == 0x000008, "Wrong alignment on ACue_Buff_10356101");
static_assert(sizeof(ACue_Buff_10356101) == 0x001110, "Wrong size on ACue_Buff_10356101");
static_assert(offsetof(ACue_Buff_10356101, NS_Buff) == 0x001038, "Member 'ACue_Buff_10356101::NS_Buff' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, HideName) == 0x001040, "Member 'ACue_Buff_10356101::HideName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, HideSpeed) == 0x00104C, "Member 'ACue_Buff_10356101::HideSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, AbilityTags) == 0x001050, "Member 'ACue_Buff_10356101::AbilityTags' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, DissolveName) == 0x0010B8, "Member 'ACue_Buff_10356101::DissolveName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, DissolveCurve) == 0x0010C8, "Member 'ACue_Buff_10356101::DissolveCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, SymbiontOpenParameterName) == 0x0010D0, "Member 'ACue_Buff_10356101::SymbiontOpenParameterName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, SymbiontIntensityParameterName) == 0x0010DC, "Member 'ACue_Buff_10356101::SymbiontIntensityParameterName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, StartSymbiontCurve) == 0x0010E8, "Member 'ACue_Buff_10356101::StartSymbiontCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, EndSymbiontCurve) == 0x0010F0, "Member 'ACue_Buff_10356101::EndSymbiontCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, RecycleFXAsset) == 0x0010F8, "Member 'ACue_Buff_10356101::RecycleFXAsset' has a wrong offset!");

// Class Hero_1035.Config_103571
// 0x0140 (0x01D8 - 0x0098)
class UConfig_103571 final : public UMarvelAbilityConfig
{
public:
	float                                         ApplyDamageToShieldRatio;                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ApplyDamageToShieldTags;                           // 0x00A0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         ScopeId;                                           // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScopeRadius;                                    // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScopeRadius;                                    // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScopeSpreadDuration;                               // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDragScope;                                  // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DragScopeID;                                       // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableKnockUpScope;                               // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KnockUpScopeID;                                    // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustedCapsuleRadius;                             // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustedCapsuleHalfHeight;                         // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NotTreatShieldBuffID;                              // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SymbioteTag;                                       // 0x0134(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ForceUpdateBoneTag;                                // 0x0140(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpGravityScale;                                  // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZVelocity;                                     // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevouringDuration;                                 // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDelayTime;                                    // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DevouringBlockTags;                                // 0x0160(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         DevouringInvincibleBuffID;                         // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncreaseSpeedBuffID;                               // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevouringOffset;                                   // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103571">();
	}
	static class UConfig_103571* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103571>();
	}
};
static_assert(alignof(UConfig_103571) == 0x000008, "Wrong alignment on UConfig_103571");
static_assert(sizeof(UConfig_103571) == 0x0001D8, "Wrong size on UConfig_103571");
static_assert(offsetof(UConfig_103571, ApplyDamageToShieldRatio) == 0x000098, "Member 'UConfig_103571::ApplyDamageToShieldRatio' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ApplyDamageToShieldTags) == 0x0000A0, "Member 'UConfig_103571::ApplyDamageToShieldTags' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ScopeId) == 0x000108, "Member 'UConfig_103571::ScopeId' has a wrong offset!");
static_assert(offsetof(UConfig_103571, MinScopeRadius) == 0x00010C, "Member 'UConfig_103571::MinScopeRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103571, MaxScopeRadius) == 0x000110, "Member 'UConfig_103571::MaxScopeRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ScopeSpreadDuration) == 0x000114, "Member 'UConfig_103571::ScopeSpreadDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103571, bEnableDragScope) == 0x000118, "Member 'UConfig_103571::bEnableDragScope' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DragScopeID) == 0x00011C, "Member 'UConfig_103571::DragScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, bEnableKnockUpScope) == 0x000120, "Member 'UConfig_103571::bEnableKnockUpScope' has a wrong offset!");
static_assert(offsetof(UConfig_103571, KnockUpScopeID) == 0x000124, "Member 'UConfig_103571::KnockUpScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, AdjustedCapsuleRadius) == 0x000128, "Member 'UConfig_103571::AdjustedCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103571, AdjustedCapsuleHalfHeight) == 0x00012C, "Member 'UConfig_103571::AdjustedCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UConfig_103571, NotTreatShieldBuffID) == 0x000130, "Member 'UConfig_103571::NotTreatShieldBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, SymbioteTag) == 0x000134, "Member 'UConfig_103571::SymbioteTag' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ForceUpdateBoneTag) == 0x000140, "Member 'UConfig_103571::ForceUpdateBoneTag' has a wrong offset!");
static_assert(offsetof(UConfig_103571, JumpGravityScale) == 0x00014C, "Member 'UConfig_103571::JumpGravityScale' has a wrong offset!");
static_assert(offsetof(UConfig_103571, JumpZVelocity) == 0x000150, "Member 'UConfig_103571::JumpZVelocity' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringDuration) == 0x000154, "Member 'UConfig_103571::DevouringDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103571, TraceDelayTime) == 0x000158, "Member 'UConfig_103571::TraceDelayTime' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringBlockTags) == 0x000160, "Member 'UConfig_103571::DevouringBlockTags' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringInvincibleBuffID) == 0x0001C8, "Member 'UConfig_103571::DevouringInvincibleBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, IncreaseSpeedBuffID) == 0x0001CC, "Member 'UConfig_103571::IncreaseSpeedBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringOffset) == 0x0001D0, "Member 'UConfig_103571::DevouringOffset' has a wrong offset!");

// Class Hero_1035.Ability_103571
// 0x0000 (0x2580 - 0x2580)
class UAbility_103571 : public UMarvelGameplayAbility
{
public:
	void ChangeGravity(float InGravityScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103571">();
	}
	static class UAbility_103571* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103571>();
	}
};
static_assert(alignof(UAbility_103571) == 0x000008, "Wrong alignment on UAbility_103571");
static_assert(sizeof(UAbility_103571) == 0x002580, "Wrong size on UAbility_103571");

// Class Hero_1035.Scope_10357101
// 0x0070 (0x1770 - 0x1700)
class AScope_10357101 : public AMarvelAbilityTargetActor_Scope
{
public:
	float                                         ScopeRadius;                                       // 0x1700(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESymbiontScopeState                           ScopeState;                                        // 0x1704(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1705[0x3];                                     // 0x1705(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetRotator;                                     // 0x1708(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartDevourDelegate;                               // 0x1720(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StopDevourDelegate;                                // 0x1730(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UConfig_103571*                         AbilityConfig;                                     // 0x1740(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1748[0x28];                                    // 0x1748(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DevourTrace();
	void OnRep_ScopeRadius();
	void OnRep_ScopeState();
	void SetScopeRadius(float InRadius);
	void SetScopeState(ESymbiontScopeState InScopeState);
	void StartDevour();
	void StartSpread();
	void StopDevour();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10357101">();
	}
	static class AScope_10357101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10357101>();
	}
};
static_assert(alignof(AScope_10357101) == 0x000010, "Wrong alignment on AScope_10357101");
static_assert(sizeof(AScope_10357101) == 0x001770, "Wrong size on AScope_10357101");
static_assert(offsetof(AScope_10357101, ScopeRadius) == 0x001700, "Member 'AScope_10357101::ScopeRadius' has a wrong offset!");
static_assert(offsetof(AScope_10357101, ScopeState) == 0x001704, "Member 'AScope_10357101::ScopeState' has a wrong offset!");
static_assert(offsetof(AScope_10357101, TargetRotator) == 0x001708, "Member 'AScope_10357101::TargetRotator' has a wrong offset!");
static_assert(offsetof(AScope_10357101, StartDevourDelegate) == 0x001720, "Member 'AScope_10357101::StartDevourDelegate' has a wrong offset!");
static_assert(offsetof(AScope_10357101, StopDevourDelegate) == 0x001730, "Member 'AScope_10357101::StopDevourDelegate' has a wrong offset!");
static_assert(offsetof(AScope_10357101, AbilityConfig) == 0x001740, "Member 'AScope_10357101::AbilityConfig' has a wrong offset!");

// Class Hero_1035.TraceComponent_10357101
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10357101 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10357101">();
	}
	static class UTraceComponent_10357101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10357101>();
	}
};
static_assert(alignof(UTraceComponent_10357101) == 0x000010, "Wrong alignment on UTraceComponent_10357101");
static_assert(sizeof(UTraceComponent_10357101) == 0x001710, "Wrong size on UTraceComponent_10357101");

// Class Hero_1035.TraceComponent_10357102
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10357102 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10357102">();
	}
	static class UTraceComponent_10357102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10357102>();
	}
};
static_assert(alignof(UTraceComponent_10357102) == 0x000010, "Wrong alignment on UTraceComponent_10357102");
static_assert(sizeof(UTraceComponent_10357102) == 0x001710, "Wrong size on UTraceComponent_10357102");

// Class Hero_1035.DragAbility_103571
// 0x0018 (0x1D00 - 0x1CE8)
class UDragAbility_103571 : public UMarvelDragAbility
{
public:
	struct FVector                                TargetOffset;                                      // 0x1CE8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragAbility_103571">();
	}
	static class UDragAbility_103571* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragAbility_103571>();
	}
};
static_assert(alignof(UDragAbility_103571) == 0x000008, "Wrong alignment on UDragAbility_103571");
static_assert(sizeof(UDragAbility_103571) == 0x001D00, "Wrong size on UDragAbility_103571");
static_assert(offsetof(UDragAbility_103571, TargetOffset) == 0x001CE8, "Member 'UDragAbility_103571::TargetOffset' has a wrong offset!");

// Class Hero_1035.SymbioteAnimInstance
// 0x0000 (0x0430 - 0x0430)
class USymbioteAnimInstance final : public UAnimInstance
{
public:
	bool                                          bIsRunning;                                        // 0x0428(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SymbioteAnimInstance">();
	}
	static class USymbioteAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USymbioteAnimInstance>();
	}
};
static_assert(alignof(USymbioteAnimInstance) == 0x000010, "Wrong alignment on USymbioteAnimInstance");
static_assert(sizeof(USymbioteAnimInstance) == 0x000430, "Wrong size on USymbioteAnimInstance");
static_assert(offsetof(USymbioteAnimInstance, bIsRunning) == 0x000428, "Member 'USymbioteAnimInstance::bIsRunning' has a wrong offset!");

// Class Hero_1035.Cue_Scope_Loop_10357101
// 0x0220 (0x0F90 - 0x0D70)
class ACue_Scope_Loop_10357101 final : public AMarvelCueNotify_Scope
{
public:
	class USkeletalMeshComponent*                 SymbioteComponent;                                 // 0x0D70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SymbioteTentacleComponent;                         // 0x0D78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Loop;                                           // 0x0D80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Tentacle;                                       // 0x0D88(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RegisterHiddenTags;                                // 0x0D90(0x0068)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_DF8[0x50];                                     // 0x0DF8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x0E48(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTraceHeight;                                 // 0x0E4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DevourMontage;                                     // 0x0E50(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachOffset;                                      // 0x0E58(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFXSystemAsset*>                 StartDevourFXAssets;                               // 0x0E70(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   TentacleAlphaName;                                 // 0x0E80(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8C[0x4];                                      // 0x0E8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TentacleAlphaCurve;                                // 0x0E90(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VelocityRatioName;                                 // 0x0E98(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityRatioSpeed;                                // 0x0EA4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IsRotateName;                                      // 0x0EA8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocityRatio;                                  // 0x0EB4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoopFXSizeName;                                    // 0x0EB8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFXSize;                                     // 0x0EC4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TentacleFXOnThrowableName;                         // 0x0EC8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartMoveAudioID;                                  // 0x0ED4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StopMoveAudioID;                                   // 0x0ED8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EDC[0x4];                                      // 0x0EDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraInterp*                          DevouringCameraInterp;                             // 0x0EE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103571*                         AbilityConfig;                                     // 0x0EE8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AScope_10357101*                        TargetScope;                                       // 0x0EF0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FSpringArmControlHandler> SpringArmHandlers;                                 // 0x0EF8(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_F48[0x48];                                     // 0x0F48(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGenericGameplayTagUpdate(const struct FGameplayTag& InTag, int32 Count);
	void OnMontageEnded(class UAnimMontage* InMontage, bool bIsInterrupted);
	void StartDevour();
	void StopDevour();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10357101">();
	}
	static class ACue_Scope_Loop_10357101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10357101>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10357101) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10357101");
static_assert(sizeof(ACue_Scope_Loop_10357101) == 0x000F90, "Wrong size on ACue_Scope_Loop_10357101");
static_assert(offsetof(ACue_Scope_Loop_10357101, SymbioteComponent) == 0x000D70, "Member 'ACue_Scope_Loop_10357101::SymbioteComponent' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, SymbioteTentacleComponent) == 0x000D78, "Member 'ACue_Scope_Loop_10357101::SymbioteTentacleComponent' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, NS_Loop) == 0x000D80, "Member 'ACue_Scope_Loop_10357101::NS_Loop' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, NS_Tentacle) == 0x000D88, "Member 'ACue_Scope_Loop_10357101::NS_Tentacle' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, RegisterHiddenTags) == 0x000D90, "Member 'ACue_Scope_Loop_10357101::RegisterHiddenTags' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, AbilityID) == 0x000E48, "Member 'ACue_Scope_Loop_10357101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, GroundTraceHeight) == 0x000E4C, "Member 'ACue_Scope_Loop_10357101::GroundTraceHeight' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, DevourMontage) == 0x000E50, "Member 'ACue_Scope_Loop_10357101::DevourMontage' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, AttachOffset) == 0x000E58, "Member 'ACue_Scope_Loop_10357101::AttachOffset' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, StartDevourFXAssets) == 0x000E70, "Member 'ACue_Scope_Loop_10357101::StartDevourFXAssets' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TentacleAlphaName) == 0x000E80, "Member 'ACue_Scope_Loop_10357101::TentacleAlphaName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TentacleAlphaCurve) == 0x000E90, "Member 'ACue_Scope_Loop_10357101::TentacleAlphaCurve' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, VelocityRatioName) == 0x000E98, "Member 'ACue_Scope_Loop_10357101::VelocityRatioName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, VelocityRatioSpeed) == 0x000EA4, "Member 'ACue_Scope_Loop_10357101::VelocityRatioSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, IsRotateName) == 0x000EA8, "Member 'ACue_Scope_Loop_10357101::IsRotateName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, MinVelocityRatio) == 0x000EB4, "Member 'ACue_Scope_Loop_10357101::MinVelocityRatio' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, LoopFXSizeName) == 0x000EB8, "Member 'ACue_Scope_Loop_10357101::LoopFXSizeName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, DefaultFXSize) == 0x000EC4, "Member 'ACue_Scope_Loop_10357101::DefaultFXSize' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TentacleFXOnThrowableName) == 0x000EC8, "Member 'ACue_Scope_Loop_10357101::TentacleFXOnThrowableName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, StartMoveAudioID) == 0x000ED4, "Member 'ACue_Scope_Loop_10357101::StartMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, StopMoveAudioID) == 0x000ED8, "Member 'ACue_Scope_Loop_10357101::StopMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, DevouringCameraInterp) == 0x000EE0, "Member 'ACue_Scope_Loop_10357101::DevouringCameraInterp' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, AbilityConfig) == 0x000EE8, "Member 'ACue_Scope_Loop_10357101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TargetScope) == 0x000EF0, "Member 'ACue_Scope_Loop_10357101::TargetScope' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, SpringArmHandlers) == 0x000EF8, "Member 'ACue_Scope_Loop_10357101::SpringArmHandlers' has a wrong offset!");

// Class Hero_1035.EpicMomentAction_1035
// 0x0040 (0x0160 - 0x0120)
class UEpicMomentAction_1035 : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelGameplayAbility*                 EAbility;                                          // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEpicMomentNodeInfo                    CtrlConfig;                                        // 0x0138(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    EConfig;                                           // 0x0144(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CtrlBuffID;                                        // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CtrlBuffCount;                                     // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EAbilityID;                                        // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EHealthThreshold;                                  // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnEAbilityActivate();
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1035">();
	}
	static class UEpicMomentAction_1035* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1035>();
	}
};
static_assert(alignof(UEpicMomentAction_1035) == 0x000008, "Wrong alignment on UEpicMomentAction_1035");
static_assert(sizeof(UEpicMomentAction_1035) == 0x000160, "Wrong size on UEpicMomentAction_1035");
static_assert(offsetof(UEpicMomentAction_1035, EAbility) == 0x000130, "Member 'UEpicMomentAction_1035::EAbility' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, CtrlConfig) == 0x000138, "Member 'UEpicMomentAction_1035::CtrlConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, EConfig) == 0x000144, "Member 'UEpicMomentAction_1035::EConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, CtrlBuffID) == 0x000150, "Member 'UEpicMomentAction_1035::CtrlBuffID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, CtrlBuffCount) == 0x000154, "Member 'UEpicMomentAction_1035::CtrlBuffCount' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, EAbilityID) == 0x000158, "Member 'UEpicMomentAction_1035::EAbilityID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, EHealthThreshold) == 0x00015C, "Member 'UEpicMomentAction_1035::EHealthThreshold' has a wrong offset!");

// Class Hero_1035.VenomAnimInstance
// 0x00A0 (0x1450 - 0x13B0)
class UVenomAnimInstance final : public USpiderManBaseAnimInstance
{
public:
	bool                                          bStartWallIdle_To_OnWallRunning;                   // 0x13B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndWallIdle_To_OnWallRunning;                     // 0x13B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B2[0x9E];                                    // 0x13B2(0x009E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomAnimInstance">();
	}
	static class UVenomAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVenomAnimInstance>();
	}
};
static_assert(alignof(UVenomAnimInstance) == 0x000010, "Wrong alignment on UVenomAnimInstance");
static_assert(sizeof(UVenomAnimInstance) == 0x001450, "Wrong size on UVenomAnimInstance");
static_assert(offsetof(UVenomAnimInstance, bStartWallIdle_To_OnWallRunning) == 0x0013B0, "Member 'UVenomAnimInstance::bStartWallIdle_To_OnWallRunning' has a wrong offset!");
static_assert(offsetof(UVenomAnimInstance, bEndWallIdle_To_OnWallRunning) == 0x0013B1, "Member 'UVenomAnimInstance::bEndWallIdle_To_OnWallRunning' has a wrong offset!");

// Class Hero_1035.VenomCharacter
// 0x0050 (0x1890 - 0x1840)
class AVenomCharacter : public ASpiderManBaseCharacter
{
public:
	class UCapsuleComponent*                      SymbioteCapsuleComponent;                          // 0x1838(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      SymbioteHitShapeComponent;                         // 0x1840(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SymbioteInterpSpeed;                               // 0x1848(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SymbioteFallingInterpSpeed;                        // 0x184C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerRotateSpeed;                                // 0x1850(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1854[0x4];                                     // 0x1854(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVenomMoveLogicBaseComponent*           VenomMoveLogic;                                    // 0x1858(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopAnim;                                         // 0x1860(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableSymbioteCollision;                        // 0x1861(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1862[0x6];                                     // 0x1862(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSymbioteStateChanged;                            // 0x1868(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1878[0x18];                                    // 0x1878(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableSymbioteCollision(bool bIsEnable);
	void OnRep_IsEnableSymbioteCollision();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomCharacter">();
	}
	static class AVenomCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVenomCharacter>();
	}
};
static_assert(alignof(AVenomCharacter) == 0x000010, "Wrong alignment on AVenomCharacter");
static_assert(sizeof(AVenomCharacter) == 0x001890, "Wrong size on AVenomCharacter");
static_assert(offsetof(AVenomCharacter, SymbioteCapsuleComponent) == 0x001838, "Member 'AVenomCharacter::SymbioteCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, SymbioteHitShapeComponent) == 0x001840, "Member 'AVenomCharacter::SymbioteHitShapeComponent' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, SymbioteInterpSpeed) == 0x001848, "Member 'AVenomCharacter::SymbioteInterpSpeed' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, SymbioteFallingInterpSpeed) == 0x00184C, "Member 'AVenomCharacter::SymbioteFallingInterpSpeed' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, TriggerRotateSpeed) == 0x001850, "Member 'AVenomCharacter::TriggerRotateSpeed' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, VenomMoveLogic) == 0x001858, "Member 'AVenomCharacter::VenomMoveLogic' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, bLoopAnim) == 0x001860, "Member 'AVenomCharacter::bLoopAnim' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, bIsEnableSymbioteCollision) == 0x001861, "Member 'AVenomCharacter::bIsEnableSymbioteCollision' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, OnSymbioteStateChanged) == 0x001868, "Member 'AVenomCharacter::OnSymbioteStateChanged' has a wrong offset!");

// Class Hero_1035.VenomChildActor
// 0x12D0 (0x1D30 - 0x0A60)
class AVenomChildActor : public AMarvelCharacterChildActor
{
public:
	class USkeletalMeshComponent*                 Tentacle1;                                         // 0x0A60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Tentacle2;                                         // 0x0A68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Tentacle3;                                         // 0x0A70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Tentacle4;                                         // 0x0A78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      BodyFX;                                            // 0x0A80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         TransitionFXAsset;                                 // 0x0A88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTentacleAnimInfo>              TentacleAnimInfos;                                 // 0x0A90(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x0AA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA4[0x4];                                      // 0x0AA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TransitionFXDissolveParameterNames;                // 0x0AA8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DefaultDissolveValue;                              // 0x0AB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TentacleSpeedName;                                 // 0x0ABC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TentacleSpeedDeltaValue;                           // 0x0AC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTentacleSpeed;                                  // 0x0ACC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTentacleSpeed;                                  // 0x0AD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideName;                                          // 0x0AD4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideSpeed;                                         // 0x0AE0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE4[0x4];                                      // 0x0AE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0AE8(0x0068)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  StopFXImmediatelyTags;                             // 0x0B50(0x0068)(Edit, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DeactivateTentacleDelegate;                        // 0x0BB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TransitionFXComponent;                             // 0x0BC8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         Tentacles;                                         // 0x0BD0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<int32>                                 CurrentAnimIndex;                                  // 0x0BE0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         CurTentacleSpeed;                                  // 0x0BF0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF4[0x4];                                      // 0x0BF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_103521*                         TentacleAbilityConfig;                             // 0x0BF8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x0C00(0x0010)(Transient, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x0C10(0x0F90)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             CameraAimResult;                                   // 0x1BA0(0x0170)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              BodyNiagaraComponents;                             // 0x1D10(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D20[0x10];                                    // 0x1D20(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideTentacle(class UAnimMontage* AnimMontage, bool bInterrupted);
	void OnComponentMaterialChanged(class UActorComponent* InActorComponent);
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomChildActor">();
	}
	static class AVenomChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVenomChildActor>();
	}
};
static_assert(alignof(AVenomChildActor) == 0x000010, "Wrong alignment on AVenomChildActor");
static_assert(sizeof(AVenomChildActor) == 0x001D30, "Wrong size on AVenomChildActor");
static_assert(offsetof(AVenomChildActor, Tentacle1) == 0x000A60, "Member 'AVenomChildActor::Tentacle1' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacle2) == 0x000A68, "Member 'AVenomChildActor::Tentacle2' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacle3) == 0x000A70, "Member 'AVenomChildActor::Tentacle3' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacle4) == 0x000A78, "Member 'AVenomChildActor::Tentacle4' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, BodyFX) == 0x000A80, "Member 'AVenomChildActor::BodyFX' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TransitionFXAsset) == 0x000A88, "Member 'AVenomChildActor::TransitionFXAsset' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleAnimInfos) == 0x000A90, "Member 'AVenomChildActor::TentacleAnimInfos' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TraceDistance) == 0x000AA0, "Member 'AVenomChildActor::TraceDistance' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TransitionFXDissolveParameterNames) == 0x000AA8, "Member 'AVenomChildActor::TransitionFXDissolveParameterNames' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, DefaultDissolveValue) == 0x000AB8, "Member 'AVenomChildActor::DefaultDissolveValue' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleSpeedName) == 0x000ABC, "Member 'AVenomChildActor::TentacleSpeedName' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleSpeedDeltaValue) == 0x000AC8, "Member 'AVenomChildActor::TentacleSpeedDeltaValue' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, MinTentacleSpeed) == 0x000ACC, "Member 'AVenomChildActor::MinTentacleSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, MaxTentacleSpeed) == 0x000AD0, "Member 'AVenomChildActor::MaxTentacleSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, HideName) == 0x000AD4, "Member 'AVenomChildActor::HideName' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, HideSpeed) == 0x000AE0, "Member 'AVenomChildActor::HideSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, AbilityTags) == 0x000AE8, "Member 'AVenomChildActor::AbilityTags' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, StopFXImmediatelyTags) == 0x000B50, "Member 'AVenomChildActor::StopFXImmediatelyTags' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, DeactivateTentacleDelegate) == 0x000BB8, "Member 'AVenomChildActor::DeactivateTentacleDelegate' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TransitionFXComponent) == 0x000BC8, "Member 'AVenomChildActor::TransitionFXComponent' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacles) == 0x000BD0, "Member 'AVenomChildActor::Tentacles' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, CurrentAnimIndex) == 0x000BE0, "Member 'AVenomChildActor::CurrentAnimIndex' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, CurTentacleSpeed) == 0x000BF0, "Member 'AVenomChildActor::CurTentacleSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleAbilityConfig) == 0x000BF8, "Member 'AVenomChildActor::TentacleAbilityConfig' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, DeclarePlayerViewSideHolder) == 0x000C00, "Member 'AVenomChildActor::DeclarePlayerViewSideHolder' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TraceContext) == 0x000C10, "Member 'AVenomChildActor::TraceContext' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, CameraAimResult) == 0x001BA0, "Member 'AVenomChildActor::CameraAimResult' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, BodyNiagaraComponents) == 0x001D10, "Member 'AVenomChildActor::BodyNiagaraComponents' has a wrong offset!");

// Class Hero_1035.VenomMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UVenomMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomMoveLogicBaseComponent">();
	}
	static class UVenomMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVenomMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UVenomMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UVenomMoveLogicBaseComponent");
static_assert(sizeof(UVenomMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UVenomMoveLogicBaseComponent");

// Class Hero_1035.VenomMovementComponent
// 0x0050 (0x3020 - 0x2FD0)
class UVenomMovementComponent final : public UCharacterWallRunningComponent
{
public:
	bool                                          bEnableAvoidMeshPenetrationTrace;                  // 0x2FD0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD1[0x3];                                     // 0x2FD1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AwayFromWallScale;                                 // 0x2FD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBetweenAngleToTrace;                            // 0x2FD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FDC[0x4];                                     // 0x2FDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HandSocketOffset;                                  // 0x2FE0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleThresholdToForceSlideUpInSwinging;            // 0x2FF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FFC[0x4];                                     // 0x2FFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorComponent*>                TraceComponentArray;                               // 0x3000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AVenomCharacter*                        VenomCharacter;                                    // 0x3010(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3018[0x8];                                     // 0x3018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomMovementComponent">();
	}
	static class UVenomMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVenomMovementComponent>();
	}
};
static_assert(alignof(UVenomMovementComponent) == 0x000010, "Wrong alignment on UVenomMovementComponent");
static_assert(sizeof(UVenomMovementComponent) == 0x003020, "Wrong size on UVenomMovementComponent");
static_assert(offsetof(UVenomMovementComponent, bEnableAvoidMeshPenetrationTrace) == 0x002FD0, "Member 'UVenomMovementComponent::bEnableAvoidMeshPenetrationTrace' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, AwayFromWallScale) == 0x002FD4, "Member 'UVenomMovementComponent::AwayFromWallScale' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, MinBetweenAngleToTrace) == 0x002FD8, "Member 'UVenomMovementComponent::MinBetweenAngleToTrace' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, HandSocketOffset) == 0x002FE0, "Member 'UVenomMovementComponent::HandSocketOffset' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, AngleThresholdToForceSlideUpInSwinging) == 0x002FF8, "Member 'UVenomMovementComponent::AngleThresholdToForceSlideUpInSwinging' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, TraceComponentArray) == 0x003000, "Member 'UVenomMovementComponent::TraceComponentArray' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, VenomCharacter) == 0x003010, "Member 'UVenomMovementComponent::VenomCharacter' has a wrong offset!");

}

