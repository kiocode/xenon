#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1047

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Hero_1047_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"


namespace SDK
{

// Class Hero_1047.Config_104701
// 0x0008 (0x00A0 - 0x0098)
class UConfig_104701 final : public UMarvelAbilityConfig
{
public:
	float                                         CriticalStrikeReductionPercentage;                 // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104701">();
	}
	static class UConfig_104701* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104701>();
	}
};
static_assert(alignof(UConfig_104701) == 0x000008, "Wrong alignment on UConfig_104701");
static_assert(sizeof(UConfig_104701) == 0x0000A0, "Wrong size on UConfig_104701");
static_assert(offsetof(UConfig_104701, CriticalStrikeReductionPercentage) == 0x000098, "Member 'UConfig_104701::CriticalStrikeReductionPercentage' has a wrong offset!");

// Class Hero_1047.Ability_104701
// 0x0000 (0x2580 - 0x2580)
class UAbility_104701 : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104701">();
	}
	static class UAbility_104701* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104701>();
	}
};
static_assert(alignof(UAbility_104701) == 0x000008, "Wrong alignment on UAbility_104701");
static_assert(sizeof(UAbility_104701) == 0x002580, "Wrong size on UAbility_104701");

// Class Hero_1047.Config_104711
// 0x0070 (0x0128 - 0x00B8)
class UConfig_104711 : public UConfig_105
{
public:
	class UCurveFloat*                            ProjectileRadiusCurveByTime;                       // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProjectileGravityCurveByTime;                      // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProjectileVelocityCurveByTime;                     // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayEnterSectionEndTime;                          // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHapplyBubbleDebug;                                // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsiderCutCosAngle;                              // 0x00D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CutAngle;                                          // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DynamicInterpRotationSpeedCurve;                   // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicInterpRotationMaxAngle;                     // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlowDelayTime;                                     // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFlowSpeed;                                      // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSegmentsSpline                        SegmentsSpline;                                    // 0x00F4(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104711">();
	}
	static class UConfig_104711* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104711>();
	}
};
static_assert(alignof(UConfig_104711) == 0x000008, "Wrong alignment on UConfig_104711");
static_assert(sizeof(UConfig_104711) == 0x000128, "Wrong size on UConfig_104711");
static_assert(offsetof(UConfig_104711, ProjectileRadiusCurveByTime) == 0x0000B8, "Member 'UConfig_104711::ProjectileRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(UConfig_104711, ProjectileGravityCurveByTime) == 0x0000C0, "Member 'UConfig_104711::ProjectileGravityCurveByTime' has a wrong offset!");
static_assert(offsetof(UConfig_104711, ProjectileVelocityCurveByTime) == 0x0000C8, "Member 'UConfig_104711::ProjectileVelocityCurveByTime' has a wrong offset!");
static_assert(offsetof(UConfig_104711, DelayEnterSectionEndTime) == 0x0000D0, "Member 'UConfig_104711::DelayEnterSectionEndTime' has a wrong offset!");
static_assert(offsetof(UConfig_104711, bHapplyBubbleDebug) == 0x0000D4, "Member 'UConfig_104711::bHapplyBubbleDebug' has a wrong offset!");
static_assert(offsetof(UConfig_104711, bConsiderCutCosAngle) == 0x0000D5, "Member 'UConfig_104711::bConsiderCutCosAngle' has a wrong offset!");
static_assert(offsetof(UConfig_104711, CutAngle) == 0x0000D8, "Member 'UConfig_104711::CutAngle' has a wrong offset!");
static_assert(offsetof(UConfig_104711, DynamicInterpRotationSpeedCurve) == 0x0000E0, "Member 'UConfig_104711::DynamicInterpRotationSpeedCurve' has a wrong offset!");
static_assert(offsetof(UConfig_104711, DynamicInterpRotationMaxAngle) == 0x0000E8, "Member 'UConfig_104711::DynamicInterpRotationMaxAngle' has a wrong offset!");
static_assert(offsetof(UConfig_104711, FlowDelayTime) == 0x0000EC, "Member 'UConfig_104711::FlowDelayTime' has a wrong offset!");
static_assert(offsetof(UConfig_104711, MaxFlowSpeed) == 0x0000F0, "Member 'UConfig_104711::MaxFlowSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104711, SegmentsSpline) == 0x0000F4, "Member 'UConfig_104711::SegmentsSpline' has a wrong offset!");

// Class Hero_1047.Projectile_10471101
// 0x0090 (0x30E0 - 0x3050)
class AProjectile_10471101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	class UConfig_104711*                         Config104711;                                      // 0x3050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProjectileRadiusCurveByTime;                       // 0x3058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProjectileGravityCurveByTime;                      // 0x3060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProjectileVelocityCurveByTime;                     // 0x3068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlowDelayTime;                                     // 0x3070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlowEscapeTime;                                    // 0x3074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OldVelocity;                                       // 0x3078(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3090[0x50];                                    // 0x3090(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetProjectileFlyingTime();
	void OnJeffProjectileStop(const struct FHitResult& ImpactResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10471101">();
	}
	static class AProjectile_10471101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10471101>();
	}
};
static_assert(alignof(AProjectile_10471101) == 0x000010, "Wrong alignment on AProjectile_10471101");
static_assert(sizeof(AProjectile_10471101) == 0x0030E0, "Wrong size on AProjectile_10471101");
static_assert(offsetof(AProjectile_10471101, Config104711) == 0x003050, "Member 'AProjectile_10471101::Config104711' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, ProjectileRadiusCurveByTime) == 0x003058, "Member 'AProjectile_10471101::ProjectileRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, ProjectileGravityCurveByTime) == 0x003060, "Member 'AProjectile_10471101::ProjectileGravityCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, ProjectileVelocityCurveByTime) == 0x003068, "Member 'AProjectile_10471101::ProjectileVelocityCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, FlowDelayTime) == 0x003070, "Member 'AProjectile_10471101::FlowDelayTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, FlowEscapeTime) == 0x003074, "Member 'AProjectile_10471101::FlowEscapeTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471101, OldVelocity) == 0x003078, "Member 'AProjectile_10471101::OldVelocity' has a wrong offset!");

// Class Hero_1047.Ability_104711
// 0x0008 (0x25D0 - 0x25C8)
class UAbility_104711 : public UAbility_105
{
public:
	uint8                                         Pad_25C8[0x8];                                     // 0x25C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104711">();
	}
	static class UAbility_104711* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104711>();
	}
};
static_assert(alignof(UAbility_104711) == 0x000008, "Wrong alignment on UAbility_104711");
static_assert(sizeof(UAbility_104711) == 0x0025D0, "Wrong size on UAbility_104711");

// Class Hero_1047.Cue_Projectile_Loop_10471101
// 0x0030 (0x0DE0 - 0x0DB0)
class ACue_Projectile_Loop_10471101 final : public AMarvelCueNotify_Projectile
{
public:
	class UNiagaraComponent*                      LoopNX;                                            // 0x0DB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      SingleFlowLoopNX;                                  // 0x0DB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConeAngleName;                                     // 0x0DC0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DCC[0x4];                                      // 0x0DCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CurveConeAngle;                                    // 0x0DD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AProjectile_10471101*                   Projectile10471101;                                // 0x0DD8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10471101">();
	}
	static class ACue_Projectile_Loop_10471101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10471101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10471101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10471101");
static_assert(sizeof(ACue_Projectile_Loop_10471101) == 0x000DE0, "Wrong size on ACue_Projectile_Loop_10471101");
static_assert(offsetof(ACue_Projectile_Loop_10471101, LoopNX) == 0x000DB0, "Member 'ACue_Projectile_Loop_10471101::LoopNX' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10471101, SingleFlowLoopNX) == 0x000DB8, "Member 'ACue_Projectile_Loop_10471101::SingleFlowLoopNX' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10471101, ConeAngleName) == 0x000DC0, "Member 'ACue_Projectile_Loop_10471101::ConeAngleName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10471101, CurveConeAngle) == 0x000DD0, "Member 'ACue_Projectile_Loop_10471101::CurveConeAngle' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10471101, Projectile10471101) == 0x000DD8, "Member 'ACue_Projectile_Loop_10471101::Projectile10471101' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10471101
// 0x0018 (0x0E68 - 0x0E50)
class ACue_Ability_Loop_10471101 final : public AMarvelCueNotify_Ability
{
public:
	int32                                         OwningAbilityID;                                   // 0x0E50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E54[0x14];                                     // 0x0E54(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10471101">();
	}
	static class ACue_Ability_Loop_10471101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10471101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10471101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10471101");
static_assert(sizeof(ACue_Ability_Loop_10471101) == 0x000E68, "Wrong size on ACue_Ability_Loop_10471101");
static_assert(offsetof(ACue_Ability_Loop_10471101, OwningAbilityID) == 0x000E50, "Member 'ACue_Ability_Loop_10471101::OwningAbilityID' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10471102
// 0x0060 (0x0EB0 - 0x0E50)
class ACue_Ability_Loop_10471102 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E50[0x8];                                      // 0x0E50(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         SystemTemplate;                                    // 0x0E58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineComponent*>               LoopNXSpines;                                      // 0x0E60(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              LoopNXs;                                           // 0x0E70(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_E80[0x10];                                     // 0x0E80(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebug;                                            // 0x0E90(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugSpineComopnent;                              // 0x0E91(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E92[0x2];                                      // 0x0E92(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OwningAbilityID;                                   // 0x0E94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDebugHapplyDebugSpline>        DebugHapplyBubblesGroup;                           // 0x0E98(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA8[0x8];                                      // 0x0EA8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyDebugHapplyBubbles(int32 FrameIndex);
	void ApplyDebugHapplyBubblesSpline(int32 FrameIndex, class USplineComponent* Spline);
	void GetDebugHapplyMinAndMaxFrame(int32* Min, int32* Max);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10471102">();
	}
	static class ACue_Ability_Loop_10471102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10471102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10471102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10471102");
static_assert(sizeof(ACue_Ability_Loop_10471102) == 0x000EB0, "Wrong size on ACue_Ability_Loop_10471102");
static_assert(offsetof(ACue_Ability_Loop_10471102, SystemTemplate) == 0x000E58, "Member 'ACue_Ability_Loop_10471102::SystemTemplate' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, LoopNXSpines) == 0x000E60, "Member 'ACue_Ability_Loop_10471102::LoopNXSpines' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, LoopNXs) == 0x000E70, "Member 'ACue_Ability_Loop_10471102::LoopNXs' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, bDebug) == 0x000E90, "Member 'ACue_Ability_Loop_10471102::bDebug' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, bDebugSpineComopnent) == 0x000E91, "Member 'ACue_Ability_Loop_10471102::bDebugSpineComopnent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, OwningAbilityID) == 0x000E94, "Member 'ACue_Ability_Loop_10471102::OwningAbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471102, DebugHapplyBubblesGroup) == 0x000E98, "Member 'ACue_Ability_Loop_10471102::DebugHapplyBubblesGroup' has a wrong offset!");

// Class Hero_1047.Cue_Projectile_HitImpact_10471101
// 0x0000 (0x04D0 - 0x04D0)
class UCue_Projectile_HitImpact_10471101 final : public UMarvelCueNotify_HitImpact
{
public:
	void OnPostExecuteAudioCreateShotActor(class AOneShotAudioActor* OneShotActor, class AActor* MyTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_HitImpact_10471101">();
	}
	static class UCue_Projectile_HitImpact_10471101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Projectile_HitImpact_10471101>();
	}
};
static_assert(alignof(UCue_Projectile_HitImpact_10471101) == 0x000008, "Wrong alignment on UCue_Projectile_HitImpact_10471101");
static_assert(sizeof(UCue_Projectile_HitImpact_10471101) == 0x0004D0, "Wrong size on UCue_Projectile_HitImpact_10471101");

// Class Hero_1047.Ability_104712
// 0x20C8 (0x4690 - 0x25C8)
class UAbility_104712 : public UAbility_105
{
public:
	class UCurveFloat*                            ProjectileCollisionRadiusCurveByTime;              // 0x25C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFlowManagerTickFunction               FlowManagerTickFunction;                           // 0x25D0(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint64                                        CurrentActiveFlowUID;                              // 0x2608(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2610[0xF0];                                    // 0x2610(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectile_10471201*                   LatestSpawnedProjectile;                           // 0x2700(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2708[0x8];                                     // 0x2708(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             CachedTraceContext;                                // 0x2710(0x0F90)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FMarvelProjectileAgentTable            CachedProjectileAgentTable;                        // 0x36A0(0x0FD8)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4678[0x18];                                    // 0x4678(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104712">();
	}
	static class UAbility_104712* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104712>();
	}
};
static_assert(alignof(UAbility_104712) == 0x000010, "Wrong alignment on UAbility_104712");
static_assert(sizeof(UAbility_104712) == 0x004690, "Wrong size on UAbility_104712");
static_assert(offsetof(UAbility_104712, ProjectileCollisionRadiusCurveByTime) == 0x0025C8, "Member 'UAbility_104712::ProjectileCollisionRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(UAbility_104712, FlowManagerTickFunction) == 0x0025D0, "Member 'UAbility_104712::FlowManagerTickFunction' has a wrong offset!");
static_assert(offsetof(UAbility_104712, CurrentActiveFlowUID) == 0x002608, "Member 'UAbility_104712::CurrentActiveFlowUID' has a wrong offset!");
static_assert(offsetof(UAbility_104712, LatestSpawnedProjectile) == 0x002700, "Member 'UAbility_104712::LatestSpawnedProjectile' has a wrong offset!");
static_assert(offsetof(UAbility_104712, CachedTraceContext) == 0x002710, "Member 'UAbility_104712::CachedTraceContext' has a wrong offset!");
static_assert(offsetof(UAbility_104712, CachedProjectileAgentTable) == 0x0036A0, "Member 'UAbility_104712::CachedProjectileAgentTable' has a wrong offset!");

// Class Hero_1047.Projectile_10471201
// 0x0030 (0x3080 - 0x3050)
class AProjectile_10471201 : public AMarvelAbilityTargetActor_Projectile
{
public:
	uint8                                         Pad_3050[0x10];                                    // 0x3050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ProjectileCollisionRadiusCurveByTime;              // 0x3060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3068[0x8];                                     // 0x3068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        InitialFlowUID;                                    // 0x3070(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3078[0x8];                                     // 0x3078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10471201">();
	}
	static class AProjectile_10471201* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10471201>();
	}
};
static_assert(alignof(AProjectile_10471201) == 0x000010, "Wrong alignment on AProjectile_10471201");
static_assert(sizeof(AProjectile_10471201) == 0x003080, "Wrong size on AProjectile_10471201");
static_assert(offsetof(AProjectile_10471201, ProjectileCollisionRadiusCurveByTime) == 0x003060, "Member 'AProjectile_10471201::ProjectileCollisionRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10471201, InitialFlowUID) == 0x003070, "Member 'AProjectile_10471201::InitialFlowUID' has a wrong offset!");

// Class Hero_1047.VisualWaterFlow
// 0x0010 (0x0040 - 0x0030)
class UVisualWaterFlow final : public UObject
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualWaterFlow">();
	}
	static class UVisualWaterFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisualWaterFlow>();
	}
};
static_assert(alignof(UVisualWaterFlow) == 0x000008, "Wrong alignment on UVisualWaterFlow");
static_assert(sizeof(UVisualWaterFlow) == 0x000040, "Wrong size on UVisualWaterFlow");
static_assert(offsetof(UVisualWaterFlow, NiagaraComponent) == 0x000030, "Member 'UVisualWaterFlow::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(UVisualWaterFlow, SplineComponent) == 0x000038, "Member 'UVisualWaterFlow::SplineComponent' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10471201
// 0x0080 (0x0ED0 - 0x0E50)
class ACue_Ability_Loop_10471201 final : public AMarvelCueNotify_Ability
{
public:
	class UNiagaraComponent*                      NS_WaterFlow;                                      // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       SplineComponent;                                   // 0x0E58(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         NS_WaterFlowSystem;                                // 0x0E60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<uint64, class UVisualWaterFlow*>         WaterFlowVisuals;                                  // 0x0E68(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UVisualWaterFlow*>               VisualWaterFlowPool;                               // 0x0EB8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UAbility_104712*                        Ability_104712;                                    // 0x0EC8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10471201">();
	}
	static class ACue_Ability_Loop_10471201* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10471201>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10471201) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10471201");
static_assert(sizeof(ACue_Ability_Loop_10471201) == 0x000ED0, "Wrong size on ACue_Ability_Loop_10471201");
static_assert(offsetof(ACue_Ability_Loop_10471201, NS_WaterFlow) == 0x000E50, "Member 'ACue_Ability_Loop_10471201::NS_WaterFlow' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471201, SplineComponent) == 0x000E58, "Member 'ACue_Ability_Loop_10471201::SplineComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471201, NS_WaterFlowSystem) == 0x000E60, "Member 'ACue_Ability_Loop_10471201::NS_WaterFlowSystem' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471201, WaterFlowVisuals) == 0x000E68, "Member 'ACue_Ability_Loop_10471201::WaterFlowVisuals' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471201, VisualWaterFlowPool) == 0x000EB8, "Member 'ACue_Ability_Loop_10471201::VisualWaterFlowPool' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10471201, Ability_104712) == 0x000EC8, "Member 'ACue_Ability_Loop_10471201::Ability_104712' has a wrong offset!");

// Class Hero_1047.WaterProjectileMovementComponent
// 0x0010 (0x2000 - 0x1FF0)
class UWaterProjectileMovementComponent final : public UMarvelProjectileComponent
{
public:
	class UCurveFloat*                            ProjectileVelocityCurveByTime;                     // 0x1FE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FF0[0x10];                                    // 0x1FF0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterProjectileMovementComponent">();
	}
	static class UWaterProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterProjectileMovementComponent>();
	}
};
static_assert(alignof(UWaterProjectileMovementComponent) == 0x000010, "Wrong alignment on UWaterProjectileMovementComponent");
static_assert(sizeof(UWaterProjectileMovementComponent) == 0x002000, "Wrong size on UWaterProjectileMovementComponent");
static_assert(offsetof(UWaterProjectileMovementComponent, ProjectileVelocityCurveByTime) == 0x001FE8, "Member 'UWaterProjectileMovementComponent::ProjectileVelocityCurveByTime' has a wrong offset!");

// Class Hero_1047.Config_104713
// 0x0020 (0x0148 - 0x0128)
class UConfig_104713 final : public UConfig_104711
{
public:
	float                                         PaintRadius;                                       // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaintIneral;                                       // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PaintRadiusSize;                                   // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     PigmentActor;                                      // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104713">();
	}
	static class UConfig_104713* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104713>();
	}
};
static_assert(alignof(UConfig_104713) == 0x000008, "Wrong alignment on UConfig_104713");
static_assert(sizeof(UConfig_104713) == 0x000148, "Wrong size on UConfig_104713");
static_assert(offsetof(UConfig_104713, PaintRadius) == 0x000128, "Member 'UConfig_104713::PaintRadius' has a wrong offset!");
static_assert(offsetof(UConfig_104713, PaintIneral) == 0x00012C, "Member 'UConfig_104713::PaintIneral' has a wrong offset!");
static_assert(offsetof(UConfig_104713, PaintRadiusSize) == 0x000130, "Member 'UConfig_104713::PaintRadiusSize' has a wrong offset!");
static_assert(offsetof(UConfig_104713, PigmentActor) == 0x000140, "Member 'UConfig_104713::PigmentActor' has a wrong offset!");

// Class Hero_1047.Projectile_10471301
// 0x0000 (0x30E0 - 0x30E0)
class AProjectile_10471301 final : public AProjectile_10471101
{
public:
	void K2_JeffPaintOnLocation(const struct FJeffPaintParams& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10471301">();
	}
	static class AProjectile_10471301* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10471301>();
	}
};
static_assert(alignof(AProjectile_10471301) == 0x000010, "Wrong alignment on AProjectile_10471301");
static_assert(sizeof(AProjectile_10471301) == 0x0030E0, "Wrong size on AProjectile_10471301");

// Class Hero_1047.JeffWinterFestivalLibrary
// 0x0000 (0x0030 - 0x0030)
class UJeffWinterFestivalLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void JeffPaintOnLocation(const struct FJeffPaintParams& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffWinterFestivalLibrary">();
	}
	static class UJeffWinterFestivalLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffWinterFestivalLibrary>();
	}
};
static_assert(alignof(UJeffWinterFestivalLibrary) == 0x000008, "Wrong alignment on UJeffWinterFestivalLibrary");
static_assert(sizeof(UJeffWinterFestivalLibrary) == 0x000030, "Wrong size on UJeffWinterFestivalLibrary");

// Class Hero_1047.Cue_Ability_Loop_10473101
// 0x0078 (0x0EC8 - 0x0E50)
class ACue_Ability_Loop_10473101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E50[0x10];                                     // 0x0E50(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BlockTags;                                         // 0x0E60(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void CheckMovementModeByState(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnSystemFinished(class UNiagaraComponent* PSystem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10473101">();
	}
	static class ACue_Ability_Loop_10473101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10473101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10473101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10473101");
static_assert(sizeof(ACue_Ability_Loop_10473101) == 0x000EC8, "Wrong size on ACue_Ability_Loop_10473101");
static_assert(offsetof(ACue_Ability_Loop_10473101, BlockTags) == 0x000E60, "Member 'ACue_Ability_Loop_10473101::BlockTags' has a wrong offset!");

// Class Hero_1047.Config_104751
// 0x0008 (0x00A0 - 0x0098)
class UConfig_104751 final : public UMarvelAbilityConfig
{
public:
	float                                         SphereRadius;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104751">();
	}
	static class UConfig_104751* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104751>();
	}
};
static_assert(alignof(UConfig_104751) == 0x000008, "Wrong alignment on UConfig_104751");
static_assert(sizeof(UConfig_104751) == 0x0000A0, "Wrong size on UConfig_104751");
static_assert(offsetof(UConfig_104751, SphereRadius) == 0x000098, "Member 'UConfig_104751::SphereRadius' has a wrong offset!");

// Class Hero_1047.Summoned_10475101
// 0x0020 (0x08B0 - 0x0890)
class ASummoned_10475101 : public AMarvelSummonerBase
{
public:
	class USphereComponent*                       OverlapCollisionComponent;                         // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlapHandlerComponent*               OverlapHandleComponent;                            // 0x0898(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A0[0x8];                                      // 0x08A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InstigatorUID;                                     // 0x08A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8AC[0x4];                                      // 0x08AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorOverlap(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10475101">();
	}
	static class ASummoned_10475101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10475101>();
	}
};
static_assert(alignof(ASummoned_10475101) == 0x000010, "Wrong alignment on ASummoned_10475101");
static_assert(sizeof(ASummoned_10475101) == 0x0008B0, "Wrong size on ASummoned_10475101");
static_assert(offsetof(ASummoned_10475101, OverlapCollisionComponent) == 0x000890, "Member 'ASummoned_10475101::OverlapCollisionComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10475101, OverlapHandleComponent) == 0x000898, "Member 'ASummoned_10475101::OverlapHandleComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10475101, InstigatorUID) == 0x0008A8, "Member 'ASummoned_10475101::InstigatorUID' has a wrong offset!");

// Class Hero_1047.Projectile_10475101
// 0x0000 (0x3050 - 0x3050)
class AProjectile_10475101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	bool CheckBubblePlacingSpace(struct FVector* BubbleLocation, const struct FHitResult& InHitResult, float BubbleRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10475101">();
	}
	static class AProjectile_10475101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10475101>();
	}
};
static_assert(alignof(AProjectile_10475101) == 0x000010, "Wrong alignment on AProjectile_10475101");
static_assert(sizeof(AProjectile_10475101) == 0x003050, "Wrong size on AProjectile_10475101");

// Class Hero_1047.Config_104761
// 0x0100 (0x0198 - 0x0098)
class UConfig_104761 : public UMarvelAbilityConfig
{
public:
	struct FGameplayTag                           DivingGameplayTag;                                 // 0x0098(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     IgnoreCollisionChannels;                           // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class FName>                             DivingHideMaterialSlots;                           // 0x00B8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<class FName>                             DivingParamMaterialSlots;                          // 0x0108(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         DivingOrientRotationLerpSpeed;                     // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChildActorMeshLerpSpeed;                           // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRelativeRotator;                             // 0x0160(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         EnterDivingCameraShake;                            // 0x0178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         ExitDivingCameraShake;                             // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraInterp*                          DivingCameraInterp;                                // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocal;                                           // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104761">();
	}
	static class UConfig_104761* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104761>();
	}
};
static_assert(alignof(UConfig_104761) == 0x000008, "Wrong alignment on UConfig_104761");
static_assert(sizeof(UConfig_104761) == 0x000198, "Wrong size on UConfig_104761");
static_assert(offsetof(UConfig_104761, DivingGameplayTag) == 0x000098, "Member 'UConfig_104761::DivingGameplayTag' has a wrong offset!");
static_assert(offsetof(UConfig_104761, IgnoreCollisionChannels) == 0x0000A8, "Member 'UConfig_104761::IgnoreCollisionChannels' has a wrong offset!");
static_assert(offsetof(UConfig_104761, DivingHideMaterialSlots) == 0x0000B8, "Member 'UConfig_104761::DivingHideMaterialSlots' has a wrong offset!");
static_assert(offsetof(UConfig_104761, DivingParamMaterialSlots) == 0x000108, "Member 'UConfig_104761::DivingParamMaterialSlots' has a wrong offset!");
static_assert(offsetof(UConfig_104761, DivingOrientRotationLerpSpeed) == 0x000158, "Member 'UConfig_104761::DivingOrientRotationLerpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104761, ChildActorMeshLerpSpeed) == 0x00015C, "Member 'UConfig_104761::ChildActorMeshLerpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104761, TargetRelativeRotator) == 0x000160, "Member 'UConfig_104761::TargetRelativeRotator' has a wrong offset!");
static_assert(offsetof(UConfig_104761, EnterDivingCameraShake) == 0x000178, "Member 'UConfig_104761::EnterDivingCameraShake' has a wrong offset!");
static_assert(offsetof(UConfig_104761, ExitDivingCameraShake) == 0x000180, "Member 'UConfig_104761::ExitDivingCameraShake' has a wrong offset!");
static_assert(offsetof(UConfig_104761, DivingCameraInterp) == 0x000188, "Member 'UConfig_104761::DivingCameraInterp' has a wrong offset!");
static_assert(offsetof(UConfig_104761, IsLocal) == 0x000190, "Member 'UConfig_104761::IsLocal' has a wrong offset!");

// Class Hero_1047.Ability_104761
// 0x00A0 (0x2620 - 0x2580)
class UAbility_104761 : public UMarvelGameplayAbility
{
public:
	struct FPredictionKey                         GravityRestoreKey;                                 // 0x2580(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104761">();
	}
	static class UAbility_104761* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104761>();
	}
};
static_assert(alignof(UAbility_104761) == 0x000008, "Wrong alignment on UAbility_104761");
static_assert(sizeof(UAbility_104761) == 0x002620, "Wrong size on UAbility_104761");
static_assert(offsetof(UAbility_104761, GravityRestoreKey) == 0x002580, "Member 'UAbility_104761::GravityRestoreKey' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10476101
// 0x00B8 (0x0F08 - 0x0E50)
class ACue_Ability_Loop_10476101 final : public AMarvelCueNotify_Ability
{
public:
	int32                                         DivingLoopAudioID;                                 // 0x0E50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartMoveAudioID;                                  // 0x0E54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopMoveAudioID;                                   // 0x0E58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMoveAudioProtectTime;                         // 0x0E5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopMoveAudioDelayTime;                            // 0x0E60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E64[0x4];                                      // 0x0E64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      LoopNX_1;                                          // 0x0E68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNX_2;                                          // 0x0E70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceDirectionParamName;                           // 0x0E78(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E84[0x4];                                      // 0x0E84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AJeffCharacter*                         JeffCharacter;                                     // 0x0E88(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJeffMovementComponent*                 JeffCharacterMovement;                             // 0x0E90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104761*                         DivingConfig;                                      // 0x0E98(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FSpringArmControlHandler> SpringArmHandlers;                                 // 0x0EA0(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UCameraShakeBase*                       EnterDivingShakeHandle;                            // 0x0EF0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EF8[0x10];                                     // 0x0EF8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnJeffStateUpdate(EJeffState InState);
	void OnOwnerTagUpdate(const struct FGameplayTag& Tag, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10476101">();
	}
	static class ACue_Ability_Loop_10476101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10476101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10476101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10476101");
static_assert(sizeof(ACue_Ability_Loop_10476101) == 0x000F08, "Wrong size on ACue_Ability_Loop_10476101");
static_assert(offsetof(ACue_Ability_Loop_10476101, DivingLoopAudioID) == 0x000E50, "Member 'ACue_Ability_Loop_10476101::DivingLoopAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, StartMoveAudioID) == 0x000E54, "Member 'ACue_Ability_Loop_10476101::StartMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, LoopMoveAudioID) == 0x000E58, "Member 'ACue_Ability_Loop_10476101::LoopMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, StartMoveAudioProtectTime) == 0x000E5C, "Member 'ACue_Ability_Loop_10476101::StartMoveAudioProtectTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, LoopMoveAudioDelayTime) == 0x000E60, "Member 'ACue_Ability_Loop_10476101::LoopMoveAudioDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, LoopNX_1) == 0x000E68, "Member 'ACue_Ability_Loop_10476101::LoopNX_1' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, LoopNX_2) == 0x000E70, "Member 'ACue_Ability_Loop_10476101::LoopNX_2' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, TraceDirectionParamName) == 0x000E78, "Member 'ACue_Ability_Loop_10476101::TraceDirectionParamName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, JeffCharacter) == 0x000E88, "Member 'ACue_Ability_Loop_10476101::JeffCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, JeffCharacterMovement) == 0x000E90, "Member 'ACue_Ability_Loop_10476101::JeffCharacterMovement' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, DivingConfig) == 0x000E98, "Member 'ACue_Ability_Loop_10476101::DivingConfig' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, SpringArmHandlers) == 0x000EA0, "Member 'ACue_Ability_Loop_10476101::SpringArmHandlers' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10476101, EnterDivingShakeHandle) == 0x000EF0, "Member 'ACue_Ability_Loop_10476101::EnterDivingShakeHandle' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_Jeff_Diving
// 0x0038 (0x0E88 - 0x0E50)
class ACue_Ability_Loop_Jeff_Diving final : public AMarvelCueNotify_Ability
{
public:
	int32                                         DivingEnvAudioID;                                  // 0x0E50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DivingMovementAudioID;                             // 0x0E54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DivingStartMoveAudioID;                            // 0x0E58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DivingStartMoveAudioProtectTime;                   // 0x0E5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DivingMovementAudioDelayTime;                      // 0x0E60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E64[0x4];                                      // 0x0E64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AJeffCharacter*                         JeffCharacter;                                     // 0x0E68(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelCharacterMovementComponent*      CharacterMovementComp;                             // 0x0E70(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E78[0x10];                                     // 0x0E78(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnJeffStateUpdate(EJeffState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_Jeff_Diving">();
	}
	static class ACue_Ability_Loop_Jeff_Diving* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_Jeff_Diving>();
	}
};
static_assert(alignof(ACue_Ability_Loop_Jeff_Diving) == 0x000008, "Wrong alignment on ACue_Ability_Loop_Jeff_Diving");
static_assert(sizeof(ACue_Ability_Loop_Jeff_Diving) == 0x000E88, "Wrong size on ACue_Ability_Loop_Jeff_Diving");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, DivingEnvAudioID) == 0x000E50, "Member 'ACue_Ability_Loop_Jeff_Diving::DivingEnvAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, DivingMovementAudioID) == 0x000E54, "Member 'ACue_Ability_Loop_Jeff_Diving::DivingMovementAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, DivingStartMoveAudioID) == 0x000E58, "Member 'ACue_Ability_Loop_Jeff_Diving::DivingStartMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, DivingStartMoveAudioProtectTime) == 0x000E5C, "Member 'ACue_Ability_Loop_Jeff_Diving::DivingStartMoveAudioProtectTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, DivingMovementAudioDelayTime) == 0x000E60, "Member 'ACue_Ability_Loop_Jeff_Diving::DivingMovementAudioDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, JeffCharacter) == 0x000E68, "Member 'ACue_Ability_Loop_Jeff_Diving::JeffCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Jeff_Diving, CharacterMovementComp) == 0x000E70, "Member 'ACue_Ability_Loop_Jeff_Diving::CharacterMovementComp' has a wrong offset!");

// Class Hero_1047.AnimNotify_JeffExitDivingPlayNiagaraEffect
// 0x0000 (0x0360 - 0x0360)
class UAnimNotify_JeffExitDivingPlayNiagaraEffect final : public UAnimNotify_PlayNiagaraEffectEx
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_JeffExitDivingPlayNiagaraEffect">();
	}
	static class UAnimNotify_JeffExitDivingPlayNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_JeffExitDivingPlayNiagaraEffect>();
	}
};
static_assert(alignof(UAnimNotify_JeffExitDivingPlayNiagaraEffect) == 0x000010, "Wrong alignment on UAnimNotify_JeffExitDivingPlayNiagaraEffect");
static_assert(sizeof(UAnimNotify_JeffExitDivingPlayNiagaraEffect) == 0x000360, "Wrong size on UAnimNotify_JeffExitDivingPlayNiagaraEffect");

// Class Hero_1047.Config_104762_New
// 0x0000 (0x00E0 - 0x00E0)
class UConfig_104762_New final : public UWallRunningPassiveAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104762_New">();
	}
	static class UConfig_104762_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104762_New>();
	}
};
static_assert(alignof(UConfig_104762_New) == 0x000008, "Wrong alignment on UConfig_104762_New");
static_assert(sizeof(UConfig_104762_New) == 0x0000E0, "Wrong size on UConfig_104762_New");

// Class Hero_1047.Ability_104762_New
// 0x0008 (0x25A0 - 0x2598)
class UAbility_104762_New : public UWallRunningPassiveAbility
{
public:
	uint8                                         Pad_2598[0x8];                                     // 0x2598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104762_New">();
	}
	static class UAbility_104762_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104762_New>();
	}
};
static_assert(alignof(UAbility_104762_New) == 0x000008, "Wrong alignment on UAbility_104762_New");
static_assert(sizeof(UAbility_104762_New) == 0x0025A0, "Wrong size on UAbility_104762_New");

// Class Hero_1047.Config_104763_New
// 0x0000 (0x0118 - 0x0118)
class UConfig_104763_New : public UWallRunningAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104763_New">();
	}
	static class UConfig_104763_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104763_New>();
	}
};
static_assert(alignof(UConfig_104763_New) == 0x000008, "Wrong alignment on UConfig_104763_New");
static_assert(sizeof(UConfig_104763_New) == 0x000118, "Wrong size on UConfig_104763_New");

// Class Hero_1047.Ability_104763_New
// 0x0000 (0x2608 - 0x2608)
class UAbility_104763_New : public UWallRunningAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104763_New">();
	}
	static class UAbility_104763_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104763_New>();
	}
};
static_assert(alignof(UAbility_104763_New) == 0x000008, "Wrong alignment on UAbility_104763_New");
static_assert(sizeof(UAbility_104763_New) == 0x002608, "Wrong size on UAbility_104763_New");

// Class Hero_1047.Config_104771
// 0x0148 (0x01E0 - 0x0098)
class UConfig_104771 : public UMarvelAbilityConfig
{
public:
	struct FSelectRegionConfig                    SelectRegionConfig;                                // 0x0098(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EnterLocatorCameraTranslation;                     // 0x00B8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EnterLocatorCameraRotation;                        // 0x00D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EnterLocatorCameraInterpSpeed;                     // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocatorTopViewCameraZ;                             // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AltitudeUpperLimit;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AltitudeLowerLimit;                                // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTopViewPushUpSpeed;                          // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTopViewPushDownSpeed;                        // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningDurationSeconds;                            // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EnterWarningCameraTranslation;                     // 0x0108(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EnterWarningCameraRotation;                        // 0x0120(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EnterWarningCameraInterpSpeed;                     // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevourCharacterLagSpeed;                           // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevourCharacterLagMaxDistance;                     // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DirectKnockUpBuffID;                               // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomKnockUpBuffID;                               // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyDirectKnockUpBuffID;                          // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyRandomKnockUpBuffID;                          // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DispelBuffsBeforeSpitOut;                          // 0x0158(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                SpitOutDir;                                        // 0x01C0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DevourBuffID;                                      // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104771">();
	}
	static class UConfig_104771* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104771>();
	}
};
static_assert(alignof(UConfig_104771) == 0x000008, "Wrong alignment on UConfig_104771");
static_assert(sizeof(UConfig_104771) == 0x0001E0, "Wrong size on UConfig_104771");
static_assert(offsetof(UConfig_104771, SelectRegionConfig) == 0x000098, "Member 'UConfig_104771::SelectRegionConfig' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterLocatorCameraTranslation) == 0x0000B8, "Member 'UConfig_104771::EnterLocatorCameraTranslation' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterLocatorCameraRotation) == 0x0000D0, "Member 'UConfig_104771::EnterLocatorCameraRotation' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterLocatorCameraInterpSpeed) == 0x0000E8, "Member 'UConfig_104771::EnterLocatorCameraInterpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104771, LocatorTopViewCameraZ) == 0x0000EC, "Member 'UConfig_104771::LocatorTopViewCameraZ' has a wrong offset!");
static_assert(offsetof(UConfig_104771, AltitudeUpperLimit) == 0x0000F0, "Member 'UConfig_104771::AltitudeUpperLimit' has a wrong offset!");
static_assert(offsetof(UConfig_104771, AltitudeLowerLimit) == 0x0000F4, "Member 'UConfig_104771::AltitudeLowerLimit' has a wrong offset!");
static_assert(offsetof(UConfig_104771, CameraTopViewPushUpSpeed) == 0x0000F8, "Member 'UConfig_104771::CameraTopViewPushUpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104771, CameraTopViewPushDownSpeed) == 0x0000FC, "Member 'UConfig_104771::CameraTopViewPushDownSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104771, WarningDurationSeconds) == 0x000100, "Member 'UConfig_104771::WarningDurationSeconds' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterWarningCameraTranslation) == 0x000108, "Member 'UConfig_104771::EnterWarningCameraTranslation' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterWarningCameraRotation) == 0x000120, "Member 'UConfig_104771::EnterWarningCameraRotation' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnterWarningCameraInterpSpeed) == 0x000138, "Member 'UConfig_104771::EnterWarningCameraInterpSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104771, DevourCharacterLagSpeed) == 0x00013C, "Member 'UConfig_104771::DevourCharacterLagSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_104771, DevourCharacterLagMaxDistance) == 0x000140, "Member 'UConfig_104771::DevourCharacterLagMaxDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104771, DirectKnockUpBuffID) == 0x000144, "Member 'UConfig_104771::DirectKnockUpBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104771, RandomKnockUpBuffID) == 0x000148, "Member 'UConfig_104771::RandomKnockUpBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnemyDirectKnockUpBuffID) == 0x00014C, "Member 'UConfig_104771::EnemyDirectKnockUpBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104771, EnemyRandomKnockUpBuffID) == 0x000150, "Member 'UConfig_104771::EnemyRandomKnockUpBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104771, DispelBuffsBeforeSpitOut) == 0x000158, "Member 'UConfig_104771::DispelBuffsBeforeSpitOut' has a wrong offset!");
static_assert(offsetof(UConfig_104771, SpitOutDir) == 0x0001C0, "Member 'UConfig_104771::SpitOutDir' has a wrong offset!");
static_assert(offsetof(UConfig_104771, DevourBuffID) == 0x0001D8, "Member 'UConfig_104771::DevourBuffID' has a wrong offset!");

// Class Hero_1047.Ability_104771
// 0x04A8 (0x2A28 - 0x2580)
class UAbility_104771 : public UMarvelGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             OnStateChanged;                                    // 0x2580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectRegionFinishDelegate;                      // 0x2590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDevouredCharacterChanged;                        // 0x25A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSelectRegionConfig                    MoveConfigCache;                                   // 0x25B0(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_25CC[0x4];                                     // 0x25CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_104771*                         Config;                                            // 0x25D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         Selection_StartKey;                                // 0x25D8(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         Selection_EnterTopViewKey;                         // 0x2678(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         Selection_ExitTopViewKey;                          // 0x2718(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         Selection_WarningKey;                              // 0x27B8(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         Selection_ClearKey;                                // 0x2858(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         AbilityEnd_ClearKey;                               // 0x28F8(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_SelectRegionAttack*  SelectRegionAttack;                                // 0x2998(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDevouredCharactersData                DevouredCharactersData;                            // 0x29A0(0x0058)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_29F8[0x8];                                     // 0x29F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDevouredCharactersDataWasSet;                     // 0x2A00(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSelectionRegionTopView;                         // 0x2A01(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A02[0x2];                                     // 0x2A02(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedSpringArmLength;                             // 0x2A04(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CachedSpringArmSocketOffset;                       // 0x2A08(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilityState_104771                          CurrentAbilityState;                               // 0x2A20(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FWarningNotify                         WarningNotify;                                     // 0x2A21(0x0002)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A23[0x5];                                     // 0x2A23(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AfterSetDevourCharacters();
	void DevourCharactersWhenStartSwimming();
	bool ExpandCapsuleSize();
	TArray<class AActor*> GetAliveDevouredCharacter();
	void HandleOwnerBuff(int32 BuffID, bool bNeedApply);
	void OnDevouredCharacterChanged__DelegateSignature();
	void OnDevouredCharacterDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnDevouredCharacterDisguiseEnd(class AMarvelBaseCharacter* InDisguiseCharacter, class AMarvelBaseCharacter* InOriginCharacter, bool bIsAvatorAlive);
	void OnDevourSummonedEndAgentTask(class AActor* InSummoned);
	void OnRep_ReplicatedCurrentAbilityState();
	void OnRep_ReplicatedDevourCharactersData();
	void OnRep_ReplicatedWarningNotify();
	void OnSelectRegionFinish(bool bActivateByTimerOrMT);
	void OnStateChanged__DelegateSignature();
	void OnUpdateDevouredCharactersData();
	void ReStartDivingBuff(float RemainDuration);
	bool RestoreCapsuleSize();
	void SetCurrentAbilityState(const EAbilityState_104771 CurrentAbilityState_0);
	void SetDevourCharactersFromScope(const TArray<TWeakObjectPtr<class AActor>>& InDevourCharactersList);
	void SetMoveLogicFrame_AbilityEndClear();
	void SetMoveLogicFrame_EnterTopView();
	void SetMoveLogicFrame_ExitTopView();
	void SetMoveLogicFrame_SelectionClear();
	void SetMoveLogicFrame_SelectionStart();
	void SetMoveLogicFrame_SelectionWarning();
	void SpitOutImpl(bool bSpitOutAll, bool bSpitOutEnemy, bool bKnockUp);
	float StopDivingBuff();
	void SwitchSelectionRegionTopView(bool bToTopView, bool bButtonSwitch);

	EAbilityState_104771 GetCurrentAbilityState() const;
	TArray<class AActor*> GetDevouredAlly() const;
	TArray<class AActor*> GetDevouredEnemy() const;
	bool HaveDevouredAlly() const;
	bool HaveDevouredEnemy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104771">();
	}
	static class UAbility_104771* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104771>();
	}
};
static_assert(alignof(UAbility_104771) == 0x000008, "Wrong alignment on UAbility_104771");
static_assert(sizeof(UAbility_104771) == 0x002A28, "Wrong size on UAbility_104771");
static_assert(offsetof(UAbility_104771, OnStateChanged) == 0x002580, "Member 'UAbility_104771::OnStateChanged' has a wrong offset!");
static_assert(offsetof(UAbility_104771, OnSelectRegionFinishDelegate) == 0x002590, "Member 'UAbility_104771::OnSelectRegionFinishDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_104771, OnDevouredCharacterChanged) == 0x0025A0, "Member 'UAbility_104771::OnDevouredCharacterChanged' has a wrong offset!");
static_assert(offsetof(UAbility_104771, MoveConfigCache) == 0x0025B0, "Member 'UAbility_104771::MoveConfigCache' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Config) == 0x0025D0, "Member 'UAbility_104771::Config' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Selection_StartKey) == 0x0025D8, "Member 'UAbility_104771::Selection_StartKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Selection_EnterTopViewKey) == 0x002678, "Member 'UAbility_104771::Selection_EnterTopViewKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Selection_ExitTopViewKey) == 0x002718, "Member 'UAbility_104771::Selection_ExitTopViewKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Selection_WarningKey) == 0x0027B8, "Member 'UAbility_104771::Selection_WarningKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, Selection_ClearKey) == 0x002858, "Member 'UAbility_104771::Selection_ClearKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, AbilityEnd_ClearKey) == 0x0028F8, "Member 'UAbility_104771::AbilityEnd_ClearKey' has a wrong offset!");
static_assert(offsetof(UAbility_104771, SelectRegionAttack) == 0x002998, "Member 'UAbility_104771::SelectRegionAttack' has a wrong offset!");
static_assert(offsetof(UAbility_104771, DevouredCharactersData) == 0x0029A0, "Member 'UAbility_104771::DevouredCharactersData' has a wrong offset!");
static_assert(offsetof(UAbility_104771, bDevouredCharactersDataWasSet) == 0x002A00, "Member 'UAbility_104771::bDevouredCharactersDataWasSet' has a wrong offset!");
static_assert(offsetof(UAbility_104771, bIsSelectionRegionTopView) == 0x002A01, "Member 'UAbility_104771::bIsSelectionRegionTopView' has a wrong offset!");
static_assert(offsetof(UAbility_104771, CachedSpringArmLength) == 0x002A04, "Member 'UAbility_104771::CachedSpringArmLength' has a wrong offset!");
static_assert(offsetof(UAbility_104771, CachedSpringArmSocketOffset) == 0x002A08, "Member 'UAbility_104771::CachedSpringArmSocketOffset' has a wrong offset!");
static_assert(offsetof(UAbility_104771, CurrentAbilityState) == 0x002A20, "Member 'UAbility_104771::CurrentAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_104771, WarningNotify) == 0x002A21, "Member 'UAbility_104771::WarningNotify' has a wrong offset!");

// Class Hero_1047.JeffPassengerContainerComponent
// 0x0010 (0x0480 - 0x0470)
class UJeffPassengerContainerComponent final : public USceneComponent
{
public:
	TArray<TWeakObjectPtr<class AActor>>          DevouredCharList;                                  // 0x0470(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void Client_AttachPassengerAndUpdateComponentTickPrerequisite(class AActor* InAttachPassenger);
	void Client_DetachPassengerAndUpdateComponentTickPrerequisite(class AActor* InDetachPassenger);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffPassengerContainerComponent">();
	}
	static class UJeffPassengerContainerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffPassengerContainerComponent>();
	}
};
static_assert(alignof(UJeffPassengerContainerComponent) == 0x000010, "Wrong alignment on UJeffPassengerContainerComponent");
static_assert(sizeof(UJeffPassengerContainerComponent) == 0x000480, "Wrong size on UJeffPassengerContainerComponent");
static_assert(offsetof(UJeffPassengerContainerComponent, DevouredCharList) == 0x000470, "Member 'UJeffPassengerContainerComponent::DevouredCharList' has a wrong offset!");

// Class Hero_1047.EffectiveComponent_10477101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10477101 : public UMarvelAgentEffectiveComponent
{
public:
	TArray<struct FHitResult> K2_OnPreApplyContainer(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10477101">();
	}
	static class UEffectiveComponent_10477101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10477101>();
	}
};
static_assert(alignof(UEffectiveComponent_10477101) == 0x000010, "Wrong alignment on UEffectiveComponent_10477101");
static_assert(sizeof(UEffectiveComponent_10477101) == 0x001C00, "Wrong size on UEffectiveComponent_10477101");

// Class Hero_1047.EffectiveComponent_10477103
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10477103 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10477103">();
	}
	static class UEffectiveComponent_10477103* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10477103>();
	}
};
static_assert(alignof(UEffectiveComponent_10477103) == 0x000010, "Wrong alignment on UEffectiveComponent_10477103");
static_assert(sizeof(UEffectiveComponent_10477103) == 0x001C00, "Wrong size on UEffectiveComponent_10477103");

// Class Hero_1047.TestMarvelAbilityTask
// 0x0018 (0x01F0 - 0x01D8)
class UTestMarvelAbilityTask : public UAbilityTask
{
public:
	TArray<class UGameplayTask*>                  SubTasks;                                          // 0x01D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsEnding;                                         // 0x01E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestMarvelAbilityTask">();
	}
	static class UTestMarvelAbilityTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestMarvelAbilityTask>();
	}
};
static_assert(alignof(UTestMarvelAbilityTask) == 0x000008, "Wrong alignment on UTestMarvelAbilityTask");
static_assert(sizeof(UTestMarvelAbilityTask) == 0x0001F0, "Wrong size on UTestMarvelAbilityTask");
static_assert(offsetof(UTestMarvelAbilityTask, SubTasks) == 0x0001D8, "Member 'UTestMarvelAbilityTask::SubTasks' has a wrong offset!");
static_assert(offsetof(UTestMarvelAbilityTask, bIsEnding) == 0x0001E8, "Member 'UTestMarvelAbilityTask::bIsEnding' has a wrong offset!");

// Class Hero_1047.MarvelAbilityTask_SelectRegionAttack
// 0x0190 (0x0380 - 0x01F0)
class UMarvelAbilityTask_SelectRegionAttack final : public UTestMarvelAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnSelectRegionFinish;                              // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectRegionWarningFinish;                       // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_WaitBindInput*       ConfirmInputTask;                                  // 0x0210(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMarvelAbilityTask_WaitDelay*           SelectingDelayTask;                                // 0x0218(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           WarningScopeTimer;                                 // 0x0220(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPredictionKey                         SelectionKeySeed;                                  // 0x0238(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPredictionKey                         WarningKeySeed;                                    // 0x02D8(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMarvelAbilityTask_SelectRegionAttack* SelectRegionAttack(class UMarvelGameplayAbility* OwningAbility, class FName ConfirmMethodName, float SelectionWarningDuration);

	void OnLocateFinish(bool bActiveByTimerOrMT);
	void OnPressActivateHurricaneKey(float TimeWaited);
	void OnPressCameraAnimationKey(float TimeWaited);
	void OnReleaseCameraAnimationKey(float TimeWaited);
	void OnTimeOverFinish();
	void OnWarningFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAbilityTask_SelectRegionAttack">();
	}
	static class UMarvelAbilityTask_SelectRegionAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAbilityTask_SelectRegionAttack>();
	}
};
static_assert(alignof(UMarvelAbilityTask_SelectRegionAttack) == 0x000008, "Wrong alignment on UMarvelAbilityTask_SelectRegionAttack");
static_assert(sizeof(UMarvelAbilityTask_SelectRegionAttack) == 0x000380, "Wrong size on UMarvelAbilityTask_SelectRegionAttack");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, OnSelectRegionFinish) == 0x0001F0, "Member 'UMarvelAbilityTask_SelectRegionAttack::OnSelectRegionFinish' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, OnSelectRegionWarningFinish) == 0x000200, "Member 'UMarvelAbilityTask_SelectRegionAttack::OnSelectRegionWarningFinish' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, ConfirmInputTask) == 0x000210, "Member 'UMarvelAbilityTask_SelectRegionAttack::ConfirmInputTask' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, SelectingDelayTask) == 0x000218, "Member 'UMarvelAbilityTask_SelectRegionAttack::SelectingDelayTask' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, WarningScopeTimer) == 0x000220, "Member 'UMarvelAbilityTask_SelectRegionAttack::WarningScopeTimer' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, SelectionKeySeed) == 0x000238, "Member 'UMarvelAbilityTask_SelectRegionAttack::SelectionKeySeed' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_SelectRegionAttack, WarningKeySeed) == 0x0002D8, "Member 'UMarvelAbilityTask_SelectRegionAttack::WarningKeySeed' has a wrong offset!");

// Class Hero_1047.KnockUp_10477109
// 0x0020 (0x1DB8 - 0x1D98)
class UKnockUp_10477109 : public UMarvelKnockUpAbility
{
public:
	float                                         RandomSpreadAngle;                                 // 0x1D98(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D9C[0x4];                                     // 0x1D9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantizeNormal              ReplicatedKnockUpDir;                              // 0x1DA0(0x0018)(Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnockUp_10477109">();
	}
	static class UKnockUp_10477109* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnockUp_10477109>();
	}
};
static_assert(alignof(UKnockUp_10477109) == 0x000008, "Wrong alignment on UKnockUp_10477109");
static_assert(sizeof(UKnockUp_10477109) == 0x001DB8, "Wrong size on UKnockUp_10477109");
static_assert(offsetof(UKnockUp_10477109, RandomSpreadAngle) == 0x001D98, "Member 'UKnockUp_10477109::RandomSpreadAngle' has a wrong offset!");
static_assert(offsetof(UKnockUp_10477109, ReplicatedKnockUpDir) == 0x001DA0, "Member 'UKnockUp_10477109::ReplicatedKnockUpDir' has a wrong offset!");

// Class Hero_1047.EffectAbility_10477110
// 0x0000 (0x10F8 - 0x10F8)
class UEffectAbility_10477110 final : public UMarvelEffectGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectAbility_10477110">();
	}
	static class UEffectAbility_10477110* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectAbility_10477110>();
	}
};
static_assert(alignof(UEffectAbility_10477110) == 0x000008, "Wrong alignment on UEffectAbility_10477110");
static_assert(sizeof(UEffectAbility_10477110) == 0x0010F8, "Wrong size on UEffectAbility_10477110");

// Class Hero_1047.Cue_Ability_Loop_10477101
// 0x0048 (0x0E98 - 0x0E50)
class ACue_Ability_Loop_10477101 final : public AMarvelCueNotify_Ability
{
public:
	class UNiagaraComponent*                      SelectRegionFxComp;                                // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      WarnFxComp;                                        // 0x0E58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        SelectRegionDecal;                                 // 0x0E60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityID;                                         // 0x0E68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectRegionScopeId;                               // 0x0E6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectRegionDecalScale;                            // 0x0E70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectPreGenerateFXOffset;                         // 0x0E74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectionAudioID;                                  // 0x0E78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectRegionConfirmAudioID;                        // 0x0E7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FallingDevourAudioID;                              // 0x0E80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DevourCharacterSuccessAudioID;                     // 0x0E84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E88[0x10];                                     // 0x0E88(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDevourCharacterSuccess();
	void OnSelectRegionFinish(bool bActivateByTimerOrMT);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10477101">();
	}
	static class ACue_Ability_Loop_10477101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10477101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10477101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10477101");
static_assert(sizeof(ACue_Ability_Loop_10477101) == 0x000E98, "Wrong size on ACue_Ability_Loop_10477101");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectRegionFxComp) == 0x000E50, "Member 'ACue_Ability_Loop_10477101::SelectRegionFxComp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, WarnFxComp) == 0x000E58, "Member 'ACue_Ability_Loop_10477101::WarnFxComp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectRegionDecal) == 0x000E60, "Member 'ACue_Ability_Loop_10477101::SelectRegionDecal' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, AbilityID) == 0x000E68, "Member 'ACue_Ability_Loop_10477101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectRegionScopeId) == 0x000E6C, "Member 'ACue_Ability_Loop_10477101::SelectRegionScopeId' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectRegionDecalScale) == 0x000E70, "Member 'ACue_Ability_Loop_10477101::SelectRegionDecalScale' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectPreGenerateFXOffset) == 0x000E74, "Member 'ACue_Ability_Loop_10477101::SelectPreGenerateFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectionAudioID) == 0x000E78, "Member 'ACue_Ability_Loop_10477101::SelectionAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, SelectRegionConfirmAudioID) == 0x000E7C, "Member 'ACue_Ability_Loop_10477101::SelectRegionConfirmAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, FallingDevourAudioID) == 0x000E80, "Member 'ACue_Ability_Loop_10477101::FallingDevourAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10477101, DevourCharacterSuccessAudioID) == 0x000E84, "Member 'ACue_Ability_Loop_10477101::DevourCharacterSuccessAudioID' has a wrong offset!");

// Class Hero_1047.Config_104781
// 0x0E30 (0x2060 - 0x1230)
class UConfig_104781 : public UMarvelSelectTargetConfig
{
public:
	int32                                         BondID;                                            // 0x1228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOptimizeGameStateFindGroot;                       // 0x122C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122D[0x3];                                     // 0x122D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrootFilterDistance;                               // 0x1230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1234[0x4];                                     // 0x1234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDashAbilityInfo                       DashToGrootInfo;                                   // 0x1238(0x0BA8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockAbilityTagsWhenFlying;                        // 0x1DE0(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   GrootSocketName;                                   // 0x1E48(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitShapeScale;                                     // 0x1E54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GrootDetachTagContainer;                           // 0x1E58(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  JeffDetachTagContainer;                            // 0x1EC0(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UCameraInterp*                          RidingCameraInterp;                                // 0x1F28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateChangedTaskParam                 ExitRideInputSetting;                              // 0x1F30(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExitRideWhenJeffTakeDamage;                       // 0x1F58(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F59[0x7];                                     // 0x1F59(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   SameBuffSet;                                       // 0x1F60(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RemoveEffectWithTagsWhileAttach;                   // 0x1FB0(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                AttachCylinderOffset;                              // 0x2018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachMeshOffset;                                  // 0x2030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DettachLaunchVelocity;                             // 0x2048(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104781">();
	}
	static class UConfig_104781* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104781>();
	}
};
static_assert(alignof(UConfig_104781) == 0x000010, "Wrong alignment on UConfig_104781");
static_assert(sizeof(UConfig_104781) == 0x002060, "Wrong size on UConfig_104781");
static_assert(offsetof(UConfig_104781, BondID) == 0x001228, "Member 'UConfig_104781::BondID' has a wrong offset!");
static_assert(offsetof(UConfig_104781, bOptimizeGameStateFindGroot) == 0x00122C, "Member 'UConfig_104781::bOptimizeGameStateFindGroot' has a wrong offset!");
static_assert(offsetof(UConfig_104781, GrootFilterDistance) == 0x001230, "Member 'UConfig_104781::GrootFilterDistance' has a wrong offset!");
static_assert(offsetof(UConfig_104781, DashToGrootInfo) == 0x001238, "Member 'UConfig_104781::DashToGrootInfo' has a wrong offset!");
static_assert(offsetof(UConfig_104781, BlockAbilityTagsWhenFlying) == 0x001DE0, "Member 'UConfig_104781::BlockAbilityTagsWhenFlying' has a wrong offset!");
static_assert(offsetof(UConfig_104781, GrootSocketName) == 0x001E48, "Member 'UConfig_104781::GrootSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_104781, HitShapeScale) == 0x001E54, "Member 'UConfig_104781::HitShapeScale' has a wrong offset!");
static_assert(offsetof(UConfig_104781, GrootDetachTagContainer) == 0x001E58, "Member 'UConfig_104781::GrootDetachTagContainer' has a wrong offset!");
static_assert(offsetof(UConfig_104781, JeffDetachTagContainer) == 0x001EC0, "Member 'UConfig_104781::JeffDetachTagContainer' has a wrong offset!");
static_assert(offsetof(UConfig_104781, RidingCameraInterp) == 0x001F28, "Member 'UConfig_104781::RidingCameraInterp' has a wrong offset!");
static_assert(offsetof(UConfig_104781, ExitRideInputSetting) == 0x001F30, "Member 'UConfig_104781::ExitRideInputSetting' has a wrong offset!");
static_assert(offsetof(UConfig_104781, bExitRideWhenJeffTakeDamage) == 0x001F58, "Member 'UConfig_104781::bExitRideWhenJeffTakeDamage' has a wrong offset!");
static_assert(offsetof(UConfig_104781, SameBuffSet) == 0x001F60, "Member 'UConfig_104781::SameBuffSet' has a wrong offset!");
static_assert(offsetof(UConfig_104781, RemoveEffectWithTagsWhileAttach) == 0x001FB0, "Member 'UConfig_104781::RemoveEffectWithTagsWhileAttach' has a wrong offset!");
static_assert(offsetof(UConfig_104781, AttachCylinderOffset) == 0x002018, "Member 'UConfig_104781::AttachCylinderOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104781, AttachMeshOffset) == 0x002030, "Member 'UConfig_104781::AttachMeshOffset' has a wrong offset!");
static_assert(offsetof(UConfig_104781, DettachLaunchVelocity) == 0x002048, "Member 'UConfig_104781::DettachLaunchVelocity' has a wrong offset!");

// Class Hero_1047.Ability_104781
// 0x0138 (0x2888 - 0x2750)
class UAbility_104781 : public UMarvelSelectTargetAbility
{
public:
	struct FGameplayTag                           MarkOnGrootTag;                                    // 0x2750(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275C[0x4];                                     // 0x275C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnJeffGrootCoopStateChangeDispatcher;              // 0x2760(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EJeffGrootAbilityState                        CurrentState;                                      // 0x2770(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2771[0x7];                                     // 0x2771(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   Groot;                                             // 0x2778(0x0008)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class USceneComponent*, struct FVector>  CachedComponentScaleMap;                           // 0x2780(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D0[0x90];                                    // 0x27D0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelGameState*                       CurrentGameState;                                  // 0x2860(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwningCharacter;                                   // 0x2868(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJeffChildActor*                        JeffChildActor;                                    // 0x2870(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_104781*                         CoopConfig;                                        // 0x2878(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitInputStateChanged* RideCancelTask;                                    // 0x2880(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BindCancelRideInput();
	void BindDettachDelegates(class AActor* InGroot);
	void MarkOnGroot(bool bOnGroot);
	void OnCoopAbilityTickStateChanged(bool bShouldAbilityTick);
	void OnGrootDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnGrootRepToSimulatedRole();
	void OnGrootTagUpdated(const struct FGameplayTag& TagUpdated, bool bTagExists);
	void OnJeffDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnJeffTagUpdated(const struct FGameplayTag& TagUpdated, bool bTagExists);
	void OnJeffTakeDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnRep_CurrentState();
	void OnRep_Groot();
	void OnRideCancel(float StateIntervalTime);
	void Python_AttachToGroot();
	void Python_DetachFromGroot();
	void Python_FailedFlyingToGroot();
	void Python_OnRideCancel();
	void Python_StartFlyingToGroot();
	void ScaleRidingHitShapeSize(bool bEnable);
	void ServerOnRideCancel(float StateIntervalTime);
	void SetJeffState(EJeffGrootAbilityState InState);
	void SetSpringArmIgnore(class AMarvelBaseCharacter* InGroot, class AMarvelBaseCharacter* OwnChar, bool bIgnore);
	void UnBindDettachDelegates(class AActor* InGroot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104781">();
	}
	static class UAbility_104781* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104781>();
	}
};
static_assert(alignof(UAbility_104781) == 0x000008, "Wrong alignment on UAbility_104781");
static_assert(sizeof(UAbility_104781) == 0x002888, "Wrong size on UAbility_104781");
static_assert(offsetof(UAbility_104781, MarkOnGrootTag) == 0x002750, "Member 'UAbility_104781::MarkOnGrootTag' has a wrong offset!");
static_assert(offsetof(UAbility_104781, OnJeffGrootCoopStateChangeDispatcher) == 0x002760, "Member 'UAbility_104781::OnJeffGrootCoopStateChangeDispatcher' has a wrong offset!");
static_assert(offsetof(UAbility_104781, CurrentState) == 0x002770, "Member 'UAbility_104781::CurrentState' has a wrong offset!");
static_assert(offsetof(UAbility_104781, Groot) == 0x002778, "Member 'UAbility_104781::Groot' has a wrong offset!");
static_assert(offsetof(UAbility_104781, CachedComponentScaleMap) == 0x002780, "Member 'UAbility_104781::CachedComponentScaleMap' has a wrong offset!");
static_assert(offsetof(UAbility_104781, CurrentGameState) == 0x002860, "Member 'UAbility_104781::CurrentGameState' has a wrong offset!");
static_assert(offsetof(UAbility_104781, OwningCharacter) == 0x002868, "Member 'UAbility_104781::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_104781, JeffChildActor) == 0x002870, "Member 'UAbility_104781::JeffChildActor' has a wrong offset!");
static_assert(offsetof(UAbility_104781, CoopConfig) == 0x002878, "Member 'UAbility_104781::CoopConfig' has a wrong offset!");
static_assert(offsetof(UAbility_104781, RideCancelTask) == 0x002880, "Member 'UAbility_104781::RideCancelTask' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10478101
// 0x0078 (0x0EC8 - 0x0E50)
class ACue_Ability_Loop_10478101 final : public AMarvelCueNotify_Ability
{
public:
	float                                         StartRideSoundID;                                  // 0x0E50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuccessRideSoundID;                                // 0x0E54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopRideSoundID;                                   // 0x0E58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5C[0x4];                                      // 0x0E5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwningCharacter;                                   // 0x0E60(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbility_104781*                        CoopAbility;                                       // 0x0E68(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraInterp*                          RidingCameraInterp;                                // 0x0E70(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FSpringArmControlHandler> SpringArmHandlers;                                 // 0x0E78(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void OnJeffGrootCoopStateChange(EJeffGrootAbilityState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10478101">();
	}
	static class ACue_Ability_Loop_10478101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10478101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10478101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10478101");
static_assert(sizeof(ACue_Ability_Loop_10478101) == 0x000EC8, "Wrong size on ACue_Ability_Loop_10478101");
static_assert(offsetof(ACue_Ability_Loop_10478101, StartRideSoundID) == 0x000E50, "Member 'ACue_Ability_Loop_10478101::StartRideSoundID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, SuccessRideSoundID) == 0x000E54, "Member 'ACue_Ability_Loop_10478101::SuccessRideSoundID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, StopRideSoundID) == 0x000E58, "Member 'ACue_Ability_Loop_10478101::StopRideSoundID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, OwningCharacter) == 0x000E60, "Member 'ACue_Ability_Loop_10478101::OwningCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, CoopAbility) == 0x000E68, "Member 'ACue_Ability_Loop_10478101::CoopAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, RidingCameraInterp) == 0x000E70, "Member 'ACue_Ability_Loop_10478101::RidingCameraInterp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10478101, SpringArmHandlers) == 0x000E78, "Member 'ACue_Ability_Loop_10478101::SpringArmHandlers' has a wrong offset!");

// Class Hero_1047.JeffAnimInstance
// 0x0250 (0x0B60 - 0x0910)
class UJeffAnimInstance final : public UMarvelAnimInstance
{
public:
	uint8                                         Pad_910[0x8];                                      // 0x0910(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendSpaceYawAngle;                                // 0x0918(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendSpaceYawAngleSpeed;                           // 0x091C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OnGrootPlayTurnMontageAngleThreshold;              // 0x0920(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RefreshOnGrootMovingStateThreshold;                // 0x0924(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SpineRigDirection;                                 // 0x0928(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ControlRigUpPoint;                                 // 0x0940(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ControlRigForwardPoint;                            // 0x0958(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAdjustControlRigAngle;                      // 0x0970(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_971[0x3];                                      // 0x0971(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrootControlRigAngleThreshold;                     // 0x0974(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendSpaceYawAngleThreshold;                       // 0x0978(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JeffOffsetSizeOnGroot;                             // 0x097C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JeffOffsetSpeedOnGroot;                            // 0x0980(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JeffGrootIKHandAlphaSpeed;                         // 0x0984(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebugJeffGrootIK : 1;                             // 0x0988(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          bDiving;                                           // 0x0989(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDiving_To_Default;                                // 0x098A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98B[0x5];                                      // 0x098B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Diving_To_DefaultTags;                             // 0x0990(0x0068)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DivingTag;                                         // 0x09F8(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFullyHidden;                                      // 0x0A04(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnGroot;                                          // 0x0A05(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A06[0x2];                                      // 0x0A06(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendSpaceYaw;                                     // 0x0A08(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendSpaceAimAOYaw;                                // 0x0A0C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJeffOnGrootMovingState                       OnGrootMovingState;                                // 0x0A10(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A11[0x7];                                      // 0x0A11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               NewJeffRotationOnGrootWS;                          // 0x0A18(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                NewJeffLocatioOnGrootnWS;                          // 0x0A30(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JeffTurnAlphaOnGroot;                              // 0x0A48(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4C[0x4];                                      // 0x0A4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                JeffGrootIKHandLLocationCS;                        // 0x0A50(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                JeffGrootIKHandRLocationCS;                        // 0x0A68(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                JeffGrootIKlLowerArmLLocationCS;                   // 0x0A80(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                JeffGrootIKlLowerArmRLocationCS;                   // 0x0A98(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JeffGrootIKHandAlpha;                              // 0x0AB0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDivingAcceleratingBase;                          // 0x0AB4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB5[0xB];                                      // 0x0AB5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class AJeffCharacter*                         JeffCharacter;                                     // 0x0AC0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC8[0x98];                                     // 0x0AC8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalucateJeffGrootIK(const struct FAnimComponentSpacePoseContext& PoseContext);
	void GetGroundMotionForwardState(const struct FAnimPoseContext& PoseContext);
	void RelevantJeffOnGrootStateNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateJeffOnGrootMotionNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateJeffOnGrootStateNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffAnimInstance">();
	}
	static class UJeffAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffAnimInstance>();
	}
};
static_assert(alignof(UJeffAnimInstance) == 0x000010, "Wrong alignment on UJeffAnimInstance");
static_assert(sizeof(UJeffAnimInstance) == 0x000B60, "Wrong size on UJeffAnimInstance");
static_assert(offsetof(UJeffAnimInstance, BlendSpaceYawAngle) == 0x000918, "Member 'UJeffAnimInstance::BlendSpaceYawAngle' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, BlendSpaceYawAngleSpeed) == 0x00091C, "Member 'UJeffAnimInstance::BlendSpaceYawAngleSpeed' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, OnGrootPlayTurnMontageAngleThreshold) == 0x000920, "Member 'UJeffAnimInstance::OnGrootPlayTurnMontageAngleThreshold' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, RefreshOnGrootMovingStateThreshold) == 0x000924, "Member 'UJeffAnimInstance::RefreshOnGrootMovingStateThreshold' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, SpineRigDirection) == 0x000928, "Member 'UJeffAnimInstance::SpineRigDirection' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, ControlRigUpPoint) == 0x000940, "Member 'UJeffAnimInstance::ControlRigUpPoint' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, ControlRigForwardPoint) == 0x000958, "Member 'UJeffAnimInstance::ControlRigForwardPoint' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, bEnableAdjustControlRigAngle) == 0x000970, "Member 'UJeffAnimInstance::bEnableAdjustControlRigAngle' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, GrootControlRigAngleThreshold) == 0x000974, "Member 'UJeffAnimInstance::GrootControlRigAngleThreshold' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, BlendSpaceYawAngleThreshold) == 0x000978, "Member 'UJeffAnimInstance::BlendSpaceYawAngleThreshold' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffOffsetSizeOnGroot) == 0x00097C, "Member 'UJeffAnimInstance::JeffOffsetSizeOnGroot' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffOffsetSpeedOnGroot) == 0x000980, "Member 'UJeffAnimInstance::JeffOffsetSpeedOnGroot' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKHandAlphaSpeed) == 0x000984, "Member 'UJeffAnimInstance::JeffGrootIKHandAlphaSpeed' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, bDiving) == 0x000989, "Member 'UJeffAnimInstance::bDiving' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, bDiving_To_Default) == 0x00098A, "Member 'UJeffAnimInstance::bDiving_To_Default' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, Diving_To_DefaultTags) == 0x000990, "Member 'UJeffAnimInstance::Diving_To_DefaultTags' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, DivingTag) == 0x0009F8, "Member 'UJeffAnimInstance::DivingTag' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, bFullyHidden) == 0x000A04, "Member 'UJeffAnimInstance::bFullyHidden' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, bOnGroot) == 0x000A05, "Member 'UJeffAnimInstance::bOnGroot' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, BlendSpaceYaw) == 0x000A08, "Member 'UJeffAnimInstance::BlendSpaceYaw' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, BlendSpaceAimAOYaw) == 0x000A0C, "Member 'UJeffAnimInstance::BlendSpaceAimAOYaw' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, OnGrootMovingState) == 0x000A10, "Member 'UJeffAnimInstance::OnGrootMovingState' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, NewJeffRotationOnGrootWS) == 0x000A18, "Member 'UJeffAnimInstance::NewJeffRotationOnGrootWS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, NewJeffLocatioOnGrootnWS) == 0x000A30, "Member 'UJeffAnimInstance::NewJeffLocatioOnGrootnWS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffTurnAlphaOnGroot) == 0x000A48, "Member 'UJeffAnimInstance::JeffTurnAlphaOnGroot' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKHandLLocationCS) == 0x000A50, "Member 'UJeffAnimInstance::JeffGrootIKHandLLocationCS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKHandRLocationCS) == 0x000A68, "Member 'UJeffAnimInstance::JeffGrootIKHandRLocationCS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKlLowerArmLLocationCS) == 0x000A80, "Member 'UJeffAnimInstance::JeffGrootIKlLowerArmLLocationCS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKlLowerArmRLocationCS) == 0x000A98, "Member 'UJeffAnimInstance::JeffGrootIKlLowerArmRLocationCS' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffGrootIKHandAlpha) == 0x000AB0, "Member 'UJeffAnimInstance::JeffGrootIKHandAlpha' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, IsDivingAcceleratingBase) == 0x000AB4, "Member 'UJeffAnimInstance::IsDivingAcceleratingBase' has a wrong offset!");
static_assert(offsetof(UJeffAnimInstance, JeffCharacter) == 0x000AC0, "Member 'UJeffAnimInstance::JeffCharacter' has a wrong offset!");

// Class Hero_1047.JeffCharacter
// 0x0180 (0x1990 - 0x1810)
class AJeffCharacter : public AMarvelBaseCharacter
{
public:
	class URideOnCharacterManagementComponent*    RideOnGrootManagementComponent;                    // 0x1810(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DivingGameplayTag;                                 // 0x1818(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1824[0x4];                                     // 0x1824(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     IgnoreCollisionChannels;                           // 0x1828(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJeffStateChangeDelegate;                         // 0x1838(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             JeffDivingUIWindowStateChangedDispatcher;          // 0x1848(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UJeffPassengerContainerComponent*       JeffPassengerContainerComponent;                   // 0x1858(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnimMovingForward;                              // 0x1860(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1861[0x7];                                     // 0x1861(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECollisionChannel, ECollisionResponse>   CollisionCachedMap;                                // 0x1868(0x0050)(Protected, NativeAccessSpecifierProtected)
	EJeffState                                    CurrentState;                                      // 0x18B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18B9[0x3];                                     // 0x18B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bHapplyBubbleButtonPressed : 1;                    // 0x18BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_18BD[0xB];                                     // 0x18BD(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USplineComponent*>               LoopNXSpines;                                      // 0x18C8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D8[0xA8];                                    // 0x18D8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerOnGrootBlendSpaceYaw;                        // 0x1980(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1984[0x4];                                     // 0x1984(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsOnWallWheDivingEnd : 1;                         // 0x1988(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1989[0x7];                                     // 0x1989(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DivingBlockAbility(const struct FGameplayTagContainer& InContainer, bool bBlock);
	EJeffState GetJeffState();
	bool IsJeffDiving();
	bool IsJeffMovingForward();
	void JeffCharacterEnterDiving();
	void JeffCharacterExitDiving();
	void OnCharacterSwimAbilityStart();
	void RecoverCollisionResponse();
	void SafeMove(const struct FVector& Delta);
	void SetIgnoreCollisionResponse();
	void SetJeffState(EJeffState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffCharacter">();
	}
	static class AJeffCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJeffCharacter>();
	}
};
static_assert(alignof(AJeffCharacter) == 0x000010, "Wrong alignment on AJeffCharacter");
static_assert(sizeof(AJeffCharacter) == 0x001990, "Wrong size on AJeffCharacter");
static_assert(offsetof(AJeffCharacter, RideOnGrootManagementComponent) == 0x001810, "Member 'AJeffCharacter::RideOnGrootManagementComponent' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, DivingGameplayTag) == 0x001818, "Member 'AJeffCharacter::DivingGameplayTag' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, IgnoreCollisionChannels) == 0x001828, "Member 'AJeffCharacter::IgnoreCollisionChannels' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, OnJeffStateChangeDelegate) == 0x001838, "Member 'AJeffCharacter::OnJeffStateChangeDelegate' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, JeffDivingUIWindowStateChangedDispatcher) == 0x001848, "Member 'AJeffCharacter::JeffDivingUIWindowStateChangedDispatcher' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, JeffPassengerContainerComponent) == 0x001858, "Member 'AJeffCharacter::JeffPassengerContainerComponent' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, bIsAnimMovingForward) == 0x001860, "Member 'AJeffCharacter::bIsAnimMovingForward' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, CollisionCachedMap) == 0x001868, "Member 'AJeffCharacter::CollisionCachedMap' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, CurrentState) == 0x0018B8, "Member 'AJeffCharacter::CurrentState' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, LoopNXSpines) == 0x0018C8, "Member 'AJeffCharacter::LoopNXSpines' has a wrong offset!");
static_assert(offsetof(AJeffCharacter, ServerOnGrootBlendSpaceYaw) == 0x001980, "Member 'AJeffCharacter::ServerOnGrootBlendSpaceYaw' has a wrong offset!");

// Class Hero_1047.JeffChildActor
// 0x0160 (0x0BC0 - 0x0A60)
class AJeffChildActor : public AMarvelCharacterChildActor
{
public:
	uint8                                         Pad_A60[0x30];                                     // 0x0A60(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DivingAbilityID;                                   // 0x0A90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A94[0x4];                                      // 0x0A94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             DivingHideMaterialSlotNames;                       // 0x0A98(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<class FName>                             DivingParamMaterialSlotNames;                      // 0x0AE8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           CheckScaledBoneNames;                              // 0x0B38(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AliveCueTagsContainer;                             // 0x0B48(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class AJeffCharacter*                         JeffOwner;                                         // 0x0BB0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJeffState                                    CurrentState;                                      // 0x0BB8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BB9[0x7];                                      // 0x0BB9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JeffChildActorEnterDiving();
	void JeffChildActorExitDiving();
	void OnCharacterDeath(class AActor* OutSourceAvatar, class AActor* OutTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnCharacterReborn(class AActor* OutTargetActor, const struct FCharacterRebornParam& Param);
	void OnCharacterSwimEnd(class FName Tag);
	void OnJeffStateChange(EJeffState InState);
	void OnTagUpdate(const struct FGameplayTag& Tag, bool bTagExists);
	void SetDivingMarteialSectionHidden(bool bDiving);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffChildActor">();
	}
	static class AJeffChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJeffChildActor>();
	}
};
static_assert(alignof(AJeffChildActor) == 0x000008, "Wrong alignment on AJeffChildActor");
static_assert(sizeof(AJeffChildActor) == 0x000BC0, "Wrong size on AJeffChildActor");
static_assert(offsetof(AJeffChildActor, DivingAbilityID) == 0x000A90, "Member 'AJeffChildActor::DivingAbilityID' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, DivingHideMaterialSlotNames) == 0x000A98, "Member 'AJeffChildActor::DivingHideMaterialSlotNames' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, DivingParamMaterialSlotNames) == 0x000AE8, "Member 'AJeffChildActor::DivingParamMaterialSlotNames' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, CheckScaledBoneNames) == 0x000B38, "Member 'AJeffChildActor::CheckScaledBoneNames' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, AliveCueTagsContainer) == 0x000B48, "Member 'AJeffChildActor::AliveCueTagsContainer' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, JeffOwner) == 0x000BB0, "Member 'AJeffChildActor::JeffOwner' has a wrong offset!");
static_assert(offsetof(AJeffChildActor, CurrentState) == 0x000BB8, "Member 'AJeffChildActor::CurrentState' has a wrong offset!");

// Class Hero_1047.Cue_Ability_Loop_10470101
// 0x0130 (0x0F80 - 0x0E50)
class ACue_Ability_Loop_10470101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E50[0x20];                                     // 0x0E50(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NormalLoopNX;                                      // 0x0E70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      HoverLoopNX;                                       // 0x0E78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsRequired;                                      // 0x0E80(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsBlocked;                                       // 0x0EE8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         VelocitySizeSquaredThreshold;                      // 0x0F50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FXHideDelay;                                       // 0x0F54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverFXRotationInterpSpeed;                        // 0x0F58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5C[0x24];                                     // 0x0F5C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoShowHide();
	void OnTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10470101">();
	}
	static class ACue_Ability_Loop_10470101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10470101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10470101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10470101");
static_assert(sizeof(ACue_Ability_Loop_10470101) == 0x000F80, "Wrong size on ACue_Ability_Loop_10470101");
static_assert(offsetof(ACue_Ability_Loop_10470101, NormalLoopNX) == 0x000E70, "Member 'ACue_Ability_Loop_10470101::NormalLoopNX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, HoverLoopNX) == 0x000E78, "Member 'ACue_Ability_Loop_10470101::HoverLoopNX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, TagsRequired) == 0x000E80, "Member 'ACue_Ability_Loop_10470101::TagsRequired' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, TagsBlocked) == 0x000EE8, "Member 'ACue_Ability_Loop_10470101::TagsBlocked' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, VelocitySizeSquaredThreshold) == 0x000F50, "Member 'ACue_Ability_Loop_10470101::VelocitySizeSquaredThreshold' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, FXHideDelay) == 0x000F54, "Member 'ACue_Ability_Loop_10470101::FXHideDelay' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10470101, HoverFXRotationInterpSpeed) == 0x000F58, "Member 'ACue_Ability_Loop_10470101::HoverFXRotationInterpSpeed' has a wrong offset!");

// Class Hero_1047.FlowSimluateSplineActor
// 0x0020 (0x04B0 - 0x0490)
class AFlowSimluateSplineActor final : public AActor
{
public:
	int32                                         SplinePointCount;                                  // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlowHorizontalHalfRadius;                          // 0x0494(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        SplinePoints;                                      // 0x0498(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FlowLerpCurve;                                     // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BuildCurrentSplinePoints(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowSimluateSplineActor">();
	}
	static class AFlowSimluateSplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlowSimluateSplineActor>();
	}
};
static_assert(alignof(AFlowSimluateSplineActor) == 0x000008, "Wrong alignment on AFlowSimluateSplineActor");
static_assert(sizeof(AFlowSimluateSplineActor) == 0x0004B0, "Wrong size on AFlowSimluateSplineActor");
static_assert(offsetof(AFlowSimluateSplineActor, SplinePointCount) == 0x000490, "Member 'AFlowSimluateSplineActor::SplinePointCount' has a wrong offset!");
static_assert(offsetof(AFlowSimluateSplineActor, FlowHorizontalHalfRadius) == 0x000494, "Member 'AFlowSimluateSplineActor::FlowHorizontalHalfRadius' has a wrong offset!");
static_assert(offsetof(AFlowSimluateSplineActor, SplinePoints) == 0x000498, "Member 'AFlowSimluateSplineActor::SplinePoints' has a wrong offset!");
static_assert(offsetof(AFlowSimluateSplineActor, FlowLerpCurve) == 0x0004A8, "Member 'AFlowSimluateSplineActor::FlowLerpCurve' has a wrong offset!");

// Class Hero_1047.JeffGroundMotionSubAnimInstance
// 0x01A0 (0x0AB0 - 0x0910)
class UJeffGroundMotionSubAnimInstance final : public UMarvelAnimInstance
{
public:
	float                                         WorldTimeSeconds;                                  // 0x0910(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreBackwardTime;                                   // 0x0914(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreForwardTime;                                    // 0x0918(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreLeftForwardTime;                                // 0x091C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreRightForwardTime;                               // 0x0920(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftForwardRelevantTime;                           // 0x0924(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightForwardRelevantTime;                          // 0x0928(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopStartTime;                                     // 0x092C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopDirection;                                     // 0x0930(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMoveForward : 1;                                  // 0x0934(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsForwardStop : 1;                                 // 0x0934(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_935[0x3];                                      // 0x0935(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StateBufferTime;                                   // 0x0938(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LRBToLRFTime;                                      // 0x093C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LRFToLRBTime;                                      // 0x0940(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopStartTimeOffset;                               // 0x0944(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnterBToFAnimationStartPosition;                   // 0x0948(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CyclesBlendTime;                                   // 0x094C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJeffGroundMotionTransitionFlags       JeffGroundMotionTransitionFlags;                   // 0x0950(0x001C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FGroundMotionTransitionFlags           GroundMotionTransitionFlags;                       // 0x096C(0x0025)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_991[0x3];                                      // 0x0991(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVelocityBlend                         VelocityBlendFactor;                               // 0x0994(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FVelocityBlend                         OrientationBlendFactor;                            // 0x09B4(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	EJeffEightDirection                           EightDirection;                                    // 0x09D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D5[0x3];                                      // 0x09D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSpeed;                                         // 0x09D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedRate;                                     // 0x09DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedRateLowerLimit;                           // 0x09E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumpForward;                                    // 0x09E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E5[0x3];                                      // 0x09E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpDirection;                                     // 0x09E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpDirectionFwd;                                  // 0x09EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpDirectionBwd;                                  // 0x09F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingIdleBlendTime;                              // 0x09F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpStartToFallingBlendTime;                       // 0x09F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandBlendFactor;                                   // 0x09FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SubIsAccelerating;                                 // 0x0A00(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A01[0x3];                                      // 0x0A01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LandMovementToGround;                              // 0x0A04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlackforwardTransitionAplha;                       // 0x0A08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0C[0x24];                                     // 0x0A0C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class AJeffCharacter*                         JeffCharacter;                                     // 0x0A30(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGroundMotionSubAnimInstanceV1*         MainGroundMotion;                                  // 0x0A38(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A40[0x70];                                     // 0x0A40(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterBToF(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantBlackforwadTransitionNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantCycleNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantJumpStartNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantLeftForwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantRightForwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void RelevantStopNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateAllBackforwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateBlackforwadTransitionNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateForwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateJumpLandNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateJumpLoopNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateJumpStartNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateLeftForwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void UpdateRightForwardNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffGroundMotionSubAnimInstance">();
	}
	static class UJeffGroundMotionSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffGroundMotionSubAnimInstance>();
	}
};
static_assert(alignof(UJeffGroundMotionSubAnimInstance) == 0x000010, "Wrong alignment on UJeffGroundMotionSubAnimInstance");
static_assert(sizeof(UJeffGroundMotionSubAnimInstance) == 0x000AB0, "Wrong size on UJeffGroundMotionSubAnimInstance");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, WorldTimeSeconds) == 0x000910, "Member 'UJeffGroundMotionSubAnimInstance::WorldTimeSeconds' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, PreBackwardTime) == 0x000914, "Member 'UJeffGroundMotionSubAnimInstance::PreBackwardTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, PreForwardTime) == 0x000918, "Member 'UJeffGroundMotionSubAnimInstance::PreForwardTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, PreLeftForwardTime) == 0x00091C, "Member 'UJeffGroundMotionSubAnimInstance::PreLeftForwardTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, PreRightForwardTime) == 0x000920, "Member 'UJeffGroundMotionSubAnimInstance::PreRightForwardTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, LeftForwardRelevantTime) == 0x000924, "Member 'UJeffGroundMotionSubAnimInstance::LeftForwardRelevantTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, RightForwardRelevantTime) == 0x000928, "Member 'UJeffGroundMotionSubAnimInstance::RightForwardRelevantTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, StopStartTime) == 0x00092C, "Member 'UJeffGroundMotionSubAnimInstance::StopStartTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, StopDirection) == 0x000930, "Member 'UJeffGroundMotionSubAnimInstance::StopDirection' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, StateBufferTime) == 0x000938, "Member 'UJeffGroundMotionSubAnimInstance::StateBufferTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, LRBToLRFTime) == 0x00093C, "Member 'UJeffGroundMotionSubAnimInstance::LRBToLRFTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, LRFToLRBTime) == 0x000940, "Member 'UJeffGroundMotionSubAnimInstance::LRFToLRBTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, StopStartTimeOffset) == 0x000944, "Member 'UJeffGroundMotionSubAnimInstance::StopStartTimeOffset' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, EnterBToFAnimationStartPosition) == 0x000948, "Member 'UJeffGroundMotionSubAnimInstance::EnterBToFAnimationStartPosition' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, CyclesBlendTime) == 0x00094C, "Member 'UJeffGroundMotionSubAnimInstance::CyclesBlendTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JeffGroundMotionTransitionFlags) == 0x000950, "Member 'UJeffGroundMotionSubAnimInstance::JeffGroundMotionTransitionFlags' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, GroundMotionTransitionFlags) == 0x00096C, "Member 'UJeffGroundMotionSubAnimInstance::GroundMotionTransitionFlags' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, VelocityBlendFactor) == 0x000994, "Member 'UJeffGroundMotionSubAnimInstance::VelocityBlendFactor' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, OrientationBlendFactor) == 0x0009B4, "Member 'UJeffGroundMotionSubAnimInstance::OrientationBlendFactor' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, EightDirection) == 0x0009D4, "Member 'UJeffGroundMotionSubAnimInstance::EightDirection' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, WalkSpeed) == 0x0009D8, "Member 'UJeffGroundMotionSubAnimInstance::WalkSpeed' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, WalkSpeedRate) == 0x0009DC, "Member 'UJeffGroundMotionSubAnimInstance::WalkSpeedRate' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, WalkSpeedRateLowerLimit) == 0x0009E0, "Member 'UJeffGroundMotionSubAnimInstance::WalkSpeedRateLowerLimit' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, bIsJumpForward) == 0x0009E4, "Member 'UJeffGroundMotionSubAnimInstance::bIsJumpForward' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JumpDirection) == 0x0009E8, "Member 'UJeffGroundMotionSubAnimInstance::JumpDirection' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JumpDirectionFwd) == 0x0009EC, "Member 'UJeffGroundMotionSubAnimInstance::JumpDirectionFwd' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JumpDirectionBwd) == 0x0009F0, "Member 'UJeffGroundMotionSubAnimInstance::JumpDirectionBwd' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, FallingIdleBlendTime) == 0x0009F4, "Member 'UJeffGroundMotionSubAnimInstance::FallingIdleBlendTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JumpStartToFallingBlendTime) == 0x0009F8, "Member 'UJeffGroundMotionSubAnimInstance::JumpStartToFallingBlendTime' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, LandBlendFactor) == 0x0009FC, "Member 'UJeffGroundMotionSubAnimInstance::LandBlendFactor' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, SubIsAccelerating) == 0x000A00, "Member 'UJeffGroundMotionSubAnimInstance::SubIsAccelerating' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, LandMovementToGround) == 0x000A04, "Member 'UJeffGroundMotionSubAnimInstance::LandMovementToGround' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, BlackforwardTransitionAplha) == 0x000A08, "Member 'UJeffGroundMotionSubAnimInstance::BlackforwardTransitionAplha' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, JeffCharacter) == 0x000A30, "Member 'UJeffGroundMotionSubAnimInstance::JeffCharacter' has a wrong offset!");
static_assert(offsetof(UJeffGroundMotionSubAnimInstance, MainGroundMotion) == 0x000A38, "Member 'UJeffGroundMotionSubAnimInstance::MainGroundMotion' has a wrong offset!");

// Class Hero_1047.JeffMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UJeffMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffMoveLogicBaseComponent">();
	}
	static class UJeffMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UJeffMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UJeffMoveLogicBaseComponent");
static_assert(sizeof(UJeffMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UJeffMoveLogicBaseComponent");

// Class Hero_1047.JeffMovementComponent
// 0x0060 (0x3030 - 0x2FD0)
class UJeffMovementComponent final : public UCharacterWallRunningComponent
{
public:
	class AJeffCharacter*                         JeffCharacter;                                     // 0x2FD0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDivingWantToClimb;                                // 0x2FD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDivingInClimbRadius;                              // 0x2FD9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FDA[0x2];                                     // 0x2FDA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DivingOrientRotationLerpSpeed;                     // 0x2FDC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChildActorMeshLerpSpeed;                           // 0x2FE0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FE4[0x4];                                     // 0x2FE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetRelativeRotator;                             // 0x2FE8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJeffFallingWhenDiveDispatcher_ThreadSafe;        // 0x3000(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         StepDownOnceHeight;                                // 0x3010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepDownHeight;                                 // 0x3014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TryRiseSpeed;                                      // 0x3018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFixZCeilMode;                                   // 0x301C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301D[0x3];                                     // 0x301D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CeilingZ;                                          // 0x3020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3024[0xC];                                     // 0x3024(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FJeffMoveForwardCheckResult CheckMoveForward(const struct FVector& MoveDelta);
	void OnJeffGetOffWall(const struct FWallRunningEndInfo& InWallRunningEndInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JeffMovementComponent">();
	}
	static class UJeffMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJeffMovementComponent>();
	}
};
static_assert(alignof(UJeffMovementComponent) == 0x000010, "Wrong alignment on UJeffMovementComponent");
static_assert(sizeof(UJeffMovementComponent) == 0x003030, "Wrong size on UJeffMovementComponent");
static_assert(offsetof(UJeffMovementComponent, JeffCharacter) == 0x002FD0, "Member 'UJeffMovementComponent::JeffCharacter' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, bDivingWantToClimb) == 0x002FD8, "Member 'UJeffMovementComponent::bDivingWantToClimb' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, bDivingInClimbRadius) == 0x002FD9, "Member 'UJeffMovementComponent::bDivingInClimbRadius' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, DivingOrientRotationLerpSpeed) == 0x002FDC, "Member 'UJeffMovementComponent::DivingOrientRotationLerpSpeed' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, ChildActorMeshLerpSpeed) == 0x002FE0, "Member 'UJeffMovementComponent::ChildActorMeshLerpSpeed' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, TargetRelativeRotator) == 0x002FE8, "Member 'UJeffMovementComponent::TargetRelativeRotator' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, OnJeffFallingWhenDiveDispatcher_ThreadSafe) == 0x003000, "Member 'UJeffMovementComponent::OnJeffFallingWhenDiveDispatcher_ThreadSafe' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, StepDownOnceHeight) == 0x003010, "Member 'UJeffMovementComponent::StepDownOnceHeight' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, MaxStepDownHeight) == 0x003014, "Member 'UJeffMovementComponent::MaxStepDownHeight' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, TryRiseSpeed) == 0x003018, "Member 'UJeffMovementComponent::TryRiseSpeed' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, bIsFixZCeilMode) == 0x00301C, "Member 'UJeffMovementComponent::bIsFixZCeilMode' has a wrong offset!");
static_assert(offsetof(UJeffMovementComponent, CeilingZ) == 0x003020, "Member 'UJeffMovementComponent::CeilingZ' has a wrong offset!");

// Class Hero_1047.ShootingLogic_104712
// 0x0008 (0x1620 - 0x1618)
class UShootingLogic_104712 final : public UShootingLogic_AbilityProjectile
{
public:
	int32                                         SimpleWaterEntityNum;                              // 0x1618(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161C[0x4];                                     // 0x161C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShootingLogic_104712">();
	}
	static class UShootingLogic_104712* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShootingLogic_104712>();
	}
};
static_assert(alignof(UShootingLogic_104712) == 0x000008, "Wrong alignment on UShootingLogic_104712");
static_assert(sizeof(UShootingLogic_104712) == 0x001620, "Wrong size on UShootingLogic_104712");
static_assert(offsetof(UShootingLogic_104712, SimpleWaterEntityNum) == 0x001618, "Member 'UShootingLogic_104712::SimpleWaterEntityNum' has a wrong offset!");

}

