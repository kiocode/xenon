#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1016

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "DeclarativeUnreal_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Hero_1016_structs.hpp"


namespace SDK
{

// Class Hero_1016.Config_101611
// 0x0078 (0x0110 - 0x0098)
class UConfig_101611 final : public UMarvelAbilityConfig
{
public:
	struct FGameplayTagContainer                  BackstabRequireTags;                               // 0x0098(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BackstabCheckAngle;                                // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackstabDamageRatio;                               // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceDeviation;                              // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101611">();
	}
	static class UConfig_101611* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101611>();
	}
};
static_assert(alignof(UConfig_101611) == 0x000008, "Wrong alignment on UConfig_101611");
static_assert(sizeof(UConfig_101611) == 0x000110, "Wrong size on UConfig_101611");
static_assert(offsetof(UConfig_101611, BackstabRequireTags) == 0x000098, "Member 'UConfig_101611::BackstabRequireTags' has a wrong offset!");
static_assert(offsetof(UConfig_101611, BackstabCheckAngle) == 0x000100, "Member 'UConfig_101611::BackstabCheckAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101611, BackstabDamageRatio) == 0x000104, "Member 'UConfig_101611::BackstabDamageRatio' has a wrong offset!");
static_assert(offsetof(UConfig_101611, MaxDistanceDeviation) == 0x000108, "Member 'UConfig_101611::MaxDistanceDeviation' has a wrong offset!");

// Class Hero_1016.EffectiveComponent_Loki
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_Loki : public UMarvelAgentEffectiveComponent
{
public:
	class UConfig_101651* GetConfig_101651();
	void ReplaceProjectileAgentApplyBuff();
	void ReplaceScopeAgentApplyBuff();
	void SetProjectileAgentDamageValue();
	void SetScopeAgentDamageValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_Loki">();
	}
	static class UEffectiveComponent_Loki* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_Loki>();
	}
};
static_assert(alignof(UEffectiveComponent_Loki) == 0x000010, "Wrong alignment on UEffectiveComponent_Loki");
static_assert(sizeof(UEffectiveComponent_Loki) == 0x001C00, "Wrong size on UEffectiveComponent_Loki");

// Class Hero_1016.EffectiveComponent_10161101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10161101 : public UEffectiveComponent_Loki
{
public:
	void JudgeBackstabAndSetEffect(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10161101">();
	}
	static class UEffectiveComponent_10161101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10161101>();
	}
};
static_assert(alignof(UEffectiveComponent_10161101) == 0x000010, "Wrong alignment on UEffectiveComponent_10161101");
static_assert(sizeof(UEffectiveComponent_10161101) == 0x001C00, "Wrong size on UEffectiveComponent_10161101");

// Class Hero_1016.Ability_101621
// 0x0000 (0x2580 - 0x2580)
class UAbility_101621 : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101621">();
	}
	static class UAbility_101621* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101621>();
	}
};
static_assert(alignof(UAbility_101621) == 0x000008, "Wrong alignment on UAbility_101621");
static_assert(sizeof(UAbility_101621) == 0x002580, "Wrong size on UAbility_101621");

// Class Hero_1016.Projectile_Loki
// 0x0010 (0x3060 - 0x3050)
class AProjectile_Loki : public AMarvelAbilityTargetActor_Projectile
{
public:
	uint8                                         Pad_3050[0x8];                                     // 0x3050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPhantomOwned;                                     // 0x3058(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3059[0x7];                                     // 0x3059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPhantomOwned();
	void SetPhantomOwned(bool bOwned);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_Loki">();
	}
	static class AProjectile_Loki* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_Loki>();
	}
};
static_assert(alignof(AProjectile_Loki) == 0x000010, "Wrong alignment on AProjectile_Loki");
static_assert(sizeof(AProjectile_Loki) == 0x003060, "Wrong size on AProjectile_Loki");
static_assert(offsetof(AProjectile_Loki, bPhantomOwned) == 0x003058, "Member 'AProjectile_Loki::bPhantomOwned' has a wrong offset!");

// Class Hero_1016.Projectile_10162101
// 0x0010 (0x3070 - 0x3060)
class AProjectile_10162101 : public AProjectile_Loki
{
public:
	uint8                                         Pad_3060[0x10];                                    // 0x3060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10162101">();
	}
	static class AProjectile_10162101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10162101>();
	}
};
static_assert(alignof(AProjectile_10162101) == 0x000010, "Wrong alignment on AProjectile_10162101");
static_assert(sizeof(AProjectile_10162101) == 0x003070, "Wrong size on AProjectile_10162101");

// Class Hero_1016.Ability_101629
// 0x0000 (0x2748 - 0x2748)
class UAbility_101629 : public UAbility_107
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101629">();
	}
	static class UAbility_101629* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101629>();
	}
};
static_assert(alignof(UAbility_101629) == 0x000008, "Wrong alignment on UAbility_101629");
static_assert(sizeof(UAbility_101629) == 0x002748, "Wrong size on UAbility_101629");

// Class Hero_1016.Config_101631
// 0x0020 (0x00B8 - 0x0098)
class UConfig_101631 : public UMarvelAbilityConfig
{
public:
	float                                         ScopeCenterHeight;                                 // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultHeight;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckSceneBlock;                            // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SummonerId;                                        // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScopeId;                                           // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SummonerGravityScale;                              // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101631">();
	}
	static class UConfig_101631* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101631>();
	}
};
static_assert(alignof(UConfig_101631) == 0x000008, "Wrong alignment on UConfig_101631");
static_assert(sizeof(UConfig_101631) == 0x0000B8, "Wrong size on UConfig_101631");
static_assert(offsetof(UConfig_101631, ScopeCenterHeight) == 0x000098, "Member 'UConfig_101631::ScopeCenterHeight' has a wrong offset!");
static_assert(offsetof(UConfig_101631, DefaultHeight) == 0x00009C, "Member 'UConfig_101631::DefaultHeight' has a wrong offset!");
static_assert(offsetof(UConfig_101631, OuterRadius) == 0x0000A0, "Member 'UConfig_101631::OuterRadius' has a wrong offset!");
static_assert(offsetof(UConfig_101631, bShouldCheckSceneBlock) == 0x0000A4, "Member 'UConfig_101631::bShouldCheckSceneBlock' has a wrong offset!");
static_assert(offsetof(UConfig_101631, SummonerId) == 0x0000A8, "Member 'UConfig_101631::SummonerId' has a wrong offset!");
static_assert(offsetof(UConfig_101631, ScopeId) == 0x0000AC, "Member 'UConfig_101631::ScopeId' has a wrong offset!");
static_assert(offsetof(UConfig_101631, SummonerGravityScale) == 0x0000B0, "Member 'UConfig_101631::SummonerGravityScale' has a wrong offset!");

// Class Hero_1016.Summoned_10163101
// 0x0020 (0x08B0 - 0x0890)
class ASummoned_10163101 : public AMarvelSummonerBase
{
public:
	uint8                                         Pad_890[0x8];                                      // 0x0890(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_101631*                         CachedConfig;                                      // 0x0898(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USummonedComp_10163101*                 SummonedComp_10163101;                             // 0x08A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A8[0x8];                                      // 0x08A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USummonedComp_10163101* GetOwningComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10163101">();
	}
	static class ASummoned_10163101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10163101>();
	}
};
static_assert(alignof(ASummoned_10163101) == 0x000010, "Wrong alignment on ASummoned_10163101");
static_assert(sizeof(ASummoned_10163101) == 0x0008B0, "Wrong size on ASummoned_10163101");
static_assert(offsetof(ASummoned_10163101, CachedConfig) == 0x000898, "Member 'ASummoned_10163101::CachedConfig' has a wrong offset!");
static_assert(offsetof(ASummoned_10163101, SummonedComp_10163101) == 0x0008A0, "Member 'ASummoned_10163101::SummonedComp_10163101' has a wrong offset!");

// Class Hero_1016.SummonedComp_10163101
// 0x1040 (0x1CE0 - 0x0CA0)
class USummonedComp_10163101 : public UMarvelSummonedComponent
{
public:
	struct FMarvelAbilityTraceContext             GroundTraceContext;                                // 0x0CA0(0x0F90)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPositionReady;                                   // 0x1C30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      BlockingTypes;                                     // 0x1C40(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bPositionReady;                                    // 0x1C50(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C51[0x7];                                     // 0x1C51(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScopeLocation;                                     // 0x1C58(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalScopeLocation;                                // 0x1C70(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RealHeight;                                        // 0x1C88(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8C[0x4];                                     // 0x1C8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_101631*                         Config_101631;                                     // 0x1C90(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASummoned_10163101*                     Summoned_101631;                                   // 0x1C98(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CA0[0x38];                                    // 0x1CA0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereCollision;                                   // 0x1CD8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	TArray<struct FVector> CalSurroundSphereCenters(const struct FVector& CenterPoint, int32 SurroundNum, float SurroundRadius);
	class UConfig_101631* GetOwnerAbilityConfig();
	class ASummoned_10163101* GetOwnerSummoned();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10163101">();
	}
	static class USummonedComp_10163101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10163101>();
	}
};
static_assert(alignof(USummonedComp_10163101) == 0x000010, "Wrong alignment on USummonedComp_10163101");
static_assert(sizeof(USummonedComp_10163101) == 0x001CE0, "Wrong size on USummonedComp_10163101");
static_assert(offsetof(USummonedComp_10163101, GroundTraceContext) == 0x000CA0, "Member 'USummonedComp_10163101::GroundTraceContext' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, OnPositionReady) == 0x001C30, "Member 'USummonedComp_10163101::OnPositionReady' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, BlockingTypes) == 0x001C40, "Member 'USummonedComp_10163101::BlockingTypes' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, bPositionReady) == 0x001C50, "Member 'USummonedComp_10163101::bPositionReady' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, ScopeLocation) == 0x001C58, "Member 'USummonedComp_10163101::ScopeLocation' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, FinalScopeLocation) == 0x001C70, "Member 'USummonedComp_10163101::FinalScopeLocation' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, RealHeight) == 0x001C88, "Member 'USummonedComp_10163101::RealHeight' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, Config_101631) == 0x001C90, "Member 'USummonedComp_10163101::Config_101631' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, Summoned_101631) == 0x001C98, "Member 'USummonedComp_10163101::Summoned_101631' has a wrong offset!");
static_assert(offsetof(USummonedComp_10163101, SphereCollision) == 0x001CD8, "Member 'USummonedComp_10163101::SphereCollision' has a wrong offset!");

// Class Hero_1016.Ability_101631
// 0x0018 (0x2598 - 0x2580)
class UAbility_101631 : public UMarvelGameplayAbility
{
public:
	class UConfig_101631*                         Config_101631;                                     // 0x2580(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbility_101631*                        Instigator_Ability_101631;                         // 0x2588(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASummoned_10163101*                     CurSummoned;                                       // 0x2590(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UAbility_101631* GetInstigatorAbility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101631">();
	}
	static class UAbility_101631* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101631>();
	}
};
static_assert(alignof(UAbility_101631) == 0x000008, "Wrong alignment on UAbility_101631");
static_assert(sizeof(UAbility_101631) == 0x002598, "Wrong size on UAbility_101631");
static_assert(offsetof(UAbility_101631, Config_101631) == 0x002580, "Member 'UAbility_101631::Config_101631' has a wrong offset!");
static_assert(offsetof(UAbility_101631, Instigator_Ability_101631) == 0x002588, "Member 'UAbility_101631::Instigator_Ability_101631' has a wrong offset!");
static_assert(offsetof(UAbility_101631, CurSummoned) == 0x002590, "Member 'UAbility_101631::CurSummoned' has a wrong offset!");

// Class Hero_1016.UMarvelTreatOverflowConvAbility_10163101
// 0x0000 (0x11F0 - 0x11F0)
class UUMarvelTreatOverflowConvAbility_10163101 : public UMarvelTreatOverflowConvAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMarvelTreatOverflowConvAbility_10163101">();
	}
	static class UUMarvelTreatOverflowConvAbility_10163101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMarvelTreatOverflowConvAbility_10163101>();
	}
};
static_assert(alignof(UUMarvelTreatOverflowConvAbility_10163101) == 0x000008, "Wrong alignment on UUMarvelTreatOverflowConvAbility_10163101");
static_assert(sizeof(UUMarvelTreatOverflowConvAbility_10163101) == 0x0011F0, "Wrong size on UUMarvelTreatOverflowConvAbility_10163101");

// Class Hero_1016.Cue_Summoner_Loop_10163101
// 0x0008 (0x0E98 - 0x0E90)
class ACue_Summoner_Loop_10163101 : public AMarvelCueNotify_Summoned
{
public:
	class ASummoned_10163101*                     OwnerSummoned;                                     // 0x0E90(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10163101">();
	}
	static class ACue_Summoner_Loop_10163101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10163101>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10163101) == 0x000008, "Wrong alignment on ACue_Summoner_Loop_10163101");
static_assert(sizeof(ACue_Summoner_Loop_10163101) == 0x000E98, "Wrong size on ACue_Summoner_Loop_10163101");
static_assert(offsetof(ACue_Summoner_Loop_10163101, OwnerSummoned) == 0x000E90, "Member 'ACue_Summoner_Loop_10163101::OwnerSummoned' has a wrong offset!");

// Class Hero_1016.Stealth_101641
// 0x0068 (0x1380 - 0x1318)
class UStealth_101641 : public UMarvelStealthAbility
{
public:
	struct FGameplayTagContainer                  BlockInputAbilities;                               // 0x1318(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Stealth_101641">();
	}
	static class UStealth_101641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStealth_101641>();
	}
};
static_assert(alignof(UStealth_101641) == 0x000008, "Wrong alignment on UStealth_101641");
static_assert(sizeof(UStealth_101641) == 0x001380, "Wrong size on UStealth_101641");
static_assert(offsetof(UStealth_101641, BlockInputAbilities) == 0x001318, "Member 'UStealth_101641::BlockInputAbilities' has a wrong offset!");

// Class Hero_1016.Cue_Buff_10164101
// 0x0028 (0x1060 - 0x1038)
class ACue_Buff_10164101 final : public AMarvelCueNotify_Buff
{
public:
	class UFXSystemComponent*                     NiagaraSystem;                                     // 0x1038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         DisappearFX;                                       // 0x1040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DisappearLocation;                                 // 0x1048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SpawnDisappearFX(class ACharacter* Character);
	void UpdateDisappearFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10164101">();
	}
	static class ACue_Buff_10164101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10164101>();
	}
};
static_assert(alignof(ACue_Buff_10164101) == 0x000008, "Wrong alignment on ACue_Buff_10164101");
static_assert(sizeof(ACue_Buff_10164101) == 0x001060, "Wrong size on ACue_Buff_10164101");
static_assert(offsetof(ACue_Buff_10164101, NiagaraSystem) == 0x001038, "Member 'ACue_Buff_10164101::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10164101, DisappearFX) == 0x001040, "Member 'ACue_Buff_10164101::DisappearFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10164101, DisappearLocation) == 0x001048, "Member 'ACue_Buff_10164101::DisappearLocation' has a wrong offset!");

// Class Hero_1016.Ability_101651
// 0x00B8 (0x2638 - 0x2580)
class UAbility_101651 : public UMarvelGameplayAbility
{
public:
	EAbilityState_101651                          CurrentAbilityState;                               // 0x2580(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityState_101651                          LastAbilityState;                                  // 0x2581(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2582[0x6];                                     // 0x2582(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                                      // 0x2588(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALokiCharacter*                         OwnerChar;                                         // 0x2590(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         TimelineKey;                                       // 0x2598(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector GetOriginCharacterAimedLocation();
	void SwitchTimelineTask(const class FName& SectionName, bool bWithAbilityEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101651">();
	}
	static class UAbility_101651* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101651>();
	}
};
static_assert(alignof(UAbility_101651) == 0x000008, "Wrong alignment on UAbility_101651");
static_assert(sizeof(UAbility_101651) == 0x002638, "Wrong size on UAbility_101651");
static_assert(offsetof(UAbility_101651, CurrentAbilityState) == 0x002580, "Member 'UAbility_101651::CurrentAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_101651, LastAbilityState) == 0x002581, "Member 'UAbility_101651::LastAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_101651, TimelineTask) == 0x002588, "Member 'UAbility_101651::TimelineTask' has a wrong offset!");
static_assert(offsetof(UAbility_101651, OwnerChar) == 0x002590, "Member 'UAbility_101651::OwnerChar' has a wrong offset!");
static_assert(offsetof(UAbility_101651, TimelineKey) == 0x002598, "Member 'UAbility_101651::TimelineKey' has a wrong offset!");

// Class Hero_1016.SummonedController_10165101
// 0x0FC8 (0x15B0 - 0x05E8)
class ASummonedController_10165101 : public ASummonedAIController
{
public:
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             AimPointTraceParam;                                // 0x05F0(0x0F90)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1580[0x18];                                    // 0x1580(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_101651*                         PhantomConfig;                                     // 0x1598(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x15A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASummoned_10165101*                     ControlledCharacter;                               // 0x15A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector GetOriginCharacterAimedLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedController_10165101">();
	}
	static class ASummonedController_10165101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummonedController_10165101>();
	}
};
static_assert(alignof(ASummonedController_10165101) == 0x000010, "Wrong alignment on ASummonedController_10165101");
static_assert(sizeof(ASummonedController_10165101) == 0x0015B0, "Wrong size on ASummonedController_10165101");
static_assert(offsetof(ASummonedController_10165101, AimPointTraceParam) == 0x0005F0, "Member 'ASummonedController_10165101::AimPointTraceParam' has a wrong offset!");
static_assert(offsetof(ASummonedController_10165101, PhantomConfig) == 0x001598, "Member 'ASummonedController_10165101::PhantomConfig' has a wrong offset!");
static_assert(offsetof(ASummonedController_10165101, InstigatorCharacter) == 0x0015A0, "Member 'ASummonedController_10165101::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(ASummonedController_10165101, ControlledCharacter) == 0x0015A8, "Member 'ASummonedController_10165101::ControlledCharacter' has a wrong offset!");

// Class Hero_1016.Summoned_10165101
// 0x0140 (0x0FE0 - 0x0EA0)
class ASummoned_10165101 : public ASummonedCharacterBase
{
public:
	uint8                                         Pad_E98[0x110];                                    // 0x0E98(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class ULokiMoveLogicBaseComponent*            LokiMoveLogicComponent;                            // 0x0FA8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelSolvePenetrationComponent*       SolvePenetrationComponent;                         // 0x0FB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshHiddenComponent*                   HiddenComponent;                                   // 0x0FB8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInVisible;                                        // 0x0FC0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC1[0x7];                                      // 0x0FC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x0FC8(0x0010)(Protected, NativeAccessSpecifierProtected)
	bool                                          bForceMovementCompActive;                          // 0x0FD8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPushByLevel;                                      // 0x0FD9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FDA[0x6];                                      // 0x0FDA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);

	EHeroRole GetHeroRole() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10165101">();
	}
	static class ASummoned_10165101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10165101>();
	}
};
static_assert(alignof(ASummoned_10165101) == 0x000010, "Wrong alignment on ASummoned_10165101");
static_assert(sizeof(ASummoned_10165101) == 0x000FE0, "Wrong size on ASummoned_10165101");
static_assert(offsetof(ASummoned_10165101, LokiMoveLogicComponent) == 0x000FA8, "Member 'ASummoned_10165101::LokiMoveLogicComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10165101, SolvePenetrationComponent) == 0x000FB0, "Member 'ASummoned_10165101::SolvePenetrationComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10165101, HiddenComponent) == 0x000FB8, "Member 'ASummoned_10165101::HiddenComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10165101, bInVisible) == 0x000FC0, "Member 'ASummoned_10165101::bInVisible' has a wrong offset!");
static_assert(offsetof(ASummoned_10165101, DeclarePlayerViewSideHolder) == 0x000FC8, "Member 'ASummoned_10165101::DeclarePlayerViewSideHolder' has a wrong offset!");
static_assert(offsetof(ASummoned_10165101, bForceMovementCompActive) == 0x000FD8, "Member 'ASummoned_10165101::bForceMovementCompActive' has a wrong offset!");
static_assert(offsetof(ASummoned_10165101, bPushByLevel) == 0x000FD9, "Member 'ASummoned_10165101::bPushByLevel' has a wrong offset!");

// Class Hero_1016.SummonedComp_V2_10165101
// 0x00B0 (0x0D50 - 0x0CA0)
class USummonedComp_V2_10165101 : public UMarvelSummonedComponent
{
public:
	class ASummoned_10165101*                     OwnerCharacter;                                    // 0x0CA0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALokiCharacter*                         SourceCharacter;                                   // 0x0CA8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelPlayerState*                     SourcePlayerState;                                 // 0x0CB0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourcePlayerUID;                                   // 0x0CB8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CBC[0x4];                                      // 0x0CBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLifetimeControlParam                  LifetimeParam;                                     // 0x0CC0(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UConfig_101651*                         PhantomConfig;                                     // 0x0D40(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D48[0x8];                                      // 0x0D48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInstigatorActivateAbility(int32 InAbilityId);
	void OnInstigatorEndAbility(int32 InAbilityId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_V2_10165101">();
	}
	static class USummonedComp_V2_10165101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_V2_10165101>();
	}
};
static_assert(alignof(USummonedComp_V2_10165101) == 0x000010, "Wrong alignment on USummonedComp_V2_10165101");
static_assert(sizeof(USummonedComp_V2_10165101) == 0x000D50, "Wrong size on USummonedComp_V2_10165101");
static_assert(offsetof(USummonedComp_V2_10165101, OwnerCharacter) == 0x000CA0, "Member 'USummonedComp_V2_10165101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USummonedComp_V2_10165101, SourceCharacter) == 0x000CA8, "Member 'USummonedComp_V2_10165101::SourceCharacter' has a wrong offset!");
static_assert(offsetof(USummonedComp_V2_10165101, SourcePlayerState) == 0x000CB0, "Member 'USummonedComp_V2_10165101::SourcePlayerState' has a wrong offset!");
static_assert(offsetof(USummonedComp_V2_10165101, SourcePlayerUID) == 0x000CB8, "Member 'USummonedComp_V2_10165101::SourcePlayerUID' has a wrong offset!");
static_assert(offsetof(USummonedComp_V2_10165101, LifetimeParam) == 0x000CC0, "Member 'USummonedComp_V2_10165101::LifetimeParam' has a wrong offset!");
static_assert(offsetof(USummonedComp_V2_10165101, PhantomConfig) == 0x000D40, "Member 'USummonedComp_V2_10165101::PhantomConfig' has a wrong offset!");

// Class Hero_1016.Cue_TraceActor_10165101
// 0x0078 (0x0D78 - 0x0D00)
class ACue_TraceActor_10165101 : public AMarvelCueNotify_TraceActor
{
public:
	class UNiagaraComponent*                      GroundShowNiagara;                                 // 0x0D00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNiagara;                                       // 0x0D08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTimelineComponent*                     YawControl;                                        // 0x0D10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0D18(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            YawCurve;                                          // 0x0D20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D28[0x18];                                     // 0x0D28(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 LokiMirrorMesh;                                    // 0x0D40(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayShowLokiMirrorMeshTime;                       // 0x0D48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4C[0x4];                                      // 0x0D4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPortableMaterialSlotName>      LokiHiddenSlots;                                   // 0x0D50(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           DelayShowMirrorMeshHandle;                         // 0x0D60(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFloatChange(class FName TrackName, class FName PropertyName, float OutValue);
	void UpdateRotation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_TraceActor_10165101">();
	}
	static class ACue_TraceActor_10165101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_TraceActor_10165101>();
	}
};
static_assert(alignof(ACue_TraceActor_10165101) == 0x000008, "Wrong alignment on ACue_TraceActor_10165101");
static_assert(sizeof(ACue_TraceActor_10165101) == 0x000D78, "Wrong size on ACue_TraceActor_10165101");
static_assert(offsetof(ACue_TraceActor_10165101, GroundShowNiagara) == 0x000D00, "Member 'ACue_TraceActor_10165101::GroundShowNiagara' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, LoopNiagara) == 0x000D08, "Member 'ACue_TraceActor_10165101::LoopNiagara' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, YawControl) == 0x000D10, "Member 'ACue_TraceActor_10165101::YawControl' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, OwnerCharacter) == 0x000D18, "Member 'ACue_TraceActor_10165101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, YawCurve) == 0x000D20, "Member 'ACue_TraceActor_10165101::YawCurve' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, LokiMirrorMesh) == 0x000D40, "Member 'ACue_TraceActor_10165101::LokiMirrorMesh' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, DelayShowLokiMirrorMeshTime) == 0x000D48, "Member 'ACue_TraceActor_10165101::DelayShowLokiMirrorMeshTime' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, LokiHiddenSlots) == 0x000D50, "Member 'ACue_TraceActor_10165101::LokiHiddenSlots' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10165101, DelayShowMirrorMeshHandle) == 0x000D60, "Member 'ACue_TraceActor_10165101::DelayShowMirrorMeshHandle' has a wrong offset!");

// Class Hero_1016.LokiSpaceActor
// 0x0018 (0x04A8 - 0x0490)
class ALokiSpaceActor : public AActor
{
public:
	class USceneCaptureComponent2D*               SceneCapComponent2D;                               // 0x0490(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        LokiRotationPivot;                                 // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVDelta;                                          // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiSpaceActor">();
	}
	static class ALokiSpaceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALokiSpaceActor>();
	}
};
static_assert(alignof(ALokiSpaceActor) == 0x000008, "Wrong alignment on ALokiSpaceActor");
static_assert(sizeof(ALokiSpaceActor) == 0x0004A8, "Wrong size on ALokiSpaceActor");
static_assert(offsetof(ALokiSpaceActor, SceneCapComponent2D) == 0x000490, "Member 'ALokiSpaceActor::SceneCapComponent2D' has a wrong offset!");
static_assert(offsetof(ALokiSpaceActor, LokiRotationPivot) == 0x000498, "Member 'ALokiSpaceActor::LokiRotationPivot' has a wrong offset!");
static_assert(offsetof(ALokiSpaceActor, FOVDelta) == 0x0004A0, "Member 'ALokiSpaceActor::FOVDelta' has a wrong offset!");

// Class Hero_1016.Summoned_10165102
// 0x0040 (0x08D0 - 0x0890)
class ASummoned_10165102 final : public AMarvelSummonerBase
{
public:
	class USphereComponent*                       OverlapCollisionComponent;                         // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlapHandlerComponent*               OverlapHandleComponent;                            // 0x0898(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OverlapActorDelegate;                              // 0x08A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 OverlappedActor;                                   // 0x08B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B8[0x8];                                      // 0x08B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasExecuteCue;                                    // 0x08C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C1[0xF];                                      // 0x08C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NetMulticastCharacterOverlap(class AActor* InActor);
	void OnValidCharacterOverlap(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10165102">();
	}
	static class ASummoned_10165102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10165102>();
	}
};
static_assert(alignof(ASummoned_10165102) == 0x000010, "Wrong alignment on ASummoned_10165102");
static_assert(sizeof(ASummoned_10165102) == 0x0008D0, "Wrong size on ASummoned_10165102");
static_assert(offsetof(ASummoned_10165102, OverlapCollisionComponent) == 0x000890, "Member 'ASummoned_10165102::OverlapCollisionComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10165102, OverlapHandleComponent) == 0x000898, "Member 'ASummoned_10165102::OverlapHandleComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10165102, OverlapActorDelegate) == 0x0008A0, "Member 'ASummoned_10165102::OverlapActorDelegate' has a wrong offset!");
static_assert(offsetof(ASummoned_10165102, OverlappedActor) == 0x0008B0, "Member 'ASummoned_10165102::OverlappedActor' has a wrong offset!");
static_assert(offsetof(ASummoned_10165102, bHasExecuteCue) == 0x0008C0, "Member 'ASummoned_10165102::bHasExecuteCue' has a wrong offset!");

// Class Hero_1016.Cue_Summoner_Loop_10165101
// 0x0098 (0x0F28 - 0x0E90)
class ACue_Summoner_Loop_10165101 : public AMarvelCueNotify_Summoned
{
public:
	class UNiagaraComponent*                      TeammateEffectFX;                                  // 0x0E90(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeammateEffectSocket;                              // 0x0E98(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA4[0x4];                                      // 0x0EA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             FX_MaterialSlotName_Set;                           // 0x0EA8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           FX_InColor_Param;                                  // 0x0EF8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FX_Fresnel_Param;                                  // 0x0F08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FX_InExponentln_Param;                             // 0x0F0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FX_InIntensity_Param;                              // 0x0F10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F14[0x4];                                      // 0x0F14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeclarationHolder                     DeclareViewSideHolder;                             // 0x0F18(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);
	void SetTeammateMaterialParams(bool bSet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10165101">();
	}
	static class ACue_Summoner_Loop_10165101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10165101>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10165101) == 0x000008, "Wrong alignment on ACue_Summoner_Loop_10165101");
static_assert(sizeof(ACue_Summoner_Loop_10165101) == 0x000F28, "Wrong size on ACue_Summoner_Loop_10165101");
static_assert(offsetof(ACue_Summoner_Loop_10165101, TeammateEffectFX) == 0x000E90, "Member 'ACue_Summoner_Loop_10165101::TeammateEffectFX' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, TeammateEffectSocket) == 0x000E98, "Member 'ACue_Summoner_Loop_10165101::TeammateEffectSocket' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, FX_MaterialSlotName_Set) == 0x000EA8, "Member 'ACue_Summoner_Loop_10165101::FX_MaterialSlotName_Set' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, FX_InColor_Param) == 0x000EF8, "Member 'ACue_Summoner_Loop_10165101::FX_InColor_Param' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, FX_Fresnel_Param) == 0x000F08, "Member 'ACue_Summoner_Loop_10165101::FX_Fresnel_Param' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, FX_InExponentln_Param) == 0x000F0C, "Member 'ACue_Summoner_Loop_10165101::FX_InExponentln_Param' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, FX_InIntensity_Param) == 0x000F10, "Member 'ACue_Summoner_Loop_10165101::FX_InIntensity_Param' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10165101, DeclareViewSideHolder) == 0x000F18, "Member 'ACue_Summoner_Loop_10165101::DeclareViewSideHolder' has a wrong offset!");

// Class Hero_1016.Config_101651
// 0x10F8 (0x1190 - 0x0098)
class UConfig_101651 final : public UMarvelAbilityConfig
{
public:
	float                                         AbilityDamageDecayRatio;                           // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            PhantomBuffMap;                                    // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFindGroundParam                       FindGroundParam;                                   // 0x00F0(0x0FD0)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Aim_MaxDistance;                                   // 0x10C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swap_MaxDistance;                                  // 0x10C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 FowardAbilities;                                   // 0x10C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BuffTable;                                         // 0x10D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockTurnTagContainer;                             // 0x10E8(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         AimDistanceTraceForNoCircle;                       // 0x1150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckDegreeAngle;                                  // 0x1154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLokiPhantomSpec>               LokiPhantomSpecs;                                  // 0x1158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocationOffset;                               // 0x1168(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CueTag;                                            // 0x1180(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhantomFollowInstigatorVisibility;                // 0x118C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118D[0x3];                                     // 0x118D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UConfig_101651* GetLokiPhantomConfig();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101651">();
	}
	static class UConfig_101651* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101651>();
	}
};
static_assert(alignof(UConfig_101651) == 0x000010, "Wrong alignment on UConfig_101651");
static_assert(sizeof(UConfig_101651) == 0x001190, "Wrong size on UConfig_101651");
static_assert(offsetof(UConfig_101651, AbilityDamageDecayRatio) == 0x000098, "Member 'UConfig_101651::AbilityDamageDecayRatio' has a wrong offset!");
static_assert(offsetof(UConfig_101651, PhantomBuffMap) == 0x0000A0, "Member 'UConfig_101651::PhantomBuffMap' has a wrong offset!");
static_assert(offsetof(UConfig_101651, FindGroundParam) == 0x0000F0, "Member 'UConfig_101651::FindGroundParam' has a wrong offset!");
static_assert(offsetof(UConfig_101651, Aim_MaxDistance) == 0x0010C0, "Member 'UConfig_101651::Aim_MaxDistance' has a wrong offset!");
static_assert(offsetof(UConfig_101651, Swap_MaxDistance) == 0x0010C4, "Member 'UConfig_101651::Swap_MaxDistance' has a wrong offset!");
static_assert(offsetof(UConfig_101651, FowardAbilities) == 0x0010C8, "Member 'UConfig_101651::FowardAbilities' has a wrong offset!");
static_assert(offsetof(UConfig_101651, BuffTable) == 0x0010D8, "Member 'UConfig_101651::BuffTable' has a wrong offset!");
static_assert(offsetof(UConfig_101651, BlockTurnTagContainer) == 0x0010E8, "Member 'UConfig_101651::BlockTurnTagContainer' has a wrong offset!");
static_assert(offsetof(UConfig_101651, AimDistanceTraceForNoCircle) == 0x001150, "Member 'UConfig_101651::AimDistanceTraceForNoCircle' has a wrong offset!");
static_assert(offsetof(UConfig_101651, CheckDegreeAngle) == 0x001154, "Member 'UConfig_101651::CheckDegreeAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101651, LokiPhantomSpecs) == 0x001158, "Member 'UConfig_101651::LokiPhantomSpecs' has a wrong offset!");
static_assert(offsetof(UConfig_101651, SpawnLocationOffset) == 0x001168, "Member 'UConfig_101651::SpawnLocationOffset' has a wrong offset!");
static_assert(offsetof(UConfig_101651, CueTag) == 0x001180, "Member 'UConfig_101651::CueTag' has a wrong offset!");
static_assert(offsetof(UConfig_101651, bPhantomFollowInstigatorVisibility) == 0x00118C, "Member 'UConfig_101651::bPhantomFollowInstigatorVisibility' has a wrong offset!");

// Class Hero_1016.Scope_Loki
// 0x0010 (0x1710 - 0x1700)
class AScope_Loki final : public AMarvelAbilityTargetActor_Scope
{
public:
	uint8                                         Pad_1700[0x8];                                     // 0x1700(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPhantomOwned;                                     // 0x1708(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1709[0x7];                                     // 0x1709(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPhantomOwned();
	void SetPhantomOwned(bool bOwned);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_Loki">();
	}
	static class AScope_Loki* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_Loki>();
	}
};
static_assert(alignof(AScope_Loki) == 0x000010, "Wrong alignment on AScope_Loki");
static_assert(sizeof(AScope_Loki) == 0x001710, "Wrong size on AScope_Loki");
static_assert(offsetof(AScope_Loki, bPhantomOwned) == 0x001708, "Member 'AScope_Loki::bPhantomOwned' has a wrong offset!");

// Class Hero_1016.LokiPhantomStatics
// 0x0000 (0x0030 - 0x0030)
class ULokiPhantomStatics final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class AActor*> GetLokiPhantoms(class AMarvelBaseCharacter* InSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiPhantomStatics">();
	}
	static class ULokiPhantomStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiPhantomStatics>();
	}
};
static_assert(alignof(ULokiPhantomStatics) == 0x000008, "Wrong alignment on ULokiPhantomStatics");
static_assert(sizeof(ULokiPhantomStatics) == 0x000030, "Wrong size on ULokiPhantomStatics");

// Class Hero_1016.LokiPhantomManagementComponent
// 0x0FD0 (0x10C0 - 0x00F0)
class ULokiPhantomManagementComponent final : public UActorComponent
{
public:
	class UConfig_101651*                         PhantomConfig;                                     // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMarvelAbilityTraceContext             AimPointTraceParam;                                // 0x0100(0x0F90)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TickPhantomTurnInterval;                           // 0x1090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickPhantomTickInterval;                           // 0x1094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1098[0x18];                                    // 0x1098(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickPhantomTurnCounter;                            // 0x10B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickPhantomTickCounter;                            // 0x10B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B8[0x8];                                     // 0x10B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetOriginCharacterAimedLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiPhantomManagementComponent">();
	}
	static class ULokiPhantomManagementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiPhantomManagementComponent>();
	}
};
static_assert(alignof(ULokiPhantomManagementComponent) == 0x000010, "Wrong alignment on ULokiPhantomManagementComponent");
static_assert(sizeof(ULokiPhantomManagementComponent) == 0x0010C0, "Wrong size on ULokiPhantomManagementComponent");
static_assert(offsetof(ULokiPhantomManagementComponent, PhantomConfig) == 0x0000F0, "Member 'ULokiPhantomManagementComponent::PhantomConfig' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, InstigatorCharacter) == 0x0000F8, "Member 'ULokiPhantomManagementComponent::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, AimPointTraceParam) == 0x000100, "Member 'ULokiPhantomManagementComponent::AimPointTraceParam' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, TickPhantomTurnInterval) == 0x001090, "Member 'ULokiPhantomManagementComponent::TickPhantomTurnInterval' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, TickPhantomTickInterval) == 0x001094, "Member 'ULokiPhantomManagementComponent::TickPhantomTickInterval' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, TickPhantomTurnCounter) == 0x0010B0, "Member 'ULokiPhantomManagementComponent::TickPhantomTurnCounter' has a wrong offset!");
static_assert(offsetof(ULokiPhantomManagementComponent, TickPhantomTickCounter) == 0x0010B4, "Member 'ULokiPhantomManagementComponent::TickPhantomTickCounter' has a wrong offset!");

// Class Hero_1016.LokiAnimTimelineComponent
// 0x0010 (0x0228 - 0x0218)
class ULokiAnimTimelineComponent final : public UAnimTimelineComponent
{
public:
	class UConfig_101651*                         PhantomConfig;                                     // 0x0218(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x0220(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiAnimTimelineComponent">();
	}
	static class ULokiAnimTimelineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiAnimTimelineComponent>();
	}
};
static_assert(alignof(ULokiAnimTimelineComponent) == 0x000008, "Wrong alignment on ULokiAnimTimelineComponent");
static_assert(sizeof(ULokiAnimTimelineComponent) == 0x000228, "Wrong size on ULokiAnimTimelineComponent");
static_assert(offsetof(ULokiAnimTimelineComponent, PhantomConfig) == 0x000218, "Member 'ULokiAnimTimelineComponent::PhantomConfig' has a wrong offset!");
static_assert(offsetof(ULokiAnimTimelineComponent, InstigatorCharacter) == 0x000220, "Member 'ULokiAnimTimelineComponent::InstigatorCharacter' has a wrong offset!");

// Class Hero_1016.Config_101652
// 0x0078 (0x0110 - 0x0098)
class UConfig_101652 final : public UMarvelAbilityConfig
{
public:
	struct FVector2D                              LockRange;                                         // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockTagContainer;                                 // 0x00A8(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101652">();
	}
	static class UConfig_101652* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101652>();
	}
};
static_assert(alignof(UConfig_101652) == 0x000008, "Wrong alignment on UConfig_101652");
static_assert(sizeof(UConfig_101652) == 0x000110, "Wrong size on UConfig_101652");
static_assert(offsetof(UConfig_101652, LockRange) == 0x000098, "Member 'UConfig_101652::LockRange' has a wrong offset!");
static_assert(offsetof(UConfig_101652, BlockTagContainer) == 0x0000A8, "Member 'UConfig_101652::BlockTagContainer' has a wrong offset!");

// Class Hero_1016.Ability_101652
// 0x0018 (0x2598 - 0x2580)
class UAbility_101652 : public UMarvelGameplayAbility
{
public:
	class ASummoned_10165101*                     TargetPhantom;                                     // 0x2580(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  ViewportTarget;                                    // 0x2588(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_101652*                         Config;                                            // 0x2590(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float AnglesToPoint(const struct FTransform& Transform, const struct FVector& Point);
	class AActor* GetProperPhantoms();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101652">();
	}
	static class UAbility_101652* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101652>();
	}
};
static_assert(alignof(UAbility_101652) == 0x000008, "Wrong alignment on UAbility_101652");
static_assert(sizeof(UAbility_101652) == 0x002598, "Wrong size on UAbility_101652");
static_assert(offsetof(UAbility_101652, TargetPhantom) == 0x002580, "Member 'UAbility_101652::TargetPhantom' has a wrong offset!");
static_assert(offsetof(UAbility_101652, ViewportTarget) == 0x002588, "Member 'UAbility_101652::ViewportTarget' has a wrong offset!");
static_assert(offsetof(UAbility_101652, Config) == 0x002590, "Member 'UAbility_101652::Config' has a wrong offset!");

// Class Hero_1016.UIC_SelectTarget_101652
// 0x0008 (0x0160 - 0x0158)
class UUIC_SelectTarget_101652 final : public UUIC_SelectTarget
{
public:
	class UAbility_101652*                        Ability_101652;                                    // 0x0158(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIC_SelectTarget_101652">();
	}
	static class UUIC_SelectTarget_101652* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIC_SelectTarget_101652>();
	}
};
static_assert(alignof(UUIC_SelectTarget_101652) == 0x000008, "Wrong alignment on UUIC_SelectTarget_101652");
static_assert(sizeof(UUIC_SelectTarget_101652) == 0x000160, "Wrong size on UUIC_SelectTarget_101652");
static_assert(offsetof(UUIC_SelectTarget_101652, Ability_101652) == 0x000158, "Member 'UUIC_SelectTarget_101652::Ability_101652' has a wrong offset!");

// Class Hero_1016.Config_101661
// 0x1368 (0x1400 - 0x0098)
class UConfig_101661 final : public UMarvelAbilityConfig
{
public:
	int32                                         TargetDeceptionBuffID;                             // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetDuplicateBuffID;                             // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetStopDisguiseBuffID;                          // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetStopDisguiseRetentionTime;                   // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourcePrepDisguiseBuffID;                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourcePostDisguiseBuffID;                          // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               SourcePostDisguiseRemoveBuffTagRequirements;       // 0x00B0(0x0118)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetFXCueTag;                                    // 0x01C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetFXCueDuration;                               // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSelectTaskParam                       SelectTaskParam;                                   // 0x01E0(0x10A0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AlwaysExcludedAbilities;                           // 0x1280(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExposeIfAbilityActivated;                          // 0x12E8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExposeTagContainer;                                // 0x1350(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag_InterruptDisguise;                             // 0x13B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExposeWhenHitOrReceiveBuff;                       // 0x13C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C5[0x3];                                     // 0x13C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraTransitionSpeed;                             // 0x13C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTransitionMaxSpeed;                          // 0x13CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTransitionAcceleration;                      // 0x13D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTransitionMinStep;                           // 0x13D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrantedUltimateEnergyPercent;                      // 0x13D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAbilityDuration;                                // 0x13DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraUltimateAbilityDuration;                      // 0x13E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MRFantasyEachJumpTime;                             // 0x13E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UserSettingConfirmationKeyName;                    // 0x13E8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfirmationIntervals;                             // 0x13F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F8[0x8];                                     // 0x13F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101661">();
	}
	static class UConfig_101661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101661>();
	}
};
static_assert(alignof(UConfig_101661) == 0x000010, "Wrong alignment on UConfig_101661");
static_assert(sizeof(UConfig_101661) == 0x001400, "Wrong size on UConfig_101661");
static_assert(offsetof(UConfig_101661, TargetDeceptionBuffID) == 0x000098, "Member 'UConfig_101661::TargetDeceptionBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101661, TargetDuplicateBuffID) == 0x00009C, "Member 'UConfig_101661::TargetDuplicateBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101661, TargetStopDisguiseBuffID) == 0x0000A0, "Member 'UConfig_101661::TargetStopDisguiseBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101661, TargetStopDisguiseRetentionTime) == 0x0000A4, "Member 'UConfig_101661::TargetStopDisguiseRetentionTime' has a wrong offset!");
static_assert(offsetof(UConfig_101661, SourcePrepDisguiseBuffID) == 0x0000A8, "Member 'UConfig_101661::SourcePrepDisguiseBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101661, SourcePostDisguiseBuffID) == 0x0000AC, "Member 'UConfig_101661::SourcePostDisguiseBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101661, SourcePostDisguiseRemoveBuffTagRequirements) == 0x0000B0, "Member 'UConfig_101661::SourcePostDisguiseRemoveBuffTagRequirements' has a wrong offset!");
static_assert(offsetof(UConfig_101661, TargetFXCueTag) == 0x0001C8, "Member 'UConfig_101661::TargetFXCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_101661, TargetFXCueDuration) == 0x0001D4, "Member 'UConfig_101661::TargetFXCueDuration' has a wrong offset!");
static_assert(offsetof(UConfig_101661, SelectTaskParam) == 0x0001E0, "Member 'UConfig_101661::SelectTaskParam' has a wrong offset!");
static_assert(offsetof(UConfig_101661, AlwaysExcludedAbilities) == 0x001280, "Member 'UConfig_101661::AlwaysExcludedAbilities' has a wrong offset!");
static_assert(offsetof(UConfig_101661, ExposeIfAbilityActivated) == 0x0012E8, "Member 'UConfig_101661::ExposeIfAbilityActivated' has a wrong offset!");
static_assert(offsetof(UConfig_101661, ExposeTagContainer) == 0x001350, "Member 'UConfig_101661::ExposeTagContainer' has a wrong offset!");
static_assert(offsetof(UConfig_101661, Tag_InterruptDisguise) == 0x0013B8, "Member 'UConfig_101661::Tag_InterruptDisguise' has a wrong offset!");
static_assert(offsetof(UConfig_101661, bExposeWhenHitOrReceiveBuff) == 0x0013C4, "Member 'UConfig_101661::bExposeWhenHitOrReceiveBuff' has a wrong offset!");
static_assert(offsetof(UConfig_101661, CameraTransitionSpeed) == 0x0013C8, "Member 'UConfig_101661::CameraTransitionSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101661, CameraTransitionMaxSpeed) == 0x0013CC, "Member 'UConfig_101661::CameraTransitionMaxSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101661, CameraTransitionAcceleration) == 0x0013D0, "Member 'UConfig_101661::CameraTransitionAcceleration' has a wrong offset!");
static_assert(offsetof(UConfig_101661, CameraTransitionMinStep) == 0x0013D4, "Member 'UConfig_101661::CameraTransitionMinStep' has a wrong offset!");
static_assert(offsetof(UConfig_101661, GrantedUltimateEnergyPercent) == 0x0013D8, "Member 'UConfig_101661::GrantedUltimateEnergyPercent' has a wrong offset!");
static_assert(offsetof(UConfig_101661, MaxAbilityDuration) == 0x0013DC, "Member 'UConfig_101661::MaxAbilityDuration' has a wrong offset!");
static_assert(offsetof(UConfig_101661, ExtraUltimateAbilityDuration) == 0x0013E0, "Member 'UConfig_101661::ExtraUltimateAbilityDuration' has a wrong offset!");
static_assert(offsetof(UConfig_101661, MRFantasyEachJumpTime) == 0x0013E4, "Member 'UConfig_101661::MRFantasyEachJumpTime' has a wrong offset!");
static_assert(offsetof(UConfig_101661, UserSettingConfirmationKeyName) == 0x0013E8, "Member 'UConfig_101661::UserSettingConfirmationKeyName' has a wrong offset!");
static_assert(offsetof(UConfig_101661, ConfirmationIntervals) == 0x0013F4, "Member 'UConfig_101661::ConfirmationIntervals' has a wrong offset!");

// Class Hero_1016.Ability_101661
// 0x01C0 (0x2740 - 0x2580)
class UAbility_101661 : public UMarvelGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             OnTryActivateWithoutTarget;                        // 0x2580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPrimaryTargetUpdate;                             // 0x2590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActingCharacterKillActor;                        // 0x25A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B0[0x18];                                    // 0x25B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_101661*                         MyConfig;                                          // 0x25C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtraUltimateTime;                                 // 0x25D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DisguiseStateUltimateUseCount;                     // 0x25D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         DisguiseStateEndedKey;                             // 0x25D8(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  ViewportTarget;                                    // 0x2678(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SavedTargetHeroID;                                 // 0x2680(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SavedTargetSkinID;                                 // 0x2684(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SavedTargetIsEnemy;                                // 0x2688(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBattleSide                                   SavedTargetBattleSide;                             // 0x2689(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268A[0x6];                                     // 0x268A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SavedTargetPlayerName;                             // 0x2690(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerState*                           SavedTargetPlayerState;                            // 0x26A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SavedTargetCollisionRadius;                        // 0x26A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SavedTargetCollisionHalfHeight;                    // 0x26AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   ActingCharacter;                                   // 0x26B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AController*                            ActingController;                                  // 0x26B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelPlayerState*                     ActingPlayerState;                                 // 0x26C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetDuplicateEffectStartTime;                    // 0x26C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            TargetDuplicateEffectHandle;                       // 0x26CC(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            TargetDeceptionEffectHandle;                       // 0x26D4(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26DC[0x4];                                     // 0x26DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffectHandle>    SourceDisguiseEffectHandles;                       // 0x26E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitGameplayEffectRemoved* WaitEffectRemovedTask;                             // 0x26F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_SelectTarget*        SelectTask;                                        // 0x26F8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitGameplayEvent*         WaitGameplayEvent;                                 // 0x2700(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2708[0x38];                                    // 0x2708(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddActingCharacterEnergyValue(class AActor* SourceActor);
	struct FTransform AdjustPawnTransform(const class APawn* NewPawn, const class APawn* OldPawn, const struct FTransform& OldTransform);
	bool CheckViewportTarget(const class AMarvelBaseCharacter* SourceCharacter, const class AActor* InTarget);
	void On104061JumpAgain(class UMarvelGameplayAbility* InAbility);
	void OnActingCharacterAbilityFinishedInit(class AActor* SourceActor);
	void OnActingCharacterKillActor__DelegateSignature(class AActor* KillTarget);
	void OnActingCharacterTagUpdated(const struct FGameplayTag& InTag, bool bInExists);
	void OnActorDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnBannerTagAdded();
	void OnDisguiseEffectRemoved(const struct FGameplayEffectRemovalInfo& InGameplayEffectRemovalInfo);
	void OnDisguiseInterruptedTagEvent(const struct FGameplayEventData& Payload);
	void OnDisguiseStateChanged(class AMarvelPlayerState* InPlayerState, class APawn* InNewPawn, class APawn* InOldPawn);
	void OnDisguiseStateEnded_CameraTransition(class AMarvelPlayerState* InPlayerState);
	void OnDisguiseStateEnded_PlayEndTimeline();
	void OnHeroHulkAbilitiesFinishInit(class AActor* SourceActor);
	void OnMrFantasyAbilityEnd(const struct FAbilityEndedData& InAbilityEndedData);
	void OnMySelfPlayerStateChange(class AMarvelPlayerState* InPlayerState);
	void OnPrimaryTargetUpdate__DelegateSignature(class AActor* InTarget);
	void OnServerControllerPostNewPawn(class APawn* InPawn);
	void OnServerControllerPostPawnSpawn(class APawn* InPawn, ESpawnMethod InMethod);
	void OnServerControllerPreNewPawn(class APawn* InPawn);
	void OnTargetPlayerAbilityActivated(class UGameplayAbility* InAbility);
	void OnTargetPlayerAbilityCommitted(class UGameplayAbility* InAbility);
	void OnTargetPlayerControllerSet();
	void OnTargetPlayerPreDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnTargetPlayerReceiveEffect(class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& EffectHandle);
	void OnTryActivateWithoutTarget__DelegateSignature();
	void PrepDisguiseEffect();
	void ReCalculateAbilityRemainTime(class UMarvelGameplayAbility* InAbility);
	void ResetSelectTask();
	bool StartDisguiseEffect();
	void StopDisguiseEffect(bool bIsAvatarAlive, class AActor* InSourceAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	bool VerifyAndSaveTarget(const class AActor* InTarget);

	bool IsDisguiseActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101661">();
	}
	static class UAbility_101661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101661>();
	}
};
static_assert(alignof(UAbility_101661) == 0x000008, "Wrong alignment on UAbility_101661");
static_assert(sizeof(UAbility_101661) == 0x002740, "Wrong size on UAbility_101661");
static_assert(offsetof(UAbility_101661, OnTryActivateWithoutTarget) == 0x002580, "Member 'UAbility_101661::OnTryActivateWithoutTarget' has a wrong offset!");
static_assert(offsetof(UAbility_101661, OnPrimaryTargetUpdate) == 0x002590, "Member 'UAbility_101661::OnPrimaryTargetUpdate' has a wrong offset!");
static_assert(offsetof(UAbility_101661, OnActingCharacterKillActor) == 0x0025A0, "Member 'UAbility_101661::OnActingCharacterKillActor' has a wrong offset!");
static_assert(offsetof(UAbility_101661, MyConfig) == 0x0025C8, "Member 'UAbility_101661::MyConfig' has a wrong offset!");
static_assert(offsetof(UAbility_101661, ExtraUltimateTime) == 0x0025D0, "Member 'UAbility_101661::ExtraUltimateTime' has a wrong offset!");
static_assert(offsetof(UAbility_101661, DisguiseStateUltimateUseCount) == 0x0025D4, "Member 'UAbility_101661::DisguiseStateUltimateUseCount' has a wrong offset!");
static_assert(offsetof(UAbility_101661, DisguiseStateEndedKey) == 0x0025D8, "Member 'UAbility_101661::DisguiseStateEndedKey' has a wrong offset!");
static_assert(offsetof(UAbility_101661, ViewportTarget) == 0x002678, "Member 'UAbility_101661::ViewportTarget' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetHeroID) == 0x002680, "Member 'UAbility_101661::SavedTargetHeroID' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetSkinID) == 0x002684, "Member 'UAbility_101661::SavedTargetSkinID' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetIsEnemy) == 0x002688, "Member 'UAbility_101661::SavedTargetIsEnemy' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetBattleSide) == 0x002689, "Member 'UAbility_101661::SavedTargetBattleSide' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetPlayerName) == 0x002690, "Member 'UAbility_101661::SavedTargetPlayerName' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetPlayerState) == 0x0026A0, "Member 'UAbility_101661::SavedTargetPlayerState' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetCollisionRadius) == 0x0026A8, "Member 'UAbility_101661::SavedTargetCollisionRadius' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SavedTargetCollisionHalfHeight) == 0x0026AC, "Member 'UAbility_101661::SavedTargetCollisionHalfHeight' has a wrong offset!");
static_assert(offsetof(UAbility_101661, ActingCharacter) == 0x0026B0, "Member 'UAbility_101661::ActingCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_101661, ActingController) == 0x0026B8, "Member 'UAbility_101661::ActingController' has a wrong offset!");
static_assert(offsetof(UAbility_101661, ActingPlayerState) == 0x0026C0, "Member 'UAbility_101661::ActingPlayerState' has a wrong offset!");
static_assert(offsetof(UAbility_101661, TargetDuplicateEffectStartTime) == 0x0026C8, "Member 'UAbility_101661::TargetDuplicateEffectStartTime' has a wrong offset!");
static_assert(offsetof(UAbility_101661, TargetDuplicateEffectHandle) == 0x0026CC, "Member 'UAbility_101661::TargetDuplicateEffectHandle' has a wrong offset!");
static_assert(offsetof(UAbility_101661, TargetDeceptionEffectHandle) == 0x0026D4, "Member 'UAbility_101661::TargetDeceptionEffectHandle' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SourceDisguiseEffectHandles) == 0x0026E0, "Member 'UAbility_101661::SourceDisguiseEffectHandles' has a wrong offset!");
static_assert(offsetof(UAbility_101661, WaitEffectRemovedTask) == 0x0026F0, "Member 'UAbility_101661::WaitEffectRemovedTask' has a wrong offset!");
static_assert(offsetof(UAbility_101661, SelectTask) == 0x0026F8, "Member 'UAbility_101661::SelectTask' has a wrong offset!");
static_assert(offsetof(UAbility_101661, WaitGameplayEvent) == 0x002700, "Member 'UAbility_101661::WaitGameplayEvent' has a wrong offset!");

// Class Hero_1016.CharacterSpawnPipeline_101661
// 0x0000 (0x0030 - 0x0030)
class UCharacterSpawnPipeline_101661 final : public UMarvelCharacterSpawnPipeline
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSpawnPipeline_101661">();
	}
	static class UCharacterSpawnPipeline_101661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSpawnPipeline_101661>();
	}
};
static_assert(alignof(UCharacterSpawnPipeline_101661) == 0x000008, "Wrong alignment on UCharacterSpawnPipeline_101661");
static_assert(sizeof(UCharacterSpawnPipeline_101661) == 0x000030, "Wrong size on UCharacterSpawnPipeline_101661");

// Class Hero_1016.ExtraWidget_101661
// 0x0000 (0x07A8 - 0x07A8)
class UExtraWidget_101661 final : public UWidget_AbilityStatus_Normal
{
public:
	void SetDurationAndStartCountDown(float Duration, float TimeRemaining);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtraWidget_101661">();
	}
	static class UExtraWidget_101661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtraWidget_101661>();
	}
};
static_assert(alignof(UExtraWidget_101661) == 0x000008, "Wrong alignment on UExtraWidget_101661");
static_assert(sizeof(UExtraWidget_101661) == 0x0007A8, "Wrong size on UExtraWidget_101661");

// Class Hero_1016.CueNotify_10166102
// 0x0088 (0x10C0 - 0x1038)
class ACueNotify_10166102 final : public AMarvelCueNotify_Buff
{
public:
	struct FGameplayTag                           DisguiseEffectGameplayTag;                         // 0x1038(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1044[0x4];                                     // 0x1044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   Character;                                         // 0x1048(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           SetDyeingStateTimerHandle;                         // 0x1050(0x0018)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           SetTickEnabledTimerHandle;                         // 0x1068(0x0018)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x1080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1084[0x4];                                     // 0x1084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RecoveryCurve;                                     // 0x1088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryTime;                                      // 0x1090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x1094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1098[0x18];                                    // 0x1098(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      InStableNiagara;                                   // 0x10B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBuffDuration;                                   // 0x10B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastTimeBuffRemainTime;                            // 0x10BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EnableSelfTick();
	void MyOnRemoveFX(class AActor* MyTarget);
	void OnTagUpdate(const struct FGameplayTag& Tag, bool bTagExists);
	void SetChildMeshMaterials(class AMarvelCharacterChildActor* InChildActor, const TArray<class FName>& SocketNames, float Value);
	void SetDuplicateEffect(bool bEnabled, bool bDisguise, class AMarvelBaseCharacter* MyOwner);
	void SetDyeingStateDisabled();
	void SetDyeingStateEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueNotify_10166102">();
	}
	static class ACueNotify_10166102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueNotify_10166102>();
	}
};
static_assert(alignof(ACueNotify_10166102) == 0x000008, "Wrong alignment on ACueNotify_10166102");
static_assert(sizeof(ACueNotify_10166102) == 0x0010C0, "Wrong size on ACueNotify_10166102");
static_assert(offsetof(ACueNotify_10166102, DisguiseEffectGameplayTag) == 0x001038, "Member 'ACueNotify_10166102::DisguiseEffectGameplayTag' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, Character) == 0x001048, "Member 'ACueNotify_10166102::Character' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, SetDyeingStateTimerHandle) == 0x001050, "Member 'ACueNotify_10166102::SetDyeingStateTimerHandle' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, SetTickEnabledTimerHandle) == 0x001068, "Member 'ACueNotify_10166102::SetTickEnabledTimerHandle' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, DelayTime) == 0x001080, "Member 'ACueNotify_10166102::DelayTime' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, RecoveryCurve) == 0x001088, "Member 'ACueNotify_10166102::RecoveryCurve' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, RecoveryTime) == 0x001090, "Member 'ACueNotify_10166102::RecoveryTime' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, CurrentTime) == 0x001094, "Member 'ACueNotify_10166102::CurrentTime' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, InStableNiagara) == 0x0010B0, "Member 'ACueNotify_10166102::InStableNiagara' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, MaxBuffDuration) == 0x0010B8, "Member 'ACueNotify_10166102::MaxBuffDuration' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166102, LastTimeBuffRemainTime) == 0x0010BC, "Member 'ACueNotify_10166102::LastTimeBuffRemainTime' has a wrong offset!");

// Class Hero_1016.CueNotify_10166104
// 0x0028 (0x0EF0 - 0x0EC8)
class ACueNotify_10166104 final : public AMarvelCueNotify_Loop
{
public:
	class UFXSystemComponent*                     EffectComponent;                                   // 0x0EC8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         FXConnection;                                      // 0x0ED0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PositionSocket;                                    // 0x0ED8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EE4[0x4];                                      // 0x0EE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   SourceCharacter;                                   // 0x0EE8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueNotify_10166104">();
	}
	static class ACueNotify_10166104* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueNotify_10166104>();
	}
};
static_assert(alignof(ACueNotify_10166104) == 0x000008, "Wrong alignment on ACueNotify_10166104");
static_assert(sizeof(ACueNotify_10166104) == 0x000EF0, "Wrong size on ACueNotify_10166104");
static_assert(offsetof(ACueNotify_10166104, EffectComponent) == 0x000EC8, "Member 'ACueNotify_10166104::EffectComponent' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166104, FXConnection) == 0x000ED0, "Member 'ACueNotify_10166104::FXConnection' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166104, PositionSocket) == 0x000ED8, "Member 'ACueNotify_10166104::PositionSocket' has a wrong offset!");
static_assert(offsetof(ACueNotify_10166104, SourceCharacter) == 0x000EE8, "Member 'ACueNotify_10166104::SourceCharacter' has a wrong offset!");

// Class Hero_1016.Cue_Scope_Loop_10163101
// 0x0018 (0x0D88 - 0x0D70)
class ACue_Scope_Loop_10163101 final : public AMarvelCueNotify_Scope
{
public:
	class UDecalComponent*                        DecalComponent;                                    // 0x0D70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           DecalScaleCurve;                                   // 0x0D78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D80[0x8];                                      // 0x0D80(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10163101">();
	}
	static class ACue_Scope_Loop_10163101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10163101>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10163101) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10163101");
static_assert(sizeof(ACue_Scope_Loop_10163101) == 0x000D88, "Wrong size on ACue_Scope_Loop_10163101");
static_assert(offsetof(ACue_Scope_Loop_10163101, DecalComponent) == 0x000D70, "Member 'ACue_Scope_Loop_10163101::DecalComponent' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10163101, DecalScaleCurve) == 0x000D78, "Member 'ACue_Scope_Loop_10163101::DecalScaleCurve' has a wrong offset!");

// Class Hero_1016.EpicMomentAction_1016
// 0x0028 (0x0198 - 0x0170)
class UEpicMomentAction_1016 : public UEpicMomentAction_Treat
{
public:
	class UMarvelGameplayAbility*                 DisguiseAbility;                                   // 0x0170(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelGameplayAbility*                 ShiftAbility;                                      // 0x0178(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x4];                                      // 0x0180(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    ShiftConfig;                                       // 0x0184(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ShiftDamageThreshold;                              // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorDamageToCure(class AActor* InSource, class AActor* InTarget, int32 AbilityID, float Value, float DamageValue);
	void OnShiftAbilityEnd();
	void OnSummonedBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Summoned, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnSummonedEnd(class AActor* InSummoner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1016">();
	}
	static class UEpicMomentAction_1016* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1016>();
	}
};
static_assert(alignof(UEpicMomentAction_1016) == 0x000008, "Wrong alignment on UEpicMomentAction_1016");
static_assert(sizeof(UEpicMomentAction_1016) == 0x000198, "Wrong size on UEpicMomentAction_1016");
static_assert(offsetof(UEpicMomentAction_1016, DisguiseAbility) == 0x000170, "Member 'UEpicMomentAction_1016::DisguiseAbility' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1016, ShiftAbility) == 0x000178, "Member 'UEpicMomentAction_1016::ShiftAbility' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1016, ShiftConfig) == 0x000184, "Member 'UEpicMomentAction_1016::ShiftConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1016, ShiftDamageThreshold) == 0x000190, "Member 'UEpicMomentAction_1016::ShiftDamageThreshold' has a wrong offset!");

// Class Hero_1016.LokiAnimInstance
// 0x0010 (0x0920 - 0x0910)
class ULokiAnimInstance : public UMarvelAnimInstance
{
public:
	int32                                         AimOffsetAnimIndex;                                // 0x0910(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_914[0xC];                                      // 0x0914(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiAnimInstance">();
	}
	static class ULokiAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiAnimInstance>();
	}
};
static_assert(alignof(ULokiAnimInstance) == 0x000010, "Wrong alignment on ULokiAnimInstance");
static_assert(sizeof(ULokiAnimInstance) == 0x000920, "Wrong size on ULokiAnimInstance");
static_assert(offsetof(ULokiAnimInstance, AimOffsetAnimIndex) == 0x000910, "Member 'ULokiAnimInstance::AimOffsetAnimIndex' has a wrong offset!");

// Class Hero_1016.LokiPhantomAnimInstance
// 0x0000 (0x0920 - 0x0920)
class ULokiPhantomAnimInstance final : public ULokiAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiPhantomAnimInstance">();
	}
	static class ULokiPhantomAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiPhantomAnimInstance>();
	}
};
static_assert(alignof(ULokiPhantomAnimInstance) == 0x000010, "Wrong alignment on ULokiPhantomAnimInstance");
static_assert(sizeof(ULokiPhantomAnimInstance) == 0x000920, "Wrong size on ULokiPhantomAnimInstance");

// Class Hero_1016.LokiPhantomGroundMotionSubAnimInstance
// 0x0030 (0x1340 - 0x1310)
class ULokiPhantomGroundMotionSubAnimInstance final : public UGroundMotionSubAnimInstanceV2
{
public:
	bool                                          bLokiPhantomIsInAir;                               // 0x1308(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1309[0x7];                                     // 0x1309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             SummonedChracter;                                  // 0x1310(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1318[0x28];                                    // 0x1318(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiPhantomGroundMotionSubAnimInstance">();
	}
	static class ULokiPhantomGroundMotionSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiPhantomGroundMotionSubAnimInstance>();
	}
};
static_assert(alignof(ULokiPhantomGroundMotionSubAnimInstance) == 0x000010, "Wrong alignment on ULokiPhantomGroundMotionSubAnimInstance");
static_assert(sizeof(ULokiPhantomGroundMotionSubAnimInstance) == 0x001340, "Wrong size on ULokiPhantomGroundMotionSubAnimInstance");
static_assert(offsetof(ULokiPhantomGroundMotionSubAnimInstance, bLokiPhantomIsInAir) == 0x001308, "Member 'ULokiPhantomGroundMotionSubAnimInstance::bLokiPhantomIsInAir' has a wrong offset!");
static_assert(offsetof(ULokiPhantomGroundMotionSubAnimInstance, SummonedChracter) == 0x001310, "Member 'ULokiPhantomGroundMotionSubAnimInstance::SummonedChracter' has a wrong offset!");

// Class Hero_1016.LokiChildActor
// 0x0010 (0x0A70 - 0x0A60)
class ALokiChildActor : public AMarvelCharacterChildActor
{
public:
	class USkeletalMeshComponent*                 DaggerMesh;                                        // 0x0A60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      WeaponNiagara;                                     // 0x0A68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiChildActor">();
	}
	static class ALokiChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALokiChildActor>();
	}
};
static_assert(alignof(ALokiChildActor) == 0x000008, "Wrong alignment on ALokiChildActor");
static_assert(sizeof(ALokiChildActor) == 0x000A70, "Wrong size on ALokiChildActor");
static_assert(offsetof(ALokiChildActor, DaggerMesh) == 0x000A60, "Member 'ALokiChildActor::DaggerMesh' has a wrong offset!");
static_assert(offsetof(ALokiChildActor, WeaponNiagara) == 0x000A68, "Member 'ALokiChildActor::WeaponNiagara' has a wrong offset!");

// Class Hero_1016.LokiCharacter
// 0x0030 (0x1840 - 0x1810)
class ALokiCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bInVisible;                                        // 0x1810(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1811[0x7];                                     // 0x1811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULokiPhantomManagementComponent*        PhantomManagementComponent;                        // 0x1818(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULokiMoveLogicBaseComponent*            LokiMoveLogic;                                     // 0x1820(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetPhantomCache;                                // 0x1828(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1829[0x7];                                     // 0x1829(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActivePhantoms;                                    // 0x1830(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void SpawnLokiPhantom(const struct FTransform& InTransform, const class UMarvelGameplayAbility* InAbility);
	void UpdatePhantomManagementComponentTick(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiCharacter">();
	}
	static class ALokiCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALokiCharacter>();
	}
};
static_assert(alignof(ALokiCharacter) == 0x000010, "Wrong alignment on ALokiCharacter");
static_assert(sizeof(ALokiCharacter) == 0x001840, "Wrong size on ALokiCharacter");
static_assert(offsetof(ALokiCharacter, bInVisible) == 0x001810, "Member 'ALokiCharacter::bInVisible' has a wrong offset!");
static_assert(offsetof(ALokiCharacter, PhantomManagementComponent) == 0x001818, "Member 'ALokiCharacter::PhantomManagementComponent' has a wrong offset!");
static_assert(offsetof(ALokiCharacter, LokiMoveLogic) == 0x001820, "Member 'ALokiCharacter::LokiMoveLogic' has a wrong offset!");
static_assert(offsetof(ALokiCharacter, bResetPhantomCache) == 0x001828, "Member 'ALokiCharacter::bResetPhantomCache' has a wrong offset!");
static_assert(offsetof(ALokiCharacter, ActivePhantoms) == 0x001830, "Member 'ALokiCharacter::ActivePhantoms' has a wrong offset!");

// Class Hero_1016.LokiMoveLogicBaseComponent
// 0x0018 (0x0408 - 0x03F0)
class ULokiMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	float                                         FortStyleTurninPlaceLimitMinOffset_Invisible;      // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PhantomDistanceThreshold;                          // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALokiCharacter*                         Loki;                                              // 0x03F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiMoveLogicBaseComponent">();
	}
	static class ULokiMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiMoveLogicBaseComponent>();
	}
};
static_assert(alignof(ULokiMoveLogicBaseComponent) == 0x000008, "Wrong alignment on ULokiMoveLogicBaseComponent");
static_assert(sizeof(ULokiMoveLogicBaseComponent) == 0x000408, "Wrong size on ULokiMoveLogicBaseComponent");
static_assert(offsetof(ULokiMoveLogicBaseComponent, FortStyleTurninPlaceLimitMinOffset_Invisible) == 0x0003F0, "Member 'ULokiMoveLogicBaseComponent::FortStyleTurninPlaceLimitMinOffset_Invisible' has a wrong offset!");
static_assert(offsetof(ULokiMoveLogicBaseComponent, PhantomDistanceThreshold) == 0x0003F4, "Member 'ULokiMoveLogicBaseComponent::PhantomDistanceThreshold' has a wrong offset!");
static_assert(offsetof(ULokiMoveLogicBaseComponent, Loki) == 0x0003F8, "Member 'ULokiMoveLogicBaseComponent::Loki' has a wrong offset!");

// Class Hero_1016.LokiMovementComponent
// 0x0000 (0x1B60 - 0x1B60)
class ULokiMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LokiMovementComponent">();
	}
	static class ULokiMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULokiMovementComponent>();
	}
};
static_assert(alignof(ULokiMovementComponent) == 0x000010, "Wrong alignment on ULokiMovementComponent");
static_assert(sizeof(ULokiMovementComponent) == 0x001B60, "Wrong size on ULokiMovementComponent");

// Class Hero_1016.TabData_1016
// 0x0000 (0x0050 - 0x0050)
class UTabData_1016 : public UHeroTabDataBase
{
public:
	void OnActorDamageToCure(class AActor* InSource, class AActor* InTarget, int32 AbilityID, float Value, float DamageValue);
	void OnActorTakeHealth(class AActor* InInstigator, class AActor* InTarget, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1016">();
	}
	static class UTabData_1016* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1016>();
	}
};
static_assert(alignof(UTabData_1016) == 0x000008, "Wrong alignment on UTabData_1016");
static_assert(sizeof(UTabData_1016) == 0x000050, "Wrong size on UTabData_1016");

}

