#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Ability_condition

#include "Basic.hpp"

#include "Marvel_structs.hpp"
#include "MarvelAI_structs.hpp"
#include "MarvelAI_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "AIModule_structs.hpp"


namespace SDK
{

// PythonClass ability_condition.PyAIConditionBase
// 0x0000 (0x0038 - 0x0038)
class UPyAIConditionBase : public UAIAbilityCondition
{
public:
	bool CouldPass(const struct FRequiredAIDataForAutoAbility& AIAutoAbilityContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIConditionBase">();
	}
	static class UPyAIConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIConditionBase>();
	}
};
//static_assert(alignof(UPyAIConditionBase) == 0x000008, "Wrong alignment on UPyAIConditionBase");
//static_assert(sizeof(UPyAIConditionBase) == 0x000038, "Wrong size on UPyAIConditionBase");

// PythonClass ability_condition.PyAICondition_StormWeatherTypeIs
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_StormWeatherTypeIs final : public UPyAIConditionBase
{
public:
	int32                                         TargetWhetherType;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_StormWeatherTypeIs">();
	}
	static class UPyAICondition_StormWeatherTypeIs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_StormWeatherTypeIs>();
	}
};
//static_assert(alignof(UPyAICondition_StormWeatherTypeIs) == 0x000008, "Wrong alignment on UPyAICondition_StormWeatherTypeIs");
//static_assert(sizeof(UPyAICondition_StormWeatherTypeIs) == 0x000040, "Wrong size on UPyAICondition_StormWeatherTypeIs");
//static_assert(offsetof(UPyAICondition_StormWeatherTypeIs, TargetWhetherType) == 0x000038, "Member 'UPyAICondition_StormWeatherTypeIs::TargetWhetherType' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_SurroundCharacterCheck
// 0x0068 (0x00A0 - 0x0038)
class UPyAICondition_SurroundCharacterCheck : public UPyAIConditionBase
{
public:
	struct FRange_Int32Value                      CharacterNum;                                      // 0x0038(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRange_FloatValue                      CharacterDistRange;                                // 0x0040(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EAICharacterSide                              CharacterSide;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAICharacterLifeStatus                        CharacterAlive;                                    // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedVisible;                                       // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScreenByHeroID;                                    // 0x004B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   CharacterList;                                     // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_SurroundCharacterCheck">();
	}
	static class UPyAICondition_SurroundCharacterCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_SurroundCharacterCheck>();
	}
};
//static_assert(alignof(UPyAICondition_SurroundCharacterCheck) == 0x000008, "Wrong alignment on UPyAICondition_SurroundCharacterCheck");
//static_assert(sizeof(UPyAICondition_SurroundCharacterCheck) == 0x0000A0, "Wrong size on UPyAICondition_SurroundCharacterCheck");
//static_assert(offsetof(UPyAICondition_SurroundCharacterCheck, CharacterNum) == 0x000038, "Member 'UPyAICondition_SurroundCharacterCheck::CharacterNum' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_SurroundCharacterCheck, CharacterDistRange) == 0x000040, "Member 'UPyAICondition_SurroundCharacterCheck::CharacterDistRange' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_SurroundCharacterCheck, CharacterSide) == 0x000048, "Member 'UPyAICondition_SurroundCharacterCheck::CharacterSide' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_SurroundCharacterCheck, CharacterAlive) == 0x000049, "Member 'UPyAICondition_SurroundCharacterCheck::CharacterAlive' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_SurroundCharacterCheck, NeedVisible) == 0x00004A, "Member 'UPyAICondition_SurroundCharacterCheck::NeedVisible' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_SurroundCharacterCheck, ScreenByHeroID) == 0x00004B, "Member 'UPyAICondition_SurroundCharacterCheck::ScreenByHeroID' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_SurroundCharacterCheck, CharacterList) == 0x000050, "Member 'UPyAICondition_SurroundCharacterCheck::CharacterList' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_StormWeatherTypeIsNot
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_StormWeatherTypeIsNot final : public UPyAIConditionBase
{
public:
	int32                                         TargetWhetherType;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_StormWeatherTypeIsNot">();
	}
	static class UPyAICondition_StormWeatherTypeIsNot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_StormWeatherTypeIsNot>();
	}
};
//static_assert(alignof(UPyAICondition_StormWeatherTypeIsNot) == 0x000008, "Wrong alignment on UPyAICondition_StormWeatherTypeIsNot");
//static_assert(sizeof(UPyAICondition_StormWeatherTypeIsNot) == 0x000040, "Wrong size on UPyAICondition_StormWeatherTypeIsNot");
//static_assert(offsetof(UPyAICondition_StormWeatherTypeIsNot, TargetWhetherType) == 0x000038, "Member 'UPyAICondition_StormWeatherTypeIsNot::TargetWhetherType' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_AmmoNumCheck
// 0x0010 (0x0048 - 0x0038)
class UPyAICondition_AmmoNumCheck final : public UPyAIConditionBase
{
public:
	bool                                          DoCheckForProportion;                              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoCheckForNum;                                     // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmmoProportionThreshold;                           // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoNumThreshold;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseWeaponAmmo;                                     // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseReloadSkillAmmo;                                // 0x0045(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAmmoClipType                                 AmmoType;                                          // 0x0046(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_AmmoNumCheck">();
	}
	static class UPyAICondition_AmmoNumCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_AmmoNumCheck>();
	}
};
//static_assert(alignof(UPyAICondition_AmmoNumCheck) == 0x000008, "Wrong alignment on UPyAICondition_AmmoNumCheck");
//static_assert(sizeof(UPyAICondition_AmmoNumCheck) == 0x000048, "Wrong size on UPyAICondition_AmmoNumCheck");
//static_assert(offsetof(UPyAICondition_AmmoNumCheck, DoCheckForProportion) == 0x000038, "Member 'UPyAICondition_AmmoNumCheck::DoCheckForProportion' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_AmmoNumCheck, DoCheckForNum) == 0x000039, "Member 'UPyAICondition_AmmoNumCheck::DoCheckForNum' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_AmmoNumCheck, AmmoProportionThreshold) == 0x00003C, "Member 'UPyAICondition_AmmoNumCheck::AmmoProportionThreshold' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_AmmoNumCheck, AmmoNumThreshold) == 0x000040, "Member 'UPyAICondition_AmmoNumCheck::AmmoNumThreshold' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_AmmoNumCheck, UseWeaponAmmo) == 0x000044, "Member 'UPyAICondition_AmmoNumCheck::UseWeaponAmmo' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_AmmoNumCheck, UseReloadSkillAmmo) == 0x000045, "Member 'UPyAICondition_AmmoNumCheck::UseReloadSkillAmmo' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_AmmoNumCheck, AmmoType) == 0x000046, "Member 'UPyAICondition_AmmoNumCheck::AmmoType' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_LokiPhantomNumCheck
// 0x0010 (0x0048 - 0x0038)
class UPyAICondition_LokiPhantomNumCheck final : public UPyAIConditionBase
{
public:
	int32                                         MinPhantomNum;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPhantomNum;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredPhantomRange;                              // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequireIsVisible;                                  // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_LokiPhantomNumCheck">();
	}
	static class UPyAICondition_LokiPhantomNumCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_LokiPhantomNumCheck>();
	}
};
//static_assert(alignof(UPyAICondition_LokiPhantomNumCheck) == 0x000008, "Wrong alignment on UPyAICondition_LokiPhantomNumCheck");
//static_assert(sizeof(UPyAICondition_LokiPhantomNumCheck) == 0x000048, "Wrong size on UPyAICondition_LokiPhantomNumCheck");
//static_assert(offsetof(UPyAICondition_LokiPhantomNumCheck, MinPhantomNum) == 0x000038, "Member 'UPyAICondition_LokiPhantomNumCheck::MinPhantomNum' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_LokiPhantomNumCheck, MaxPhantomNum) == 0x00003C, "Member 'UPyAICondition_LokiPhantomNumCheck::MaxPhantomNum' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_LokiPhantomNumCheck, RequiredPhantomRange) == 0x000040, "Member 'UPyAICondition_LokiPhantomNumCheck::RequiredPhantomRange' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_LokiPhantomNumCheck, RequireIsVisible) == 0x000044, "Member 'UPyAICondition_LokiPhantomNumCheck::RequireIsVisible' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_HasDarkMana
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_HasDarkMana final : public UPyAIConditionBase
{
public:
	float                                         TargetDarkManaValue;                               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_HasDarkMana">();
	}
	static class UPyAICondition_HasDarkMana* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_HasDarkMana>();
	}
};
//static_assert(alignof(UPyAICondition_HasDarkMana) == 0x000008, "Wrong alignment on UPyAICondition_HasDarkMana");
//static_assert(sizeof(UPyAICondition_HasDarkMana) == 0x000040, "Wrong size on UPyAICondition_HasDarkMana");
//static_assert(offsetof(UPyAICondition_HasDarkMana, TargetDarkManaValue) == 0x000038, "Member 'UPyAICondition_HasDarkMana::TargetDarkManaValue' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_1018_ShieldCheck
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_1018_ShieldCheck final : public UPyAIConditionBase
{
public:
	float                                         HeroHealthPropThreshold;                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldHealthPropThreshold;                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_1018_ShieldCheck">();
	}
	static class UPyAICondition_1018_ShieldCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_1018_ShieldCheck>();
	}
};
//static_assert(alignof(UPyAICondition_1018_ShieldCheck) == 0x000008, "Wrong alignment on UPyAICondition_1018_ShieldCheck");
//static_assert(sizeof(UPyAICondition_1018_ShieldCheck) == 0x000040, "Wrong size on UPyAICondition_1018_ShieldCheck");
//static_assert(offsetof(UPyAICondition_1018_ShieldCheck, HeroHealthPropThreshold) == 0x000038, "Member 'UPyAICondition_1018_ShieldCheck::HeroHealthPropThreshold' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_1018_ShieldCheck, ShieldHealthPropThreshold) == 0x00003C, "Member 'UPyAICondition_1018_ShieldCheck::ShieldHealthPropThreshold' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_LunaSnowCheckIsUsingUltimateSkill
// 0x0000 (0x0038 - 0x0038)
class UPyAICondition_LunaSnowCheckIsUsingUltimateSkill final : public UPyAIConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_LunaSnowCheckIsUsingUltimateSkill">();
	}
	static class UPyAICondition_LunaSnowCheckIsUsingUltimateSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_LunaSnowCheckIsUsingUltimateSkill>();
	}
};
//static_assert(alignof(UPyAICondition_LunaSnowCheckIsUsingUltimateSkill) == 0x000008, "Wrong alignment on UPyAICondition_LunaSnowCheckIsUsingUltimateSkill");
//static_assert(sizeof(UPyAICondition_LunaSnowCheckIsUsingUltimateSkill) == 0x000038, "Wrong size on UPyAICondition_LunaSnowCheckIsUsingUltimateSkill");

// PythonClass ability_condition.PyAICondition_GrootSetWoodWall_Defend
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_GrootSetWoodWall_Defend final : public UPyAIConditionBase
{
public:
	float                                         LowHealthPercent;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeammateRange;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_GrootSetWoodWall_Defend">();
	}
	static class UPyAICondition_GrootSetWoodWall_Defend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_GrootSetWoodWall_Defend>();
	}
};
//static_assert(alignof(UPyAICondition_GrootSetWoodWall_Defend) == 0x000008, "Wrong alignment on UPyAICondition_GrootSetWoodWall_Defend");
//static_assert(sizeof(UPyAICondition_GrootSetWoodWall_Defend) == 0x000040, "Wrong size on UPyAICondition_GrootSetWoodWall_Defend");
//static_assert(offsetof(UPyAICondition_GrootSetWoodWall_Defend, LowHealthPercent) == 0x000038, "Member 'UPyAICondition_GrootSetWoodWall_Defend::LowHealthPercent' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_GrootSetWoodWall_Defend, TeammateRange) == 0x00003C, "Member 'UPyAICondition_GrootSetWoodWall_Defend::TeammateRange' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_GrootSetWoodWall_Distrub
// 0x0000 (0x0038 - 0x0038)
class UPyAICondition_GrootSetWoodWall_Distrub final : public UPyAIConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_GrootSetWoodWall_Distrub">();
	}
	static class UPyAICondition_GrootSetWoodWall_Distrub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_GrootSetWoodWall_Distrub>();
	}
};
//static_assert(alignof(UPyAICondition_GrootSetWoodWall_Distrub) == 0x000008, "Wrong alignment on UPyAICondition_GrootSetWoodWall_Distrub");
//static_assert(sizeof(UPyAICondition_GrootSetWoodWall_Distrub) == 0x000038, "Wrong size on UPyAICondition_GrootSetWoodWall_Distrub");

// PythonClass ability_condition.PyAICondition_IronManCheckHasEnemyUnder
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_IronManCheckHasEnemyUnder final : public UPyAIConditionBase
{
public:
	float                                         AccessAngle;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_IronManCheckHasEnemyUnder">();
	}
	static class UPyAICondition_IronManCheckHasEnemyUnder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_IronManCheckHasEnemyUnder>();
	}
};
//static_assert(alignof(UPyAICondition_IronManCheckHasEnemyUnder) == 0x000008, "Wrong alignment on UPyAICondition_IronManCheckHasEnemyUnder");
//static_assert(sizeof(UPyAICondition_IronManCheckHasEnemyUnder) == 0x000040, "Wrong size on UPyAICondition_IronManCheckHasEnemyUnder");
//static_assert(offsetof(UPyAICondition_IronManCheckHasEnemyUnder, AccessAngle) == 0x000038, "Member 'UPyAICondition_IronManCheckHasEnemyUnder::AccessAngle' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckAbilityCompHasTag
// 0x0068 (0x00A0 - 0x0038)
class UPyAICondition_CheckAbilityCompHasTag final : public UPyAIConditionBase
{
public:
	struct FGameplayTagContainer                  TagsToCheck;                                       // 0x0038(0x0068)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckAbilityCompHasTag">();
	}
	static class UPyAICondition_CheckAbilityCompHasTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckAbilityCompHasTag>();
	}
};
//static_assert(alignof(UPyAICondition_CheckAbilityCompHasTag) == 0x000008, "Wrong alignment on UPyAICondition_CheckAbilityCompHasTag");
//static_assert(sizeof(UPyAICondition_CheckAbilityCompHasTag) == 0x0000A0, "Wrong size on UPyAICondition_CheckAbilityCompHasTag");
//static_assert(offsetof(UPyAICondition_CheckAbilityCompHasTag, TagsToCheck) == 0x000038, "Member 'UPyAICondition_CheckAbilityCompHasTag::TagsToCheck' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckAIInfoHasTag
// 0x0068 (0x00A0 - 0x0038)
class UPyAICondition_CheckAIInfoHasTag final : public UPyAIConditionBase
{
public:
	struct FGameplayTagContainer                  TagsToCheck;                                       // 0x0038(0x0068)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckAIInfoHasTag">();
	}
	static class UPyAICondition_CheckAIInfoHasTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckAIInfoHasTag>();
	}
};
//static_assert(alignof(UPyAICondition_CheckAIInfoHasTag) == 0x000008, "Wrong alignment on UPyAICondition_CheckAIInfoHasTag");
//static_assert(sizeof(UPyAICondition_CheckAIInfoHasTag) == 0x0000A0, "Wrong size on UPyAICondition_CheckAIInfoHasTag");
//static_assert(offsetof(UPyAICondition_CheckAIInfoHasTag, TagsToCheck) == 0x000038, "Member 'UPyAICondition_CheckAIInfoHasTag::TagsToCheck' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckSkillTimeTrigger
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_CheckSkillTimeTrigger final : public UPyAIConditionBase
{
public:
	int32                                         SkillID;                                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckSkillTimeTrigger">();
	}
	static class UPyAICondition_CheckSkillTimeTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckSkillTimeTrigger>();
	}
};
//static_assert(alignof(UPyAICondition_CheckSkillTimeTrigger) == 0x000008, "Wrong alignment on UPyAICondition_CheckSkillTimeTrigger");
//static_assert(sizeof(UPyAICondition_CheckSkillTimeTrigger) == 0x000040, "Wrong size on UPyAICondition_CheckSkillTimeTrigger");
//static_assert(offsetof(UPyAICondition_CheckSkillTimeTrigger, SkillID) == 0x000038, "Member 'UPyAICondition_CheckSkillTimeTrigger::SkillID' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckObjectiveDistance
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_CheckObjectiveDistance final : public UPyAIConditionBase
{
public:
	float                                         Distance;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckObjectiveDistance">();
	}
	static class UPyAICondition_CheckObjectiveDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckObjectiveDistance>();
	}
};
//static_assert(alignof(UPyAICondition_CheckObjectiveDistance) == 0x000008, "Wrong alignment on UPyAICondition_CheckObjectiveDistance");
//static_assert(sizeof(UPyAICondition_CheckObjectiveDistance) == 0x000040, "Wrong size on UPyAICondition_CheckObjectiveDistance");
//static_assert(offsetof(UPyAICondition_CheckObjectiveDistance, Distance) == 0x000038, "Member 'UPyAICondition_CheckObjectiveDistance::Distance' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckTeamPower
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_CheckTeamPower final : public UPyAIConditionBase
{
public:
	int32                                         MinDiffPower;                                      // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDiffPower;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckTeamPower">();
	}
	static class UPyAICondition_CheckTeamPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckTeamPower>();
	}
};
//static_assert(alignof(UPyAICondition_CheckTeamPower) == 0x000008, "Wrong alignment on UPyAICondition_CheckTeamPower");
//static_assert(sizeof(UPyAICondition_CheckTeamPower) == 0x000040, "Wrong size on UPyAICondition_CheckTeamPower");
//static_assert(offsetof(UPyAICondition_CheckTeamPower, MinDiffPower) == 0x000038, "Member 'UPyAICondition_CheckTeamPower::MinDiffPower' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_CheckTeamPower, MaxDiffPower) == 0x00003C, "Member 'UPyAICondition_CheckTeamPower::MaxDiffPower' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckAbilityCD
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_CheckAbilityCD final : public UPyAIConditionBase
{
public:
	int32                                         AbilityID;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckAbilityCD">();
	}
	static class UPyAICondition_CheckAbilityCD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckAbilityCD>();
	}
};
//static_assert(alignof(UPyAICondition_CheckAbilityCD) == 0x000008, "Wrong alignment on UPyAICondition_CheckAbilityCD");
//static_assert(sizeof(UPyAICondition_CheckAbilityCD) == 0x000040, "Wrong size on UPyAICondition_CheckAbilityCD");
//static_assert(offsetof(UPyAICondition_CheckAbilityCD, AbilityID) == 0x000038, "Member 'UPyAICondition_CheckAbilityCD::AbilityID' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_TargetHasTag
// 0x0070 (0x00A8 - 0x0038)
class UPyAICondition_TargetHasTag final : public UPyAIConditionBase
{
public:
	bool                                          EnemyOrTeammate;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagsToCheck;                                       // 0x0040(0x0068)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_TargetHasTag">();
	}
	static class UPyAICondition_TargetHasTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_TargetHasTag>();
	}
};
//static_assert(alignof(UPyAICondition_TargetHasTag) == 0x000008, "Wrong alignment on UPyAICondition_TargetHasTag");
//static_assert(sizeof(UPyAICondition_TargetHasTag) == 0x0000A8, "Wrong size on UPyAICondition_TargetHasTag");
//static_assert(offsetof(UPyAICondition_TargetHasTag, EnemyOrTeammate) == 0x000038, "Member 'UPyAICondition_TargetHasTag::EnemyOrTeammate' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_TargetHasTag, TagsToCheck) == 0x000040, "Member 'UPyAICondition_TargetHasTag::TagsToCheck' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_ForbidUsageByType
// 0x0000 (0x0038 - 0x0038)
class UPyAICondition_ForbidUsageByType final : public UPyAIConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_ForbidUsageByType">();
	}
	static class UPyAICondition_ForbidUsageByType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_ForbidUsageByType>();
	}
};
//static_assert(alignof(UPyAICondition_ForbidUsageByType) == 0x000008, "Wrong alignment on UPyAICondition_ForbidUsageByType");
//static_assert(sizeof(UPyAICondition_ForbidUsageByType) == 0x000038, "Wrong size on UPyAICondition_ForbidUsageByType");

// PythonClass ability_condition.PyAICondition_TeammateTakingDamage
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_TeammateTakingDamage final : public UPyAIConditionBase
{
public:
	float                                         Radius;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeSelf;                                       // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_TeammateTakingDamage">();
	}
	static class UPyAICondition_TeammateTakingDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_TeammateTakingDamage>();
	}
};
//static_assert(alignof(UPyAICondition_TeammateTakingDamage) == 0x000008, "Wrong alignment on UPyAICondition_TeammateTakingDamage");
//static_assert(sizeof(UPyAICondition_TeammateTakingDamage) == 0x000040, "Wrong size on UPyAICondition_TeammateTakingDamage");
//static_assert(offsetof(UPyAICondition_TeammateTakingDamage, Radius) == 0x000038, "Member 'UPyAICondition_TeammateTakingDamage::Radius' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_TeammateTakingDamage, IncludeSelf) == 0x00003C, "Member 'UPyAICondition_TeammateTakingDamage::IncludeSelf' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_InTeamFormation
// 0x0000 (0x0038 - 0x0038)
class UPyAICondition_InTeamFormation final : public UPyAIConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_InTeamFormation">();
	}
	static class UPyAICondition_InTeamFormation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_InTeamFormation>();
	}
};
//static_assert(alignof(UPyAICondition_InTeamFormation) == 0x000008, "Wrong alignment on UPyAICondition_InTeamFormation");
//static_assert(sizeof(UPyAICondition_InTeamFormation) == 0x000038, "Wrong size on UPyAICondition_InTeamFormation");

// PythonClass ability_condition.PyAICondition_CheckFloatAbilityAttribute
// 0x0048 (0x0080 - 0x0038)
class UPyAICondition_CheckFloatAbilityAttribute final : public UPyAIConditionBase
{
public:
	struct FGameplayAttribute                     ToCheckAttribute;                                  // 0x0038(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompareValue;                                      // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       OperationType;                                     // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckFloatAbilityAttribute">();
	}
	static class UPyAICondition_CheckFloatAbilityAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckFloatAbilityAttribute>();
	}
};
//static_assert(alignof(UPyAICondition_CheckFloatAbilityAttribute) == 0x000008, "Wrong alignment on UPyAICondition_CheckFloatAbilityAttribute");
//static_assert(sizeof(UPyAICondition_CheckFloatAbilityAttribute) == 0x000080, "Wrong size on UPyAICondition_CheckFloatAbilityAttribute");
//static_assert(offsetof(UPyAICondition_CheckFloatAbilityAttribute, ToCheckAttribute) == 0x000038, "Member 'UPyAICondition_CheckFloatAbilityAttribute::ToCheckAttribute' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_CheckFloatAbilityAttribute, CompareValue) == 0x000078, "Member 'UPyAICondition_CheckFloatAbilityAttribute::CompareValue' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_CheckFloatAbilityAttribute, OperationType) == 0x00007C, "Member 'UPyAICondition_CheckFloatAbilityAttribute::OperationType' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_IsHoldingPhysicalWeapon
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_IsHoldingPhysicalWeapon final : public UPyAIConditionBase
{
public:
	bool                                          ShouldHoldingWeapon;                               // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_IsHoldingPhysicalWeapon">();
	}
	static class UPyAICondition_IsHoldingPhysicalWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_IsHoldingPhysicalWeapon>();
	}
};
//static_assert(alignof(UPyAICondition_IsHoldingPhysicalWeapon) == 0x000008, "Wrong alignment on UPyAICondition_IsHoldingPhysicalWeapon");
//static_assert(sizeof(UPyAICondition_IsHoldingPhysicalWeapon) == 0x000040, "Wrong size on UPyAICondition_IsHoldingPhysicalWeapon");
//static_assert(offsetof(UPyAICondition_IsHoldingPhysicalWeapon, ShouldHoldingWeapon) == 0x000038, "Member 'UPyAICondition_IsHoldingPhysicalWeapon::ShouldHoldingWeapon' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_HasNearbyPhysicalInteractions
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_HasNearbyPhysicalInteractions final : public UPyAIConditionBase
{
public:
	int32                                         RequiredInteractionsNum;                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldSetInteractionAsTarget;                      // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_HasNearbyPhysicalInteractions">();
	}
	static class UPyAICondition_HasNearbyPhysicalInteractions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_HasNearbyPhysicalInteractions>();
	}
};
//static_assert(alignof(UPyAICondition_HasNearbyPhysicalInteractions) == 0x000008, "Wrong alignment on UPyAICondition_HasNearbyPhysicalInteractions");
//static_assert(sizeof(UPyAICondition_HasNearbyPhysicalInteractions) == 0x000040, "Wrong size on UPyAICondition_HasNearbyPhysicalInteractions");
//static_assert(offsetof(UPyAICondition_HasNearbyPhysicalInteractions, RequiredInteractionsNum) == 0x000038, "Member 'UPyAICondition_HasNearbyPhysicalInteractions::RequiredInteractionsNum' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_HasNearbyPhysicalInteractions, ShouldSetInteractionAsTarget) == 0x00003C, "Member 'UPyAICondition_HasNearbyPhysicalInteractions::ShouldSetInteractionAsTarget' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckTeammateHealth
// 0x0010 (0x0048 - 0x0038)
class UPyAICondition_CheckTeammateHealth final : public UPyAIConditionBase
{
public:
	float                                         CheckRange;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMarvelArithmeticOperation                    CheckType;                                         // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowHealthThreshold;                                // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckAll;                                          // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckTeammateHealth">();
	}
	static class UPyAICondition_CheckTeammateHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckTeammateHealth>();
	}
};
//static_assert(alignof(UPyAICondition_CheckTeammateHealth) == 0x000008, "Wrong alignment on UPyAICondition_CheckTeammateHealth");
//static_assert(sizeof(UPyAICondition_CheckTeammateHealth) == 0x000048, "Wrong size on UPyAICondition_CheckTeammateHealth");
//static_assert(offsetof(UPyAICondition_CheckTeammateHealth, CheckRange) == 0x000038, "Member 'UPyAICondition_CheckTeammateHealth::CheckRange' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_CheckTeammateHealth, CheckType) == 0x00003C, "Member 'UPyAICondition_CheckTeammateHealth::CheckType' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_CheckTeammateHealth, LowHealthThreshold) == 0x000040, "Member 'UPyAICondition_CheckTeammateHealth::LowHealthThreshold' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_CheckTeammateHealth, CheckAll) == 0x000044, "Member 'UPyAICondition_CheckTeammateHealth::CheckAll' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckEscapeDistance
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_CheckEscapeDistance final : public UPyAIConditionBase
{
public:
	float                                         AllowDistance;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckEscapeDistance">();
	}
	static class UPyAICondition_CheckEscapeDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckEscapeDistance>();
	}
};
//static_assert(alignof(UPyAICondition_CheckEscapeDistance) == 0x000008, "Wrong alignment on UPyAICondition_CheckEscapeDistance");
//static_assert(sizeof(UPyAICondition_CheckEscapeDistance) == 0x000040, "Wrong size on UPyAICondition_CheckEscapeDistance");
//static_assert(offsetof(UPyAICondition_CheckEscapeDistance, AllowDistance) == 0x000038, "Member 'UPyAICondition_CheckEscapeDistance::AllowDistance' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckSkillEnergyRemain
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_CheckSkillEnergyRemain final : public UPyAIConditionBase
{
public:
	float                                         EnergyCost;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyKeep;                                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckSkillEnergyRemain">();
	}
	static class UPyAICondition_CheckSkillEnergyRemain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckSkillEnergyRemain>();
	}
};
//static_assert(alignof(UPyAICondition_CheckSkillEnergyRemain) == 0x000008, "Wrong alignment on UPyAICondition_CheckSkillEnergyRemain");
//static_assert(sizeof(UPyAICondition_CheckSkillEnergyRemain) == 0x000040, "Wrong size on UPyAICondition_CheckSkillEnergyRemain");
//static_assert(offsetof(UPyAICondition_CheckSkillEnergyRemain, EnergyCost) == 0x000038, "Member 'UPyAICondition_CheckSkillEnergyRemain::EnergyCost' has a wrong offset!");
//static_assert(offsetof(UPyAICondition_CheckSkillEnergyRemain, EnergyKeep) == 0x00003C, "Member 'UPyAICondition_CheckSkillEnergyRemain::EnergyKeep' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckHasBuff
// 0x0010 (0x0048 - 0x0038)
class UPyAICondition_CheckHasBuff final : public UPyAIConditionBase
{
public:
	TArray<int32>                                 BuffIDList;                                        // 0x0038(0x0010)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckHasBuff">();
	}
	static class UPyAICondition_CheckHasBuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckHasBuff>();
	}
};
//static_assert(alignof(UPyAICondition_CheckHasBuff) == 0x000008, "Wrong alignment on UPyAICondition_CheckHasBuff");
//static_assert(sizeof(UPyAICondition_CheckHasBuff) == 0x000048, "Wrong size on UPyAICondition_CheckHasBuff");
//static_assert(offsetof(UPyAICondition_CheckHasBuff, BuffIDList) == 0x000038, "Member 'UPyAICondition_CheckHasBuff::BuffIDList' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_HasVerifySummonedTarget
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_HasVerifySummonedTarget : public UPyAIConditionBase
{
public:
	int32                                         SummonedID;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_HasVerifySummonedTarget">();
	}
	static class UPyAICondition_HasVerifySummonedTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_HasVerifySummonedTarget>();
	}
};
//static_assert(alignof(UPyAICondition_HasVerifySummonedTarget) == 0x000008, "Wrong alignment on UPyAICondition_HasVerifySummonedTarget");
//static_assert(sizeof(UPyAICondition_HasVerifySummonedTarget) == 0x000040, "Wrong size on UPyAICondition_HasVerifySummonedTarget");
//static_assert(offsetof(UPyAICondition_HasVerifySummonedTarget, SummonedID) == 0x000038, "Member 'UPyAICondition_HasVerifySummonedTarget::SummonedID' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckDistanceToNextPathPoint
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_CheckDistanceToNextPathPoint : public UPyAIConditionBase
{
public:
	float                                         PassRange;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckDistanceToNextPathPoint">();
	}
	static class UPyAICondition_CheckDistanceToNextPathPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckDistanceToNextPathPoint>();
	}
};
//static_assert(alignof(UPyAICondition_CheckDistanceToNextPathPoint) == 0x000008, "Wrong alignment on UPyAICondition_CheckDistanceToNextPathPoint");
//static_assert(sizeof(UPyAICondition_CheckDistanceToNextPathPoint) == 0x000040, "Wrong size on UPyAICondition_CheckDistanceToNextPathPoint");
//static_assert(offsetof(UPyAICondition_CheckDistanceToNextPathPoint, PassRange) == 0x000038, "Member 'UPyAICondition_CheckDistanceToNextPathPoint::PassRange' has a wrong offset!");

// PythonClass ability_condition.PyAICondition_CheckDistanceToPathEndPoint
// 0x0008 (0x0040 - 0x0038)
class UPyAICondition_CheckDistanceToPathEndPoint : public UPyAIConditionBase
{
public:
	float                                         PassRange;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAICondition_CheckDistanceToPathEndPoint">();
	}
	static class UPyAICondition_CheckDistanceToPathEndPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAICondition_CheckDistanceToPathEndPoint>();
	}
};
//static_assert(alignof(UPyAICondition_CheckDistanceToPathEndPoint) == 0x000008, "Wrong alignment on UPyAICondition_CheckDistanceToPathEndPoint");
//static_assert(sizeof(UPyAICondition_CheckDistanceToPathEndPoint) == 0x000040, "Wrong size on UPyAICondition_CheckDistanceToPathEndPoint");
//static_assert(offsetof(UPyAICondition_CheckDistanceToPathEndPoint, PassRange) == 0x000038, "Member 'UPyAICondition_CheckDistanceToPathEndPoint::PassRange' has a wrong offset!");

}

