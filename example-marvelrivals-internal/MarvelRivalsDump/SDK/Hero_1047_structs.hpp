#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1047

#include "Basic.hpp"

#include "Marvel_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum Hero_1047.EJeffGrootAbilityState
// NumValues: 0x0006
enum class EJeffGrootAbilityState : uint8
{
	FlyingToGroot                            = 0,
	FlyingToGrootFailed                      = 1,
	AttachToGroot                            = 2,
	DetachFromGroot                          = 3,
	NoCoop                                   = 4,
	EJeffGrootAbilityState_MAX               = 5,
};

// Enum Hero_1047.EJeffState
// NumValues: 0x0004
enum class EJeffState : uint8
{
	Normal                                   = 0,
	Diving                                   = 1,
	Quiting                                  = 2,
	EJeffState_MAX                           = 3,
};

// Enum Hero_1047.EAbilityState_104771
// NumValues: 0x000E
enum class EAbilityState_104771 : uint8
{
	Default                                  = 0,
	MovingSelectionRegion                    = 1,
	Warning                                  = 2,
	Falling                                  = 3,
	Entering                                 = 4,
	Devour_Begin                             = 5,
	Devour_Character                         = 6,
	Devour_Check                             = 7,
	Diving                                   = 8,
	SpittingOut                              = 9,
	DivingEnd                                = 10,
	HapplyEnd                                = 11,
	SadEnd                                   = 12,
	EAbilityState_MAX                        = 13,
};

// Enum Hero_1047.EAbilityCameraState_104771
// NumValues: 0x0006
enum class EAbilityCameraState_104771 : uint8
{
	Normal                                   = 0,
	SelectRegion                             = 1,
	SelectRegion_Press                       = 2,
	SelectRegion_Release                     = 3,
	Warning                                  = 4,
	EAbilityCameraState_MAX                  = 5,
};

// Enum Hero_1047.EJeffOnGrootMovingState
// NumValues: 0x0004
enum class EJeffOnGrootMovingState : uint8
{
	TurningRight                             = 0,
	TurningLeft                              = 1,
	Idle                                     = 2,
	EJeffOnGrootMovingState_MAX              = 3,
};

// Enum Hero_1047.EJeffEightDirection
// NumValues: 0x0009
enum class EJeffEightDirection : uint8
{
	ED_Backward                              = 0,
	ED_BackwardLeft                          = 1,
	ED_Left                                  = 2,
	ED_ForwardLeft                           = 3,
	ED_Forward                               = 4,
	ED_ForwardRight                          = 5,
	ED_Right                                 = 6,
	ED_BackwardRight                         = 7,
	ED_MAX                                   = 8,
};

// ScriptStruct Hero_1047.DebugHapplyDebugSplinePoint
// 0x00A0 (0x00A0 - 0x0000)
struct FDebugHapplyDebugSplinePoint final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArriveTangent;                                     // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeaveTangent;                                      // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStart;                                            // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0xF];                                       // 0x0091(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugHapplyDebugSplinePoint) == 0x000010, "Wrong alignment on FDebugHapplyDebugSplinePoint");
static_assert(sizeof(FDebugHapplyDebugSplinePoint) == 0x0000A0, "Wrong size on FDebugHapplyDebugSplinePoint");
static_assert(offsetof(FDebugHapplyDebugSplinePoint, Transform) == 0x000000, "Member 'FDebugHapplyDebugSplinePoint::Transform' has a wrong offset!");
static_assert(offsetof(FDebugHapplyDebugSplinePoint, ArriveTangent) == 0x000060, "Member 'FDebugHapplyDebugSplinePoint::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FDebugHapplyDebugSplinePoint, LeaveTangent) == 0x000078, "Member 'FDebugHapplyDebugSplinePoint::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FDebugHapplyDebugSplinePoint, bStart) == 0x000090, "Member 'FDebugHapplyDebugSplinePoint::bStart' has a wrong offset!");

// ScriptStruct Hero_1047.DebugHapplyDebugSplinePoints
// 0x0010 (0x0010 - 0x0000)
struct FDebugHapplyDebugSplinePoints final
{
public:
	TArray<struct FDebugHapplyDebugSplinePoint>   Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugHapplyDebugSplinePoints) == 0x000008, "Wrong alignment on FDebugHapplyDebugSplinePoints");
static_assert(sizeof(FDebugHapplyDebugSplinePoints) == 0x000010, "Wrong size on FDebugHapplyDebugSplinePoints");
static_assert(offsetof(FDebugHapplyDebugSplinePoints, Points) == 0x000000, "Member 'FDebugHapplyDebugSplinePoints::Points' has a wrong offset!");

// ScriptStruct Hero_1047.DebugHapplyDebugSpline
// 0x0018 (0x0018 - 0x0000)
struct FDebugHapplyDebugSpline final
{
public:
	TArray<struct FDebugHapplyDebugSplinePoints>  DebugSpline;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         Frame;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugHapplyDebugSpline) == 0x000008, "Wrong alignment on FDebugHapplyDebugSpline");
static_assert(sizeof(FDebugHapplyDebugSpline) == 0x000018, "Wrong size on FDebugHapplyDebugSpline");
static_assert(offsetof(FDebugHapplyDebugSpline, DebugSpline) == 0x000000, "Member 'FDebugHapplyDebugSpline::DebugSpline' has a wrong offset!");
static_assert(offsetof(FDebugHapplyDebugSpline, Frame) == 0x000010, "Member 'FDebugHapplyDebugSpline::Frame' has a wrong offset!");

// ScriptStruct Hero_1047.WarningNotify
// 0x0002 (0x0002 - 0x0000)
struct FWarningNotify final
{
public:
	uint8                                         bActiveByTimerOrMT : 1;                            // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         NotifyCounter;                                     // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWarningNotify) == 0x000001, "Wrong alignment on FWarningNotify");
static_assert(sizeof(FWarningNotify) == 0x000002, "Wrong size on FWarningNotify");
static_assert(offsetof(FWarningNotify, NotifyCounter) == 0x000001, "Member 'FWarningNotify::NotifyCounter' has a wrong offset!");

// ScriptStruct Hero_1047.SegmentsSpline
// 0x0030 (0x0030 - 0x0000)
struct FSegmentsSpline final
{
public:
	int32                                         SeqPointNum;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeqTime;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeqParameter_1;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeqParameter_2;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeqType;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TangleScale;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BuffApply;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuffApplyDistance;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuffIDExtraTime;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TailBaseWidth;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TailBaseWidthLerpSpeed;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSegmentsSpline) == 0x000004, "Wrong alignment on FSegmentsSpline");
static_assert(sizeof(FSegmentsSpline) == 0x000030, "Wrong size on FSegmentsSpline");
static_assert(offsetof(FSegmentsSpline, SeqPointNum) == 0x000000, "Member 'FSegmentsSpline::SeqPointNum' has a wrong offset!");
static_assert(offsetof(FSegmentsSpline, SeqTime) == 0x000004, "Member 'FSegmentsSpline::SeqTime' has a wrong offset!");
static_assert(offsetof(FSegmentsSpline, SeqParameter_1) == 0x000008, "Member 'FSegmentsSpline::SeqParameter_1' has a wrong offset!");
static_assert(offsetof(FSegmentsSpline, SeqParameter_2) == 0x00000C, "Member 'FSegmentsSpline::SeqParameter_2' has a wrong offset!");
static_assert(offsetof(FSegmentsSpline, SeqType) == 0x000010, "Member 'FSegmentsSpline::SeqType' has a wrong offset!");
static_assert(offsetof(FSegmentsSpline, TangleScale) == 0x000014, "Member 'FSegmentsSpline::TangleScale' has a wrong offset!");
static_assert(offsetof(FSegmentsSpline, BuffApply) == 0x000018, "Member 'FSegmentsSpline::BuffApply' has a wrong offset!");
static_assert(offsetof(FSegmentsSpline, BuffApplyDistance) == 0x00001C, "Member 'FSegmentsSpline::BuffApplyDistance' has a wrong offset!");
static_assert(offsetof(FSegmentsSpline, BuffID) == 0x000020, "Member 'FSegmentsSpline::BuffID' has a wrong offset!");
static_assert(offsetof(FSegmentsSpline, BuffIDExtraTime) == 0x000024, "Member 'FSegmentsSpline::BuffIDExtraTime' has a wrong offset!");
static_assert(offsetof(FSegmentsSpline, TailBaseWidth) == 0x000028, "Member 'FSegmentsSpline::TailBaseWidth' has a wrong offset!");
static_assert(offsetof(FSegmentsSpline, TailBaseWidthLerpSpeed) == 0x00002C, "Member 'FSegmentsSpline::TailBaseWidthLerpSpeed' has a wrong offset!");

// ScriptStruct Hero_1047.DevouredCharactersData
// 0x0058 (0x0058 - 0x0000)
struct FDevouredCharactersData final
{
public:
	TArray<TWeakObjectPtr<class AActor>>          DevourCharacters;                                  // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         PredictionSerial;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DeathCounter;                                      // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NotifyCounter;                                     // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x42];                                      // 0x0016(0x0042)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDevouredCharactersData) == 0x000008, "Wrong alignment on FDevouredCharactersData");
static_assert(sizeof(FDevouredCharactersData) == 0x000058, "Wrong size on FDevouredCharactersData");
static_assert(offsetof(FDevouredCharactersData, DevourCharacters) == 0x000000, "Member 'FDevouredCharactersData::DevourCharacters' has a wrong offset!");
static_assert(offsetof(FDevouredCharactersData, PredictionSerial) == 0x000010, "Member 'FDevouredCharactersData::PredictionSerial' has a wrong offset!");
static_assert(offsetof(FDevouredCharactersData, DeathCounter) == 0x000014, "Member 'FDevouredCharactersData::DeathCounter' has a wrong offset!");
static_assert(offsetof(FDevouredCharactersData, NotifyCounter) == 0x000015, "Member 'FDevouredCharactersData::NotifyCounter' has a wrong offset!");

// ScriptStruct Hero_1047.SelectRegionConfig
// 0x001C (0x001C - 0x0000)
struct FSelectRegionConfig final
{
public:
	float                                         MaxWalkSpeed;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccelerationWalking;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationWalking;                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFlySpeed;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccelerationFlying;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationFlying;                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationFalling;                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectRegionConfig) == 0x000004, "Wrong alignment on FSelectRegionConfig");
static_assert(sizeof(FSelectRegionConfig) == 0x00001C, "Wrong size on FSelectRegionConfig");
static_assert(offsetof(FSelectRegionConfig, MaxWalkSpeed) == 0x000000, "Member 'FSelectRegionConfig::MaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(FSelectRegionConfig, MaxAccelerationWalking) == 0x000004, "Member 'FSelectRegionConfig::MaxAccelerationWalking' has a wrong offset!");
static_assert(offsetof(FSelectRegionConfig, BrakingDecelerationWalking) == 0x000008, "Member 'FSelectRegionConfig::BrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(FSelectRegionConfig, MaxFlySpeed) == 0x00000C, "Member 'FSelectRegionConfig::MaxFlySpeed' has a wrong offset!");
static_assert(offsetof(FSelectRegionConfig, MaxAccelerationFlying) == 0x000010, "Member 'FSelectRegionConfig::MaxAccelerationFlying' has a wrong offset!");
static_assert(offsetof(FSelectRegionConfig, BrakingDecelerationFlying) == 0x000014, "Member 'FSelectRegionConfig::BrakingDecelerationFlying' has a wrong offset!");
static_assert(offsetof(FSelectRegionConfig, BrakingDecelerationFalling) == 0x000018, "Member 'FSelectRegionConfig::BrakingDecelerationFalling' has a wrong offset!");

// ScriptStruct Hero_1047.FlowManagerTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FFlowManagerTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFlowManagerTickFunction) == 0x000008, "Wrong alignment on FFlowManagerTickFunction");
static_assert(sizeof(FFlowManagerTickFunction) == 0x000038, "Wrong size on FFlowManagerTickFunction");

// ScriptStruct Hero_1047.JeffPaintParams
// 0x0038 (0x0038 - 0x0000)
struct FJeffPaintParams final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaintRadius;                                       // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Jeff;                                              // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PaintRadiusSize;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJeffPaintParams) == 0x000008, "Wrong alignment on FJeffPaintParams");
static_assert(sizeof(FJeffPaintParams) == 0x000038, "Wrong size on FJeffPaintParams");
static_assert(offsetof(FJeffPaintParams, Location) == 0x000000, "Member 'FJeffPaintParams::Location' has a wrong offset!");
static_assert(offsetof(FJeffPaintParams, PaintRadius) == 0x000018, "Member 'FJeffPaintParams::PaintRadius' has a wrong offset!");
static_assert(offsetof(FJeffPaintParams, Jeff) == 0x000020, "Member 'FJeffPaintParams::Jeff' has a wrong offset!");
static_assert(offsetof(FJeffPaintParams, PaintRadiusSize) == 0x000028, "Member 'FJeffPaintParams::PaintRadiusSize' has a wrong offset!");

// ScriptStruct Hero_1047.SpitOutArgs
// 0x0010 (0x0010 - 0x0000)
struct FSpitOutArgs final
{
public:
	class UMarvelBaseGameplayAbility*             Ability;                                           // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpitOutAll;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpitOutEnemy;                                     // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKnockUp;                                          // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpitOutArgs) == 0x000008, "Wrong alignment on FSpitOutArgs");
static_assert(sizeof(FSpitOutArgs) == 0x000010, "Wrong size on FSpitOutArgs");
static_assert(offsetof(FSpitOutArgs, Ability) == 0x000000, "Member 'FSpitOutArgs::Ability' has a wrong offset!");
static_assert(offsetof(FSpitOutArgs, bSpitOutAll) == 0x000008, "Member 'FSpitOutArgs::bSpitOutAll' has a wrong offset!");
static_assert(offsetof(FSpitOutArgs, bSpitOutEnemy) == 0x000009, "Member 'FSpitOutArgs::bSpitOutEnemy' has a wrong offset!");
static_assert(offsetof(FSpitOutArgs, bKnockUp) == 0x00000A, "Member 'FSpitOutArgs::bKnockUp' has a wrong offset!");

// ScriptStruct Hero_1047.JeffGroundMotionTransitionFlags
// 0x001C (0x001C - 0x0000)
struct FJeffGroundMotionTransitionFlags final
{
public:
	float                                         StateTimeLB;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateTimeRB;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateTimeLF;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateTimeRF;                                       // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LocomotionCycles_bCanEnterBToF;                    // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LocomotionCycles_LB_TO_LF;                         // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LocomotionCycles_RB_TO_RF;                         // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LocomotionCycles_Any_To_LB;                        // 0x0013(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LocomotionCycles_Any_To_RB;                        // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JumpStart_BToF_To_Fwd;                             // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JumpStart_FtoB_To_Bwd;                             // 0x0016(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JumpLoop_BToF_To_Fwd;                              // 0x0017(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JumpLoop_FToB_To_Bwd;                              // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JumpLoop_BToF_To_Idle;                             // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JumpLand_BToF_To_Fwd;                              // 0x001A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JumpLand_FToB_To_Bwd;                              // 0x001B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJeffGroundMotionTransitionFlags) == 0x000004, "Wrong alignment on FJeffGroundMotionTransitionFlags");
static_assert(sizeof(FJeffGroundMotionTransitionFlags) == 0x00001C, "Wrong size on FJeffGroundMotionTransitionFlags");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, StateTimeLB) == 0x000000, "Member 'FJeffGroundMotionTransitionFlags::StateTimeLB' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, StateTimeRB) == 0x000004, "Member 'FJeffGroundMotionTransitionFlags::StateTimeRB' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, StateTimeLF) == 0x000008, "Member 'FJeffGroundMotionTransitionFlags::StateTimeLF' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, StateTimeRF) == 0x00000C, "Member 'FJeffGroundMotionTransitionFlags::StateTimeRF' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, LocomotionCycles_bCanEnterBToF) == 0x000010, "Member 'FJeffGroundMotionTransitionFlags::LocomotionCycles_bCanEnterBToF' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, LocomotionCycles_LB_TO_LF) == 0x000011, "Member 'FJeffGroundMotionTransitionFlags::LocomotionCycles_LB_TO_LF' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, LocomotionCycles_RB_TO_RF) == 0x000012, "Member 'FJeffGroundMotionTransitionFlags::LocomotionCycles_RB_TO_RF' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, LocomotionCycles_Any_To_LB) == 0x000013, "Member 'FJeffGroundMotionTransitionFlags::LocomotionCycles_Any_To_LB' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, LocomotionCycles_Any_To_RB) == 0x000014, "Member 'FJeffGroundMotionTransitionFlags::LocomotionCycles_Any_To_RB' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, JumpStart_BToF_To_Fwd) == 0x000015, "Member 'FJeffGroundMotionTransitionFlags::JumpStart_BToF_To_Fwd' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, JumpStart_FtoB_To_Bwd) == 0x000016, "Member 'FJeffGroundMotionTransitionFlags::JumpStart_FtoB_To_Bwd' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, JumpLoop_BToF_To_Fwd) == 0x000017, "Member 'FJeffGroundMotionTransitionFlags::JumpLoop_BToF_To_Fwd' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, JumpLoop_FToB_To_Bwd) == 0x000018, "Member 'FJeffGroundMotionTransitionFlags::JumpLoop_FToB_To_Bwd' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, JumpLoop_BToF_To_Idle) == 0x000019, "Member 'FJeffGroundMotionTransitionFlags::JumpLoop_BToF_To_Idle' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, JumpLand_BToF_To_Fwd) == 0x00001A, "Member 'FJeffGroundMotionTransitionFlags::JumpLand_BToF_To_Fwd' has a wrong offset!");
static_assert(offsetof(FJeffGroundMotionTransitionFlags, JumpLand_FToB_To_Bwd) == 0x00001B, "Member 'FJeffGroundMotionTransitionFlags::JumpLand_FToB_To_Bwd' has a wrong offset!");

// ScriptStruct Hero_1047.JeffGroundMotionSubAnimInstanceProxy
// 0x0030 (0x0800 - 0x07D0)
struct FJeffGroundMotionSubAnimInstanceProxy final : public FGroundMotionSubAnimInstanceProxyBase
{
public:
	uint8                                         Pad_7D0[0x30];                                     // 0x07D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJeffGroundMotionSubAnimInstanceProxy) == 0x000010, "Wrong alignment on FJeffGroundMotionSubAnimInstanceProxy");
static_assert(sizeof(FJeffGroundMotionSubAnimInstanceProxy) == 0x000800, "Wrong size on FJeffGroundMotionSubAnimInstanceProxy");

// ScriptStruct Hero_1047.JeffMoveForwardCheckResult
// 0x0070 (0x0070 - 0x0000)
struct FJeffMoveForwardCheckResult final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Position;                                          // 0x0010(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJeffMoveForwardCheckResult) == 0x000010, "Wrong alignment on FJeffMoveForwardCheckResult");
static_assert(sizeof(FJeffMoveForwardCheckResult) == 0x000070, "Wrong size on FJeffMoveForwardCheckResult");
static_assert(offsetof(FJeffMoveForwardCheckResult, bSuccess) == 0x000000, "Member 'FJeffMoveForwardCheckResult::bSuccess' has a wrong offset!");
static_assert(offsetof(FJeffMoveForwardCheckResult, Position) == 0x000010, "Member 'FJeffMoveForwardCheckResult::Position' has a wrong offset!");

}

