#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1027

#include "Basic.hpp"

#include "DeclarativeUnreal_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Hero_1027_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"


namespace SDK
{

// Class Hero_1027.Projectile_10271101
// 0x0010 (0x3060 - 0x3050)
class AProjectile_10271101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	float                                         CancelIfOffCenterYawGreaterThan;                   // 0x3050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CancelIfOffCenterPitchGreaterThan;                 // 0x3054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ComboStateIndex;                                   // 0x3058(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3059[0x7];                                     // 0x3059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetProjectileRadius() const;
	bool IsProjectileInterrupted() const;
	bool IsProjectileOffCenter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10271101">();
	}
	static class AProjectile_10271101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10271101>();
	}
};
static_assert(alignof(AProjectile_10271101) == 0x000010, "Wrong alignment on AProjectile_10271101");
static_assert(sizeof(AProjectile_10271101) == 0x003060, "Wrong size on AProjectile_10271101");
static_assert(offsetof(AProjectile_10271101, CancelIfOffCenterYawGreaterThan) == 0x003050, "Member 'AProjectile_10271101::CancelIfOffCenterYawGreaterThan' has a wrong offset!");
static_assert(offsetof(AProjectile_10271101, CancelIfOffCenterPitchGreaterThan) == 0x003054, "Member 'AProjectile_10271101::CancelIfOffCenterPitchGreaterThan' has a wrong offset!");
static_assert(offsetof(AProjectile_10271101, ComboStateIndex) == 0x003058, "Member 'AProjectile_10271101::ComboStateIndex' has a wrong offset!");

// Class Hero_1027.Ability_102711
// 0x0010 (0x2598 - 0x2588)
class UAbility_102711 : public UAbility_108
{
public:
	class AActor*                                 LeftProjectile;                                    // 0x2588(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 RightProjectile;                                   // 0x2590(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102711">();
	}
	static class UAbility_102711* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102711>();
	}
};
static_assert(alignof(UAbility_102711) == 0x000008, "Wrong alignment on UAbility_102711");
static_assert(sizeof(UAbility_102711) == 0x002598, "Wrong size on UAbility_102711");
static_assert(offsetof(UAbility_102711, LeftProjectile) == 0x002588, "Member 'UAbility_102711::LeftProjectile' has a wrong offset!");
static_assert(offsetof(UAbility_102711, RightProjectile) == 0x002590, "Member 'UAbility_102711::RightProjectile' has a wrong offset!");

// Class Hero_1027.Cue_Projectile_Loop_10271101
// 0x0150 (0x0F00 - 0x0DB0)
class ACue_Projectile_Loop_10271101 final : public AMarvelCueNotify_Projectile
{
public:
	class UNiagaraComponent*                      LoopNX_PrickleVine;                                // 0x0DB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   PhantomPrickleVineMeshComp;                        // 0x0DB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           PhantomPrickleVineMeshComps;                       // 0x0DC0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         PrickleVineGrowTime;                               // 0x0DD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrickleVineDissolveTime;                           // 0x0DD4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrickleVineMeshLength;                             // 0x0DD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DDC[0x4];                                      // 0x0DDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               PrickleVineMeshRotation;                           // 0x0DE0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         PrickleVineDissolveFX;                             // 0x0DF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         PrickleVineCurveWhenGrowing;                       // 0x0E00(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         PrickleVineCurveWhenDissolving;                    // 0x0E50(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           PrickleVineAttachSockets;                          // 0x0EA0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     PrickleVineAttachTransforms;                       // 0x0EB0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       PhantomPrickleVineMeshMIDs;                        // 0x0EC0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         PrickleVineComboIndex;                             // 0x0ED0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrickleVineRandRoll;                               // 0x0ED4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrickleVineGrowRange;                              // 0x0ED8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrickleVineGrowDelta;                              // 0x0EDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrickleVineGrowLastDelta;                          // 0x0EE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE4[0x4];                                      // 0x0EE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CachedSourceLocation;                              // 0x0EE8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GetPrickleVineTrans(class AMarvelBaseCharacter* InCharacter, class AProjectile_10271101* InProjectile, struct FVector* SourceLocation, struct FTransform* TargetTransform);
	bool ShouldSetParameterWhenDissolving(class FName ParameterName);
	bool ShouldSetParameterWhenGrowing(class FName ParameterName);
	void UpdatePrickleVineFX(class AMarvelBaseCharacter* InCharacter, class AProjectile_10271101* InProjectile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10271101">();
	}
	static class ACue_Projectile_Loop_10271101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10271101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10271101) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10271101");
static_assert(sizeof(ACue_Projectile_Loop_10271101) == 0x000F00, "Wrong size on ACue_Projectile_Loop_10271101");
static_assert(offsetof(ACue_Projectile_Loop_10271101, LoopNX_PrickleVine) == 0x000DB0, "Member 'ACue_Projectile_Loop_10271101::LoopNX_PrickleVine' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PhantomPrickleVineMeshComp) == 0x000DB8, "Member 'ACue_Projectile_Loop_10271101::PhantomPrickleVineMeshComp' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PhantomPrickleVineMeshComps) == 0x000DC0, "Member 'ACue_Projectile_Loop_10271101::PhantomPrickleVineMeshComps' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineGrowTime) == 0x000DD0, "Member 'ACue_Projectile_Loop_10271101::PrickleVineGrowTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineDissolveTime) == 0x000DD4, "Member 'ACue_Projectile_Loop_10271101::PrickleVineDissolveTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineMeshLength) == 0x000DD8, "Member 'ACue_Projectile_Loop_10271101::PrickleVineMeshLength' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineMeshRotation) == 0x000DE0, "Member 'ACue_Projectile_Loop_10271101::PrickleVineMeshRotation' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineDissolveFX) == 0x000DF8, "Member 'ACue_Projectile_Loop_10271101::PrickleVineDissolveFX' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineCurveWhenGrowing) == 0x000E00, "Member 'ACue_Projectile_Loop_10271101::PrickleVineCurveWhenGrowing' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineCurveWhenDissolving) == 0x000E50, "Member 'ACue_Projectile_Loop_10271101::PrickleVineCurveWhenDissolving' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineAttachSockets) == 0x000EA0, "Member 'ACue_Projectile_Loop_10271101::PrickleVineAttachSockets' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineAttachTransforms) == 0x000EB0, "Member 'ACue_Projectile_Loop_10271101::PrickleVineAttachTransforms' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PhantomPrickleVineMeshMIDs) == 0x000EC0, "Member 'ACue_Projectile_Loop_10271101::PhantomPrickleVineMeshMIDs' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineComboIndex) == 0x000ED0, "Member 'ACue_Projectile_Loop_10271101::PrickleVineComboIndex' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineRandRoll) == 0x000ED4, "Member 'ACue_Projectile_Loop_10271101::PrickleVineRandRoll' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineGrowRange) == 0x000ED8, "Member 'ACue_Projectile_Loop_10271101::PrickleVineGrowRange' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineGrowDelta) == 0x000EDC, "Member 'ACue_Projectile_Loop_10271101::PrickleVineGrowDelta' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, PrickleVineGrowLastDelta) == 0x000EE0, "Member 'ACue_Projectile_Loop_10271101::PrickleVineGrowLastDelta' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10271101, CachedSourceLocation) == 0x000EE8, "Member 'ACue_Projectile_Loop_10271101::CachedSourceLocation' has a wrong offset!");

// Class Hero_1027.Projectile_10273101
// 0x0000 (0x3050 - 0x3050)
class AProjectile_10273101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	int32 GetProjectileRandSeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10273101">();
	}
	static class AProjectile_10273101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10273101>();
	}
};
static_assert(alignof(AProjectile_10273101) == 0x000010, "Wrong alignment on AProjectile_10273101");
static_assert(sizeof(AProjectile_10273101) == 0x003050, "Wrong size on AProjectile_10273101");

// Class Hero_1027.Projectile_10273102
// 0x0010 (0x3060 - 0x3050)
class AProjectile_10273102 : public AMarvelAbilityTargetActor_Projectile
{
public:
	float                                         ProjectileRandomSpeed;                             // 0x3050(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileSpeedMin;                                // 0x3054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileSpeedMax;                                // 0x3058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_305C[0x4];                                     // 0x305C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10273102">();
	}
	static class AProjectile_10273102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10273102>();
	}
};
static_assert(alignof(AProjectile_10273102) == 0x000010, "Wrong alignment on AProjectile_10273102");
static_assert(sizeof(AProjectile_10273102) == 0x003060, "Wrong size on AProjectile_10273102");
static_assert(offsetof(AProjectile_10273102, ProjectileRandomSpeed) == 0x003050, "Member 'AProjectile_10273102::ProjectileRandomSpeed' has a wrong offset!");
static_assert(offsetof(AProjectile_10273102, ProjectileSpeedMin) == 0x003054, "Member 'AProjectile_10273102::ProjectileSpeedMin' has a wrong offset!");
static_assert(offsetof(AProjectile_10273102, ProjectileSpeedMax) == 0x003058, "Member 'AProjectile_10273102::ProjectileSpeedMax' has a wrong offset!");

// Class Hero_1027.MarvelWallBuildingActor
// 0x0620 (0x0EB0 - 0x0890)
class AMarvelWallBuildingActor : public AMarvelSummonerBase
{
public:
	FMulticastInlineDelegateProperty_             OnWallScaleApproved;                               // 0x0890(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWallHealthStateChange;                           // 0x08A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWallActivateStateChange_Async;                   // 0x08B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        IndicatorComponent;                                // 0x08C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelSummonedComp_WallBuilding*       InstancedSummonedComponent;                        // 0x08C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WallBuildingMaxPlanks;                             // 0x08D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D4[0x4];                                      // 0x08D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WallBuildingMaxPlankExtend;                        // 0x08D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBoxComponent*>                  PlankBoxColliders;                                 // 0x08F0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UBoxComponent*                          FullBoxCollider;                                   // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanBuildingOnEdges : 1;                           // 0x0908(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_909[0x3];                                      // 0x0909(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallBuildingTotalTime;                             // 0x090C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallBuildingMinPlankScale;                         // 0x0910(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallBuildingMinMajorPlankScale;                    // 0x0914(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReclaimIfTotalScaleLessThen;                       // 0x0918(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaybackCooldownRatio;                              // 0x091C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreatApplyInterval;                                // 0x0920(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreatValuePerSecond;                               // 0x0924(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreatRatioPerSecond;                               // 0x0928(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreatInhibitingTimeAfterTakeDamage;                // 0x092C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetratingTestTimeInterval;                       // 0x0930(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_934[0x4];                                      // 0x0934(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECollisionChannel, ECollisionResponse>   PenetratingTestChannels;                           // 0x0938(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<ECollisionChannel, ECollisionResponse>   WallBuildingOverrideChannels;                      // 0x0988(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<ECollisionChannel, ECollisionResponse>   WallTargetingOverrideChannels;                     // 0x09D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EWallHealthState, struct FWallHealthStateConfig> WallHealthStateConfigs;                            // 0x0A28(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         WallActionDurationTimeForSelf;                     // 0x0A78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallActionDurationTimeForAlly;                     // 0x0A7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelGameplayTagRequirements         WallActionTargetRequirements;                      // 0x0A80(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         GrootEnergyAuraScopeID;                            // 0x0B50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWallHealthState                              HealthState;                                       // 0x0B54(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B55[0x3];                                      // 0x0B55(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WallFillColorIndex;                                // 0x0B58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5C[0x4];                                      // 0x0B5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFindBuildingPlace>             SuccessorBuildingQueue;                            // 0x0B60(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMarvelWallBuildingActor> ParentWallActor;                                   // 0x0B70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AMarvelWallBuildingActor*>       ChildrenWallActors;                                // 0x0B78(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_B88[0x48];                                     // 0x0B88(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelWallBuildingContext             BuildingContext;                                   // 0x0BD0(0x02E0)(Transient, NativeAccessSpecifierPublic)

public:
	void AddSuccessorBuildingPlace(const struct FFindBuildingPlace& InBuildingPlace);
	bool InitializeWallBuildingData(EWallBuildingMode InWallBuildingMode, const struct FHitResult& InHitResult);
	void OnApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnCharacterRegisterApplyDamage(class AActor* InActor);
	void OnCharacterUnregisterApplyDamage(class AActor* InActor);
	void OnPivotChaosDesResetCollision();
	void OnPivotComponentCollisionChange(class UPrimitiveComponent* InAttachParent);
	void OnPivotDestructibleFracture(class FName BoneName, const struct FVector& ImpactPoint);
	void OnRelevantSummonedEndTask(class AActor* InActor);
	void OnSuccessorWallSpawnSuccess(class AActor* SpawnActor);
	void OnWallBooleanStateChange_GameThread__DelegateSignature(bool bNewState);
	void OnWallEventReceived__DelegateSignature();
	void OnWallHealthStateChange__DelegateSignature(EWallHealthState NewState, EWallHealthState OldState);
	bool SetFullBoxEnabled(bool bEnable);
	bool SetFullBoxScale(float PlankScale);
	bool SetPlankEnabled(int32 PlankID, bool bEnable);
	bool SetPlankScale(int32 PlankID, float PlankScale);

	bool CanBuildingOnEdges() const;
	int32 GetCentricLeftPlankID() const;
	int32 GetCentricRightPlankID() const;
	void GetChildrenWallActors(bool bIncludeAllDescendants, TArray<class AMarvelWallBuildingActor*>* ChildrenWalls) const;
	void GetDependentWallActors(TArray<class AMarvelWallBuildingActor*>* DependentWalls) const;
	bool GetFullBoxEnabled() const;
	bool GetFullBoxExtent(struct FVector* OutPlankExtent) const;
	bool GetFullBoxLength(float* OutPlankLength) const;
	bool GetFullBoxScale(float* OutPlankScale) const;
	int32 GetLeftmostPlankID() const;
	class AMarvelWallBuildingActor* GetParentWallActor() const;
	class UBoxComponent* GetPlankCollider(int32 PlankID) const;
	TArray<class UBoxComponent*> GetPlankColliders() const;
	bool GetPlankEnabled(int32 PlankID) const;
	bool GetPlankExtent(int32 PlankID, struct FVector* OutPlankExtent) const;
	bool GetPlankLength(int32 PlankID, float* OutPlankLength) const;
	bool GetPlankScale(int32 PlankID, float* OutPlankScale) const;
	int32 GetRightmostPlankID() const;
	class UMarvelWallBuildingAbilityConfig* GetWallBuildingAbilityConfig() const;
	EWallBuildingMode GetWallBuildingMode() const;
	bool HasEverParentWallActor() const;
	bool HasFinishedBuilding() const;
	bool IsWallActivating() const;
	bool IsWallPreviewVisible() const;
	bool IsWallScaleApproved() const;
	bool IsWallScaleFull() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelWallBuildingActor">();
	}
	static class AMarvelWallBuildingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelWallBuildingActor>();
	}
};
static_assert(alignof(AMarvelWallBuildingActor) == 0x000010, "Wrong alignment on AMarvelWallBuildingActor");
static_assert(sizeof(AMarvelWallBuildingActor) == 0x000EB0, "Wrong size on AMarvelWallBuildingActor");
static_assert(offsetof(AMarvelWallBuildingActor, OnWallScaleApproved) == 0x000890, "Member 'AMarvelWallBuildingActor::OnWallScaleApproved' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, OnWallHealthStateChange) == 0x0008A0, "Member 'AMarvelWallBuildingActor::OnWallHealthStateChange' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, OnWallActivateStateChange_Async) == 0x0008B0, "Member 'AMarvelWallBuildingActor::OnWallActivateStateChange_Async' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, IndicatorComponent) == 0x0008C0, "Member 'AMarvelWallBuildingActor::IndicatorComponent' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, InstancedSummonedComponent) == 0x0008C8, "Member 'AMarvelWallBuildingActor::InstancedSummonedComponent' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallBuildingMaxPlanks) == 0x0008D0, "Member 'AMarvelWallBuildingActor::WallBuildingMaxPlanks' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallBuildingMaxPlankExtend) == 0x0008D8, "Member 'AMarvelWallBuildingActor::WallBuildingMaxPlankExtend' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, PlankBoxColliders) == 0x0008F0, "Member 'AMarvelWallBuildingActor::PlankBoxColliders' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, FullBoxCollider) == 0x000900, "Member 'AMarvelWallBuildingActor::FullBoxCollider' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallBuildingTotalTime) == 0x00090C, "Member 'AMarvelWallBuildingActor::WallBuildingTotalTime' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallBuildingMinPlankScale) == 0x000910, "Member 'AMarvelWallBuildingActor::WallBuildingMinPlankScale' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallBuildingMinMajorPlankScale) == 0x000914, "Member 'AMarvelWallBuildingActor::WallBuildingMinMajorPlankScale' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, ReclaimIfTotalScaleLessThen) == 0x000918, "Member 'AMarvelWallBuildingActor::ReclaimIfTotalScaleLessThen' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, PaybackCooldownRatio) == 0x00091C, "Member 'AMarvelWallBuildingActor::PaybackCooldownRatio' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, TreatApplyInterval) == 0x000920, "Member 'AMarvelWallBuildingActor::TreatApplyInterval' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, TreatValuePerSecond) == 0x000924, "Member 'AMarvelWallBuildingActor::TreatValuePerSecond' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, TreatRatioPerSecond) == 0x000928, "Member 'AMarvelWallBuildingActor::TreatRatioPerSecond' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, TreatInhibitingTimeAfterTakeDamage) == 0x00092C, "Member 'AMarvelWallBuildingActor::TreatInhibitingTimeAfterTakeDamage' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, PenetratingTestTimeInterval) == 0x000930, "Member 'AMarvelWallBuildingActor::PenetratingTestTimeInterval' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, PenetratingTestChannels) == 0x000938, "Member 'AMarvelWallBuildingActor::PenetratingTestChannels' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallBuildingOverrideChannels) == 0x000988, "Member 'AMarvelWallBuildingActor::WallBuildingOverrideChannels' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallTargetingOverrideChannels) == 0x0009D8, "Member 'AMarvelWallBuildingActor::WallTargetingOverrideChannels' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallHealthStateConfigs) == 0x000A28, "Member 'AMarvelWallBuildingActor::WallHealthStateConfigs' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallActionDurationTimeForSelf) == 0x000A78, "Member 'AMarvelWallBuildingActor::WallActionDurationTimeForSelf' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallActionDurationTimeForAlly) == 0x000A7C, "Member 'AMarvelWallBuildingActor::WallActionDurationTimeForAlly' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallActionTargetRequirements) == 0x000A80, "Member 'AMarvelWallBuildingActor::WallActionTargetRequirements' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, GrootEnergyAuraScopeID) == 0x000B50, "Member 'AMarvelWallBuildingActor::GrootEnergyAuraScopeID' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, HealthState) == 0x000B54, "Member 'AMarvelWallBuildingActor::HealthState' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, WallFillColorIndex) == 0x000B58, "Member 'AMarvelWallBuildingActor::WallFillColorIndex' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, SuccessorBuildingQueue) == 0x000B60, "Member 'AMarvelWallBuildingActor::SuccessorBuildingQueue' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, ParentWallActor) == 0x000B70, "Member 'AMarvelWallBuildingActor::ParentWallActor' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, ChildrenWallActors) == 0x000B78, "Member 'AMarvelWallBuildingActor::ChildrenWallActors' has a wrong offset!");
static_assert(offsetof(AMarvelWallBuildingActor, BuildingContext) == 0x000BD0, "Member 'AMarvelWallBuildingActor::BuildingContext' has a wrong offset!");

// Class Hero_1027.Summoned_10274101
// 0x0040 (0x0EF0 - 0x0EB0)
class ASummoned_10274101 : public AMarvelWallBuildingActor
{
public:
	FMulticastInlineDelegateProperty_             OnWallAttackStart;                                 // 0x0EB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         WallAttackScopeID;                                 // 0x0EC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallAttackMissileDelay;                            // 0x0EC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallHalfHeightForOcclusion;                        // 0x0EC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ECC[0x24];                                     // 0x0ECC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10274101">();
	}
	static class ASummoned_10274101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10274101>();
	}
};
static_assert(alignof(ASummoned_10274101) == 0x000010, "Wrong alignment on ASummoned_10274101");
static_assert(sizeof(ASummoned_10274101) == 0x000EF0, "Wrong size on ASummoned_10274101");
static_assert(offsetof(ASummoned_10274101, OnWallAttackStart) == 0x000EB0, "Member 'ASummoned_10274101::OnWallAttackStart' has a wrong offset!");
static_assert(offsetof(ASummoned_10274101, WallAttackScopeID) == 0x000EC0, "Member 'ASummoned_10274101::WallAttackScopeID' has a wrong offset!");
static_assert(offsetof(ASummoned_10274101, WallAttackMissileDelay) == 0x000EC4, "Member 'ASummoned_10274101::WallAttackMissileDelay' has a wrong offset!");
static_assert(offsetof(ASummoned_10274101, WallHalfHeightForOcclusion) == 0x000EC8, "Member 'ASummoned_10274101::WallHalfHeightForOcclusion' has a wrong offset!");

// Class Hero_1027.MarvelSummonedComp_WallBuilding
// 0x0120 (0x0DC0 - 0x0CA0)
class UMarvelSummonedComp_WallBuilding : public UMarvelSummonedComponent
{
public:
	struct FWallBuildingPostPhysicsTickFunction   PostPhysicsTickFunction;                           // 0x0CA0(0x0038)(NativeAccessSpecifierPublic)
	int32                                         WallRandomSeed;                                    // 0x0CD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWallBuildingMode                             WallBuildingMode;                                  // 0x0CDC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CDD[0x3];                                      // 0x0CDD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPrimitiveComponent>     CarryingComponent;                                 // 0x0CE0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CarryingPlaneNormal;                               // 0x0CE8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D00[0x80];                                     // 0x0D00(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ExpectedScaleOfPlanks;                             // 0x0D80(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 ApprovedScaleOfPlanks;                             // 0x0D90(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA0[0x20];                                     // 0x0DA0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ApprovedScaleOfPlanks();

	class UMarvelWallBuildingAbilityConfig* GetWallBuildingAbilityConfig() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelSummonedComp_WallBuilding">();
	}
	static class UMarvelSummonedComp_WallBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelSummonedComp_WallBuilding>();
	}
};
static_assert(alignof(UMarvelSummonedComp_WallBuilding) == 0x000010, "Wrong alignment on UMarvelSummonedComp_WallBuilding");
static_assert(sizeof(UMarvelSummonedComp_WallBuilding) == 0x000DC0, "Wrong size on UMarvelSummonedComp_WallBuilding");
static_assert(offsetof(UMarvelSummonedComp_WallBuilding, PostPhysicsTickFunction) == 0x000CA0, "Member 'UMarvelSummonedComp_WallBuilding::PostPhysicsTickFunction' has a wrong offset!");
static_assert(offsetof(UMarvelSummonedComp_WallBuilding, WallRandomSeed) == 0x000CD8, "Member 'UMarvelSummonedComp_WallBuilding::WallRandomSeed' has a wrong offset!");
static_assert(offsetof(UMarvelSummonedComp_WallBuilding, WallBuildingMode) == 0x000CDC, "Member 'UMarvelSummonedComp_WallBuilding::WallBuildingMode' has a wrong offset!");
static_assert(offsetof(UMarvelSummonedComp_WallBuilding, CarryingComponent) == 0x000CE0, "Member 'UMarvelSummonedComp_WallBuilding::CarryingComponent' has a wrong offset!");
static_assert(offsetof(UMarvelSummonedComp_WallBuilding, CarryingPlaneNormal) == 0x000CE8, "Member 'UMarvelSummonedComp_WallBuilding::CarryingPlaneNormal' has a wrong offset!");
static_assert(offsetof(UMarvelSummonedComp_WallBuilding, ExpectedScaleOfPlanks) == 0x000D80, "Member 'UMarvelSummonedComp_WallBuilding::ExpectedScaleOfPlanks' has a wrong offset!");
static_assert(offsetof(UMarvelSummonedComp_WallBuilding, ApprovedScaleOfPlanks) == 0x000D90, "Member 'UMarvelSummonedComp_WallBuilding::ApprovedScaleOfPlanks' has a wrong offset!");

// Class Hero_1027.SummonedComp_10274101
// 0x0010 (0x0DD0 - 0x0DC0)
class USummonedComp_10274101 final : public UMarvelSummonedComp_WallBuilding
{
public:
	struct FWallAttackNotify                      WallAttackNotify;                                  // 0x0DC0(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC2[0xE];                                      // 0x0DC2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_WallAttackNotify();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10274101">();
	}
	static class USummonedComp_10274101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10274101>();
	}
};
static_assert(alignof(USummonedComp_10274101) == 0x000010, "Wrong alignment on USummonedComp_10274101");
static_assert(sizeof(USummonedComp_10274101) == 0x000DD0, "Wrong size on USummonedComp_10274101");
static_assert(offsetof(USummonedComp_10274101, WallAttackNotify) == 0x000DC0, "Member 'USummonedComp_10274101::WallAttackNotify' has a wrong offset!");

// Class Hero_1027.Summoned_10274101_AnimInstance
// 0x0000 (0x0430 - 0x0430)
class USummoned_10274101_AnimInstance final : public UAnimInstance
{
public:
	bool                                          bIsWallActivating;                                 // 0x0428(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldWallStateTransition;                        // 0x0429(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42A[0x6];                                      // 0x042A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWallActivateStateChange(bool bNewState);
	void SetBindSummonerState(class AMarvelWallBuildingActor* InWallActor, bool bBindState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10274101_AnimInstance">();
	}
	static class USummoned_10274101_AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummoned_10274101_AnimInstance>();
	}
};
static_assert(alignof(USummoned_10274101_AnimInstance) == 0x000010, "Wrong alignment on USummoned_10274101_AnimInstance");
static_assert(sizeof(USummoned_10274101_AnimInstance) == 0x000430, "Wrong size on USummoned_10274101_AnimInstance");
static_assert(offsetof(USummoned_10274101_AnimInstance, bIsWallActivating) == 0x000428, "Member 'USummoned_10274101_AnimInstance::bIsWallActivating' has a wrong offset!");
static_assert(offsetof(USummoned_10274101_AnimInstance, bShouldWallStateTransition) == 0x000429, "Member 'USummoned_10274101_AnimInstance::bShouldWallStateTransition' has a wrong offset!");

// Class Hero_1027.MarvelWallBuildingAbilityConfig
// 0x0298 (0x0330 - 0x0098)
class UMarvelWallBuildingAbilityConfig : public UMarvelAbilityConfig
{
public:
	bool                                          bAutoSwitchBuildingMode;                           // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MultipleBuildingCountLimit;                        // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonerAgentID;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBuildingRadius;                                 // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBuildingRadius;                                 // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBuildingHeight;                                 // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraBuildingRadiusWhenConfirming;                 // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopePitchDegree;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeckingStepDegree;                                 // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LiftingViewDegree;                                 // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LiftingStepDegree;                                 // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingViewDegree;                                 // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingStepDegree;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingMinDistance;                                // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingMaxDistance;                                // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingMinDistanceWhenBlocking;                    // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingMaxDistanceWhenBlocking;                    // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAdsorbDegree;                                   // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAdsorbDistance;                                 // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFloorDist;                                      // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           WallBuildingDenyCollisionPresets;                  // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           WallBuildingIgnoreCollisionPresets;                // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EWallBuildingMode>                     AvailableBuildingModes;                            // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TraceActorCueTag;                                  // 0x0118(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  WallPushingTargetGrantTags;                        // 0x0128(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMarvelGameplayTagRequirements         WallPushUtmostlyTargetRequirements;                // 0x0190(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMarvelGameplayTagRequirements         WallPushNormallyTargetRequirements;                // 0x0260(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	class AMarvelWallBuildingActor* GetWallActorCDO() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelWallBuildingAbilityConfig">();
	}
	static class UMarvelWallBuildingAbilityConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelWallBuildingAbilityConfig>();
	}
};
static_assert(alignof(UMarvelWallBuildingAbilityConfig) == 0x000008, "Wrong alignment on UMarvelWallBuildingAbilityConfig");
static_assert(sizeof(UMarvelWallBuildingAbilityConfig) == 0x000330, "Wrong size on UMarvelWallBuildingAbilityConfig");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, bAutoSwitchBuildingMode) == 0x000098, "Member 'UMarvelWallBuildingAbilityConfig::bAutoSwitchBuildingMode' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, MultipleBuildingCountLimit) == 0x00009C, "Member 'UMarvelWallBuildingAbilityConfig::MultipleBuildingCountLimit' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, SummonerAgentID) == 0x0000A0, "Member 'UMarvelWallBuildingAbilityConfig::SummonerAgentID' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, MinBuildingRadius) == 0x0000A4, "Member 'UMarvelWallBuildingAbilityConfig::MinBuildingRadius' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, MaxBuildingRadius) == 0x0000A8, "Member 'UMarvelWallBuildingAbilityConfig::MaxBuildingRadius' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, MaxBuildingHeight) == 0x0000AC, "Member 'UMarvelWallBuildingAbilityConfig::MaxBuildingHeight' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, ExtraBuildingRadiusWhenConfirming) == 0x0000B0, "Member 'UMarvelWallBuildingAbilityConfig::ExtraBuildingRadiusWhenConfirming' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, SlopePitchDegree) == 0x0000B4, "Member 'UMarvelWallBuildingAbilityConfig::SlopePitchDegree' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, DeckingStepDegree) == 0x0000B8, "Member 'UMarvelWallBuildingAbilityConfig::DeckingStepDegree' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, LiftingViewDegree) == 0x0000BC, "Member 'UMarvelWallBuildingAbilityConfig::LiftingViewDegree' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, LiftingStepDegree) == 0x0000C0, "Member 'UMarvelWallBuildingAbilityConfig::LiftingStepDegree' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, LandingViewDegree) == 0x0000C4, "Member 'UMarvelWallBuildingAbilityConfig::LandingViewDegree' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, LandingStepDegree) == 0x0000C8, "Member 'UMarvelWallBuildingAbilityConfig::LandingStepDegree' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, LandingMinDistance) == 0x0000CC, "Member 'UMarvelWallBuildingAbilityConfig::LandingMinDistance' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, LandingMaxDistance) == 0x0000D0, "Member 'UMarvelWallBuildingAbilityConfig::LandingMaxDistance' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, LandingMinDistanceWhenBlocking) == 0x0000D4, "Member 'UMarvelWallBuildingAbilityConfig::LandingMinDistanceWhenBlocking' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, LandingMaxDistanceWhenBlocking) == 0x0000D8, "Member 'UMarvelWallBuildingAbilityConfig::LandingMaxDistanceWhenBlocking' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, MaxAdsorbDegree) == 0x0000DC, "Member 'UMarvelWallBuildingAbilityConfig::MaxAdsorbDegree' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, MaxAdsorbDistance) == 0x0000E0, "Member 'UMarvelWallBuildingAbilityConfig::MaxAdsorbDistance' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, MaxFloorDist) == 0x0000E4, "Member 'UMarvelWallBuildingAbilityConfig::MaxFloorDist' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, WallBuildingDenyCollisionPresets) == 0x0000E8, "Member 'UMarvelWallBuildingAbilityConfig::WallBuildingDenyCollisionPresets' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, WallBuildingIgnoreCollisionPresets) == 0x0000F8, "Member 'UMarvelWallBuildingAbilityConfig::WallBuildingIgnoreCollisionPresets' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, AvailableBuildingModes) == 0x000108, "Member 'UMarvelWallBuildingAbilityConfig::AvailableBuildingModes' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, TraceActorCueTag) == 0x000118, "Member 'UMarvelWallBuildingAbilityConfig::TraceActorCueTag' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, WallPushingTargetGrantTags) == 0x000128, "Member 'UMarvelWallBuildingAbilityConfig::WallPushingTargetGrantTags' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, WallPushUtmostlyTargetRequirements) == 0x000190, "Member 'UMarvelWallBuildingAbilityConfig::WallPushUtmostlyTargetRequirements' has a wrong offset!");
static_assert(offsetof(UMarvelWallBuildingAbilityConfig, WallPushNormallyTargetRequirements) == 0x000260, "Member 'UMarvelWallBuildingAbilityConfig::WallPushNormallyTargetRequirements' has a wrong offset!");

// Class Hero_1027.Config_102741
// 0x0000 (0x0330 - 0x0330)
class UConfig_102741 : public UMarvelWallBuildingAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102741">();
	}
	static class UConfig_102741* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102741>();
	}
};
static_assert(alignof(UConfig_102741) == 0x000008, "Wrong alignment on UConfig_102741");
static_assert(sizeof(UConfig_102741) == 0x000330, "Wrong size on UConfig_102741");

// Class Hero_1027.Ability_102741
// 0x0070 (0x25F0 - 0x2580)
class UAbility_102741 : public UMarvelGameplayAbility
{
public:
	uint8                                         Pad_2580[0x20];                                    // 0x2580(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWallBuildingModeChanged;                         // 0x25A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNumOwnedWallsChanged;                            // 0x25B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EWallBuildingMode                             ReplicatedBuildingMode;                            // 0x25C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C1[0x3];                                     // 0x25C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivateCostValueOverride;                         // 0x25C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReplicatedNumOwnedWalls;                           // 0x25C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25CC[0x4];                                     // 0x25CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AMarvelWallBuildingActor*>       OwnedWallActors;                                   // 0x25D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E0[0x10];                                    // 0x25E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_CommitCustomAbilityCost(int32 Multiplier);
	void OnNumOwnedWallsChanged__DelegateSignature(int32 NumWalls, int32 MaxWalls);
	void OnOwnedWallActorEndTask(class AActor* InWallActor);
	void OnRep_ReplicatedNumOwnedWalls();
	void OnRep_ReplicatedOwnedWallActors();
	void OnWallBuildConfirm__DelegateSignature();
	void OnWallBuildingModeChanged__DelegateSignature(EWallBuildingMode InMode);
	void SetWallBuildingMode(EWallBuildingMode InBuildingMode);

	int32 GetMaxOwnedWalls() const;
	int32 GetNumOwnedWalls() const;
	EWallBuildingMode GetWallBuildingMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102741">();
	}
	static class UAbility_102741* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102741>();
	}
};
static_assert(alignof(UAbility_102741) == 0x000008, "Wrong alignment on UAbility_102741");
static_assert(sizeof(UAbility_102741) == 0x0025F0, "Wrong size on UAbility_102741");
static_assert(offsetof(UAbility_102741, OnWallBuildingModeChanged) == 0x0025A0, "Member 'UAbility_102741::OnWallBuildingModeChanged' has a wrong offset!");
static_assert(offsetof(UAbility_102741, OnNumOwnedWallsChanged) == 0x0025B0, "Member 'UAbility_102741::OnNumOwnedWallsChanged' has a wrong offset!");
static_assert(offsetof(UAbility_102741, ReplicatedBuildingMode) == 0x0025C0, "Member 'UAbility_102741::ReplicatedBuildingMode' has a wrong offset!");
static_assert(offsetof(UAbility_102741, ActivateCostValueOverride) == 0x0025C4, "Member 'UAbility_102741::ActivateCostValueOverride' has a wrong offset!");
static_assert(offsetof(UAbility_102741, ReplicatedNumOwnedWalls) == 0x0025C8, "Member 'UAbility_102741::ReplicatedNumOwnedWalls' has a wrong offset!");
static_assert(offsetof(UAbility_102741, OwnedWallActors) == 0x0025D0, "Member 'UAbility_102741::OwnedWallActors' has a wrong offset!");

// Class Hero_1027.Cue_TraceActor_10274101
// 0x0030 (0x0D30 - 0x0D00)
class ACue_TraceActor_10274101 : public AMarvelCueNotify_TraceActor
{
public:
	class UStaticMeshComponent*                   WallPreviewGoodEntityComp;                         // 0x0D00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      WallPreviewGoodGroundComp;                         // 0x0D08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   WallPreviewBadEntityComp;                          // 0x0D10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      WallPreviewBadGroundComp;                          // 0x0D18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WallBuildingModeChangeAudioID;                     // 0x0D20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D24[0x4];                                      // 0x0D24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_102741*                         AbilityConfig;                                     // 0x0D28(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnWallBuildingModeChange();
	void OnWallPreviewStateChange(EWallPreviewState InPreviewState);
	void OnWallPreviewUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_TraceActor_10274101">();
	}
	static class ACue_TraceActor_10274101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_TraceActor_10274101>();
	}
};
static_assert(alignof(ACue_TraceActor_10274101) == 0x000008, "Wrong alignment on ACue_TraceActor_10274101");
static_assert(sizeof(ACue_TraceActor_10274101) == 0x000D30, "Wrong size on ACue_TraceActor_10274101");
static_assert(offsetof(ACue_TraceActor_10274101, WallPreviewGoodEntityComp) == 0x000D00, "Member 'ACue_TraceActor_10274101::WallPreviewGoodEntityComp' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10274101, WallPreviewGoodGroundComp) == 0x000D08, "Member 'ACue_TraceActor_10274101::WallPreviewGoodGroundComp' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10274101, WallPreviewBadEntityComp) == 0x000D10, "Member 'ACue_TraceActor_10274101::WallPreviewBadEntityComp' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10274101, WallPreviewBadGroundComp) == 0x000D18, "Member 'ACue_TraceActor_10274101::WallPreviewBadGroundComp' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10274101, WallBuildingModeChangeAudioID) == 0x000D20, "Member 'ACue_TraceActor_10274101::WallBuildingModeChangeAudioID' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10274101, AbilityConfig) == 0x000D28, "Member 'ACue_TraceActor_10274101::AbilityConfig' has a wrong offset!");

// Class Hero_1027.Cue_Summoner_Loop_10274101
// 0x0410 (0x12A0 - 0x0E90)
#pragma pack(push, 0x1)
class alignas(0x10) ACue_Summoner_Loop_10274101 : public AMarvelCueNotify_Summoned
{
public:
	class USceneComponent*                        WallEntitySceneComp;                               // 0x0E90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 WallThornMesh01;                                   // 0x0E98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 WallThornMesh03_A;                                 // 0x0EA0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 WallThornMesh03_B;                                 // 0x0EA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 WallThornMesh03_C;                                 // 0x0EB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     WallEntityFXComp;                                  // 0x0EB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     WallActiveFXComp;                                  // 0x0EC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     WallThornFXComp;                                   // 0x0EC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     WallGroundFXComp;                                  // 0x0ED0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             WallEntityMats;                                    // 0x0ED8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      WallEntityFXMatInfos;                              // 0x0EE8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      WallActiveFXMatInfos;                              // 0x0F38(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      WallGroundFXMatInfos;                              // 0x0F88(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         WallDamagedFX;                                     // 0x0FD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         WallBuildingDustFX;                                // 0x0FE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE8[0x8];                                      // 0x0FE8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WallThornAttachTransformFront;                     // 0x0FF0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WallThornAttachTransformBack;                      // 0x1050(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallBuildingTotalTime;                             // 0x10B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WallMaterialClipInverse;                           // 0x10B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B5[0x3];                                     // 0x10B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallMaterialClipOffset;                            // 0x10B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallMaterialClipTotalWidth;                        // 0x10BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallMaterialClipTotalLength;                       // 0x10C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallMaterialClipExtraLength;                       // 0x10C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallMaterialClipWipedLength;                       // 0x10C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10CC[0x4];                                     // 0x10CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           WallMaterialClipParmNames;                         // 0x10D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         WallActiveStartAudioID;                            // 0x10E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WallActiveEndAudioID;                              // 0x10E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallBuildingDeltaTime;                             // 0x10E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10EC[0x4];                                     // 0x10EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       WallEntityMIDs;                                    // 0x10F0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<int32>                                 HitWallAbilityIDArray;                             // 0x1100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MaxChangeTime;                                     // 0x1110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeTimeInterval;                                // 0x1114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusValue;                                       // 0x1118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WidthValue;                                        // 0x111C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1120[0x1C];                                    // 0x1120(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallEntityFXActivateTime;                          // 0x113C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallActiveFXActivateTime;                          // 0x1140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallGroundFXActivateTime;                          // 0x1144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallThornFXActivateTime;                           // 0x1148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114C[0x6C];                                    // 0x114C(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WallMoreSemiDamageAudioId;                         // 0x11B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WallMoreMostDamageAudioId;                         // 0x11BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WallLessHealthyAudioId;                            // 0x11C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WallLessSemiDamageAudioId;                         // 0x11C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         EnhancedGroundFX;                                  // 0x11C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         EnhancedBurstFX;                                   // 0x11D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EnhancedAudioID;                                   // 0x11D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11DC[0x4];                                     // 0x11DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCueHintData                           HintData;                                          // 0x11E0(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     EnhancedGroundFXComponent;                         // 0x1278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     EnhancedBurstFXComponent;                          // 0x1280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1288[0x8];                                     // 0x1288(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelUserWidget*                      UIWidget;                                          // 0x1290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeRadiusValue();
	class UMarvelUserWidget* GetUIWidget();
	void OnEnhanceStateChanged(bool bIsEnhanced);
	void OnTakeDamage(class AActor* InSource, class AActor* InSourceAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnWallActivateStateChange_ThreadSafe(bool bNewState);
	void OnWallAttackStart(bool bAttackFront);
	void OnWallHealthStateChange(const EWallHealthState NewState, const EWallHealthState OldState);
	void OnWallScaleApproved();

	float ComputeClipLength(const float InScale) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10274101">();
	}
	static class ACue_Summoner_Loop_10274101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10274101>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACue_Summoner_Loop_10274101) == 0x000010, "Wrong alignment on ACue_Summoner_Loop_10274101");
static_assert(sizeof(ACue_Summoner_Loop_10274101) == 0x0012A0, "Wrong size on ACue_Summoner_Loop_10274101");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallEntitySceneComp) == 0x000E90, "Member 'ACue_Summoner_Loop_10274101::WallEntitySceneComp' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallThornMesh01) == 0x000E98, "Member 'ACue_Summoner_Loop_10274101::WallThornMesh01' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallThornMesh03_A) == 0x000EA0, "Member 'ACue_Summoner_Loop_10274101::WallThornMesh03_A' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallThornMesh03_B) == 0x000EA8, "Member 'ACue_Summoner_Loop_10274101::WallThornMesh03_B' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallThornMesh03_C) == 0x000EB0, "Member 'ACue_Summoner_Loop_10274101::WallThornMesh03_C' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallEntityFXComp) == 0x000EB8, "Member 'ACue_Summoner_Loop_10274101::WallEntityFXComp' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallActiveFXComp) == 0x000EC0, "Member 'ACue_Summoner_Loop_10274101::WallActiveFXComp' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallThornFXComp) == 0x000EC8, "Member 'ACue_Summoner_Loop_10274101::WallThornFXComp' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallGroundFXComp) == 0x000ED0, "Member 'ACue_Summoner_Loop_10274101::WallGroundFXComp' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallEntityMats) == 0x000ED8, "Member 'ACue_Summoner_Loop_10274101::WallEntityMats' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallEntityFXMatInfos) == 0x000EE8, "Member 'ACue_Summoner_Loop_10274101::WallEntityFXMatInfos' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallActiveFXMatInfos) == 0x000F38, "Member 'ACue_Summoner_Loop_10274101::WallActiveFXMatInfos' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallGroundFXMatInfos) == 0x000F88, "Member 'ACue_Summoner_Loop_10274101::WallGroundFXMatInfos' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallDamagedFX) == 0x000FD8, "Member 'ACue_Summoner_Loop_10274101::WallDamagedFX' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallBuildingDustFX) == 0x000FE0, "Member 'ACue_Summoner_Loop_10274101::WallBuildingDustFX' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallThornAttachTransformFront) == 0x000FF0, "Member 'ACue_Summoner_Loop_10274101::WallThornAttachTransformFront' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallThornAttachTransformBack) == 0x001050, "Member 'ACue_Summoner_Loop_10274101::WallThornAttachTransformBack' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallBuildingTotalTime) == 0x0010B0, "Member 'ACue_Summoner_Loop_10274101::WallBuildingTotalTime' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallMaterialClipInverse) == 0x0010B4, "Member 'ACue_Summoner_Loop_10274101::WallMaterialClipInverse' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallMaterialClipOffset) == 0x0010B8, "Member 'ACue_Summoner_Loop_10274101::WallMaterialClipOffset' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallMaterialClipTotalWidth) == 0x0010BC, "Member 'ACue_Summoner_Loop_10274101::WallMaterialClipTotalWidth' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallMaterialClipTotalLength) == 0x0010C0, "Member 'ACue_Summoner_Loop_10274101::WallMaterialClipTotalLength' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallMaterialClipExtraLength) == 0x0010C4, "Member 'ACue_Summoner_Loop_10274101::WallMaterialClipExtraLength' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallMaterialClipWipedLength) == 0x0010C8, "Member 'ACue_Summoner_Loop_10274101::WallMaterialClipWipedLength' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallMaterialClipParmNames) == 0x0010D0, "Member 'ACue_Summoner_Loop_10274101::WallMaterialClipParmNames' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallActiveStartAudioID) == 0x0010E0, "Member 'ACue_Summoner_Loop_10274101::WallActiveStartAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallActiveEndAudioID) == 0x0010E4, "Member 'ACue_Summoner_Loop_10274101::WallActiveEndAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallBuildingDeltaTime) == 0x0010E8, "Member 'ACue_Summoner_Loop_10274101::WallBuildingDeltaTime' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallEntityMIDs) == 0x0010F0, "Member 'ACue_Summoner_Loop_10274101::WallEntityMIDs' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, HitWallAbilityIDArray) == 0x001100, "Member 'ACue_Summoner_Loop_10274101::HitWallAbilityIDArray' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, MaxChangeTime) == 0x001110, "Member 'ACue_Summoner_Loop_10274101::MaxChangeTime' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, ChangeTimeInterval) == 0x001114, "Member 'ACue_Summoner_Loop_10274101::ChangeTimeInterval' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, RadiusValue) == 0x001118, "Member 'ACue_Summoner_Loop_10274101::RadiusValue' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WidthValue) == 0x00111C, "Member 'ACue_Summoner_Loop_10274101::WidthValue' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallEntityFXActivateTime) == 0x00113C, "Member 'ACue_Summoner_Loop_10274101::WallEntityFXActivateTime' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallActiveFXActivateTime) == 0x001140, "Member 'ACue_Summoner_Loop_10274101::WallActiveFXActivateTime' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallGroundFXActivateTime) == 0x001144, "Member 'ACue_Summoner_Loop_10274101::WallGroundFXActivateTime' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallThornFXActivateTime) == 0x001148, "Member 'ACue_Summoner_Loop_10274101::WallThornFXActivateTime' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallMoreSemiDamageAudioId) == 0x0011B8, "Member 'ACue_Summoner_Loop_10274101::WallMoreSemiDamageAudioId' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallMoreMostDamageAudioId) == 0x0011BC, "Member 'ACue_Summoner_Loop_10274101::WallMoreMostDamageAudioId' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallLessHealthyAudioId) == 0x0011C0, "Member 'ACue_Summoner_Loop_10274101::WallLessHealthyAudioId' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, WallLessSemiDamageAudioId) == 0x0011C4, "Member 'ACue_Summoner_Loop_10274101::WallLessSemiDamageAudioId' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, EnhancedGroundFX) == 0x0011C8, "Member 'ACue_Summoner_Loop_10274101::EnhancedGroundFX' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, EnhancedBurstFX) == 0x0011D0, "Member 'ACue_Summoner_Loop_10274101::EnhancedBurstFX' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, EnhancedAudioID) == 0x0011D8, "Member 'ACue_Summoner_Loop_10274101::EnhancedAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, HintData) == 0x0011E0, "Member 'ACue_Summoner_Loop_10274101::HintData' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, EnhancedGroundFXComponent) == 0x001278, "Member 'ACue_Summoner_Loop_10274101::EnhancedGroundFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, EnhancedBurstFXComponent) == 0x001280, "Member 'ACue_Summoner_Loop_10274101::EnhancedBurstFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10274101, UIWidget) == 0x001290, "Member 'ACue_Summoner_Loop_10274101::UIWidget' has a wrong offset!");

// Class Hero_1027.WallBuildingPlaceTag
// 0x0008 (0x0038 - 0x0030)
class UWallBuildingPlaceTag final : public UAssetUserData
{
public:
	bool                                          bAllowWallBuilding;                                // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAttachToBase;                               // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WallBuildingPlaceTag">();
	}
	static class UWallBuildingPlaceTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWallBuildingPlaceTag>();
	}
};
static_assert(alignof(UWallBuildingPlaceTag) == 0x000008, "Wrong alignment on UWallBuildingPlaceTag");
static_assert(sizeof(UWallBuildingPlaceTag) == 0x000038, "Wrong size on UWallBuildingPlaceTag");
static_assert(offsetof(UWallBuildingPlaceTag, bAllowWallBuilding) == 0x000030, "Member 'UWallBuildingPlaceTag::bAllowWallBuilding' has a wrong offset!");
static_assert(offsetof(UWallBuildingPlaceTag, bShouldAttachToBase) == 0x000031, "Member 'UWallBuildingPlaceTag::bShouldAttachToBase' has a wrong offset!");

// Class Hero_1027.StableAxisXBoxComponent
// 0x0000 (0x08A0 - 0x08A0)
class UStableAxisXBoxComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StableAxisXBoxComponent">();
	}
	static class UStableAxisXBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStableAxisXBoxComponent>();
	}
};
static_assert(alignof(UStableAxisXBoxComponent) == 0x000010, "Wrong alignment on UStableAxisXBoxComponent");
static_assert(sizeof(UStableAxisXBoxComponent) == 0x0008A0, "Wrong size on UStableAxisXBoxComponent");

// Class Hero_1027.MarvelWallBuildingAbilityInterface
// 0x0000 (0x0030 - 0x0030)
class IMarvelWallBuildingAbilityInterface final : public IInterface
{
public:
	void TrySwitchBuildingMode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelWallBuildingAbilityInterface">();
	}
	static class IMarvelWallBuildingAbilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMarvelWallBuildingAbilityInterface>();
	}
};
static_assert(alignof(IMarvelWallBuildingAbilityInterface) == 0x000008, "Wrong alignment on IMarvelWallBuildingAbilityInterface");
static_assert(sizeof(IMarvelWallBuildingAbilityInterface) == 0x000030, "Wrong size on IMarvelWallBuildingAbilityInterface");

// Class Hero_1027.MarvelSummonedAbilityInterface
// 0x0000 (0x0030 - 0x0030)
class IMarvelSummonedAbilityInterface final : public IInterface
{
public:
	void BindSummonedChangeDelegate(const TDelegate<void(class AActor* InActor, bool bIsAdd)>& InDelegate);
	FMulticastInlineDelegateProperty_ GetOnSummonedChangeDelegate();
	void UnBindSummonedChangeDelegate(const TDelegate<void(class AActor* InActor, bool bIsAdd)>& InDelegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelSummonedAbilityInterface">();
	}
	static class IMarvelSummonedAbilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMarvelSummonedAbilityInterface>();
	}
};
static_assert(alignof(IMarvelSummonedAbilityInterface) == 0x000008, "Wrong alignment on IMarvelSummonedAbilityInterface");
static_assert(sizeof(IMarvelSummonedAbilityInterface) == 0x000030, "Wrong size on IMarvelSummonedAbilityInterface");

// Class Hero_1027.MarvelAbilityTargetActor_WallBuilding
// 0x0730 (0x0E60 - 0x0730)
class AMarvelAbilityTargetActor_WallBuilding final : public AGameplayAbilityTargetActor
{
public:
	FMulticastInlineDelegateProperty_             OnWallPreviewStateChange;                          // 0x0730(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWallPreviewUpdate;                               // 0x0740(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWallBuildingModeChange;                          // 0x0750(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_760[0x10];                                     // 0x0760(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkinID;                                            // 0x0770(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityID;                                         // 0x0774(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWallBuildingMode                             BuildingMode;                                      // 0x0778(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFollowerActor;                                  // 0x0779(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConfirmingStage;                                // 0x077A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77B[0x5];                                      // 0x077B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelWallBuildingAbilityConfig*       AbilityConfig;                                     // 0x0780(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWallPreviewState                             PreviewState;                                      // 0x0788(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_789[0x7];                                      // 0x0789(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PreviewScaleOfPlanks;                              // 0x0790(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FFindBuildingPlace                     BuildingPlace;                                     // 0x07A0(0x0240)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                LastBuildingNormal;                                // 0x09E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AMarvelAbilityTargetActor_WallBuilding*> FollowerTraceActors;                               // 0x09F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_A08[0x140];                                    // 0x0A08(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TraceActorCueTag;                                  // 0x0B48(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B54[0x4];                                      // 0x0B54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IMarvelWallBuildingAbilityInterface> BuildingAbilityInterface;                          // 0x0B58(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDeclarationHolder                     DeclareViewSideHolder;                             // 0x0B68(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B78[0x8];                                      // 0x0B78(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelWallBuildingContext             BuildingContext;                                   // 0x0B80(0x02E0)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);
	void OnRep_BuildingMode();
	void OnWallPreviewStateChange__DelegateSignature(EWallPreviewState InPreviewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAbilityTargetActor_WallBuilding">();
	}
	static class AMarvelAbilityTargetActor_WallBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelAbilityTargetActor_WallBuilding>();
	}
};
static_assert(alignof(AMarvelAbilityTargetActor_WallBuilding) == 0x000010, "Wrong alignment on AMarvelAbilityTargetActor_WallBuilding");
static_assert(sizeof(AMarvelAbilityTargetActor_WallBuilding) == 0x000E60, "Wrong size on AMarvelAbilityTargetActor_WallBuilding");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, OnWallPreviewStateChange) == 0x000730, "Member 'AMarvelAbilityTargetActor_WallBuilding::OnWallPreviewStateChange' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, OnWallPreviewUpdate) == 0x000740, "Member 'AMarvelAbilityTargetActor_WallBuilding::OnWallPreviewUpdate' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, OnWallBuildingModeChange) == 0x000750, "Member 'AMarvelAbilityTargetActor_WallBuilding::OnWallBuildingModeChange' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, SkinID) == 0x000770, "Member 'AMarvelAbilityTargetActor_WallBuilding::SkinID' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, AbilityID) == 0x000774, "Member 'AMarvelAbilityTargetActor_WallBuilding::AbilityID' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, BuildingMode) == 0x000778, "Member 'AMarvelAbilityTargetActor_WallBuilding::BuildingMode' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, bIsFollowerActor) == 0x000779, "Member 'AMarvelAbilityTargetActor_WallBuilding::bIsFollowerActor' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, bIsConfirmingStage) == 0x00077A, "Member 'AMarvelAbilityTargetActor_WallBuilding::bIsConfirmingStage' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, AbilityConfig) == 0x000780, "Member 'AMarvelAbilityTargetActor_WallBuilding::AbilityConfig' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, PreviewState) == 0x000788, "Member 'AMarvelAbilityTargetActor_WallBuilding::PreviewState' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, PreviewScaleOfPlanks) == 0x000790, "Member 'AMarvelAbilityTargetActor_WallBuilding::PreviewScaleOfPlanks' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, BuildingPlace) == 0x0007A0, "Member 'AMarvelAbilityTargetActor_WallBuilding::BuildingPlace' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, LastBuildingNormal) == 0x0009E0, "Member 'AMarvelAbilityTargetActor_WallBuilding::LastBuildingNormal' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, FollowerTraceActors) == 0x0009F8, "Member 'AMarvelAbilityTargetActor_WallBuilding::FollowerTraceActors' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, TraceActorCueTag) == 0x000B48, "Member 'AMarvelAbilityTargetActor_WallBuilding::TraceActorCueTag' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, BuildingAbilityInterface) == 0x000B58, "Member 'AMarvelAbilityTargetActor_WallBuilding::BuildingAbilityInterface' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, DeclareViewSideHolder) == 0x000B68, "Member 'AMarvelAbilityTargetActor_WallBuilding::DeclareViewSideHolder' has a wrong offset!");
static_assert(offsetof(AMarvelAbilityTargetActor_WallBuilding, BuildingContext) == 0x000B80, "Member 'AMarvelAbilityTargetActor_WallBuilding::BuildingContext' has a wrong offset!");

// Class Hero_1027.MarvelAbilityTask_FindBuildingLoc
// 0x0028 (0x0200 - 0x01D8)
class UMarvelAbilityTask_FindBuildingLoc final : public UAbilityTask
{
public:
	bool                                          bHasConfirm;                                       // 0x01D8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x01DC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWallBuildingMode                             BuildingMode;                                      // 0x01E0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsConfirmingStage;                                // 0x01E1(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E2[0x6];                                      // 0x01E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AMarvelAbilityTargetActor_WallBuilding> TraceActorClass;                                   // 0x01E8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelWallBuildingAbilityConfig*       AbilityConfig;                                     // 0x01F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelAbilityTargetActor_WallBuilding* AbilityTraceActor;                                 // 0x01F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UMarvelAbilityTask_FindBuildingLoc* FindBuildingLoc(class UMarvelGameplayAbility* OwningAbility, TSubclassOf<class AMarvelAbilityTargetActor_WallBuilding> TraceActorClass_0);

	void SetBuildingMode(EWallBuildingMode InBuildingMode);
	void SetHasConfirmed(bool bInHasConfirmed);
	void SetIsConfirmingStage(bool bNewState);

	bool GetFindBuildingPlaces(TArray<struct FFindBuildingPlace>* OutPlaces) const;
	bool HasFindBuildingPlaces() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAbilityTask_FindBuildingLoc">();
	}
	static class UMarvelAbilityTask_FindBuildingLoc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAbilityTask_FindBuildingLoc>();
	}
};
static_assert(alignof(UMarvelAbilityTask_FindBuildingLoc) == 0x000008, "Wrong alignment on UMarvelAbilityTask_FindBuildingLoc");
static_assert(sizeof(UMarvelAbilityTask_FindBuildingLoc) == 0x000200, "Wrong size on UMarvelAbilityTask_FindBuildingLoc");
static_assert(offsetof(UMarvelAbilityTask_FindBuildingLoc, bHasConfirm) == 0x0001D8, "Member 'UMarvelAbilityTask_FindBuildingLoc::bHasConfirm' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_FindBuildingLoc, AbilityID) == 0x0001DC, "Member 'UMarvelAbilityTask_FindBuildingLoc::AbilityID' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_FindBuildingLoc, BuildingMode) == 0x0001E0, "Member 'UMarvelAbilityTask_FindBuildingLoc::BuildingMode' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_FindBuildingLoc, bIsConfirmingStage) == 0x0001E1, "Member 'UMarvelAbilityTask_FindBuildingLoc::bIsConfirmingStage' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_FindBuildingLoc, TraceActorClass) == 0x0001E8, "Member 'UMarvelAbilityTask_FindBuildingLoc::TraceActorClass' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_FindBuildingLoc, AbilityConfig) == 0x0001F0, "Member 'UMarvelAbilityTask_FindBuildingLoc::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_FindBuildingLoc, AbilityTraceActor) == 0x0001F8, "Member 'UMarvelAbilityTask_FindBuildingLoc::AbilityTraceActor' has a wrong offset!");

// Class Hero_1027.Config_102742
// 0x10A8 (0x1140 - 0x0098)
class UConfig_102742 final : public UMarvelAbilityConfig
{
public:
	float                                         ReclaimAllPressedTime;                             // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSelectTaskParam                       SelectParam;                                       // 0x00A0(0x10A0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102742">();
	}
	static class UConfig_102742* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102742>();
	}
};
static_assert(alignof(UConfig_102742) == 0x000010, "Wrong alignment on UConfig_102742");
static_assert(sizeof(UConfig_102742) == 0x001140, "Wrong size on UConfig_102742");
static_assert(offsetof(UConfig_102742, ReclaimAllPressedTime) == 0x000098, "Member 'UConfig_102742::ReclaimAllPressedTime' has a wrong offset!");
static_assert(offsetof(UConfig_102742, SelectParam) == 0x0000A0, "Member 'UConfig_102742::SelectParam' has a wrong offset!");

// Class Hero_1027.Ability_102742
// 0x0010 (0x2590 - 0x2580)
class UAbility_102742 : public UMarvelGameplayAbility
{
public:
	class UConfig_102742*                         MyConfig;                                          // 0x2580(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_SelectTarget*        SelectTask;                                        // 0x2588(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AActor* GetSelectTarget();
	bool VerifyPrimaryTarget(class AActor* InTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102742">();
	}
	static class UAbility_102742* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102742>();
	}
};
static_assert(alignof(UAbility_102742) == 0x000008, "Wrong alignment on UAbility_102742");
static_assert(sizeof(UAbility_102742) == 0x002590, "Wrong size on UAbility_102742");
static_assert(offsetof(UAbility_102742, MyConfig) == 0x002580, "Member 'UAbility_102742::MyConfig' has a wrong offset!");
static_assert(offsetof(UAbility_102742, SelectTask) == 0x002588, "Member 'UAbility_102742::SelectTask' has a wrong offset!");

// Class Hero_1027.TraceComponent_10274301
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10274301 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10274301">();
	}
	static class UTraceComponent_10274301* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10274301>();
	}
};
static_assert(alignof(UTraceComponent_10274301) == 0x000010, "Wrong alignment on UTraceComponent_10274301");
static_assert(sizeof(UTraceComponent_10274301) == 0x001710, "Wrong size on UTraceComponent_10274301");

// Class Hero_1027.EffectiveComponent_10274301
// 0x0050 (0x1C50 - 0x1C00)
class UEffectiveComponent_10274301 final : public UMarvelAgentEffectiveComponent
{
public:
	uint8                                         Pad_1BF8[0x58];                                    // 0x1BF8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10274301">();
	}
	static class UEffectiveComponent_10274301* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10274301>();
	}
};
static_assert(alignof(UEffectiveComponent_10274301) == 0x000010, "Wrong alignment on UEffectiveComponent_10274301");
static_assert(sizeof(UEffectiveComponent_10274301) == 0x001C50, "Wrong size on UEffectiveComponent_10274301");

// Class Hero_1027.Cue_Scope_Loop_10274301
// 0x0078 (0x0DE8 - 0x0D70)
class ACue_Scope_Loop_10274301 final : public AMarvelCueNotify_Scope
{
public:
	float                                         AuraGroundTestInterval;                            // 0x0D70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AuraGroundTestStepDist;                            // 0x0D74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AuraGroundTestMaxIterations;                       // 0x0D78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AuraPlantMinNumber;                                // 0x0D7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AuraPlantMaxNumber;                                // 0x0D80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AuraPlantDissolveParamName;                        // 0x0D84(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AuraPlantDissolveTime;                             // 0x0D90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFXSystemReleaseMethod                        AuraPlantFXReleaseMethod;                          // 0x0D94(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D95[0x3];                                      // 0x0D95(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAuraPlantAreaDensitySpec>      AuraPlantAreaDensitySpecs;                         // 0x0D98(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FAuraPlantActiveFXSpec>         AuraPlantActiveFXSpecs;                            // 0x0DA8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         AuraRangeRadius;                                   // 0x0DB8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AuraRangeHalfHeight;                               // 0x0DBC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAuraPlantCompleted;                               // 0x0DC0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC1[0x3];                                      // 0x0DC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AuraGroundTestDeltaTime;                           // 0x0DC4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDeclarationHolder                     AuraDeclarationHolder;                             // 0x0DC8(0x0010)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Decal;                                          // 0x0DD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE0[0x8];                                      // 0x0DE0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CreateAuraPlantFX(struct FAuraPlantActiveFXSpec* OutActiveFXSpec, const struct FVector& InOrigin, class UFXSystemAsset* FXAsset, const struct FVector& InLocation);
	void FXBeginFadeOut(class UFXSystemComponent* FXComponent);
	void OnBaseActorEndTask(class AActor* InActor);
	void OnClientPlayerViewSideChange(EClientPlayerViewSide InViewSide);
	void OnFXFadeOutEnd(class UFXSystemComponent* FXComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10274301">();
	}
	static class ACue_Scope_Loop_10274301* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10274301>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10274301) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10274301");
static_assert(sizeof(ACue_Scope_Loop_10274301) == 0x000DE8, "Wrong size on ACue_Scope_Loop_10274301");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraGroundTestInterval) == 0x000D70, "Member 'ACue_Scope_Loop_10274301::AuraGroundTestInterval' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraGroundTestStepDist) == 0x000D74, "Member 'ACue_Scope_Loop_10274301::AuraGroundTestStepDist' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraGroundTestMaxIterations) == 0x000D78, "Member 'ACue_Scope_Loop_10274301::AuraGroundTestMaxIterations' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraPlantMinNumber) == 0x000D7C, "Member 'ACue_Scope_Loop_10274301::AuraPlantMinNumber' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraPlantMaxNumber) == 0x000D80, "Member 'ACue_Scope_Loop_10274301::AuraPlantMaxNumber' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraPlantDissolveParamName) == 0x000D84, "Member 'ACue_Scope_Loop_10274301::AuraPlantDissolveParamName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraPlantDissolveTime) == 0x000D90, "Member 'ACue_Scope_Loop_10274301::AuraPlantDissolveTime' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraPlantFXReleaseMethod) == 0x000D94, "Member 'ACue_Scope_Loop_10274301::AuraPlantFXReleaseMethod' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraPlantAreaDensitySpecs) == 0x000D98, "Member 'ACue_Scope_Loop_10274301::AuraPlantAreaDensitySpecs' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraPlantActiveFXSpecs) == 0x000DA8, "Member 'ACue_Scope_Loop_10274301::AuraPlantActiveFXSpecs' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraRangeRadius) == 0x000DB8, "Member 'ACue_Scope_Loop_10274301::AuraRangeRadius' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraRangeHalfHeight) == 0x000DBC, "Member 'ACue_Scope_Loop_10274301::AuraRangeHalfHeight' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, bAuraPlantCompleted) == 0x000DC0, "Member 'ACue_Scope_Loop_10274301::bAuraPlantCompleted' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraGroundTestDeltaTime) == 0x000DC4, "Member 'ACue_Scope_Loop_10274301::AuraGroundTestDeltaTime' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, AuraDeclarationHolder) == 0x000DC8, "Member 'ACue_Scope_Loop_10274301::AuraDeclarationHolder' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10274301, NS_Decal) == 0x000DD8, "Member 'ACue_Scope_Loop_10274301::NS_Decal' has a wrong offset!");

// Class Hero_1027.Summoned_10275101
// 0x0020 (0x0ED0 - 0x0EB0)
class ASummoned_10275101 : public AMarvelWallBuildingActor
{
public:
	FMulticastInlineDelegateProperty_             OnWallDefenceApply;                                // 0x0EB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         WallDefendBuffID;                                  // 0x0EC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC4[0xC];                                      // 0x0EC4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10275101">();
	}
	static class ASummoned_10275101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10275101>();
	}
};
static_assert(alignof(ASummoned_10275101) == 0x000010, "Wrong alignment on ASummoned_10275101");
static_assert(sizeof(ASummoned_10275101) == 0x000ED0, "Wrong size on ASummoned_10275101");
static_assert(offsetof(ASummoned_10275101, OnWallDefenceApply) == 0x000EB0, "Member 'ASummoned_10275101::OnWallDefenceApply' has a wrong offset!");
static_assert(offsetof(ASummoned_10275101, WallDefendBuffID) == 0x000EC0, "Member 'ASummoned_10275101::WallDefendBuffID' has a wrong offset!");

// Class Hero_1027.SummonedComp_10275101
// 0x0010 (0x0DD0 - 0x0DC0)
class USummonedComp_10275101 final : public UMarvelSummonedComp_WallBuilding
{
public:
	struct FWallDefendNotify                      WallDefendNotify;                                  // 0x0DC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC8[0x8];                                      // 0x0DC8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_WallDefendNotify();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10275101">();
	}
	static class USummonedComp_10275101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10275101>();
	}
};
static_assert(alignof(USummonedComp_10275101) == 0x000010, "Wrong alignment on USummonedComp_10275101");
static_assert(sizeof(USummonedComp_10275101) == 0x000DD0, "Wrong size on USummonedComp_10275101");
static_assert(offsetof(USummonedComp_10275101, WallDefendNotify) == 0x000DC0, "Member 'USummonedComp_10275101::WallDefendNotify' has a wrong offset!");

// Class Hero_1027.Config_102751
// 0x0000 (0x0330 - 0x0330)
class UConfig_102751 final : public UConfig_102741
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102751">();
	}
	static class UConfig_102751* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102751>();
	}
};
static_assert(alignof(UConfig_102751) == 0x000008, "Wrong alignment on UConfig_102751");
static_assert(sizeof(UConfig_102751) == 0x000330, "Wrong size on UConfig_102751");

// Class Hero_1027.Cue_TraceActor_10275101
// 0x0000 (0x0D30 - 0x0D30)
class ACue_TraceActor_10275101 final : public ACue_TraceActor_10274101
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_TraceActor_10275101">();
	}
	static class ACue_TraceActor_10275101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_TraceActor_10275101>();
	}
};
static_assert(alignof(ACue_TraceActor_10275101) == 0x000008, "Wrong alignment on ACue_TraceActor_10275101");
static_assert(sizeof(ACue_TraceActor_10275101) == 0x000D30, "Wrong size on ACue_TraceActor_10275101");

// Class Hero_1027.Cue_Summoner_Loop_10275101
// 0x0080 (0x1320 - 0x12A0)
class ACue_Summoner_Loop_10275101 : public ACue_Summoner_Loop_10274101
{
public:
	class USkeletalMeshComponent*                 WallShellMesh01;                                   // 0x1298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 WallShellMesh02;                                   // 0x12A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WallShellMesh01_DefenceApplyAnimation;             // 0x12A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WallShellMesh02_DefenceApplyAnimation;             // 0x12B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         WallShellMeshCurves;                               // 0x12B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       WallShellMeshMIDS;                                 // 0x1308(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1318[0x8];                                     // 0x1318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWallDefenceApply(const struct FWallDefendNotify& NewWallDefendNotify);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10275101">();
	}
	static class ACue_Summoner_Loop_10275101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10275101>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10275101) == 0x000010, "Wrong alignment on ACue_Summoner_Loop_10275101");
static_assert(sizeof(ACue_Summoner_Loop_10275101) == 0x001320, "Wrong size on ACue_Summoner_Loop_10275101");
static_assert(offsetof(ACue_Summoner_Loop_10275101, WallShellMesh01) == 0x001298, "Member 'ACue_Summoner_Loop_10275101::WallShellMesh01' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10275101, WallShellMesh02) == 0x0012A0, "Member 'ACue_Summoner_Loop_10275101::WallShellMesh02' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10275101, WallShellMesh01_DefenceApplyAnimation) == 0x0012A8, "Member 'ACue_Summoner_Loop_10275101::WallShellMesh01_DefenceApplyAnimation' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10275101, WallShellMesh02_DefenceApplyAnimation) == 0x0012B0, "Member 'ACue_Summoner_Loop_10275101::WallShellMesh02_DefenceApplyAnimation' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10275101, WallShellMeshCurves) == 0x0012B8, "Member 'ACue_Summoner_Loop_10275101::WallShellMeshCurves' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10275101, WallShellMeshMIDS) == 0x001308, "Member 'ACue_Summoner_Loop_10275101::WallShellMeshMIDS' has a wrong offset!");

// Class Hero_1027.AnimNotify_IronWoodenWallPlayNiagaraEffectEx
// 0x0000 (0x0360 - 0x0360)
class UAnimNotify_IronWoodenWallPlayNiagaraEffectEx final : public UAnimNotify_PlayNiagaraEffectEx
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_IronWoodenWallPlayNiagaraEffectEx">();
	}
	static class UAnimNotify_IronWoodenWallPlayNiagaraEffectEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_IronWoodenWallPlayNiagaraEffectEx>();
	}
};
static_assert(alignof(UAnimNotify_IronWoodenWallPlayNiagaraEffectEx) == 0x000010, "Wrong alignment on UAnimNotify_IronWoodenWallPlayNiagaraEffectEx");
static_assert(sizeof(UAnimNotify_IronWoodenWallPlayNiagaraEffectEx) == 0x000360, "Wrong size on UAnimNotify_IronWoodenWallPlayNiagaraEffectEx");

// Class Hero_1027.AnimNotify_IronWoodenWallPlayCombineNiagaraEffect
// 0x0000 (0x0350 - 0x0350)
class UAnimNotify_IronWoodenWallPlayCombineNiagaraEffect final : public UAnimNotify_PlayNiagaraCombineEffectEx
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_IronWoodenWallPlayCombineNiagaraEffect">();
	}
	static class UAnimNotify_IronWoodenWallPlayCombineNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_IronWoodenWallPlayCombineNiagaraEffect>();
	}
};
static_assert(alignof(UAnimNotify_IronWoodenWallPlayCombineNiagaraEffect) == 0x000010, "Wrong alignment on UAnimNotify_IronWoodenWallPlayCombineNiagaraEffect");
static_assert(sizeof(UAnimNotify_IronWoodenWallPlayCombineNiagaraEffect) == 0x000350, "Wrong size on UAnimNotify_IronWoodenWallPlayCombineNiagaraEffect");

// Class Hero_1027.Scope_10276101
// 0x0010 (0x1710 - 0x1700)
class AScope_10276101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	class UShapeComponent*                        PawnCollisionComponent;                            // 0x1700(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1708[0x8];                                     // 0x1708(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10276101">();
	}
	static class AScope_10276101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10276101>();
	}
};
static_assert(alignof(AScope_10276101) == 0x000010, "Wrong alignment on AScope_10276101");
static_assert(sizeof(AScope_10276101) == 0x001710, "Wrong size on AScope_10276101");
static_assert(offsetof(AScope_10276101, PawnCollisionComponent) == 0x001700, "Member 'AScope_10276101::PawnCollisionComponent' has a wrong offset!");

// Class Hero_1027.BuffAbility_ForceMoveTo_10276103
// 0x0D58 (0x1E50 - 0x10F8)
class UBuffAbility_ForceMoveTo_10276103 : public UMarvelEffectGameplayAbility
{
public:
	int32                                         DashBuffID;                                        // 0x10F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashCoreRadius;                                    // 0x10FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashStartDelay;                                    // 0x1100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1104[0x4];                                     // 0x1104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDashAbilityInfo                       DashInfo;                                          // 0x1108(0x0BA8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DashStartTimerHandle;                              // 0x1CB0(0x0018)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x1CC8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetDirection;                                   // 0x1CE0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_Dash*                DashAbilityTask;                                   // 0x1CF8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTargetInKnockOutState;                          // 0x1D00(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D01[0x3];                                     // 0x1D01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SetBeingKnockOutTag;                               // 0x1D04(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         ApplyDashTaskKey;                                  // 0x1D10(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         OnDashTaskFinishedKey;                             // 0x1DB0(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnDashAbilityFinish(EDashStopReason Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffAbility_ForceMoveTo_10276103">();
	}
	static class UBuffAbility_ForceMoveTo_10276103* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffAbility_ForceMoveTo_10276103>();
	}
};
static_assert(alignof(UBuffAbility_ForceMoveTo_10276103) == 0x000008, "Wrong alignment on UBuffAbility_ForceMoveTo_10276103");
static_assert(sizeof(UBuffAbility_ForceMoveTo_10276103) == 0x001E50, "Wrong size on UBuffAbility_ForceMoveTo_10276103");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, DashBuffID) == 0x0010F8, "Member 'UBuffAbility_ForceMoveTo_10276103::DashBuffID' has a wrong offset!");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, DashCoreRadius) == 0x0010FC, "Member 'UBuffAbility_ForceMoveTo_10276103::DashCoreRadius' has a wrong offset!");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, DashStartDelay) == 0x001100, "Member 'UBuffAbility_ForceMoveTo_10276103::DashStartDelay' has a wrong offset!");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, DashInfo) == 0x001108, "Member 'UBuffAbility_ForceMoveTo_10276103::DashInfo' has a wrong offset!");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, DashStartTimerHandle) == 0x001CB0, "Member 'UBuffAbility_ForceMoveTo_10276103::DashStartTimerHandle' has a wrong offset!");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, TargetLocation) == 0x001CC8, "Member 'UBuffAbility_ForceMoveTo_10276103::TargetLocation' has a wrong offset!");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, TargetDirection) == 0x001CE0, "Member 'UBuffAbility_ForceMoveTo_10276103::TargetDirection' has a wrong offset!");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, DashAbilityTask) == 0x001CF8, "Member 'UBuffAbility_ForceMoveTo_10276103::DashAbilityTask' has a wrong offset!");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, bIsTargetInKnockOutState) == 0x001D00, "Member 'UBuffAbility_ForceMoveTo_10276103::bIsTargetInKnockOutState' has a wrong offset!");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, SetBeingKnockOutTag) == 0x001D04, "Member 'UBuffAbility_ForceMoveTo_10276103::SetBeingKnockOutTag' has a wrong offset!");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, ApplyDashTaskKey) == 0x001D10, "Member 'UBuffAbility_ForceMoveTo_10276103::ApplyDashTaskKey' has a wrong offset!");
static_assert(offsetof(UBuffAbility_ForceMoveTo_10276103, OnDashTaskFinishedKey) == 0x001DB0, "Member 'UBuffAbility_ForceMoveTo_10276103::OnDashTaskFinishedKey' has a wrong offset!");

// Class Hero_1027.Cue_Scope_Loop_10276101
// 0x0040 (0x0DB0 - 0x0D70)
class ACue_Scope_Loop_10276101 final : public AMarvelCueNotify_Scope
{
public:
	class UFXSystemAsset*                         ExplodeFXAsset;                                    // 0x0D70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplodeDelay;                                      // 0x0D78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7C[0x4];                                      // 0x0D7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ExplodeTimerHandle;                                // 0x0D80(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         GroundImpactFXAsset;                               // 0x0D98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundImpactMaxHeight;                             // 0x0DA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA4[0x4];                                      // 0x0DA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemComponent*                     GroundImpactFXComp;                                // 0x0DA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnExplode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10276101">();
	}
	static class ACue_Scope_Loop_10276101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10276101>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10276101) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10276101");
static_assert(sizeof(ACue_Scope_Loop_10276101) == 0x000DB0, "Wrong size on ACue_Scope_Loop_10276101");
static_assert(offsetof(ACue_Scope_Loop_10276101, ExplodeFXAsset) == 0x000D70, "Member 'ACue_Scope_Loop_10276101::ExplodeFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10276101, ExplodeDelay) == 0x000D78, "Member 'ACue_Scope_Loop_10276101::ExplodeDelay' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10276101, ExplodeTimerHandle) == 0x000D80, "Member 'ACue_Scope_Loop_10276101::ExplodeTimerHandle' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10276101, GroundImpactFXAsset) == 0x000D98, "Member 'ACue_Scope_Loop_10276101::GroundImpactFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10276101, GroundImpactMaxHeight) == 0x000DA0, "Member 'ACue_Scope_Loop_10276101::GroundImpactMaxHeight' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10276101, GroundImpactFXComp) == 0x000DA8, "Member 'ACue_Scope_Loop_10276101::GroundImpactFXComp' has a wrong offset!");

// Class Hero_1027.Cue_Buff_10276102
// 0x0058 (0x1090 - 0x1038)
class ACue_Buff_10276102 final : public AMarvelCueNotify_Buff
{
public:
	struct FScaleByBodySizeConfig                 PeriodicDamageFXConfig;                            // 0x1038(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           PlayPeriodicDamageFXHandle;                        // 0x1070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EffectCauser;                                      // 0x1088(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayPeriodicDamageFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10276102">();
	}
	static class ACue_Buff_10276102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10276102>();
	}
};
static_assert(alignof(ACue_Buff_10276102) == 0x000008, "Wrong alignment on ACue_Buff_10276102");
static_assert(sizeof(ACue_Buff_10276102) == 0x001090, "Wrong size on ACue_Buff_10276102");
static_assert(offsetof(ACue_Buff_10276102, PeriodicDamageFXConfig) == 0x001038, "Member 'ACue_Buff_10276102::PeriodicDamageFXConfig' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276102, PlayPeriodicDamageFXHandle) == 0x001070, "Member 'ACue_Buff_10276102::PlayPeriodicDamageFXHandle' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276102, EffectCauser) == 0x001088, "Member 'ACue_Buff_10276102::EffectCauser' has a wrong offset!");

// Class Hero_1027.Cue_Buff_10276103
// 0x01C8 (0x1200 - 0x1038)
class ACue_Buff_10276103 final : public AMarvelCueNotify_Buff
{
public:
	class UMaterialInterface*                     StranglingThorn02_Mat;                             // 0x1038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StranglingThorn02_Length;                          // 0x1040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StranglingThorn02_GrowTime;                        // 0x1044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StranglingThorn02_DissolveTime;                    // 0x1048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104C[0x4];                                     // 0x104C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               StranglingThorn02_Rotation;                        // 0x1050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         StranglingThorn02_CurvesWhenGrowing;               // 0x1068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         StranglingThorn02_CurvesWhenDissolving;            // 0x10B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRotator                               TwiningThornFX_Rotation;                           // 0x1108(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FScaleByBodySizeConfig                 TwiningThornFX_ScaleConfig;                        // 0x1120(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               StranglingThorn02_MID;                             // 0x1158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StranglingThorn02_ElapsedTime;                     // 0x1160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StranglingThorn02_TotalDuration;                   // 0x1164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             TargetCharacter;                                   // 0x1168(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckStranglingThorn02Length;                     // 0x1170(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1171[0x17];                                    // 0x1171(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 StranglingThorn02;                                 // 0x1188(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TwiningThornFXC;                                   // 0x1190(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SetHiddenTagContainer;                             // 0x1198(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnTargetCharacterTagUpdated(const struct FGameplayTag& Tag, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10276103">();
	}
	static class ACue_Buff_10276103* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10276103>();
	}
};
static_assert(alignof(ACue_Buff_10276103) == 0x000008, "Wrong alignment on ACue_Buff_10276103");
static_assert(sizeof(ACue_Buff_10276103) == 0x001200, "Wrong size on ACue_Buff_10276103");
static_assert(offsetof(ACue_Buff_10276103, StranglingThorn02_Mat) == 0x001038, "Member 'ACue_Buff_10276103::StranglingThorn02_Mat' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, StranglingThorn02_Length) == 0x001040, "Member 'ACue_Buff_10276103::StranglingThorn02_Length' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, StranglingThorn02_GrowTime) == 0x001044, "Member 'ACue_Buff_10276103::StranglingThorn02_GrowTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, StranglingThorn02_DissolveTime) == 0x001048, "Member 'ACue_Buff_10276103::StranglingThorn02_DissolveTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, StranglingThorn02_Rotation) == 0x001050, "Member 'ACue_Buff_10276103::StranglingThorn02_Rotation' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, StranglingThorn02_CurvesWhenGrowing) == 0x001068, "Member 'ACue_Buff_10276103::StranglingThorn02_CurvesWhenGrowing' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, StranglingThorn02_CurvesWhenDissolving) == 0x0010B8, "Member 'ACue_Buff_10276103::StranglingThorn02_CurvesWhenDissolving' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, TwiningThornFX_Rotation) == 0x001108, "Member 'ACue_Buff_10276103::TwiningThornFX_Rotation' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, TwiningThornFX_ScaleConfig) == 0x001120, "Member 'ACue_Buff_10276103::TwiningThornFX_ScaleConfig' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, StranglingThorn02_MID) == 0x001158, "Member 'ACue_Buff_10276103::StranglingThorn02_MID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, StranglingThorn02_ElapsedTime) == 0x001160, "Member 'ACue_Buff_10276103::StranglingThorn02_ElapsedTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, StranglingThorn02_TotalDuration) == 0x001164, "Member 'ACue_Buff_10276103::StranglingThorn02_TotalDuration' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, TargetCharacter) == 0x001168, "Member 'ACue_Buff_10276103::TargetCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, bCheckStranglingThorn02Length) == 0x001170, "Member 'ACue_Buff_10276103::bCheckStranglingThorn02Length' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, StranglingThorn02) == 0x001188, "Member 'ACue_Buff_10276103::StranglingThorn02' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, TwiningThornFXC) == 0x001190, "Member 'ACue_Buff_10276103::TwiningThornFXC' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10276103, SetHiddenTagContainer) == 0x001198, "Member 'ACue_Buff_10276103::SetHiddenTagContainer' has a wrong offset!");

// Class Hero_1027.EpicMomentAction_1027
// 0x0028 (0x0148 - 0x0120)
class UEpicMomentAction_1027 : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    QConfig;                                           // 0x0130(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         QBuffID;                                           // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QBuffCount;                                        // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1027">();
	}
	static class UEpicMomentAction_1027* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1027>();
	}
};
static_assert(alignof(UEpicMomentAction_1027) == 0x000008, "Wrong alignment on UEpicMomentAction_1027");
static_assert(sizeof(UEpicMomentAction_1027) == 0x000148, "Wrong size on UEpicMomentAction_1027");
static_assert(offsetof(UEpicMomentAction_1027, QConfig) == 0x000130, "Member 'UEpicMomentAction_1027::QConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1027, QBuffID) == 0x00013C, "Member 'UEpicMomentAction_1027::QBuffID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1027, QBuffCount) == 0x000140, "Member 'UEpicMomentAction_1027::QBuffCount' has a wrong offset!");

// Class Hero_1027.GrootAnimInstance
// 0x0220 (0x0B30 - 0x0910)
class UGrootAnimInstance final : public UMarvelAnimInstance
{
public:
	class FName                                   UpperBodyRotationCurveName;                        // 0x0910(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActiveAimIK;                                       // 0x091C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91D[0x3];                                      // 0x091D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LeftHandAimIKCurveName;                            // 0x0920(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightHandAimIKCurveName;                           // 0x092C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistFromActor;                                  // 0x0938(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93C[0x4];                                      // 0x093C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   LeftAimIKResetMontage;                             // 0x0940(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   RightAimIKResetMontage;                            // 0x0950(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         UpperBodyRotationCurveValue;                       // 0x0960(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_964[0x4];                                      // 0x0964(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               UpperBodyRotation;                                 // 0x0968(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HeadRotation;                                      // 0x0980(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LeftTargetAlpha;                                   // 0x0998(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldUseAimIK_L;                                  // 0x099C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99D[0x3];                                      // 0x099D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeftHandAimTarget;                                 // 0x09A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeftCanUpdateEffectorLocation;                     // 0x09B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B9[0x3];                                      // 0x09B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RightTargetAlpha;                                  // 0x09BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandAimTarget;                                // 0x09C0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldUseAimIK_R;                                  // 0x09D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RightCanUpdateEffectorLocation;                    // 0x09D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9DA[0x156];                                    // 0x09DA(0x0156)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrootAnimInstance">();
	}
	static class UGrootAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrootAnimInstance>();
	}
};
static_assert(alignof(UGrootAnimInstance) == 0x000010, "Wrong alignment on UGrootAnimInstance");
static_assert(sizeof(UGrootAnimInstance) == 0x000B30, "Wrong size on UGrootAnimInstance");
static_assert(offsetof(UGrootAnimInstance, UpperBodyRotationCurveName) == 0x000910, "Member 'UGrootAnimInstance::UpperBodyRotationCurveName' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, ActiveAimIK) == 0x00091C, "Member 'UGrootAnimInstance::ActiveAimIK' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, LeftHandAimIKCurveName) == 0x000920, "Member 'UGrootAnimInstance::LeftHandAimIKCurveName' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, RightHandAimIKCurveName) == 0x00092C, "Member 'UGrootAnimInstance::RightHandAimIKCurveName' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, MinDistFromActor) == 0x000938, "Member 'UGrootAnimInstance::MinDistFromActor' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, LeftAimIKResetMontage) == 0x000940, "Member 'UGrootAnimInstance::LeftAimIKResetMontage' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, RightAimIKResetMontage) == 0x000950, "Member 'UGrootAnimInstance::RightAimIKResetMontage' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, UpperBodyRotationCurveValue) == 0x000960, "Member 'UGrootAnimInstance::UpperBodyRotationCurveValue' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, UpperBodyRotation) == 0x000968, "Member 'UGrootAnimInstance::UpperBodyRotation' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, HeadRotation) == 0x000980, "Member 'UGrootAnimInstance::HeadRotation' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, LeftTargetAlpha) == 0x000998, "Member 'UGrootAnimInstance::LeftTargetAlpha' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, ShouldUseAimIK_L) == 0x00099C, "Member 'UGrootAnimInstance::ShouldUseAimIK_L' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, LeftHandAimTarget) == 0x0009A0, "Member 'UGrootAnimInstance::LeftHandAimTarget' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, LeftCanUpdateEffectorLocation) == 0x0009B8, "Member 'UGrootAnimInstance::LeftCanUpdateEffectorLocation' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, RightTargetAlpha) == 0x0009BC, "Member 'UGrootAnimInstance::RightTargetAlpha' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, RightHandAimTarget) == 0x0009C0, "Member 'UGrootAnimInstance::RightHandAimTarget' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, ShouldUseAimIK_R) == 0x0009D8, "Member 'UGrootAnimInstance::ShouldUseAimIK_R' has a wrong offset!");
static_assert(offsetof(UGrootAnimInstance, RightCanUpdateEffectorLocation) == 0x0009D9, "Member 'UGrootAnimInstance::RightCanUpdateEffectorLocation' has a wrong offset!");

// Class Hero_1027.GrootChildActor
// 0x0030 (0x0A90 - 0x0A60)
class AGrootChildActor final : public AMarvelCharacterChildActor
{
public:
	class USkeletalMeshComponent*                 GiantArm_L;                                        // 0x0A60(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 GiantArm_R;                                        // 0x0A68(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x0A70(0x0010)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              OnlyViewTargetFX;                                  // 0x0A80(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrootChildActor">();
	}
	static class AGrootChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrootChildActor>();
	}
};
static_assert(alignof(AGrootChildActor) == 0x000008, "Wrong alignment on AGrootChildActor");
static_assert(sizeof(AGrootChildActor) == 0x000A90, "Wrong size on AGrootChildActor");
static_assert(offsetof(AGrootChildActor, GiantArm_L) == 0x000A60, "Member 'AGrootChildActor::GiantArm_L' has a wrong offset!");
static_assert(offsetof(AGrootChildActor, GiantArm_R) == 0x000A68, "Member 'AGrootChildActor::GiantArm_R' has a wrong offset!");
static_assert(offsetof(AGrootChildActor, DeclarePlayerViewSideHolder) == 0x000A70, "Member 'AGrootChildActor::DeclarePlayerViewSideHolder' has a wrong offset!");
static_assert(offsetof(AGrootChildActor, OnlyViewTargetFX) == 0x000A80, "Member 'AGrootChildActor::OnlyViewTargetFX' has a wrong offset!");

// Class Hero_1027.GrootCharacter
// 0x0020 (0x1830 - 0x1810)
class AGrootCharacter : public AMarvelBaseCharacter
{
public:
	class UGrootMoveLogicBaseComponent*           GrootMoveLogic;                                    // 0x1810(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RightHand;                                         // 0x1818(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        LeftHand;                                          // 0x1820(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1828[0x8];                                     // 0x1828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrootCharacter">();
	}
	static class AGrootCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrootCharacter>();
	}
};
static_assert(alignof(AGrootCharacter) == 0x000010, "Wrong alignment on AGrootCharacter");
static_assert(sizeof(AGrootCharacter) == 0x001830, "Wrong size on AGrootCharacter");
static_assert(offsetof(AGrootCharacter, GrootMoveLogic) == 0x001810, "Member 'AGrootCharacter::GrootMoveLogic' has a wrong offset!");
static_assert(offsetof(AGrootCharacter, RightHand) == 0x001818, "Member 'AGrootCharacter::RightHand' has a wrong offset!");
static_assert(offsetof(AGrootCharacter, LeftHand) == 0x001820, "Member 'AGrootCharacter::LeftHand' has a wrong offset!");

// Class Hero_1027.GrootMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UGrootMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrootMoveLogicBaseComponent">();
	}
	static class UGrootMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrootMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UGrootMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UGrootMoveLogicBaseComponent");
static_assert(sizeof(UGrootMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UGrootMoveLogicBaseComponent");

// Class Hero_1027.GrootMovementComponent
// 0x0000 (0x1B60 - 0x1B60)
class UGrootMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrootMovementComponent">();
	}
	static class UGrootMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrootMovementComponent>();
	}
};
static_assert(alignof(UGrootMovementComponent) == 0x000010, "Wrong alignment on UGrootMovementComponent");
static_assert(sizeof(UGrootMovementComponent) == 0x001B60, "Wrong size on UGrootMovementComponent");

// Class Hero_1027.TabData_1027
// 0x0000 (0x0050 - 0x0050)
class UTabData_1027 final : public UHeroTabDataBase
{
public:
	void OnActorTakeDamage(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1027">();
	}
	static class UTabData_1027* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1027>();
	}
};
static_assert(alignof(UTabData_1027) == 0x000008, "Wrong alignment on UTabData_1027");
static_assert(sizeof(UTabData_1027) == 0x000050, "Wrong size on UTabData_1027");

// Class Hero_1027.WallBuildingStatics
// 0x0000 (0x0030 - 0x0030)
class UWallBuildingStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool CalcBuildingEdgeByLoc3(EWallBuildingEdge* OutBuildingEdge, const struct FVector& InLocation, const struct FVector& InWallExtend, const struct FTransform& InWallTransform, const struct FVector2D& ErrorTolerance);
	static bool CalcBuildingEdgeByLoc4(EWallBuildingEdge* OutBuildingEdge, const struct FVector& InLocation, EWallBuildingMode InBuildingMode, const struct FVector& InWallExtend, const struct FTransform& InWallTransform, const struct FVector2D& ErrorTolerance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WallBuildingStatics">();
	}
	static class UWallBuildingStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWallBuildingStatics>();
	}
};
static_assert(alignof(UWallBuildingStatics) == 0x000008, "Wrong alignment on UWallBuildingStatics");
static_assert(sizeof(UWallBuildingStatics) == 0x000030, "Wrong size on UWallBuildingStatics");

}

