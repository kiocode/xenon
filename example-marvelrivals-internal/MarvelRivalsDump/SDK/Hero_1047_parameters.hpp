#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1047

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Hero_1047_structs.hpp"
#include "Marvel_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK::Params
{

// Function Hero_1047.Projectile_10471101.GetProjectileFlyingTime
// 0x0004 (0x0004 - 0x0000)
struct Projectile_10471101_GetProjectileFlyingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_10471101_GetProjectileFlyingTime) == 0x000004, "Wrong alignment on Projectile_10471101_GetProjectileFlyingTime");
static_assert(sizeof(Projectile_10471101_GetProjectileFlyingTime) == 0x000004, "Wrong size on Projectile_10471101_GetProjectileFlyingTime");
static_assert(offsetof(Projectile_10471101_GetProjectileFlyingTime, ReturnValue) == 0x000000, "Member 'Projectile_10471101_GetProjectileFlyingTime::ReturnValue' has a wrong offset!");

// Function Hero_1047.Projectile_10471101.OnJeffProjectileStop
// 0x0170 (0x0170 - 0x0000)
struct Projectile_10471101_OnJeffProjectileStop final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0170)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_10471101_OnJeffProjectileStop) == 0x000008, "Wrong alignment on Projectile_10471101_OnJeffProjectileStop");
static_assert(sizeof(Projectile_10471101_OnJeffProjectileStop) == 0x000170, "Wrong size on Projectile_10471101_OnJeffProjectileStop");
static_assert(offsetof(Projectile_10471101_OnJeffProjectileStop, ImpactResult) == 0x000000, "Member 'Projectile_10471101_OnJeffProjectileStop::ImpactResult' has a wrong offset!");

// Function Hero_1047.Cue_Ability_Loop_10471102.ApplyDebugHapplyBubbles
// 0x0004 (0x0004 - 0x0000)
struct Cue_Ability_Loop_10471102_ApplyDebugHapplyBubbles final
{
public:
	int32                                         FrameIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10471102_ApplyDebugHapplyBubbles) == 0x000004, "Wrong alignment on Cue_Ability_Loop_10471102_ApplyDebugHapplyBubbles");
static_assert(sizeof(Cue_Ability_Loop_10471102_ApplyDebugHapplyBubbles) == 0x000004, "Wrong size on Cue_Ability_Loop_10471102_ApplyDebugHapplyBubbles");
static_assert(offsetof(Cue_Ability_Loop_10471102_ApplyDebugHapplyBubbles, FrameIndex) == 0x000000, "Member 'Cue_Ability_Loop_10471102_ApplyDebugHapplyBubbles::FrameIndex' has a wrong offset!");

// Function Hero_1047.Cue_Ability_Loop_10471102.ApplyDebugHapplyBubblesSpline
// 0x0010 (0x0010 - 0x0000)
struct Cue_Ability_Loop_10471102_ApplyDebugHapplyBubblesSpline final
{
public:
	int32                                         FrameIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       Spline;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10471102_ApplyDebugHapplyBubblesSpline) == 0x000008, "Wrong alignment on Cue_Ability_Loop_10471102_ApplyDebugHapplyBubblesSpline");
static_assert(sizeof(Cue_Ability_Loop_10471102_ApplyDebugHapplyBubblesSpline) == 0x000010, "Wrong size on Cue_Ability_Loop_10471102_ApplyDebugHapplyBubblesSpline");
static_assert(offsetof(Cue_Ability_Loop_10471102_ApplyDebugHapplyBubblesSpline, FrameIndex) == 0x000000, "Member 'Cue_Ability_Loop_10471102_ApplyDebugHapplyBubblesSpline::FrameIndex' has a wrong offset!");
static_assert(offsetof(Cue_Ability_Loop_10471102_ApplyDebugHapplyBubblesSpline, Spline) == 0x000008, "Member 'Cue_Ability_Loop_10471102_ApplyDebugHapplyBubblesSpline::Spline' has a wrong offset!");

// Function Hero_1047.Cue_Ability_Loop_10471102.GetDebugHapplyMinAndMaxFrame
// 0x0008 (0x0008 - 0x0000)
struct Cue_Ability_Loop_10471102_GetDebugHapplyMinAndMaxFrame final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10471102_GetDebugHapplyMinAndMaxFrame) == 0x000004, "Wrong alignment on Cue_Ability_Loop_10471102_GetDebugHapplyMinAndMaxFrame");
static_assert(sizeof(Cue_Ability_Loop_10471102_GetDebugHapplyMinAndMaxFrame) == 0x000008, "Wrong size on Cue_Ability_Loop_10471102_GetDebugHapplyMinAndMaxFrame");
static_assert(offsetof(Cue_Ability_Loop_10471102_GetDebugHapplyMinAndMaxFrame, Min) == 0x000000, "Member 'Cue_Ability_Loop_10471102_GetDebugHapplyMinAndMaxFrame::Min' has a wrong offset!");
static_assert(offsetof(Cue_Ability_Loop_10471102_GetDebugHapplyMinAndMaxFrame, Max) == 0x000004, "Member 'Cue_Ability_Loop_10471102_GetDebugHapplyMinAndMaxFrame::Max' has a wrong offset!");

// Function Hero_1047.Cue_Projectile_HitImpact_10471101.OnPostExecuteAudioCreateShotActor
// 0x0010 (0x0010 - 0x0000)
struct Cue_Projectile_HitImpact_10471101_OnPostExecuteAudioCreateShotActor final
{
public:
	class AOneShotAudioActor*                     OneShotActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MyTarget;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Projectile_HitImpact_10471101_OnPostExecuteAudioCreateShotActor) == 0x000008, "Wrong alignment on Cue_Projectile_HitImpact_10471101_OnPostExecuteAudioCreateShotActor");
static_assert(sizeof(Cue_Projectile_HitImpact_10471101_OnPostExecuteAudioCreateShotActor) == 0x000010, "Wrong size on Cue_Projectile_HitImpact_10471101_OnPostExecuteAudioCreateShotActor");
static_assert(offsetof(Cue_Projectile_HitImpact_10471101_OnPostExecuteAudioCreateShotActor, OneShotActor) == 0x000000, "Member 'Cue_Projectile_HitImpact_10471101_OnPostExecuteAudioCreateShotActor::OneShotActor' has a wrong offset!");
static_assert(offsetof(Cue_Projectile_HitImpact_10471101_OnPostExecuteAudioCreateShotActor, MyTarget) == 0x000008, "Member 'Cue_Projectile_HitImpact_10471101_OnPostExecuteAudioCreateShotActor::MyTarget' has a wrong offset!");

// Function Hero_1047.Projectile_10471301.K2_JeffPaintOnLocation
// 0x0038 (0x0038 - 0x0000)
struct Projectile_10471301_K2_JeffPaintOnLocation final
{
public:
	struct FJeffPaintParams                       Param;                                             // 0x0000(0x0038)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_10471301_K2_JeffPaintOnLocation) == 0x000008, "Wrong alignment on Projectile_10471301_K2_JeffPaintOnLocation");
static_assert(sizeof(Projectile_10471301_K2_JeffPaintOnLocation) == 0x000038, "Wrong size on Projectile_10471301_K2_JeffPaintOnLocation");
static_assert(offsetof(Projectile_10471301_K2_JeffPaintOnLocation, Param) == 0x000000, "Member 'Projectile_10471301_K2_JeffPaintOnLocation::Param' has a wrong offset!");

// Function Hero_1047.JeffWinterFestivalLibrary.JeffPaintOnLocation
// 0x0038 (0x0038 - 0x0000)
struct JeffWinterFestivalLibrary_JeffPaintOnLocation final
{
public:
	struct FJeffPaintParams                       Param;                                             // 0x0000(0x0038)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffWinterFestivalLibrary_JeffPaintOnLocation) == 0x000008, "Wrong alignment on JeffWinterFestivalLibrary_JeffPaintOnLocation");
static_assert(sizeof(JeffWinterFestivalLibrary_JeffPaintOnLocation) == 0x000038, "Wrong size on JeffWinterFestivalLibrary_JeffPaintOnLocation");
static_assert(offsetof(JeffWinterFestivalLibrary_JeffPaintOnLocation, Param) == 0x000000, "Member 'JeffWinterFestivalLibrary_JeffPaintOnLocation::Param' has a wrong offset!");

// Function Hero_1047.Cue_Ability_Loop_10473101.CheckMovementModeByState
// 0x0010 (0x0010 - 0x0000)
struct Cue_Ability_Loop_10473101_CheckMovementModeByState final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Cue_Ability_Loop_10473101_CheckMovementModeByState) == 0x000008, "Wrong alignment on Cue_Ability_Loop_10473101_CheckMovementModeByState");
static_assert(sizeof(Cue_Ability_Loop_10473101_CheckMovementModeByState) == 0x000010, "Wrong size on Cue_Ability_Loop_10473101_CheckMovementModeByState");
static_assert(offsetof(Cue_Ability_Loop_10473101_CheckMovementModeByState, Character) == 0x000000, "Member 'Cue_Ability_Loop_10473101_CheckMovementModeByState::Character' has a wrong offset!");
static_assert(offsetof(Cue_Ability_Loop_10473101_CheckMovementModeByState, PrevMovementMode) == 0x000008, "Member 'Cue_Ability_Loop_10473101_CheckMovementModeByState::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(Cue_Ability_Loop_10473101_CheckMovementModeByState, PreviousCustomMode) == 0x000009, "Member 'Cue_Ability_Loop_10473101_CheckMovementModeByState::PreviousCustomMode' has a wrong offset!");

// Function Hero_1047.Cue_Ability_Loop_10473101.OnSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct Cue_Ability_Loop_10473101_OnSystemFinished final
{
public:
	class UNiagaraComponent*                      PSystem;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10473101_OnSystemFinished) == 0x000008, "Wrong alignment on Cue_Ability_Loop_10473101_OnSystemFinished");
static_assert(sizeof(Cue_Ability_Loop_10473101_OnSystemFinished) == 0x000008, "Wrong size on Cue_Ability_Loop_10473101_OnSystemFinished");
static_assert(offsetof(Cue_Ability_Loop_10473101_OnSystemFinished, PSystem) == 0x000000, "Member 'Cue_Ability_Loop_10473101_OnSystemFinished::PSystem' has a wrong offset!");

// Function Hero_1047.Summoned_10475101.OnActorOverlap
// 0x0008 (0x0008 - 0x0000)
struct Summoned_10475101_OnActorOverlap final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Summoned_10475101_OnActorOverlap) == 0x000008, "Wrong alignment on Summoned_10475101_OnActorOverlap");
static_assert(sizeof(Summoned_10475101_OnActorOverlap) == 0x000008, "Wrong size on Summoned_10475101_OnActorOverlap");
static_assert(offsetof(Summoned_10475101_OnActorOverlap, InActor) == 0x000000, "Member 'Summoned_10475101_OnActorOverlap::InActor' has a wrong offset!");

// Function Hero_1047.Projectile_10475101.CheckBubblePlacingSpace
// 0x0190 (0x0190 - 0x0000)
struct Projectile_10475101_CheckBubblePlacingSpace final
{
public:
	struct FVector                                BubbleLocation;                                    // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             InHitResult;                                       // 0x0018(0x0170)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         BubbleRadius;                                      // 0x0188(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x018C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D[0x3];                                      // 0x018D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Projectile_10475101_CheckBubblePlacingSpace) == 0x000008, "Wrong alignment on Projectile_10475101_CheckBubblePlacingSpace");
static_assert(sizeof(Projectile_10475101_CheckBubblePlacingSpace) == 0x000190, "Wrong size on Projectile_10475101_CheckBubblePlacingSpace");
static_assert(offsetof(Projectile_10475101_CheckBubblePlacingSpace, BubbleLocation) == 0x000000, "Member 'Projectile_10475101_CheckBubblePlacingSpace::BubbleLocation' has a wrong offset!");
static_assert(offsetof(Projectile_10475101_CheckBubblePlacingSpace, InHitResult) == 0x000018, "Member 'Projectile_10475101_CheckBubblePlacingSpace::InHitResult' has a wrong offset!");
static_assert(offsetof(Projectile_10475101_CheckBubblePlacingSpace, BubbleRadius) == 0x000188, "Member 'Projectile_10475101_CheckBubblePlacingSpace::BubbleRadius' has a wrong offset!");
static_assert(offsetof(Projectile_10475101_CheckBubblePlacingSpace, ReturnValue) == 0x00018C, "Member 'Projectile_10475101_CheckBubblePlacingSpace::ReturnValue' has a wrong offset!");

// Function Hero_1047.Cue_Ability_Loop_10476101.OnJeffStateUpdate
// 0x0001 (0x0001 - 0x0000)
struct Cue_Ability_Loop_10476101_OnJeffStateUpdate final
{
public:
	EJeffState                                    InState;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10476101_OnJeffStateUpdate) == 0x000001, "Wrong alignment on Cue_Ability_Loop_10476101_OnJeffStateUpdate");
static_assert(sizeof(Cue_Ability_Loop_10476101_OnJeffStateUpdate) == 0x000001, "Wrong size on Cue_Ability_Loop_10476101_OnJeffStateUpdate");
static_assert(offsetof(Cue_Ability_Loop_10476101_OnJeffStateUpdate, InState) == 0x000000, "Member 'Cue_Ability_Loop_10476101_OnJeffStateUpdate::InState' has a wrong offset!");

// Function Hero_1047.Cue_Ability_Loop_10476101.OnOwnerTagUpdate
// 0x0010 (0x0010 - 0x0000)
struct Cue_Ability_Loop_10476101_OnOwnerTagUpdate final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TagExists;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Cue_Ability_Loop_10476101_OnOwnerTagUpdate) == 0x000004, "Wrong alignment on Cue_Ability_Loop_10476101_OnOwnerTagUpdate");
static_assert(sizeof(Cue_Ability_Loop_10476101_OnOwnerTagUpdate) == 0x000010, "Wrong size on Cue_Ability_Loop_10476101_OnOwnerTagUpdate");
static_assert(offsetof(Cue_Ability_Loop_10476101_OnOwnerTagUpdate, Tag) == 0x000000, "Member 'Cue_Ability_Loop_10476101_OnOwnerTagUpdate::Tag' has a wrong offset!");
static_assert(offsetof(Cue_Ability_Loop_10476101_OnOwnerTagUpdate, TagExists) == 0x00000C, "Member 'Cue_Ability_Loop_10476101_OnOwnerTagUpdate::TagExists' has a wrong offset!");

// Function Hero_1047.Cue_Ability_Loop_Jeff_Diving.OnJeffStateUpdate
// 0x0001 (0x0001 - 0x0000)
struct Cue_Ability_Loop_Jeff_Diving_OnJeffStateUpdate final
{
public:
	EJeffState                                    InState;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_Jeff_Diving_OnJeffStateUpdate) == 0x000001, "Wrong alignment on Cue_Ability_Loop_Jeff_Diving_OnJeffStateUpdate");
static_assert(sizeof(Cue_Ability_Loop_Jeff_Diving_OnJeffStateUpdate) == 0x000001, "Wrong size on Cue_Ability_Loop_Jeff_Diving_OnJeffStateUpdate");
static_assert(offsetof(Cue_Ability_Loop_Jeff_Diving_OnJeffStateUpdate, InState) == 0x000000, "Member 'Cue_Ability_Loop_Jeff_Diving_OnJeffStateUpdate::InState' has a wrong offset!");

// Function Hero_1047.Ability_104771.ExpandCapsuleSize
// 0x0001 (0x0001 - 0x0000)
struct Ability_104771_ExpandCapsuleSize final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_ExpandCapsuleSize) == 0x000001, "Wrong alignment on Ability_104771_ExpandCapsuleSize");
static_assert(sizeof(Ability_104771_ExpandCapsuleSize) == 0x000001, "Wrong size on Ability_104771_ExpandCapsuleSize");
static_assert(offsetof(Ability_104771_ExpandCapsuleSize, ReturnValue) == 0x000000, "Member 'Ability_104771_ExpandCapsuleSize::ReturnValue' has a wrong offset!");

// Function Hero_1047.Ability_104771.GetAliveDevouredCharacter
// 0x0010 (0x0010 - 0x0000)
struct Ability_104771_GetAliveDevouredCharacter final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_GetAliveDevouredCharacter) == 0x000008, "Wrong alignment on Ability_104771_GetAliveDevouredCharacter");
static_assert(sizeof(Ability_104771_GetAliveDevouredCharacter) == 0x000010, "Wrong size on Ability_104771_GetAliveDevouredCharacter");
static_assert(offsetof(Ability_104771_GetAliveDevouredCharacter, ReturnValue) == 0x000000, "Member 'Ability_104771_GetAliveDevouredCharacter::ReturnValue' has a wrong offset!");

// Function Hero_1047.Ability_104771.HandleOwnerBuff
// 0x0008 (0x0008 - 0x0000)
struct Ability_104771_HandleOwnerBuff final
{
public:
	int32                                         BuffID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedApply;                                        // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Ability_104771_HandleOwnerBuff) == 0x000004, "Wrong alignment on Ability_104771_HandleOwnerBuff");
static_assert(sizeof(Ability_104771_HandleOwnerBuff) == 0x000008, "Wrong size on Ability_104771_HandleOwnerBuff");
static_assert(offsetof(Ability_104771_HandleOwnerBuff, BuffID) == 0x000000, "Member 'Ability_104771_HandleOwnerBuff::BuffID' has a wrong offset!");
static_assert(offsetof(Ability_104771_HandleOwnerBuff, bNeedApply) == 0x000004, "Member 'Ability_104771_HandleOwnerBuff::bNeedApply' has a wrong offset!");

// Function Hero_1047.Ability_104771.OnDevouredCharacterDeath
// 0x0028 (0x0028 - 0x0000)
struct Ability_104771_OnDevouredCharacterDeath final
{
public:
	class AActor*                                 InSourceAvatar;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetAvatar;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeModifierHandle               ModifierParameterHandle;                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_OnDevouredCharacterDeath) == 0x000008, "Wrong alignment on Ability_104771_OnDevouredCharacterDeath");
static_assert(sizeof(Ability_104771_OnDevouredCharacterDeath) == 0x000028, "Wrong size on Ability_104771_OnDevouredCharacterDeath");
static_assert(offsetof(Ability_104771_OnDevouredCharacterDeath, InSourceAvatar) == 0x000000, "Member 'Ability_104771_OnDevouredCharacterDeath::InSourceAvatar' has a wrong offset!");
static_assert(offsetof(Ability_104771_OnDevouredCharacterDeath, InTargetAvatar) == 0x000008, "Member 'Ability_104771_OnDevouredCharacterDeath::InTargetAvatar' has a wrong offset!");
static_assert(offsetof(Ability_104771_OnDevouredCharacterDeath, ModifierParameterHandle) == 0x000010, "Member 'Ability_104771_OnDevouredCharacterDeath::ModifierParameterHandle' has a wrong offset!");

// Function Hero_1047.Ability_104771.OnDevouredCharacterDisguiseEnd
// 0x0018 (0x0018 - 0x0000)
struct Ability_104771_OnDevouredCharacterDisguiseEnd final
{
public:
	class AMarvelBaseCharacter*                   InDisguiseCharacter;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   InOriginCharacter;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAvatorAlive;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Ability_104771_OnDevouredCharacterDisguiseEnd) == 0x000008, "Wrong alignment on Ability_104771_OnDevouredCharacterDisguiseEnd");
static_assert(sizeof(Ability_104771_OnDevouredCharacterDisguiseEnd) == 0x000018, "Wrong size on Ability_104771_OnDevouredCharacterDisguiseEnd");
static_assert(offsetof(Ability_104771_OnDevouredCharacterDisguiseEnd, InDisguiseCharacter) == 0x000000, "Member 'Ability_104771_OnDevouredCharacterDisguiseEnd::InDisguiseCharacter' has a wrong offset!");
static_assert(offsetof(Ability_104771_OnDevouredCharacterDisguiseEnd, InOriginCharacter) == 0x000008, "Member 'Ability_104771_OnDevouredCharacterDisguiseEnd::InOriginCharacter' has a wrong offset!");
static_assert(offsetof(Ability_104771_OnDevouredCharacterDisguiseEnd, bIsAvatorAlive) == 0x000010, "Member 'Ability_104771_OnDevouredCharacterDisguiseEnd::bIsAvatorAlive' has a wrong offset!");

// Function Hero_1047.Ability_104771.OnDevourSummonedEndAgentTask
// 0x0008 (0x0008 - 0x0000)
struct Ability_104771_OnDevourSummonedEndAgentTask final
{
public:
	class AActor*                                 InSummoned;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_OnDevourSummonedEndAgentTask) == 0x000008, "Wrong alignment on Ability_104771_OnDevourSummonedEndAgentTask");
static_assert(sizeof(Ability_104771_OnDevourSummonedEndAgentTask) == 0x000008, "Wrong size on Ability_104771_OnDevourSummonedEndAgentTask");
static_assert(offsetof(Ability_104771_OnDevourSummonedEndAgentTask, InSummoned) == 0x000000, "Member 'Ability_104771_OnDevourSummonedEndAgentTask::InSummoned' has a wrong offset!");

// Function Hero_1047.Ability_104771.OnSelectRegionFinish
// 0x0001 (0x0001 - 0x0000)
struct Ability_104771_OnSelectRegionFinish final
{
public:
	bool                                          bActivateByTimerOrMT;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_OnSelectRegionFinish) == 0x000001, "Wrong alignment on Ability_104771_OnSelectRegionFinish");
static_assert(sizeof(Ability_104771_OnSelectRegionFinish) == 0x000001, "Wrong size on Ability_104771_OnSelectRegionFinish");
static_assert(offsetof(Ability_104771_OnSelectRegionFinish, bActivateByTimerOrMT) == 0x000000, "Member 'Ability_104771_OnSelectRegionFinish::bActivateByTimerOrMT' has a wrong offset!");

// Function Hero_1047.Ability_104771.ReStartDivingBuff
// 0x0004 (0x0004 - 0x0000)
struct Ability_104771_ReStartDivingBuff final
{
public:
	float                                         RemainDuration;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_ReStartDivingBuff) == 0x000004, "Wrong alignment on Ability_104771_ReStartDivingBuff");
static_assert(sizeof(Ability_104771_ReStartDivingBuff) == 0x000004, "Wrong size on Ability_104771_ReStartDivingBuff");
static_assert(offsetof(Ability_104771_ReStartDivingBuff, RemainDuration) == 0x000000, "Member 'Ability_104771_ReStartDivingBuff::RemainDuration' has a wrong offset!");

// Function Hero_1047.Ability_104771.RestoreCapsuleSize
// 0x0001 (0x0001 - 0x0000)
struct Ability_104771_RestoreCapsuleSize final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_RestoreCapsuleSize) == 0x000001, "Wrong alignment on Ability_104771_RestoreCapsuleSize");
static_assert(sizeof(Ability_104771_RestoreCapsuleSize) == 0x000001, "Wrong size on Ability_104771_RestoreCapsuleSize");
static_assert(offsetof(Ability_104771_RestoreCapsuleSize, ReturnValue) == 0x000000, "Member 'Ability_104771_RestoreCapsuleSize::ReturnValue' has a wrong offset!");

// Function Hero_1047.Ability_104771.SetCurrentAbilityState
// 0x0001 (0x0001 - 0x0000)
struct Ability_104771_SetCurrentAbilityState final
{
public:
	EAbilityState_104771                          CurrentAbilityState_0;                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_SetCurrentAbilityState) == 0x000001, "Wrong alignment on Ability_104771_SetCurrentAbilityState");
static_assert(sizeof(Ability_104771_SetCurrentAbilityState) == 0x000001, "Wrong size on Ability_104771_SetCurrentAbilityState");
static_assert(offsetof(Ability_104771_SetCurrentAbilityState, CurrentAbilityState_0) == 0x000000, "Member 'Ability_104771_SetCurrentAbilityState::CurrentAbilityState_0' has a wrong offset!");

// Function Hero_1047.Ability_104771.SetDevourCharactersFromScope
// 0x0010 (0x0010 - 0x0000)
struct Ability_104771_SetDevourCharactersFromScope final
{
public:
	TArray<TWeakObjectPtr<class AActor>>          InDevourCharactersList;                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_SetDevourCharactersFromScope) == 0x000008, "Wrong alignment on Ability_104771_SetDevourCharactersFromScope");
static_assert(sizeof(Ability_104771_SetDevourCharactersFromScope) == 0x000010, "Wrong size on Ability_104771_SetDevourCharactersFromScope");
static_assert(offsetof(Ability_104771_SetDevourCharactersFromScope, InDevourCharactersList) == 0x000000, "Member 'Ability_104771_SetDevourCharactersFromScope::InDevourCharactersList' has a wrong offset!");

// Function Hero_1047.Ability_104771.SpitOutImpl
// 0x0003 (0x0003 - 0x0000)
struct Ability_104771_SpitOutImpl final
{
public:
	bool                                          bSpitOutAll;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpitOutEnemy;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKnockUp;                                          // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_SpitOutImpl) == 0x000001, "Wrong alignment on Ability_104771_SpitOutImpl");
static_assert(sizeof(Ability_104771_SpitOutImpl) == 0x000003, "Wrong size on Ability_104771_SpitOutImpl");
static_assert(offsetof(Ability_104771_SpitOutImpl, bSpitOutAll) == 0x000000, "Member 'Ability_104771_SpitOutImpl::bSpitOutAll' has a wrong offset!");
static_assert(offsetof(Ability_104771_SpitOutImpl, bSpitOutEnemy) == 0x000001, "Member 'Ability_104771_SpitOutImpl::bSpitOutEnemy' has a wrong offset!");
static_assert(offsetof(Ability_104771_SpitOutImpl, bKnockUp) == 0x000002, "Member 'Ability_104771_SpitOutImpl::bKnockUp' has a wrong offset!");

// Function Hero_1047.Ability_104771.StopDivingBuff
// 0x0004 (0x0004 - 0x0000)
struct Ability_104771_StopDivingBuff final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_StopDivingBuff) == 0x000004, "Wrong alignment on Ability_104771_StopDivingBuff");
static_assert(sizeof(Ability_104771_StopDivingBuff) == 0x000004, "Wrong size on Ability_104771_StopDivingBuff");
static_assert(offsetof(Ability_104771_StopDivingBuff, ReturnValue) == 0x000000, "Member 'Ability_104771_StopDivingBuff::ReturnValue' has a wrong offset!");

// Function Hero_1047.Ability_104771.SwitchSelectionRegionTopView
// 0x0002 (0x0002 - 0x0000)
struct Ability_104771_SwitchSelectionRegionTopView final
{
public:
	bool                                          bToTopView;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bButtonSwitch;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_SwitchSelectionRegionTopView) == 0x000001, "Wrong alignment on Ability_104771_SwitchSelectionRegionTopView");
static_assert(sizeof(Ability_104771_SwitchSelectionRegionTopView) == 0x000002, "Wrong size on Ability_104771_SwitchSelectionRegionTopView");
static_assert(offsetof(Ability_104771_SwitchSelectionRegionTopView, bToTopView) == 0x000000, "Member 'Ability_104771_SwitchSelectionRegionTopView::bToTopView' has a wrong offset!");
static_assert(offsetof(Ability_104771_SwitchSelectionRegionTopView, bButtonSwitch) == 0x000001, "Member 'Ability_104771_SwitchSelectionRegionTopView::bButtonSwitch' has a wrong offset!");

// Function Hero_1047.Ability_104771.GetCurrentAbilityState
// 0x0001 (0x0001 - 0x0000)
struct Ability_104771_GetCurrentAbilityState final
{
public:
	EAbilityState_104771                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_GetCurrentAbilityState) == 0x000001, "Wrong alignment on Ability_104771_GetCurrentAbilityState");
static_assert(sizeof(Ability_104771_GetCurrentAbilityState) == 0x000001, "Wrong size on Ability_104771_GetCurrentAbilityState");
static_assert(offsetof(Ability_104771_GetCurrentAbilityState, ReturnValue) == 0x000000, "Member 'Ability_104771_GetCurrentAbilityState::ReturnValue' has a wrong offset!");

// Function Hero_1047.Ability_104771.GetDevouredAlly
// 0x0010 (0x0010 - 0x0000)
struct Ability_104771_GetDevouredAlly final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_GetDevouredAlly) == 0x000008, "Wrong alignment on Ability_104771_GetDevouredAlly");
static_assert(sizeof(Ability_104771_GetDevouredAlly) == 0x000010, "Wrong size on Ability_104771_GetDevouredAlly");
static_assert(offsetof(Ability_104771_GetDevouredAlly, ReturnValue) == 0x000000, "Member 'Ability_104771_GetDevouredAlly::ReturnValue' has a wrong offset!");

// Function Hero_1047.Ability_104771.GetDevouredEnemy
// 0x0010 (0x0010 - 0x0000)
struct Ability_104771_GetDevouredEnemy final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_GetDevouredEnemy) == 0x000008, "Wrong alignment on Ability_104771_GetDevouredEnemy");
static_assert(sizeof(Ability_104771_GetDevouredEnemy) == 0x000010, "Wrong size on Ability_104771_GetDevouredEnemy");
static_assert(offsetof(Ability_104771_GetDevouredEnemy, ReturnValue) == 0x000000, "Member 'Ability_104771_GetDevouredEnemy::ReturnValue' has a wrong offset!");

// Function Hero_1047.Ability_104771.HaveDevouredAlly
// 0x0001 (0x0001 - 0x0000)
struct Ability_104771_HaveDevouredAlly final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_HaveDevouredAlly) == 0x000001, "Wrong alignment on Ability_104771_HaveDevouredAlly");
static_assert(sizeof(Ability_104771_HaveDevouredAlly) == 0x000001, "Wrong size on Ability_104771_HaveDevouredAlly");
static_assert(offsetof(Ability_104771_HaveDevouredAlly, ReturnValue) == 0x000000, "Member 'Ability_104771_HaveDevouredAlly::ReturnValue' has a wrong offset!");

// Function Hero_1047.Ability_104771.HaveDevouredEnemy
// 0x0001 (0x0001 - 0x0000)
struct Ability_104771_HaveDevouredEnemy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104771_HaveDevouredEnemy) == 0x000001, "Wrong alignment on Ability_104771_HaveDevouredEnemy");
static_assert(sizeof(Ability_104771_HaveDevouredEnemy) == 0x000001, "Wrong size on Ability_104771_HaveDevouredEnemy");
static_assert(offsetof(Ability_104771_HaveDevouredEnemy, ReturnValue) == 0x000000, "Member 'Ability_104771_HaveDevouredEnemy::ReturnValue' has a wrong offset!");

// Function Hero_1047.JeffPassengerContainerComponent.Client_AttachPassengerAndUpdateComponentTickPrerequisite
// 0x0008 (0x0008 - 0x0000)
struct JeffPassengerContainerComponent_Client_AttachPassengerAndUpdateComponentTickPrerequisite final
{
public:
	class AActor*                                 InAttachPassenger;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffPassengerContainerComponent_Client_AttachPassengerAndUpdateComponentTickPrerequisite) == 0x000008, "Wrong alignment on JeffPassengerContainerComponent_Client_AttachPassengerAndUpdateComponentTickPrerequisite");
static_assert(sizeof(JeffPassengerContainerComponent_Client_AttachPassengerAndUpdateComponentTickPrerequisite) == 0x000008, "Wrong size on JeffPassengerContainerComponent_Client_AttachPassengerAndUpdateComponentTickPrerequisite");
static_assert(offsetof(JeffPassengerContainerComponent_Client_AttachPassengerAndUpdateComponentTickPrerequisite, InAttachPassenger) == 0x000000, "Member 'JeffPassengerContainerComponent_Client_AttachPassengerAndUpdateComponentTickPrerequisite::InAttachPassenger' has a wrong offset!");

// Function Hero_1047.JeffPassengerContainerComponent.Client_DetachPassengerAndUpdateComponentTickPrerequisite
// 0x0008 (0x0008 - 0x0000)
struct JeffPassengerContainerComponent_Client_DetachPassengerAndUpdateComponentTickPrerequisite final
{
public:
	class AActor*                                 InDetachPassenger;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffPassengerContainerComponent_Client_DetachPassengerAndUpdateComponentTickPrerequisite) == 0x000008, "Wrong alignment on JeffPassengerContainerComponent_Client_DetachPassengerAndUpdateComponentTickPrerequisite");
static_assert(sizeof(JeffPassengerContainerComponent_Client_DetachPassengerAndUpdateComponentTickPrerequisite) == 0x000008, "Wrong size on JeffPassengerContainerComponent_Client_DetachPassengerAndUpdateComponentTickPrerequisite");
static_assert(offsetof(JeffPassengerContainerComponent_Client_DetachPassengerAndUpdateComponentTickPrerequisite, InDetachPassenger) == 0x000000, "Member 'JeffPassengerContainerComponent_Client_DetachPassengerAndUpdateComponentTickPrerequisite::InDetachPassenger' has a wrong offset!");

// Function Hero_1047.EffectiveComponent_10477101.K2_OnPreApplyContainer
// 0x0020 (0x0020 - 0x0000)
struct EffectiveComponent_10477101_K2_OnPreApplyContainer final
{
public:
	TArray<struct FHitResult>                     HitResults;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(EffectiveComponent_10477101_K2_OnPreApplyContainer) == 0x000008, "Wrong alignment on EffectiveComponent_10477101_K2_OnPreApplyContainer");
static_assert(sizeof(EffectiveComponent_10477101_K2_OnPreApplyContainer) == 0x000020, "Wrong size on EffectiveComponent_10477101_K2_OnPreApplyContainer");
static_assert(offsetof(EffectiveComponent_10477101_K2_OnPreApplyContainer, HitResults) == 0x000000, "Member 'EffectiveComponent_10477101_K2_OnPreApplyContainer::HitResults' has a wrong offset!");
static_assert(offsetof(EffectiveComponent_10477101_K2_OnPreApplyContainer, ReturnValue) == 0x000010, "Member 'EffectiveComponent_10477101_K2_OnPreApplyContainer::ReturnValue' has a wrong offset!");

// Function Hero_1047.MarvelAbilityTask_SelectRegionAttack.SelectRegionAttack
// 0x0020 (0x0020 - 0x0000)
struct MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack final
{
public:
	class UMarvelGameplayAbility*                 OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConfirmMethodName;                                 // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectionWarningDuration;                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_SelectRegionAttack*  ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack) == 0x000008, "Wrong alignment on MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack");
static_assert(sizeof(MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack) == 0x000020, "Wrong size on MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack");
static_assert(offsetof(MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack, OwningAbility) == 0x000000, "Member 'MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack::OwningAbility' has a wrong offset!");
static_assert(offsetof(MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack, ConfirmMethodName) == 0x000008, "Member 'MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack::ConfirmMethodName' has a wrong offset!");
static_assert(offsetof(MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack, SelectionWarningDuration) == 0x000014, "Member 'MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack::SelectionWarningDuration' has a wrong offset!");
static_assert(offsetof(MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack, ReturnValue) == 0x000018, "Member 'MarvelAbilityTask_SelectRegionAttack_SelectRegionAttack::ReturnValue' has a wrong offset!");

// Function Hero_1047.MarvelAbilityTask_SelectRegionAttack.OnLocateFinish
// 0x0001 (0x0001 - 0x0000)
struct MarvelAbilityTask_SelectRegionAttack_OnLocateFinish final
{
public:
	bool                                          bActiveByTimerOrMT;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelAbilityTask_SelectRegionAttack_OnLocateFinish) == 0x000001, "Wrong alignment on MarvelAbilityTask_SelectRegionAttack_OnLocateFinish");
static_assert(sizeof(MarvelAbilityTask_SelectRegionAttack_OnLocateFinish) == 0x000001, "Wrong size on MarvelAbilityTask_SelectRegionAttack_OnLocateFinish");
static_assert(offsetof(MarvelAbilityTask_SelectRegionAttack_OnLocateFinish, bActiveByTimerOrMT) == 0x000000, "Member 'MarvelAbilityTask_SelectRegionAttack_OnLocateFinish::bActiveByTimerOrMT' has a wrong offset!");

// Function Hero_1047.MarvelAbilityTask_SelectRegionAttack.OnPressActivateHurricaneKey
// 0x0004 (0x0004 - 0x0000)
struct MarvelAbilityTask_SelectRegionAttack_OnPressActivateHurricaneKey final
{
public:
	float                                         TimeWaited;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelAbilityTask_SelectRegionAttack_OnPressActivateHurricaneKey) == 0x000004, "Wrong alignment on MarvelAbilityTask_SelectRegionAttack_OnPressActivateHurricaneKey");
static_assert(sizeof(MarvelAbilityTask_SelectRegionAttack_OnPressActivateHurricaneKey) == 0x000004, "Wrong size on MarvelAbilityTask_SelectRegionAttack_OnPressActivateHurricaneKey");
static_assert(offsetof(MarvelAbilityTask_SelectRegionAttack_OnPressActivateHurricaneKey, TimeWaited) == 0x000000, "Member 'MarvelAbilityTask_SelectRegionAttack_OnPressActivateHurricaneKey::TimeWaited' has a wrong offset!");

// Function Hero_1047.MarvelAbilityTask_SelectRegionAttack.OnPressCameraAnimationKey
// 0x0004 (0x0004 - 0x0000)
struct MarvelAbilityTask_SelectRegionAttack_OnPressCameraAnimationKey final
{
public:
	float                                         TimeWaited;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelAbilityTask_SelectRegionAttack_OnPressCameraAnimationKey) == 0x000004, "Wrong alignment on MarvelAbilityTask_SelectRegionAttack_OnPressCameraAnimationKey");
static_assert(sizeof(MarvelAbilityTask_SelectRegionAttack_OnPressCameraAnimationKey) == 0x000004, "Wrong size on MarvelAbilityTask_SelectRegionAttack_OnPressCameraAnimationKey");
static_assert(offsetof(MarvelAbilityTask_SelectRegionAttack_OnPressCameraAnimationKey, TimeWaited) == 0x000000, "Member 'MarvelAbilityTask_SelectRegionAttack_OnPressCameraAnimationKey::TimeWaited' has a wrong offset!");

// Function Hero_1047.MarvelAbilityTask_SelectRegionAttack.OnReleaseCameraAnimationKey
// 0x0004 (0x0004 - 0x0000)
struct MarvelAbilityTask_SelectRegionAttack_OnReleaseCameraAnimationKey final
{
public:
	float                                         TimeWaited;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelAbilityTask_SelectRegionAttack_OnReleaseCameraAnimationKey) == 0x000004, "Wrong alignment on MarvelAbilityTask_SelectRegionAttack_OnReleaseCameraAnimationKey");
static_assert(sizeof(MarvelAbilityTask_SelectRegionAttack_OnReleaseCameraAnimationKey) == 0x000004, "Wrong size on MarvelAbilityTask_SelectRegionAttack_OnReleaseCameraAnimationKey");
static_assert(offsetof(MarvelAbilityTask_SelectRegionAttack_OnReleaseCameraAnimationKey, TimeWaited) == 0x000000, "Member 'MarvelAbilityTask_SelectRegionAttack_OnReleaseCameraAnimationKey::TimeWaited' has a wrong offset!");

// Function Hero_1047.Cue_Ability_Loop_10477101.OnSelectRegionFinish
// 0x0001 (0x0001 - 0x0000)
struct Cue_Ability_Loop_10477101_OnSelectRegionFinish final
{
public:
	bool                                          bActivateByTimerOrMT;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10477101_OnSelectRegionFinish) == 0x000001, "Wrong alignment on Cue_Ability_Loop_10477101_OnSelectRegionFinish");
static_assert(sizeof(Cue_Ability_Loop_10477101_OnSelectRegionFinish) == 0x000001, "Wrong size on Cue_Ability_Loop_10477101_OnSelectRegionFinish");
static_assert(offsetof(Cue_Ability_Loop_10477101_OnSelectRegionFinish, bActivateByTimerOrMT) == 0x000000, "Member 'Cue_Ability_Loop_10477101_OnSelectRegionFinish::bActivateByTimerOrMT' has a wrong offset!");

// Function Hero_1047.Ability_104781.BindDettachDelegates
// 0x0008 (0x0008 - 0x0000)
struct Ability_104781_BindDettachDelegates final
{
public:
	class AActor*                                 InGroot;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104781_BindDettachDelegates) == 0x000008, "Wrong alignment on Ability_104781_BindDettachDelegates");
static_assert(sizeof(Ability_104781_BindDettachDelegates) == 0x000008, "Wrong size on Ability_104781_BindDettachDelegates");
static_assert(offsetof(Ability_104781_BindDettachDelegates, InGroot) == 0x000000, "Member 'Ability_104781_BindDettachDelegates::InGroot' has a wrong offset!");

// Function Hero_1047.Ability_104781.MarkOnGroot
// 0x0001 (0x0001 - 0x0000)
struct Ability_104781_MarkOnGroot final
{
public:
	bool                                          bOnGroot;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104781_MarkOnGroot) == 0x000001, "Wrong alignment on Ability_104781_MarkOnGroot");
static_assert(sizeof(Ability_104781_MarkOnGroot) == 0x000001, "Wrong size on Ability_104781_MarkOnGroot");
static_assert(offsetof(Ability_104781_MarkOnGroot, bOnGroot) == 0x000000, "Member 'Ability_104781_MarkOnGroot::bOnGroot' has a wrong offset!");

// Function Hero_1047.Ability_104781.OnCoopAbilityTickStateChanged
// 0x0001 (0x0001 - 0x0000)
struct Ability_104781_OnCoopAbilityTickStateChanged final
{
public:
	bool                                          bShouldAbilityTick;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104781_OnCoopAbilityTickStateChanged) == 0x000001, "Wrong alignment on Ability_104781_OnCoopAbilityTickStateChanged");
static_assert(sizeof(Ability_104781_OnCoopAbilityTickStateChanged) == 0x000001, "Wrong size on Ability_104781_OnCoopAbilityTickStateChanged");
static_assert(offsetof(Ability_104781_OnCoopAbilityTickStateChanged, bShouldAbilityTick) == 0x000000, "Member 'Ability_104781_OnCoopAbilityTickStateChanged::bShouldAbilityTick' has a wrong offset!");

// Function Hero_1047.Ability_104781.OnGrootDeath
// 0x0028 (0x0028 - 0x0000)
struct Ability_104781_OnGrootDeath final
{
public:
	class AActor*                                 InSourceAvatar;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetAvatar;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeModifierHandle               ModifierParameterHandle;                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104781_OnGrootDeath) == 0x000008, "Wrong alignment on Ability_104781_OnGrootDeath");
static_assert(sizeof(Ability_104781_OnGrootDeath) == 0x000028, "Wrong size on Ability_104781_OnGrootDeath");
static_assert(offsetof(Ability_104781_OnGrootDeath, InSourceAvatar) == 0x000000, "Member 'Ability_104781_OnGrootDeath::InSourceAvatar' has a wrong offset!");
static_assert(offsetof(Ability_104781_OnGrootDeath, InTargetAvatar) == 0x000008, "Member 'Ability_104781_OnGrootDeath::InTargetAvatar' has a wrong offset!");
static_assert(offsetof(Ability_104781_OnGrootDeath, ModifierParameterHandle) == 0x000010, "Member 'Ability_104781_OnGrootDeath::ModifierParameterHandle' has a wrong offset!");

// Function Hero_1047.Ability_104781.OnGrootTagUpdated
// 0x0010 (0x0010 - 0x0000)
struct Ability_104781_OnGrootTagUpdated final
{
public:
	struct FGameplayTag                           TagUpdated;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTagExists;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Ability_104781_OnGrootTagUpdated) == 0x000004, "Wrong alignment on Ability_104781_OnGrootTagUpdated");
static_assert(sizeof(Ability_104781_OnGrootTagUpdated) == 0x000010, "Wrong size on Ability_104781_OnGrootTagUpdated");
static_assert(offsetof(Ability_104781_OnGrootTagUpdated, TagUpdated) == 0x000000, "Member 'Ability_104781_OnGrootTagUpdated::TagUpdated' has a wrong offset!");
static_assert(offsetof(Ability_104781_OnGrootTagUpdated, bTagExists) == 0x00000C, "Member 'Ability_104781_OnGrootTagUpdated::bTagExists' has a wrong offset!");

// Function Hero_1047.Ability_104781.OnJeffDeath
// 0x0028 (0x0028 - 0x0000)
struct Ability_104781_OnJeffDeath final
{
public:
	class AActor*                                 InSourceAvatar;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetAvatar;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeModifierHandle               ModifierParameterHandle;                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104781_OnJeffDeath) == 0x000008, "Wrong alignment on Ability_104781_OnJeffDeath");
static_assert(sizeof(Ability_104781_OnJeffDeath) == 0x000028, "Wrong size on Ability_104781_OnJeffDeath");
static_assert(offsetof(Ability_104781_OnJeffDeath, InSourceAvatar) == 0x000000, "Member 'Ability_104781_OnJeffDeath::InSourceAvatar' has a wrong offset!");
static_assert(offsetof(Ability_104781_OnJeffDeath, InTargetAvatar) == 0x000008, "Member 'Ability_104781_OnJeffDeath::InTargetAvatar' has a wrong offset!");
static_assert(offsetof(Ability_104781_OnJeffDeath, ModifierParameterHandle) == 0x000010, "Member 'Ability_104781_OnJeffDeath::ModifierParameterHandle' has a wrong offset!");

// Function Hero_1047.Ability_104781.OnJeffTagUpdated
// 0x0010 (0x0010 - 0x0000)
struct Ability_104781_OnJeffTagUpdated final
{
public:
	struct FGameplayTag                           TagUpdated;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTagExists;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Ability_104781_OnJeffTagUpdated) == 0x000004, "Wrong alignment on Ability_104781_OnJeffTagUpdated");
static_assert(sizeof(Ability_104781_OnJeffTagUpdated) == 0x000010, "Wrong size on Ability_104781_OnJeffTagUpdated");
static_assert(offsetof(Ability_104781_OnJeffTagUpdated, TagUpdated) == 0x000000, "Member 'Ability_104781_OnJeffTagUpdated::TagUpdated' has a wrong offset!");
static_assert(offsetof(Ability_104781_OnJeffTagUpdated, bTagExists) == 0x00000C, "Member 'Ability_104781_OnJeffTagUpdated::bTagExists' has a wrong offset!");

// Function Hero_1047.Ability_104781.OnJeffTakeDamage
// 0x0028 (0x0028 - 0x0000)
struct Ability_104781_OnJeffTakeDamage final
{
public:
	class AActor*                                 InSourceAvatar;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetAvatar;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeModifierHandle               ModifierParameterHandle;                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104781_OnJeffTakeDamage) == 0x000008, "Wrong alignment on Ability_104781_OnJeffTakeDamage");
static_assert(sizeof(Ability_104781_OnJeffTakeDamage) == 0x000028, "Wrong size on Ability_104781_OnJeffTakeDamage");
static_assert(offsetof(Ability_104781_OnJeffTakeDamage, InSourceAvatar) == 0x000000, "Member 'Ability_104781_OnJeffTakeDamage::InSourceAvatar' has a wrong offset!");
static_assert(offsetof(Ability_104781_OnJeffTakeDamage, InTargetAvatar) == 0x000008, "Member 'Ability_104781_OnJeffTakeDamage::InTargetAvatar' has a wrong offset!");
static_assert(offsetof(Ability_104781_OnJeffTakeDamage, ModifierParameterHandle) == 0x000010, "Member 'Ability_104781_OnJeffTakeDamage::ModifierParameterHandle' has a wrong offset!");

// Function Hero_1047.Ability_104781.OnRideCancel
// 0x0004 (0x0004 - 0x0000)
struct Ability_104781_OnRideCancel final
{
public:
	float                                         StateIntervalTime;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104781_OnRideCancel) == 0x000004, "Wrong alignment on Ability_104781_OnRideCancel");
static_assert(sizeof(Ability_104781_OnRideCancel) == 0x000004, "Wrong size on Ability_104781_OnRideCancel");
static_assert(offsetof(Ability_104781_OnRideCancel, StateIntervalTime) == 0x000000, "Member 'Ability_104781_OnRideCancel::StateIntervalTime' has a wrong offset!");

// Function Hero_1047.Ability_104781.ScaleRidingHitShapeSize
// 0x0001 (0x0001 - 0x0000)
struct Ability_104781_ScaleRidingHitShapeSize final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104781_ScaleRidingHitShapeSize) == 0x000001, "Wrong alignment on Ability_104781_ScaleRidingHitShapeSize");
static_assert(sizeof(Ability_104781_ScaleRidingHitShapeSize) == 0x000001, "Wrong size on Ability_104781_ScaleRidingHitShapeSize");
static_assert(offsetof(Ability_104781_ScaleRidingHitShapeSize, bEnable) == 0x000000, "Member 'Ability_104781_ScaleRidingHitShapeSize::bEnable' has a wrong offset!");

// Function Hero_1047.Ability_104781.ServerOnRideCancel
// 0x0004 (0x0004 - 0x0000)
struct Ability_104781_ServerOnRideCancel final
{
public:
	float                                         StateIntervalTime;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104781_ServerOnRideCancel) == 0x000004, "Wrong alignment on Ability_104781_ServerOnRideCancel");
static_assert(sizeof(Ability_104781_ServerOnRideCancel) == 0x000004, "Wrong size on Ability_104781_ServerOnRideCancel");
static_assert(offsetof(Ability_104781_ServerOnRideCancel, StateIntervalTime) == 0x000000, "Member 'Ability_104781_ServerOnRideCancel::StateIntervalTime' has a wrong offset!");

// Function Hero_1047.Ability_104781.SetJeffState
// 0x0001 (0x0001 - 0x0000)
struct Ability_104781_SetJeffState final
{
public:
	EJeffGrootAbilityState                        InState;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104781_SetJeffState) == 0x000001, "Wrong alignment on Ability_104781_SetJeffState");
static_assert(sizeof(Ability_104781_SetJeffState) == 0x000001, "Wrong size on Ability_104781_SetJeffState");
static_assert(offsetof(Ability_104781_SetJeffState, InState) == 0x000000, "Member 'Ability_104781_SetJeffState::InState' has a wrong offset!");

// Function Hero_1047.Ability_104781.SetSpringArmIgnore
// 0x0018 (0x0018 - 0x0000)
struct Ability_104781_SetSpringArmIgnore final
{
public:
	class AMarvelBaseCharacter*                   InGroot;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnChar;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnore;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Ability_104781_SetSpringArmIgnore) == 0x000008, "Wrong alignment on Ability_104781_SetSpringArmIgnore");
static_assert(sizeof(Ability_104781_SetSpringArmIgnore) == 0x000018, "Wrong size on Ability_104781_SetSpringArmIgnore");
static_assert(offsetof(Ability_104781_SetSpringArmIgnore, InGroot) == 0x000000, "Member 'Ability_104781_SetSpringArmIgnore::InGroot' has a wrong offset!");
static_assert(offsetof(Ability_104781_SetSpringArmIgnore, OwnChar) == 0x000008, "Member 'Ability_104781_SetSpringArmIgnore::OwnChar' has a wrong offset!");
static_assert(offsetof(Ability_104781_SetSpringArmIgnore, bIgnore) == 0x000010, "Member 'Ability_104781_SetSpringArmIgnore::bIgnore' has a wrong offset!");

// Function Hero_1047.Ability_104781.UnBindDettachDelegates
// 0x0008 (0x0008 - 0x0000)
struct Ability_104781_UnBindDettachDelegates final
{
public:
	class AActor*                                 InGroot;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_104781_UnBindDettachDelegates) == 0x000008, "Wrong alignment on Ability_104781_UnBindDettachDelegates");
static_assert(sizeof(Ability_104781_UnBindDettachDelegates) == 0x000008, "Wrong size on Ability_104781_UnBindDettachDelegates");
static_assert(offsetof(Ability_104781_UnBindDettachDelegates, InGroot) == 0x000000, "Member 'Ability_104781_UnBindDettachDelegates::InGroot' has a wrong offset!");

// Function Hero_1047.Cue_Ability_Loop_10478101.OnJeffGrootCoopStateChange
// 0x0001 (0x0001 - 0x0000)
struct Cue_Ability_Loop_10478101_OnJeffGrootCoopStateChange final
{
public:
	EJeffGrootAbilityState                        InState;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_10478101_OnJeffGrootCoopStateChange) == 0x000001, "Wrong alignment on Cue_Ability_Loop_10478101_OnJeffGrootCoopStateChange");
static_assert(sizeof(Cue_Ability_Loop_10478101_OnJeffGrootCoopStateChange) == 0x000001, "Wrong size on Cue_Ability_Loop_10478101_OnJeffGrootCoopStateChange");
static_assert(offsetof(Cue_Ability_Loop_10478101_OnJeffGrootCoopStateChange, InState) == 0x000000, "Member 'Cue_Ability_Loop_10478101_OnJeffGrootCoopStateChange::InState' has a wrong offset!");

// Function Hero_1047.JeffAnimInstance.CalucateJeffGrootIK
// 0x0010 (0x0010 - 0x0000)
struct JeffAnimInstance_CalucateJeffGrootIK final
{
public:
	struct FAnimComponentSpacePoseContext         PoseContext;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffAnimInstance_CalucateJeffGrootIK) == 0x000008, "Wrong alignment on JeffAnimInstance_CalucateJeffGrootIK");
static_assert(sizeof(JeffAnimInstance_CalucateJeffGrootIK) == 0x000010, "Wrong size on JeffAnimInstance_CalucateJeffGrootIK");
static_assert(offsetof(JeffAnimInstance_CalucateJeffGrootIK, PoseContext) == 0x000000, "Member 'JeffAnimInstance_CalucateJeffGrootIK::PoseContext' has a wrong offset!");

// Function Hero_1047.JeffAnimInstance.GetGroundMotionForwardState
// 0x0010 (0x0010 - 0x0000)
struct JeffAnimInstance_GetGroundMotionForwardState final
{
public:
	struct FAnimPoseContext                       PoseContext;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffAnimInstance_GetGroundMotionForwardState) == 0x000008, "Wrong alignment on JeffAnimInstance_GetGroundMotionForwardState");
static_assert(sizeof(JeffAnimInstance_GetGroundMotionForwardState) == 0x000010, "Wrong size on JeffAnimInstance_GetGroundMotionForwardState");
static_assert(offsetof(JeffAnimInstance_GetGroundMotionForwardState, PoseContext) == 0x000000, "Member 'JeffAnimInstance_GetGroundMotionForwardState::PoseContext' has a wrong offset!");

// Function Hero_1047.JeffAnimInstance.RelevantJeffOnGrootStateNode
// 0x0020 (0x0020 - 0x0000)
struct JeffAnimInstance_RelevantJeffOnGrootStateNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffAnimInstance_RelevantJeffOnGrootStateNode) == 0x000008, "Wrong alignment on JeffAnimInstance_RelevantJeffOnGrootStateNode");
static_assert(sizeof(JeffAnimInstance_RelevantJeffOnGrootStateNode) == 0x000020, "Wrong size on JeffAnimInstance_RelevantJeffOnGrootStateNode");
static_assert(offsetof(JeffAnimInstance_RelevantJeffOnGrootStateNode, Context) == 0x000000, "Member 'JeffAnimInstance_RelevantJeffOnGrootStateNode::Context' has a wrong offset!");
static_assert(offsetof(JeffAnimInstance_RelevantJeffOnGrootStateNode, Node) == 0x000010, "Member 'JeffAnimInstance_RelevantJeffOnGrootStateNode::Node' has a wrong offset!");

// Function Hero_1047.JeffAnimInstance.UpdateJeffOnGrootMotionNode
// 0x0020 (0x0020 - 0x0000)
struct JeffAnimInstance_UpdateJeffOnGrootMotionNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffAnimInstance_UpdateJeffOnGrootMotionNode) == 0x000008, "Wrong alignment on JeffAnimInstance_UpdateJeffOnGrootMotionNode");
static_assert(sizeof(JeffAnimInstance_UpdateJeffOnGrootMotionNode) == 0x000020, "Wrong size on JeffAnimInstance_UpdateJeffOnGrootMotionNode");
static_assert(offsetof(JeffAnimInstance_UpdateJeffOnGrootMotionNode, Context) == 0x000000, "Member 'JeffAnimInstance_UpdateJeffOnGrootMotionNode::Context' has a wrong offset!");
static_assert(offsetof(JeffAnimInstance_UpdateJeffOnGrootMotionNode, Node) == 0x000010, "Member 'JeffAnimInstance_UpdateJeffOnGrootMotionNode::Node' has a wrong offset!");

// Function Hero_1047.JeffAnimInstance.UpdateJeffOnGrootStateNode
// 0x0020 (0x0020 - 0x0000)
struct JeffAnimInstance_UpdateJeffOnGrootStateNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffAnimInstance_UpdateJeffOnGrootStateNode) == 0x000008, "Wrong alignment on JeffAnimInstance_UpdateJeffOnGrootStateNode");
static_assert(sizeof(JeffAnimInstance_UpdateJeffOnGrootStateNode) == 0x000020, "Wrong size on JeffAnimInstance_UpdateJeffOnGrootStateNode");
static_assert(offsetof(JeffAnimInstance_UpdateJeffOnGrootStateNode, Context) == 0x000000, "Member 'JeffAnimInstance_UpdateJeffOnGrootStateNode::Context' has a wrong offset!");
static_assert(offsetof(JeffAnimInstance_UpdateJeffOnGrootStateNode, Node) == 0x000010, "Member 'JeffAnimInstance_UpdateJeffOnGrootStateNode::Node' has a wrong offset!");

// Function Hero_1047.JeffCharacter.DivingBlockAbility
// 0x0070 (0x0070 - 0x0000)
struct JeffCharacter_DivingBlockAbility final
{
public:
	struct FGameplayTagContainer                  InContainer;                                       // 0x0000(0x0068)(Parm, NativeAccessSpecifierPublic)
	bool                                          bBlock;                                            // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(JeffCharacter_DivingBlockAbility) == 0x000008, "Wrong alignment on JeffCharacter_DivingBlockAbility");
static_assert(sizeof(JeffCharacter_DivingBlockAbility) == 0x000070, "Wrong size on JeffCharacter_DivingBlockAbility");
static_assert(offsetof(JeffCharacter_DivingBlockAbility, InContainer) == 0x000000, "Member 'JeffCharacter_DivingBlockAbility::InContainer' has a wrong offset!");
static_assert(offsetof(JeffCharacter_DivingBlockAbility, bBlock) == 0x000068, "Member 'JeffCharacter_DivingBlockAbility::bBlock' has a wrong offset!");

// Function Hero_1047.JeffCharacter.GetJeffState
// 0x0001 (0x0001 - 0x0000)
struct JeffCharacter_GetJeffState final
{
public:
	EJeffState                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffCharacter_GetJeffState) == 0x000001, "Wrong alignment on JeffCharacter_GetJeffState");
static_assert(sizeof(JeffCharacter_GetJeffState) == 0x000001, "Wrong size on JeffCharacter_GetJeffState");
static_assert(offsetof(JeffCharacter_GetJeffState, ReturnValue) == 0x000000, "Member 'JeffCharacter_GetJeffState::ReturnValue' has a wrong offset!");

// Function Hero_1047.JeffCharacter.IsJeffDiving
// 0x0001 (0x0001 - 0x0000)
struct JeffCharacter_IsJeffDiving final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffCharacter_IsJeffDiving) == 0x000001, "Wrong alignment on JeffCharacter_IsJeffDiving");
static_assert(sizeof(JeffCharacter_IsJeffDiving) == 0x000001, "Wrong size on JeffCharacter_IsJeffDiving");
static_assert(offsetof(JeffCharacter_IsJeffDiving, ReturnValue) == 0x000000, "Member 'JeffCharacter_IsJeffDiving::ReturnValue' has a wrong offset!");

// Function Hero_1047.JeffCharacter.IsJeffMovingForward
// 0x0001 (0x0001 - 0x0000)
struct JeffCharacter_IsJeffMovingForward final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffCharacter_IsJeffMovingForward) == 0x000001, "Wrong alignment on JeffCharacter_IsJeffMovingForward");
static_assert(sizeof(JeffCharacter_IsJeffMovingForward) == 0x000001, "Wrong size on JeffCharacter_IsJeffMovingForward");
static_assert(offsetof(JeffCharacter_IsJeffMovingForward, ReturnValue) == 0x000000, "Member 'JeffCharacter_IsJeffMovingForward::ReturnValue' has a wrong offset!");

// Function Hero_1047.JeffCharacter.SafeMove
// 0x0018 (0x0018 - 0x0000)
struct JeffCharacter_SafeMove final
{
public:
	struct FVector                                Delta;                                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffCharacter_SafeMove) == 0x000008, "Wrong alignment on JeffCharacter_SafeMove");
static_assert(sizeof(JeffCharacter_SafeMove) == 0x000018, "Wrong size on JeffCharacter_SafeMove");
static_assert(offsetof(JeffCharacter_SafeMove, Delta) == 0x000000, "Member 'JeffCharacter_SafeMove::Delta' has a wrong offset!");

// Function Hero_1047.JeffCharacter.SetJeffState
// 0x0001 (0x0001 - 0x0000)
struct JeffCharacter_SetJeffState final
{
public:
	EJeffState                                    InState;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffCharacter_SetJeffState) == 0x000001, "Wrong alignment on JeffCharacter_SetJeffState");
static_assert(sizeof(JeffCharacter_SetJeffState) == 0x000001, "Wrong size on JeffCharacter_SetJeffState");
static_assert(offsetof(JeffCharacter_SetJeffState, InState) == 0x000000, "Member 'JeffCharacter_SetJeffState::InState' has a wrong offset!");

// Function Hero_1047.JeffChildActor.OnCharacterDeath
// 0x0028 (0x0028 - 0x0000)
struct JeffChildActor_OnCharacterDeath final
{
public:
	class AActor*                                 OutSourceAvatar;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OutTargetAvatar;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeModifierHandle               ModifierParameterHandle;                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffChildActor_OnCharacterDeath) == 0x000008, "Wrong alignment on JeffChildActor_OnCharacterDeath");
static_assert(sizeof(JeffChildActor_OnCharacterDeath) == 0x000028, "Wrong size on JeffChildActor_OnCharacterDeath");
static_assert(offsetof(JeffChildActor_OnCharacterDeath, OutSourceAvatar) == 0x000000, "Member 'JeffChildActor_OnCharacterDeath::OutSourceAvatar' has a wrong offset!");
static_assert(offsetof(JeffChildActor_OnCharacterDeath, OutTargetAvatar) == 0x000008, "Member 'JeffChildActor_OnCharacterDeath::OutTargetAvatar' has a wrong offset!");
static_assert(offsetof(JeffChildActor_OnCharacterDeath, ModifierParameterHandle) == 0x000010, "Member 'JeffChildActor_OnCharacterDeath::ModifierParameterHandle' has a wrong offset!");

// Function Hero_1047.JeffChildActor.OnCharacterReborn
// 0x0740 (0x0740 - 0x0000)
struct JeffChildActor_OnCharacterReborn final
{
public:
	class AActor*                                 OutTargetActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterRebornParam                  Param;                                             // 0x0010(0x0730)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffChildActor_OnCharacterReborn) == 0x000010, "Wrong alignment on JeffChildActor_OnCharacterReborn");
static_assert(sizeof(JeffChildActor_OnCharacterReborn) == 0x000740, "Wrong size on JeffChildActor_OnCharacterReborn");
static_assert(offsetof(JeffChildActor_OnCharacterReborn, OutTargetActor) == 0x000000, "Member 'JeffChildActor_OnCharacterReborn::OutTargetActor' has a wrong offset!");
static_assert(offsetof(JeffChildActor_OnCharacterReborn, Param) == 0x000010, "Member 'JeffChildActor_OnCharacterReborn::Param' has a wrong offset!");

// Function Hero_1047.JeffChildActor.OnCharacterSwimEnd
// 0x000C (0x000C - 0x0000)
struct JeffChildActor_OnCharacterSwimEnd final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffChildActor_OnCharacterSwimEnd) == 0x000004, "Wrong alignment on JeffChildActor_OnCharacterSwimEnd");
static_assert(sizeof(JeffChildActor_OnCharacterSwimEnd) == 0x00000C, "Wrong size on JeffChildActor_OnCharacterSwimEnd");
static_assert(offsetof(JeffChildActor_OnCharacterSwimEnd, Tag) == 0x000000, "Member 'JeffChildActor_OnCharacterSwimEnd::Tag' has a wrong offset!");

// Function Hero_1047.JeffChildActor.OnJeffStateChange
// 0x0001 (0x0001 - 0x0000)
struct JeffChildActor_OnJeffStateChange final
{
public:
	EJeffState                                    InState;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffChildActor_OnJeffStateChange) == 0x000001, "Wrong alignment on JeffChildActor_OnJeffStateChange");
static_assert(sizeof(JeffChildActor_OnJeffStateChange) == 0x000001, "Wrong size on JeffChildActor_OnJeffStateChange");
static_assert(offsetof(JeffChildActor_OnJeffStateChange, InState) == 0x000000, "Member 'JeffChildActor_OnJeffStateChange::InState' has a wrong offset!");

// Function Hero_1047.JeffChildActor.OnTagUpdate
// 0x0010 (0x0010 - 0x0000)
struct JeffChildActor_OnTagUpdate final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTagExists;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(JeffChildActor_OnTagUpdate) == 0x000004, "Wrong alignment on JeffChildActor_OnTagUpdate");
static_assert(sizeof(JeffChildActor_OnTagUpdate) == 0x000010, "Wrong size on JeffChildActor_OnTagUpdate");
static_assert(offsetof(JeffChildActor_OnTagUpdate, Tag) == 0x000000, "Member 'JeffChildActor_OnTagUpdate::Tag' has a wrong offset!");
static_assert(offsetof(JeffChildActor_OnTagUpdate, bTagExists) == 0x00000C, "Member 'JeffChildActor_OnTagUpdate::bTagExists' has a wrong offset!");

// Function Hero_1047.JeffChildActor.SetDivingMarteialSectionHidden
// 0x0001 (0x0001 - 0x0000)
struct JeffChildActor_SetDivingMarteialSectionHidden final
{
public:
	bool                                          bDiving;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffChildActor_SetDivingMarteialSectionHidden) == 0x000001, "Wrong alignment on JeffChildActor_SetDivingMarteialSectionHidden");
static_assert(sizeof(JeffChildActor_SetDivingMarteialSectionHidden) == 0x000001, "Wrong size on JeffChildActor_SetDivingMarteialSectionHidden");
static_assert(offsetof(JeffChildActor_SetDivingMarteialSectionHidden, bDiving) == 0x000000, "Member 'JeffChildActor_SetDivingMarteialSectionHidden::bDiving' has a wrong offset!");

// Function Hero_1047.Cue_Ability_Loop_10470101.OnTagUpdate
// 0x0010 (0x0010 - 0x0000)
struct Cue_Ability_Loop_10470101_OnTagUpdate final
{
public:
	struct FGameplayTag                           TagUpdated;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTagExists;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Cue_Ability_Loop_10470101_OnTagUpdate) == 0x000004, "Wrong alignment on Cue_Ability_Loop_10470101_OnTagUpdate");
static_assert(sizeof(Cue_Ability_Loop_10470101_OnTagUpdate) == 0x000010, "Wrong size on Cue_Ability_Loop_10470101_OnTagUpdate");
static_assert(offsetof(Cue_Ability_Loop_10470101_OnTagUpdate, TagUpdated) == 0x000000, "Member 'Cue_Ability_Loop_10470101_OnTagUpdate::TagUpdated' has a wrong offset!");
static_assert(offsetof(Cue_Ability_Loop_10470101_OnTagUpdate, bTagExists) == 0x00000C, "Member 'Cue_Ability_Loop_10470101_OnTagUpdate::bTagExists' has a wrong offset!");

// Function Hero_1047.FlowSimluateSplineActor.BuildCurrentSplinePoints
// 0x0004 (0x0004 - 0x0000)
struct FlowSimluateSplineActor_BuildCurrentSplinePoints final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlowSimluateSplineActor_BuildCurrentSplinePoints) == 0x000004, "Wrong alignment on FlowSimluateSplineActor_BuildCurrentSplinePoints");
static_assert(sizeof(FlowSimluateSplineActor_BuildCurrentSplinePoints) == 0x000004, "Wrong size on FlowSimluateSplineActor_BuildCurrentSplinePoints");
static_assert(offsetof(FlowSimluateSplineActor_BuildCurrentSplinePoints, DeltaTime) == 0x000000, "Member 'FlowSimluateSplineActor_BuildCurrentSplinePoints::DeltaTime' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.EnterBToF
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_EnterBToF final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_EnterBToF) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_EnterBToF");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_EnterBToF) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_EnterBToF");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_EnterBToF, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_EnterBToF::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_EnterBToF, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_EnterBToF::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.RelevantBlackforwadTransitionNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_RelevantBlackforwadTransitionNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_RelevantBlackforwadTransitionNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_RelevantBlackforwadTransitionNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_RelevantBlackforwadTransitionNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_RelevantBlackforwadTransitionNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantBlackforwadTransitionNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_RelevantBlackforwadTransitionNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantBlackforwadTransitionNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_RelevantBlackforwadTransitionNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.RelevantCycleNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_RelevantCycleNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_RelevantCycleNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_RelevantCycleNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_RelevantCycleNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_RelevantCycleNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantCycleNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_RelevantCycleNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantCycleNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_RelevantCycleNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.RelevantJumpStartNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_RelevantJumpStartNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_RelevantJumpStartNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_RelevantJumpStartNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_RelevantJumpStartNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_RelevantJumpStartNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantJumpStartNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_RelevantJumpStartNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantJumpStartNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_RelevantJumpStartNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.RelevantLeftForwardNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_RelevantLeftForwardNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_RelevantLeftForwardNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_RelevantLeftForwardNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_RelevantLeftForwardNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_RelevantLeftForwardNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantLeftForwardNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_RelevantLeftForwardNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantLeftForwardNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_RelevantLeftForwardNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.RelevantRightForwardNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_RelevantRightForwardNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_RelevantRightForwardNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_RelevantRightForwardNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_RelevantRightForwardNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_RelevantRightForwardNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantRightForwardNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_RelevantRightForwardNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantRightForwardNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_RelevantRightForwardNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.RelevantStopNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_RelevantStopNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_RelevantStopNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_RelevantStopNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_RelevantStopNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_RelevantStopNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantStopNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_RelevantStopNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_RelevantStopNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_RelevantStopNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.UpdateAllBackforwardNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_UpdateAllBackforwardNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_UpdateAllBackforwardNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_UpdateAllBackforwardNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_UpdateAllBackforwardNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_UpdateAllBackforwardNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateAllBackforwardNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_UpdateAllBackforwardNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateAllBackforwardNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_UpdateAllBackforwardNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.UpdateBlackforwadTransitionNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_UpdateBlackforwadTransitionNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_UpdateBlackforwadTransitionNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_UpdateBlackforwadTransitionNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_UpdateBlackforwadTransitionNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_UpdateBlackforwadTransitionNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateBlackforwadTransitionNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_UpdateBlackforwadTransitionNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateBlackforwadTransitionNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_UpdateBlackforwadTransitionNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.UpdateForwardNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_UpdateForwardNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_UpdateForwardNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_UpdateForwardNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_UpdateForwardNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_UpdateForwardNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateForwardNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_UpdateForwardNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateForwardNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_UpdateForwardNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.UpdateJumpLandNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_UpdateJumpLandNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_UpdateJumpLandNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_UpdateJumpLandNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_UpdateJumpLandNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_UpdateJumpLandNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateJumpLandNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_UpdateJumpLandNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateJumpLandNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_UpdateJumpLandNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.UpdateJumpLoopNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_UpdateJumpLoopNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_UpdateJumpLoopNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_UpdateJumpLoopNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_UpdateJumpLoopNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_UpdateJumpLoopNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateJumpLoopNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_UpdateJumpLoopNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateJumpLoopNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_UpdateJumpLoopNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.UpdateJumpStartNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_UpdateJumpStartNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_UpdateJumpStartNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_UpdateJumpStartNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_UpdateJumpStartNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_UpdateJumpStartNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateJumpStartNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_UpdateJumpStartNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateJumpStartNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_UpdateJumpStartNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.UpdateLeftForwardNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_UpdateLeftForwardNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_UpdateLeftForwardNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_UpdateLeftForwardNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_UpdateLeftForwardNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_UpdateLeftForwardNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateLeftForwardNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_UpdateLeftForwardNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateLeftForwardNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_UpdateLeftForwardNode::Node' has a wrong offset!");

// Function Hero_1047.JeffGroundMotionSubAnimInstance.UpdateRightForwardNode
// 0x0020 (0x0020 - 0x0000)
struct JeffGroundMotionSubAnimInstance_UpdateRightForwardNode final
{
public:
	struct FAnimUpdateContext                     Context;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAnimNodeReference                     Node;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffGroundMotionSubAnimInstance_UpdateRightForwardNode) == 0x000008, "Wrong alignment on JeffGroundMotionSubAnimInstance_UpdateRightForwardNode");
static_assert(sizeof(JeffGroundMotionSubAnimInstance_UpdateRightForwardNode) == 0x000020, "Wrong size on JeffGroundMotionSubAnimInstance_UpdateRightForwardNode");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateRightForwardNode, Context) == 0x000000, "Member 'JeffGroundMotionSubAnimInstance_UpdateRightForwardNode::Context' has a wrong offset!");
static_assert(offsetof(JeffGroundMotionSubAnimInstance_UpdateRightForwardNode, Node) == 0x000010, "Member 'JeffGroundMotionSubAnimInstance_UpdateRightForwardNode::Node' has a wrong offset!");

// Function Hero_1047.JeffMovementComponent.CheckMoveForward
// 0x0090 (0x0090 - 0x0000)
struct JeffMovementComponent_CheckMoveForward final
{
public:
	struct FVector                                MoveDelta;                                         // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJeffMoveForwardCheckResult            ReturnValue;                                       // 0x0020(0x0070)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffMovementComponent_CheckMoveForward) == 0x000010, "Wrong alignment on JeffMovementComponent_CheckMoveForward");
static_assert(sizeof(JeffMovementComponent_CheckMoveForward) == 0x000090, "Wrong size on JeffMovementComponent_CheckMoveForward");
static_assert(offsetof(JeffMovementComponent_CheckMoveForward, MoveDelta) == 0x000000, "Member 'JeffMovementComponent_CheckMoveForward::MoveDelta' has a wrong offset!");
static_assert(offsetof(JeffMovementComponent_CheckMoveForward, ReturnValue) == 0x000020, "Member 'JeffMovementComponent_CheckMoveForward::ReturnValue' has a wrong offset!");

// Function Hero_1047.JeffMovementComponent.OnJeffGetOffWall
// 0x0020 (0x0020 - 0x0000)
struct JeffMovementComponent_OnJeffGetOffWall final
{
public:
	struct FWallRunningEndInfo                    InWallRunningEndInfo;                              // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(JeffMovementComponent_OnJeffGetOffWall) == 0x000008, "Wrong alignment on JeffMovementComponent_OnJeffGetOffWall");
static_assert(sizeof(JeffMovementComponent_OnJeffGetOffWall) == 0x000020, "Wrong size on JeffMovementComponent_OnJeffGetOffWall");
static_assert(offsetof(JeffMovementComponent_OnJeffGetOffWall, InWallRunningEndInfo) == 0x000000, "Member 'JeffMovementComponent_OnJeffGetOffWall::InWallRunningEndInfo' has a wrong offset!");

}

