#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1026

#include "Basic.hpp"

#include "GameplayAbilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Hero_1026_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Class Hero_1026.Cue_Ability_Loop_10260101
// 0x00B0 (0x0F00 - 0x0E50)
class ACue_Ability_Loop_10260101 final : public AMarvelCueNotify_Ability
{
public:
	bool                                          bUseMaxLoopTime;                                   // 0x0E50(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E51[0x3];                                      // 0x0E51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FxMaxLoopTime;                                     // 0x0E54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FxCurrentTime;                                     // 0x0E58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FxAttributeTime;                                   // 0x0E5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0E60(0x0040)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFxMaterialsCurve>              MaterialsCurveArray;                               // 0x0EA0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFxMaterialsCurve>              TimeMaterialsCurveArray;                           // 0x0EB0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinAttributeValue;                                 // 0x0EC0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BuffTag;                                           // 0x0EC4(0x000C)(Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         MeshCom;                                           // 0x0ED0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED8[0x28];                                     // 0x0ED8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterMeshMaterialChanged();
	void OnDeath(class AActor* InSource, class AActor* InSourceAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);
	void UpdateMaterials(float CurrentValue);
	void UpdateMaterialsForTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10260101">();
	}
	static class ACue_Ability_Loop_10260101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10260101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10260101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10260101");
static_assert(sizeof(ACue_Ability_Loop_10260101) == 0x000F00, "Wrong size on ACue_Ability_Loop_10260101");
static_assert(offsetof(ACue_Ability_Loop_10260101, bUseMaxLoopTime) == 0x000E50, "Member 'ACue_Ability_Loop_10260101::bUseMaxLoopTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, FxMaxLoopTime) == 0x000E54, "Member 'ACue_Ability_Loop_10260101::FxMaxLoopTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, FxCurrentTime) == 0x000E58, "Member 'ACue_Ability_Loop_10260101::FxCurrentTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, FxAttributeTime) == 0x000E5C, "Member 'ACue_Ability_Loop_10260101::FxAttributeTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, Attribute) == 0x000E60, "Member 'ACue_Ability_Loop_10260101::Attribute' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, MaterialsCurveArray) == 0x000EA0, "Member 'ACue_Ability_Loop_10260101::MaterialsCurveArray' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, TimeMaterialsCurveArray) == 0x000EB0, "Member 'ACue_Ability_Loop_10260101::TimeMaterialsCurveArray' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, MinAttributeValue) == 0x000EC0, "Member 'ACue_Ability_Loop_10260101::MinAttributeValue' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, BuffTag) == 0x000EC4, "Member 'ACue_Ability_Loop_10260101::BuffTag' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, MeshCom) == 0x000ED0, "Member 'ACue_Ability_Loop_10260101::MeshCom' has a wrong offset!");

// Class Hero_1026.TraceComponent_10261101
// 0x0020 (0x1730 - 0x1710)
class UTraceComponent_10261101 final : public UMarvelAgentTraceComponent
{
public:
	struct FVector                                Offset;                                            // 0x1708(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndWhenHeadCollide;                               // 0x1720(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1721[0xF];                                     // 0x1721(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTraceResult(class UObject* TraceSource, const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10261101">();
	}
	static class UTraceComponent_10261101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10261101>();
	}
};
static_assert(alignof(UTraceComponent_10261101) == 0x000010, "Wrong alignment on UTraceComponent_10261101");
static_assert(sizeof(UTraceComponent_10261101) == 0x001730, "Wrong size on UTraceComponent_10261101");
static_assert(offsetof(UTraceComponent_10261101, Offset) == 0x001708, "Member 'UTraceComponent_10261101::Offset' has a wrong offset!");
static_assert(offsetof(UTraceComponent_10261101, bEndWhenHeadCollide) == 0x001720, "Member 'UTraceComponent_10261101::bEndWhenHeadCollide' has a wrong offset!");

// Class Hero_1026.Ability_102611
// 0x0058 (0x2660 - 0x2608)
class UAbility_102611 final : public UWallRunningAbility
{
public:
	struct FVector                                HitNormal;                                         // 0x2608(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2620[0x1];                                     // 0x2620(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsClimbingZ;                                      // 0x2621(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2622[0x2];                                     // 0x2622(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputXYRate;                                       // 0x2624(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2628[0x4];                                     // 0x2628(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedMeshOffset;                                  // 0x262C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeClimbNoSpeed;                               // 0x2630(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValidClimbSpeed;                                // 0x2634(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceStartOffset;                                  // 0x2638(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanActivateLength;                                 // 0x2650(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2654[0x4];                                     // 0x2654(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_102612*                        TraceAbility;                                      // 0x2658(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EndClimbing();
	void SetHitNormal(const struct FVector& InNormal);
	void UpdateLastTimeHasValidSpeed();

	bool GetIsValidActivated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102611">();
	}
	static class UAbility_102611* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102611>();
	}
};
static_assert(alignof(UAbility_102611) == 0x000008, "Wrong alignment on UAbility_102611");
static_assert(sizeof(UAbility_102611) == 0x002660, "Wrong size on UAbility_102611");
static_assert(offsetof(UAbility_102611, HitNormal) == 0x002608, "Member 'UAbility_102611::HitNormal' has a wrong offset!");
static_assert(offsetof(UAbility_102611, bIsClimbingZ) == 0x002621, "Member 'UAbility_102611::bIsClimbingZ' has a wrong offset!");
static_assert(offsetof(UAbility_102611, InputXYRate) == 0x002624, "Member 'UAbility_102611::InputXYRate' has a wrong offset!");
static_assert(offsetof(UAbility_102611, CachedMeshOffset) == 0x00262C, "Member 'UAbility_102611::CachedMeshOffset' has a wrong offset!");
static_assert(offsetof(UAbility_102611, MaxTimeClimbNoSpeed) == 0x002630, "Member 'UAbility_102611::MaxTimeClimbNoSpeed' has a wrong offset!");
static_assert(offsetof(UAbility_102611, MinValidClimbSpeed) == 0x002634, "Member 'UAbility_102611::MinValidClimbSpeed' has a wrong offset!");
static_assert(offsetof(UAbility_102611, TraceStartOffset) == 0x002638, "Member 'UAbility_102611::TraceStartOffset' has a wrong offset!");
static_assert(offsetof(UAbility_102611, CanActivateLength) == 0x002650, "Member 'UAbility_102611::CanActivateLength' has a wrong offset!");
static_assert(offsetof(UAbility_102611, TraceAbility) == 0x002658, "Member 'UAbility_102611::TraceAbility' has a wrong offset!");

// Class Hero_1026.Config_102612
// 0x0030 (0x0110 - 0x00E0)
class UConfig_102612 final : public UWallRunningPassiveAbilityConfig
{
public:
	bool                                          bUseNewMethod;                                     // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawOffset;                                         // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallCheckAngle;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInvalidWallTime;                                // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCrossHorizonAngle;                              // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinClimbWallHeight;                                // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizonExtendAngle;                                // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceWithSphere;                                  // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceSphereRadius;                                 // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceLineLength;                                   // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawHorizonExtend;                                // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawHorizonExtendTime;                             // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102612">();
	}
	static class UConfig_102612* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102612>();
	}
};
static_assert(alignof(UConfig_102612) == 0x000008, "Wrong alignment on UConfig_102612");
static_assert(sizeof(UConfig_102612) == 0x000110, "Wrong size on UConfig_102612");
static_assert(offsetof(UConfig_102612, bUseNewMethod) == 0x0000E0, "Member 'UConfig_102612::bUseNewMethod' has a wrong offset!");
static_assert(offsetof(UConfig_102612, YawOffset) == 0x0000E4, "Member 'UConfig_102612::YawOffset' has a wrong offset!");
static_assert(offsetof(UConfig_102612, WallCheckAngle) == 0x0000E8, "Member 'UConfig_102612::WallCheckAngle' has a wrong offset!");
static_assert(offsetof(UConfig_102612, MaxInvalidWallTime) == 0x0000EC, "Member 'UConfig_102612::MaxInvalidWallTime' has a wrong offset!");
static_assert(offsetof(UConfig_102612, MaxCrossHorizonAngle) == 0x0000F0, "Member 'UConfig_102612::MaxCrossHorizonAngle' has a wrong offset!");
static_assert(offsetof(UConfig_102612, MinClimbWallHeight) == 0x0000F4, "Member 'UConfig_102612::MinClimbWallHeight' has a wrong offset!");
static_assert(offsetof(UConfig_102612, HorizonExtendAngle) == 0x0000F8, "Member 'UConfig_102612::HorizonExtendAngle' has a wrong offset!");
static_assert(offsetof(UConfig_102612, bTraceWithSphere) == 0x0000FC, "Member 'UConfig_102612::bTraceWithSphere' has a wrong offset!");
static_assert(offsetof(UConfig_102612, TraceSphereRadius) == 0x000100, "Member 'UConfig_102612::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(UConfig_102612, TraceLineLength) == 0x000104, "Member 'UConfig_102612::TraceLineLength' has a wrong offset!");
static_assert(offsetof(UConfig_102612, bDrawHorizonExtend) == 0x000108, "Member 'UConfig_102612::bDrawHorizonExtend' has a wrong offset!");
static_assert(offsetof(UConfig_102612, DrawHorizonExtendTime) == 0x00010C, "Member 'UConfig_102612::DrawHorizonExtendTime' has a wrong offset!");

// Class Hero_1026.Ability_102612
// 0x01A8 (0x2740 - 0x2598)
class UAbility_102612 final : public UWallRunningPassiveAbility
{
public:
	uint8                                         Pad_2598[0x8];                                     // 0x2598(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlackPantherMovementComponent*         MoveComp;                                          // 0x25A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbility_102611*                        ClimbAbility;                                      // 0x25A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTracing;                                        // 0x25B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasFoundWall;                                     // 0x25B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSpacePressed;                                   // 0x25B2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWPressed;                                       // 0x25B3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanClimbWall;                                     // 0x25B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25B5[0x18B];                                   // 0x25B5(0x018B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndTracing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102612">();
	}
	static class UAbility_102612* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102612>();
	}
};
static_assert(alignof(UAbility_102612) == 0x000008, "Wrong alignment on UAbility_102612");
static_assert(sizeof(UAbility_102612) == 0x002740, "Wrong size on UAbility_102612");
static_assert(offsetof(UAbility_102612, MoveComp) == 0x0025A0, "Member 'UAbility_102612::MoveComp' has a wrong offset!");
static_assert(offsetof(UAbility_102612, ClimbAbility) == 0x0025A8, "Member 'UAbility_102612::ClimbAbility' has a wrong offset!");
static_assert(offsetof(UAbility_102612, bIsTracing) == 0x0025B0, "Member 'UAbility_102612::bIsTracing' has a wrong offset!");
static_assert(offsetof(UAbility_102612, bHasFoundWall) == 0x0025B1, "Member 'UAbility_102612::bHasFoundWall' has a wrong offset!");
static_assert(offsetof(UAbility_102612, bIsSpacePressed) == 0x0025B2, "Member 'UAbility_102612::bIsSpacePressed' has a wrong offset!");
static_assert(offsetof(UAbility_102612, bIsWPressed) == 0x0025B3, "Member 'UAbility_102612::bIsWPressed' has a wrong offset!");
static_assert(offsetof(UAbility_102612, bCanClimbWall) == 0x0025B4, "Member 'UAbility_102612::bCanClimbWall' has a wrong offset!");

// Class Hero_1026.Ability_102613
// 0x0008 (0x2680 - 0x2678)
class UAbility_102613 : public UMarvelAbility_DoubleJump
{
public:
	uint8                                         Pad_2678[0x8];                                     // 0x2678(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102613">();
	}
	static class UAbility_102613* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102613>();
	}
};
static_assert(alignof(UAbility_102613) == 0x000008, "Wrong alignment on UAbility_102613");
static_assert(sizeof(UAbility_102613) == 0x002680, "Wrong size on UAbility_102613");

// Class Hero_1026.Config_102641
// 0x0BC0 (0x0C58 - 0x0098)
class UConfig_102641 : public UMarvelAbilityConfig
{
public:
	struct FDashAbilityInfo                       DashInfo;                                          // 0x0098(0x0BA8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MinAbilityLoopTime;                                // 0x0C40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndAbilityWhenHit;                                // 0x0C44(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C45[0x3];                                      // 0x0C45(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Rate;                                              // 0x0C48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetAnimRootMotionTranslationScale;                // 0x0C4C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4D[0x3];                                      // 0x0C4D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractiveAbilityCooldown;                        // 0x0C50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C54[0x4];                                      // 0x0C54(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102641">();
	}
	static class UConfig_102641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102641>();
	}
};
static_assert(alignof(UConfig_102641) == 0x000008, "Wrong alignment on UConfig_102641");
static_assert(sizeof(UConfig_102641) == 0x000C58, "Wrong size on UConfig_102641");
static_assert(offsetof(UConfig_102641, DashInfo) == 0x000098, "Member 'UConfig_102641::DashInfo' has a wrong offset!");
static_assert(offsetof(UConfig_102641, MinAbilityLoopTime) == 0x000C40, "Member 'UConfig_102641::MinAbilityLoopTime' has a wrong offset!");
static_assert(offsetof(UConfig_102641, bEndAbilityWhenHit) == 0x000C44, "Member 'UConfig_102641::bEndAbilityWhenHit' has a wrong offset!");
static_assert(offsetof(UConfig_102641, Rate) == 0x000C48, "Member 'UConfig_102641::Rate' has a wrong offset!");
static_assert(offsetof(UConfig_102641, bSetAnimRootMotionTranslationScale) == 0x000C4C, "Member 'UConfig_102641::bSetAnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UConfig_102641, InteractiveAbilityCooldown) == 0x000C50, "Member 'UConfig_102641::InteractiveAbilityCooldown' has a wrong offset!");

// Class Hero_1026.Ability_102641
// 0x0070 (0x25F0 - 0x2580)
class UAbility_102641 : public UMarvelGameplayAbility
{
public:
	struct FTimerHandle                           TimerHandle;                                       // 0x2580(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           EndAbilityHandle;                                  // 0x2598(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B0[0x10];                                    // 0x25B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* PlayTimelineTask;                                  // 0x25C0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_Dash*                DashTask;                                          // 0x25C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D0[0x20];                                    // 0x25D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckDashTaskValidWhenBreak();
	void EndLimitCameraTask();
	void MyActiveAbility();
	void MyEndAbility();
	void OnAbilityHit(class UGameplayAbility* InAbility, const struct FMarvelAbilityHitParams& HitParams, const TArray<struct FHitResult>& HitResults);
	void OnDashTaskFinished(EDashStopReason Reason);
	void OnTimerSuccess();
	void OnTranslatedByPortal(class APortalViewActor* Portal);
	void OnTranslatedByPortalTimer();
	void StartLimitCameraTask(float TimeSeconds, const struct FRotator& TargetRotator);
	void TickUpdateCameraLimitation(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102641">();
	}
	static class UAbility_102641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102641>();
	}
};
static_assert(alignof(UAbility_102641) == 0x000008, "Wrong alignment on UAbility_102641");
static_assert(sizeof(UAbility_102641) == 0x0025F0, "Wrong size on UAbility_102641");
static_assert(offsetof(UAbility_102641, TimerHandle) == 0x002580, "Member 'UAbility_102641::TimerHandle' has a wrong offset!");
static_assert(offsetof(UAbility_102641, EndAbilityHandle) == 0x002598, "Member 'UAbility_102641::EndAbilityHandle' has a wrong offset!");
static_assert(offsetof(UAbility_102641, PlayTimelineTask) == 0x0025C0, "Member 'UAbility_102641::PlayTimelineTask' has a wrong offset!");
static_assert(offsetof(UAbility_102641, DashTask) == 0x0025C8, "Member 'UAbility_102641::DashTask' has a wrong offset!");

// Class Hero_1026.Cue_Ability_Loop_10265101
// 0x0028 (0x0E78 - 0x0E50)
class ACue_Ability_Loop_10265101 final : public AMarvelCueNotify_Ability
{
public:
	float                                         SpearHorizonRotationOffset;                        // 0x0E50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpearVerticalRotationOffset;                       // 0x0E54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugLine;                                        // 0x0E58(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E59[0x3];                                      // 0x0E59(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RHandName;                                         // 0x0E5C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0E68(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0E70(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10265101">();
	}
	static class ACue_Ability_Loop_10265101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10265101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10265101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10265101");
static_assert(sizeof(ACue_Ability_Loop_10265101) == 0x000E78, "Wrong size on ACue_Ability_Loop_10265101");
static_assert(offsetof(ACue_Ability_Loop_10265101, SpearHorizonRotationOffset) == 0x000E50, "Member 'ACue_Ability_Loop_10265101::SpearHorizonRotationOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10265101, SpearVerticalRotationOffset) == 0x000E54, "Member 'ACue_Ability_Loop_10265101::SpearVerticalRotationOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10265101, bDebugLine) == 0x000E58, "Member 'ACue_Ability_Loop_10265101::bDebugLine' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10265101, RHandName) == 0x000E5C, "Member 'ACue_Ability_Loop_10265101::RHandName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10265101, OwnerCharacter) == 0x000E68, "Member 'ACue_Ability_Loop_10265101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10265101, Mesh) == 0x000E70, "Member 'ACue_Ability_Loop_10265101::Mesh' has a wrong offset!");

// Class Hero_1026.Config_102661
// 0x0000 (0x0098 - 0x0098)
class UConfig_102661 : public UMarvelAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102661">();
	}
	static class UConfig_102661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102661>();
	}
};
static_assert(alignof(UConfig_102661) == 0x000008, "Wrong alignment on UConfig_102661");
static_assert(sizeof(UConfig_102661) == 0x000098, "Wrong size on UConfig_102661");

// Class Hero_1026.Ability_102661
// 0x0030 (0x25B8 - 0x2588)
class UAbility_102661 : public UAbility_108
{
public:
	ERush_State_102661                            CurrentStat;                                       // 0x2588(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2589[0x3];                                     // 0x2589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoopCount;                                         // 0x258C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDashFinish;                                     // 0x2590(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2591[0x7];                                     // 0x2591(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStateChangeDelegate;                             // 0x2598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddedShield;                                     // 0x25A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	ERush_State_102661 GetCurrentStart();
	void OnRep_CurrentStat();
	void SetCurrentStat(ERush_State_102661 NewStat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102661">();
	}
	static class UAbility_102661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102661>();
	}
};
static_assert(alignof(UAbility_102661) == 0x000008, "Wrong alignment on UAbility_102661");
static_assert(sizeof(UAbility_102661) == 0x0025B8, "Wrong size on UAbility_102661");
static_assert(offsetof(UAbility_102661, CurrentStat) == 0x002588, "Member 'UAbility_102661::CurrentStat' has a wrong offset!");
static_assert(offsetof(UAbility_102661, LoopCount) == 0x00258C, "Member 'UAbility_102661::LoopCount' has a wrong offset!");
static_assert(offsetof(UAbility_102661, bIsDashFinish) == 0x002590, "Member 'UAbility_102661::bIsDashFinish' has a wrong offset!");
static_assert(offsetof(UAbility_102661, OnStateChangeDelegate) == 0x002598, "Member 'UAbility_102661::OnStateChangeDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_102661, OnAddedShield) == 0x0025A8, "Member 'UAbility_102661::OnAddedShield' has a wrong offset!");

// Class Hero_1026.Config_102671
// 0x0000 (0x0098 - 0x0098)
class UConfig_102671 final : public UMarvelAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102671">();
	}
	static class UConfig_102671* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102671>();
	}
};
static_assert(alignof(UConfig_102671) == 0x000008, "Wrong alignment on UConfig_102671");
static_assert(sizeof(UConfig_102671) == 0x000098, "Wrong size on UConfig_102671");

// Class Hero_1026.Ability_102671
// 0x0000 (0x2580 - 0x2580)
class UAbility_102671 : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102671">();
	}
	static class UAbility_102671* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102671>();
	}
};
static_assert(alignof(UAbility_102671) == 0x000008, "Wrong alignment on UAbility_102671");
static_assert(sizeof(UAbility_102671) == 0x002580, "Wrong size on UAbility_102671");

// Class Hero_1026.Summoner_10267101
// 0x0000 (0x0890 - 0x0890)
class ASummoner_10267101 : public AMarvelSummonerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoner_10267101">();
	}
	static class ASummoner_10267101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoner_10267101>();
	}
};
static_assert(alignof(ASummoner_10267101) == 0x000010, "Wrong alignment on ASummoner_10267101");
static_assert(sizeof(ASummoner_10267101) == 0x000890, "Wrong size on ASummoner_10267101");

// Class Hero_1026.SummonedComp_10267101
// 0x0000 (0x0CA0 - 0x0CA0)
class USummonedComp_10267101 : public UMarvelSummonedComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10267101">();
	}
	static class USummonedComp_10267101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10267101>();
	}
};
static_assert(alignof(USummonedComp_10267101) == 0x000010, "Wrong alignment on USummonedComp_10267101");
static_assert(sizeof(USummonedComp_10267101) == 0x000CA0, "Wrong size on USummonedComp_10267101");

// Class Hero_1026.Cue_Ability_Loop_10267101
// 0x0008 (0x0E58 - 0x0E50)
class ACue_Ability_Loop_10267101 : public AMarvelCueNotify_Ability
{
public:
	class AMarvelBaseCharacter*                   MyCharacter;                                       // 0x0E50(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10267101">();
	}
	static class ACue_Ability_Loop_10267101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10267101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10267101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10267101");
static_assert(sizeof(ACue_Ability_Loop_10267101) == 0x000E58, "Wrong size on ACue_Ability_Loop_10267101");
static_assert(offsetof(ACue_Ability_Loop_10267101, MyCharacter) == 0x000E50, "Member 'ACue_Ability_Loop_10267101::MyCharacter' has a wrong offset!");

// Class Hero_1026.Cue_Ability_Loop_10267102
// 0x0038 (0x0E88 - 0x0E50)
class ACue_Ability_Loop_10267102 final : public AMarvelCueNotify_Ability
{
public:
	TArray<struct FFxMaterialsCurve>              TimeMaterialsCurveArray;                           // 0x0E50(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDecalComponent*>                DecalComps;                                        // 0x0E60(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       MaterialInstances;                                 // 0x0E70(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E80[0x8];                                      // 0x0E80(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10267102">();
	}
	static class ACue_Ability_Loop_10267102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10267102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10267102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10267102");
static_assert(sizeof(ACue_Ability_Loop_10267102) == 0x000E88, "Wrong size on ACue_Ability_Loop_10267102");
static_assert(offsetof(ACue_Ability_Loop_10267102, TimeMaterialsCurveArray) == 0x000E50, "Member 'ACue_Ability_Loop_10267102::TimeMaterialsCurveArray' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10267102, DecalComps) == 0x000E60, "Member 'ACue_Ability_Loop_10267102::DecalComps' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10267102, MaterialInstances) == 0x000E70, "Member 'ACue_Ability_Loop_10267102::MaterialInstances' has a wrong offset!");

// Class Hero_1026.BlackPantherAnimInstance
// 0x0050 (0x0960 - 0x0910)
class UBlackPantherAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          UseAO;                                             // 0x0910(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoubleJump;                                     // 0x0911(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_912[0x2];                                      // 0x0912(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentAngle;                                      // 0x0914(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterShift;                                       // 0x0918(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExitShift;                                        // 0x0919(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipEndState;                                     // 0x091A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91B[0x45];                                     // 0x091B(0x0045)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStateChanged(ERush_State_102661 CurrentStat);
	void OnTagUpdated(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackPantherAnimInstance">();
	}
	static class UBlackPantherAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackPantherAnimInstance>();
	}
};
static_assert(alignof(UBlackPantherAnimInstance) == 0x000010, "Wrong alignment on UBlackPantherAnimInstance");
static_assert(sizeof(UBlackPantherAnimInstance) == 0x000960, "Wrong size on UBlackPantherAnimInstance");
static_assert(offsetof(UBlackPantherAnimInstance, UseAO) == 0x000910, "Member 'UBlackPantherAnimInstance::UseAO' has a wrong offset!");
static_assert(offsetof(UBlackPantherAnimInstance, bIsDoubleJump) == 0x000911, "Member 'UBlackPantherAnimInstance::bIsDoubleJump' has a wrong offset!");
static_assert(offsetof(UBlackPantherAnimInstance, CurrentAngle) == 0x000914, "Member 'UBlackPantherAnimInstance::CurrentAngle' has a wrong offset!");
static_assert(offsetof(UBlackPantherAnimInstance, bEnterShift) == 0x000918, "Member 'UBlackPantherAnimInstance::bEnterShift' has a wrong offset!");
static_assert(offsetof(UBlackPantherAnimInstance, bExitShift) == 0x000919, "Member 'UBlackPantherAnimInstance::bExitShift' has a wrong offset!");
static_assert(offsetof(UBlackPantherAnimInstance, bSkipEndState) == 0x00091A, "Member 'UBlackPantherAnimInstance::bSkipEndState' has a wrong offset!");

// Class Hero_1026.BlackPantherCharacter
// 0x0010 (0x1820 - 0x1810)
class ABlackPantherCharacter : public AMarvelBaseCharacter
{
public:
	class UBlackPantherMoveLogicBaseComponent*    BlackPantherMoveLogic;                             // 0x1810(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1818[0x8];                                     // 0x1818(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackPantherCharacter">();
	}
	static class ABlackPantherCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlackPantherCharacter>();
	}
};
static_assert(alignof(ABlackPantherCharacter) == 0x000010, "Wrong alignment on ABlackPantherCharacter");
static_assert(sizeof(ABlackPantherCharacter) == 0x001820, "Wrong size on ABlackPantherCharacter");
static_assert(offsetof(ABlackPantherCharacter, BlackPantherMoveLogic) == 0x001810, "Member 'ABlackPantherCharacter::BlackPantherMoveLogic' has a wrong offset!");

// Class Hero_1026.BlackPantherChildActor
// 0x0010 (0x0A70 - 0x0A60)
class ABlackPantherChildActor final : public AMarvelCharacterChildActor
{
public:
	float                                         DelayLengthToRotateMesh;                           // 0x0A60(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A64[0xC];                                      // 0x0A64(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackPantherChildActor">();
	}
	static class ABlackPantherChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlackPantherChildActor>();
	}
};
static_assert(alignof(ABlackPantherChildActor) == 0x000008, "Wrong alignment on ABlackPantherChildActor");
static_assert(sizeof(ABlackPantherChildActor) == 0x000A70, "Wrong size on ABlackPantherChildActor");
static_assert(offsetof(ABlackPantherChildActor, DelayLengthToRotateMesh) == 0x000A60, "Member 'ABlackPantherChildActor::DelayLengthToRotateMesh' has a wrong offset!");

// Class Hero_1026.BlackPantherMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UBlackPantherMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackPantherMoveLogicBaseComponent">();
	}
	static class UBlackPantherMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackPantherMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UBlackPantherMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UBlackPantherMoveLogicBaseComponent");
static_assert(sizeof(UBlackPantherMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UBlackPantherMoveLogicBaseComponent");

// Class Hero_1026.BlackPantherMovementComponent
// 0x0000 (0x2FD0 - 0x2FD0)
class UBlackPantherMovementComponent final : public UCharacterWallRunningComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackPantherMovementComponent">();
	}
	static class UBlackPantherMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackPantherMovementComponent>();
	}
};
static_assert(alignof(UBlackPantherMovementComponent) == 0x000010, "Wrong alignment on UBlackPantherMovementComponent");
static_assert(sizeof(UBlackPantherMovementComponent) == 0x002FD0, "Wrong size on UBlackPantherMovementComponent");

// Class Hero_1026.TabData_1026
// 0x0000 (0x0050 - 0x0050)
class UTabData_1026 final : public UHeroTabDataBase
{
public:
	void OnAbilityInitialize(int32 AbilityID);
	void OnActorDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnShieldAdded(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1026">();
	}
	static class UTabData_1026* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1026>();
	}
};
static_assert(alignof(UTabData_1026) == 0x000008, "Wrong alignment on UTabData_1026");
static_assert(sizeof(UTabData_1026) == 0x000050, "Wrong size on UTabData_1026");

}

