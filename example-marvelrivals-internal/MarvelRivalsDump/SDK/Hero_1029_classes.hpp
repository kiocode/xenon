#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1029

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_classes.hpp"
#include "Hero_1029_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Class Hero_1029.Projectile_10292101
// 0x0000 (0x3050 - 0x3050)
class AProjectile_10292101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	float GetAccumulateTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10292101">();
	}
	static class AProjectile_10292101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10292101>();
	}
};
static_assert(alignof(AProjectile_10292101) == 0x000010, "Wrong alignment on AProjectile_10292101");
static_assert(sizeof(AProjectile_10292101) == 0x003050, "Wrong size on AProjectile_10292101");

// Class Hero_1029.Cue_Ability_Loop_102921_Common
// 0x0048 (0x0E98 - 0x0E50)
class ACue_Ability_Loop_102921_Common : public AMarvelCueNotify_Ability
{
public:
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x0E50(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     FxComp;                                            // 0x0E58(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         FXAsset;                                           // 0x0E60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FxScale;                                           // 0x0E68(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FxLocSocketName;                                   // 0x0E80(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetLength;                                      // 0x0E8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffset;                                           // 0x0E90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtAimDir;                                     // 0x0E94(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E95[0x3];                                      // 0x0E95(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateFxLocRot(struct FVector* OutLoc, struct FRotator* OutRot);
	void UpdateFx();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_102921_Common">();
	}
	static class ACue_Ability_Loop_102921_Common* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_102921_Common>();
	}
};
static_assert(alignof(ACue_Ability_Loop_102921_Common) == 0x000008, "Wrong alignment on ACue_Ability_Loop_102921_Common");
static_assert(sizeof(ACue_Ability_Loop_102921_Common) == 0x000E98, "Wrong size on ACue_Ability_Loop_102921_Common");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, OwnerChar) == 0x000E50, "Member 'ACue_Ability_Loop_102921_Common::OwnerChar' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, FxComp) == 0x000E58, "Member 'ACue_Ability_Loop_102921_Common::FxComp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, FXAsset) == 0x000E60, "Member 'ACue_Ability_Loop_102921_Common::FXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, FxScale) == 0x000E68, "Member 'ACue_Ability_Loop_102921_Common::FxScale' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, FxLocSocketName) == 0x000E80, "Member 'ACue_Ability_Loop_102921_Common::FxLocSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, OffsetLength) == 0x000E8C, "Member 'ACue_Ability_Loop_102921_Common::OffsetLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, ZOffset) == 0x000E90, "Member 'ACue_Ability_Loop_102921_Common::ZOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, bLookAtAimDir) == 0x000E94, "Member 'ACue_Ability_Loop_102921_Common::bLookAtAimDir' has a wrong offset!");

// Class Hero_1029.Cue_Ability_Loop_10292102
// 0x0000 (0x0E98 - 0x0E98)
class ACue_Ability_Loop_10292102 final : public ACue_Ability_Loop_102921_Common
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10292102">();
	}
	static class ACue_Ability_Loop_10292102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10292102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10292102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10292102");
static_assert(sizeof(ACue_Ability_Loop_10292102) == 0x000E98, "Wrong size on ACue_Ability_Loop_10292102");

// Class Hero_1029.Cue_Projectile_HitImpact_10292101
// 0x0010 (0x04E0 - 0x04D0)
class UCue_Projectile_HitImpact_10292101 final : public UMarvelCueNotify_HitImpact
{
public:
	class UCurveVector*                           HitImpactFXSizeCurve;                              // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            HitImpactDecalSizeCurve;                           // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnHitNiagaraSpawned(class UNiagaraComponent* SpawnedNiagara, class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_HitImpact_10292101">();
	}
	static class UCue_Projectile_HitImpact_10292101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Projectile_HitImpact_10292101>();
	}
};
static_assert(alignof(UCue_Projectile_HitImpact_10292101) == 0x000008, "Wrong alignment on UCue_Projectile_HitImpact_10292101");
static_assert(sizeof(UCue_Projectile_HitImpact_10292101) == 0x0004E0, "Wrong size on UCue_Projectile_HitImpact_10292101");
static_assert(offsetof(UCue_Projectile_HitImpact_10292101, HitImpactFXSizeCurve) == 0x0004D0, "Member 'UCue_Projectile_HitImpact_10292101::HitImpactFXSizeCurve' has a wrong offset!");
static_assert(offsetof(UCue_Projectile_HitImpact_10292101, HitImpactDecalSizeCurve) == 0x0004D8, "Member 'UCue_Projectile_HitImpact_10292101::HitImpactDecalSizeCurve' has a wrong offset!");

// Class Hero_1029.UIController_102921
// 0x0010 (0x0C70 - 0x0C60)
class UUIController_102921 : public UUIC_Ability
{
public:
	float                                         ReticleMinRadius;                                  // 0x0C60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReticleMaxRadius;                                  // 0x0C64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDuration;                                       // 0x0C68(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C6C[0x4];                                      // 0x0C6C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateReticle(float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIController_102921">();
	}
	static class UUIController_102921* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIController_102921>();
	}
};
static_assert(alignof(UUIController_102921) == 0x000008, "Wrong alignment on UUIController_102921");
static_assert(sizeof(UUIController_102921) == 0x000C70, "Wrong size on UUIController_102921");
static_assert(offsetof(UUIController_102921, ReticleMinRadius) == 0x000C60, "Member 'UUIController_102921::ReticleMinRadius' has a wrong offset!");
static_assert(offsetof(UUIController_102921, ReticleMaxRadius) == 0x000C64, "Member 'UUIController_102921::ReticleMaxRadius' has a wrong offset!");
static_assert(offsetof(UUIController_102921, MaxDuration) == 0x000C68, "Member 'UUIController_102921::MaxDuration' has a wrong offset!");

// Class Hero_1029.Summoned_10294101
// 0x00D0 (0x0960 - 0x0890)
class ASummoned_10294101 final : public AMarvelSummonerBase
{
public:
	uint8                                         Pad_890[0x14];                                     // 0x0890(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TPCD;                                              // 0x08A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TPAbilityBuff;                                     // 0x08A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8AC[0x4];                                      // 0x08AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TPBuffs;                                           // 0x08B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         UpdateInterval;                                    // 0x08C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetEnterTag;                                    // 0x08C4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetLeaveTag;                                    // 0x08D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8DC[0x4];                                      // 0x08DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTargetThroughTP;                                 // 0x08E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FVector                                FaceDir;                                           // 0x08F0(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASummoned_10294101*                     TargetTP;                                          // 0x0908(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTPUsageRecord_102941>          TPUsageRecords;                                    // 0x0910(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             NeedRefreshTP;                                     // 0x0920(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UOverlapHandlerComponent*               OverlapHandlerComponent;                           // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       OverlapCollisionComponent;                         // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           UpdateTimer;                                       // 0x0940(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_958[0x8];                                      // 0x0958(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearUpdateTimer();
	void HandleTargetTPBuff(class AActor* TargetActor, bool bApply);
	bool IsTargetCanBeTP(class AActor* TargetActor);
	void OnASCTagUpdate(const struct FGameplayTag& TagUpdate, bool bTagExist);
	void OnRep_FaceDir();
	void OnRep_TargetTP();
	void OnRep_TPUsageRecords();
	void SetTargetTP(class ASummoned_10294101* InTargetTP);
	void SetTPFaceDir(const struct FVector& InDir);
	void SetUpdateTimer();
	void TryTeleportTarget(class AActor* TargetActor);
	void UpdateTPState(class AActor* TargetActor, bool bStartTP);
	void UpdateUsageRecord(class AActor* TargetActor);

	class ASummoned_10294101* GetTargetTP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10294101">();
	}
	static class ASummoned_10294101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10294101>();
	}
};
static_assert(alignof(ASummoned_10294101) == 0x000010, "Wrong alignment on ASummoned_10294101");
static_assert(sizeof(ASummoned_10294101) == 0x000960, "Wrong size on ASummoned_10294101");
static_assert(offsetof(ASummoned_10294101, TPCD) == 0x0008A4, "Member 'ASummoned_10294101::TPCD' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TPAbilityBuff) == 0x0008A8, "Member 'ASummoned_10294101::TPAbilityBuff' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TPBuffs) == 0x0008B0, "Member 'ASummoned_10294101::TPBuffs' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, UpdateInterval) == 0x0008C0, "Member 'ASummoned_10294101::UpdateInterval' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TargetEnterTag) == 0x0008C4, "Member 'ASummoned_10294101::TargetEnterTag' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TargetLeaveTag) == 0x0008D0, "Member 'ASummoned_10294101::TargetLeaveTag' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, OnTargetThroughTP) == 0x0008E0, "Member 'ASummoned_10294101::OnTargetThroughTP' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, FaceDir) == 0x0008F0, "Member 'ASummoned_10294101::FaceDir' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TargetTP) == 0x000908, "Member 'ASummoned_10294101::TargetTP' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TPUsageRecords) == 0x000910, "Member 'ASummoned_10294101::TPUsageRecords' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, NeedRefreshTP) == 0x000920, "Member 'ASummoned_10294101::NeedRefreshTP' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, OverlapHandlerComponent) == 0x000930, "Member 'ASummoned_10294101::OverlapHandlerComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, OverlapCollisionComponent) == 0x000938, "Member 'ASummoned_10294101::OverlapCollisionComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, UpdateTimer) == 0x000940, "Member 'ASummoned_10294101::UpdateTimer' has a wrong offset!");

// Class Hero_1029.SummonedOverlapComp_10294101
// 0x0008 (0x0C38 - 0x0C30)
class USummonedOverlapComp_10294101 final : public UOverlapHandlerComponent
{
public:
	class ASummoned_10294101*                     OwnerSummoned_10294101;                            // 0x0C30(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class ASummoned_10294101* GetOwnerSummoned_10294101();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedOverlapComp_10294101">();
	}
	static class USummonedOverlapComp_10294101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedOverlapComp_10294101>();
	}
};
static_assert(alignof(USummonedOverlapComp_10294101) == 0x000008, "Wrong alignment on USummonedOverlapComp_10294101");
static_assert(sizeof(USummonedOverlapComp_10294101) == 0x000C38, "Wrong size on USummonedOverlapComp_10294101");
static_assert(offsetof(USummonedOverlapComp_10294101, OwnerSummoned_10294101) == 0x000C30, "Member 'USummonedOverlapComp_10294101::OwnerSummoned_10294101' has a wrong offset!");

// Class Hero_1029.Cue_Ability_Instant_10294101
// 0x0068 (0x03D0 - 0x0368)
class UCue_Ability_Instant_10294101 : public UMarvelCueNotify_Base
{
public:
	struct FVector                                FXDir;                                             // 0x0368(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwningAbilityID;                                   // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         EndTrailFx;                                        // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndTrailFxIsAttach;                               // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               EndTrailRelativeRot;                               // 0x0398(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                EndTrailRelativeLoc;                               // 0x03B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x03C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugDrawTime;                                     // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CustomDebugDraw(const struct FRotator& Dir, const struct FVector& Start) const;
	void CustomSpawnFX(class UFXSystemAsset* InFXAsset, bool bIsAttach, class USkeletalMeshComponent* Mesh, class FName Socket, const struct FGameplayCueParameters& Parameters, const struct FVector& Loc, const struct FRotator& Rot, const struct FVector& RelativeLoc, const struct FRotator& RelativeRot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Instant_10294101">();
	}
	static class UCue_Ability_Instant_10294101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Ability_Instant_10294101>();
	}
};
static_assert(alignof(UCue_Ability_Instant_10294101) == 0x000008, "Wrong alignment on UCue_Ability_Instant_10294101");
static_assert(sizeof(UCue_Ability_Instant_10294101) == 0x0003D0, "Wrong size on UCue_Ability_Instant_10294101");
static_assert(offsetof(UCue_Ability_Instant_10294101, FXDir) == 0x000368, "Member 'UCue_Ability_Instant_10294101::FXDir' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, OwningAbilityID) == 0x000380, "Member 'UCue_Ability_Instant_10294101::OwningAbilityID' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, EndTrailFx) == 0x000388, "Member 'UCue_Ability_Instant_10294101::EndTrailFx' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, bEndTrailFxIsAttach) == 0x000390, "Member 'UCue_Ability_Instant_10294101::bEndTrailFxIsAttach' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, EndTrailRelativeRot) == 0x000398, "Member 'UCue_Ability_Instant_10294101::EndTrailRelativeRot' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, EndTrailRelativeLoc) == 0x0003B0, "Member 'UCue_Ability_Instant_10294101::EndTrailRelativeLoc' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, bDrawDebug) == 0x0003C8, "Member 'UCue_Ability_Instant_10294101::bDrawDebug' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, DebugDrawTime) == 0x0003CC, "Member 'UCue_Ability_Instant_10294101::DebugDrawTime' has a wrong offset!");

// Class Hero_1029.Cue_Ability_Loop_10294102
// 0x0270 (0x10C0 - 0x0E50)
class ACue_Ability_Loop_10294102 final : public AMarvelCueNotify_Ability
{
public:
	float                                         CueLifeSpan;                                       // 0x0E50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMaterialLastTime;                               // 0x0E54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCommonCurve;                                   // 0x0E58(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E59[0x7];                                      // 0x0E59(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   CommonMaterialSlots;                               // 0x0E60(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMaterialCurve_102941                  CommonMaterialMap;                                 // 0x0EB0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct FMaterialCurve_102941>     MaterialMap;                                       // 0x0F00(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         DefaultValCurveTime;                               // 0x0F50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F54[0x4];                                      // 0x0F54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            BackFresnelPowerDefaultVals;                       // 0x0F58(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct FLinearColor>              BackRimDefaultColors;                              // 0x0FA8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct FVector>                   RimLightDirectionDefaultVecs;                      // 0x0FF8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         ChargeTime;                                        // 0x1048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104C[0x4];                                     // 0x104C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x1050(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UMaterialInstanceDynamic*>  CachedMaterialInstances;                           // 0x1058(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DelayRecycleCueHandle;                             // 0x10A8(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleSlotMaterial(float CurveTime, bool bIsReset);
	bool IsMaterialHasCached(int32 SlotIdx);
	void ResetMaterial();
	void SetMaterialParamInternal(class UCurveBase* CurveBase, float CurveTime, class UMaterialInstanceDynamic* Material, class FName Param, int32 SlotIdx, bool bIsReset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10294102">();
	}
	static class ACue_Ability_Loop_10294102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10294102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10294102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10294102");
static_assert(sizeof(ACue_Ability_Loop_10294102) == 0x0010C0, "Wrong size on ACue_Ability_Loop_10294102");
static_assert(offsetof(ACue_Ability_Loop_10294102, CueLifeSpan) == 0x000E50, "Member 'ACue_Ability_Loop_10294102::CueLifeSpan' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, MaxMaterialLastTime) == 0x000E54, "Member 'ACue_Ability_Loop_10294102::MaxMaterialLastTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, bUseCommonCurve) == 0x000E58, "Member 'ACue_Ability_Loop_10294102::bUseCommonCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, CommonMaterialSlots) == 0x000E60, "Member 'ACue_Ability_Loop_10294102::CommonMaterialSlots' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, CommonMaterialMap) == 0x000EB0, "Member 'ACue_Ability_Loop_10294102::CommonMaterialMap' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, MaterialMap) == 0x000F00, "Member 'ACue_Ability_Loop_10294102::MaterialMap' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, DefaultValCurveTime) == 0x000F50, "Member 'ACue_Ability_Loop_10294102::DefaultValCurveTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, BackFresnelPowerDefaultVals) == 0x000F58, "Member 'ACue_Ability_Loop_10294102::BackFresnelPowerDefaultVals' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, BackRimDefaultColors) == 0x000FA8, "Member 'ACue_Ability_Loop_10294102::BackRimDefaultColors' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, RimLightDirectionDefaultVecs) == 0x000FF8, "Member 'ACue_Ability_Loop_10294102::RimLightDirectionDefaultVecs' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, ChargeTime) == 0x001048, "Member 'ACue_Ability_Loop_10294102::ChargeTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, TargetMesh) == 0x001050, "Member 'ACue_Ability_Loop_10294102::TargetMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, CachedMaterialInstances) == 0x001058, "Member 'ACue_Ability_Loop_10294102::CachedMaterialInstances' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, DelayRecycleCueHandle) == 0x0010A8, "Member 'ACue_Ability_Loop_10294102::DelayRecycleCueHandle' has a wrong offset!");

// Class Hero_1029.Summoned_102961
// 0x0000 (0x0890 - 0x0890)
class ASummoned_102961 : public AMarvelSummonerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_102961">();
	}
	static class ASummoned_102961* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_102961>();
	}
};
static_assert(alignof(ASummoned_102961) == 0x000010, "Wrong alignment on ASummoned_102961");
static_assert(sizeof(ASummoned_102961) == 0x000890, "Wrong size on ASummoned_102961");

// Class Hero_1029.Config_102972
// 0x0010 (0x00A8 - 0x0098)
class UConfig_102972 final : public UMarvelAbilityConfig
{
public:
	TSubclassOf<class UMarvelKnockUpAbility>      KnockUpAbility;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedMagikLaunch;                                  // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102972">();
	}
	static class UConfig_102972* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102972>();
	}
};
static_assert(alignof(UConfig_102972) == 0x000008, "Wrong alignment on UConfig_102972");
static_assert(sizeof(UConfig_102972) == 0x0000A8, "Wrong size on UConfig_102972");
static_assert(offsetof(UConfig_102972, KnockUpAbility) == 0x000098, "Member 'UConfig_102972::KnockUpAbility' has a wrong offset!");
static_assert(offsetof(UConfig_102972, bNeedMagikLaunch) == 0x0000A0, "Member 'UConfig_102972::bNeedMagikLaunch' has a wrong offset!");

// Class Hero_1029.Ability_102972
// 0x0020 (0x25A8 - 0x2588)
class UAbility_102972 : public UAbility_108
{
public:
	class AActor*                                 TargetActor;                                       // 0x2588(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle;                                       // 0x2590(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetTarget(class AActor* OutTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102972">();
	}
	static class UAbility_102972* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102972>();
	}
};
static_assert(alignof(UAbility_102972) == 0x000008, "Wrong alignment on UAbility_102972");
static_assert(sizeof(UAbility_102972) == 0x0025A8, "Wrong size on UAbility_102972");
static_assert(offsetof(UAbility_102972, TargetActor) == 0x002588, "Member 'UAbility_102972::TargetActor' has a wrong offset!");
static_assert(offsetof(UAbility_102972, TimerHandle) == 0x002590, "Member 'UAbility_102972::TimerHandle' has a wrong offset!");

// Class Hero_1029.TraceComponent_10297201
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10297201 : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10297201">();
	}
	static class UTraceComponent_10297201* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10297201>();
	}
};
static_assert(alignof(UTraceComponent_10297201) == 0x000010, "Wrong alignment on UTraceComponent_10297201");
static_assert(sizeof(UTraceComponent_10297201) == 0x001710, "Wrong size on UTraceComponent_10297201");

// Class Hero_1029.TraceComponent_10297401
// 0x0000 (0x1710 - 0x1710)
class UTraceComponent_10297401 final : public UTraceComponent_10297201
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10297401">();
	}
	static class UTraceComponent_10297401* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10297401>();
	}
};
static_assert(alignof(UTraceComponent_10297401) == 0x000010, "Wrong alignment on UTraceComponent_10297401");
static_assert(sizeof(UTraceComponent_10297401) == 0x001710, "Wrong size on UTraceComponent_10297401");

// Class Hero_1029.MagikAnimInstance
// 0x00B0 (0x09C0 - 0x0910)
class UMagikAnimInstance final : public UMarvelAnimInstance
{
public:
	struct FGameplayTag                           DashingTag;                                        // 0x0910(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TPPlaceingTag;                                     // 0x091C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AssaultTag;                                        // 0x0928(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SwirlSlashTag;                                     // 0x0934(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DarkchyldeSwirlSlashTag;                           // 0x0940(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HellTeleLoopAnimTime;                              // 0x094C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInDash;                                         // 0x0950(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPendingMove;                                      // 0x0951(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTPPlacing;                                      // 0x0952(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_953[0x1];                                      // 0x0953(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HellTeleportFrontAxis;                             // 0x0954(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HellTeleportRightAxis;                             // 0x0958(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AssaultState;                                      // 0x095C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SwirlSlashState;                                   // 0x095D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAssaultRecovery_To_GroundMotion;                  // 0x095E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGroundMotion_To_SwirlSlash;                       // 0x095F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwirlSlashRecovery_To_GroundMotion;               // 0x0960(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHellTeleportLoop_To_HellTeleportEnd;              // 0x0961(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_962[0x5E];                                     // 0x0962(0x005E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterTagUpdate(const struct FGameplayTag& InTag, bool bExist);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagikAnimInstance">();
	}
	static class UMagikAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagikAnimInstance>();
	}
};
static_assert(alignof(UMagikAnimInstance) == 0x000010, "Wrong alignment on UMagikAnimInstance");
static_assert(sizeof(UMagikAnimInstance) == 0x0009C0, "Wrong size on UMagikAnimInstance");
static_assert(offsetof(UMagikAnimInstance, DashingTag) == 0x000910, "Member 'UMagikAnimInstance::DashingTag' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, TPPlaceingTag) == 0x00091C, "Member 'UMagikAnimInstance::TPPlaceingTag' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, AssaultTag) == 0x000928, "Member 'UMagikAnimInstance::AssaultTag' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, SwirlSlashTag) == 0x000934, "Member 'UMagikAnimInstance::SwirlSlashTag' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, DarkchyldeSwirlSlashTag) == 0x000940, "Member 'UMagikAnimInstance::DarkchyldeSwirlSlashTag' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, HellTeleLoopAnimTime) == 0x00094C, "Member 'UMagikAnimInstance::HellTeleLoopAnimTime' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bIsInDash) == 0x000950, "Member 'UMagikAnimInstance::bIsInDash' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bPendingMove) == 0x000951, "Member 'UMagikAnimInstance::bPendingMove' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bIsTPPlacing) == 0x000952, "Member 'UMagikAnimInstance::bIsTPPlacing' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, HellTeleportFrontAxis) == 0x000954, "Member 'UMagikAnimInstance::HellTeleportFrontAxis' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, HellTeleportRightAxis) == 0x000958, "Member 'UMagikAnimInstance::HellTeleportRightAxis' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, AssaultState) == 0x00095C, "Member 'UMagikAnimInstance::AssaultState' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, SwirlSlashState) == 0x00095D, "Member 'UMagikAnimInstance::SwirlSlashState' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bAssaultRecovery_To_GroundMotion) == 0x00095E, "Member 'UMagikAnimInstance::bAssaultRecovery_To_GroundMotion' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bGroundMotion_To_SwirlSlash) == 0x00095F, "Member 'UMagikAnimInstance::bGroundMotion_To_SwirlSlash' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bSwirlSlashRecovery_To_GroundMotion) == 0x000960, "Member 'UMagikAnimInstance::bSwirlSlashRecovery_To_GroundMotion' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bHellTeleportLoop_To_HellTeleportEnd) == 0x000961, "Member 'UMagikAnimInstance::bHellTeleportLoop_To_HellTeleportEnd' has a wrong offset!");

// Class Hero_1029.MagikCharacter
// 0x0020 (0x1830 - 0x1810)
class AMagikCharacter : public AMarvelBaseCharacter
{
public:
	struct FVector                                DashDir;                                           // 0x1810(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMagikMoveLogicBaseComponent*           MagikMoveLogic;                                    // 0x1828(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagikCharacter">();
	}
	static class AMagikCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMagikCharacter>();
	}
};
static_assert(alignof(AMagikCharacter) == 0x000010, "Wrong alignment on AMagikCharacter");
static_assert(sizeof(AMagikCharacter) == 0x001830, "Wrong size on AMagikCharacter");
static_assert(offsetof(AMagikCharacter, DashDir) == 0x001810, "Member 'AMagikCharacter::DashDir' has a wrong offset!");
static_assert(offsetof(AMagikCharacter, MagikMoveLogic) == 0x001828, "Member 'AMagikCharacter::MagikMoveLogic' has a wrong offset!");

// Class Hero_1029.MagikMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UMagikMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	void InterruptTurningPlaceMontage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagikMoveLogicBaseComponent">();
	}
	static class UMagikMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagikMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UMagikMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UMagikMoveLogicBaseComponent");
static_assert(sizeof(UMagikMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UMagikMoveLogicBaseComponent");

// Class Hero_1029.MagikMovementComponent
// 0x0000 (0x1B60 - 0x1B60)
class UMagikMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagikMovementComponent">();
	}
	static class UMagikMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagikMovementComponent>();
	}
};
static_assert(alignof(UMagikMovementComponent) == 0x000010, "Wrong alignment on UMagikMovementComponent");
static_assert(sizeof(UMagikMovementComponent) == 0x001B60, "Wrong size on UMagikMovementComponent");

// Class Hero_1029.TabData_1029
// 0x0000 (0x0050 - 0x0050)
class UTabData_1029 : public UHeroTabDataBase
{
public:
	void OnActorDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1029">();
	}
	static class UTabData_1029* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1029>();
	}
};
static_assert(alignof(UTabData_1029) == 0x000008, "Wrong alignment on UTabData_1029");
static_assert(sizeof(UTabData_1029) == 0x000050, "Wrong size on UTabData_1029");

}

